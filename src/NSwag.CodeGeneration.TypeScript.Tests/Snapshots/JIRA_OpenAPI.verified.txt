//----------------------
// <auto-generated>
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Update issues to move them to the backlog
     * @param body The issues to move to the backlog.
     * @return Empty response is returned if operation was successful.
     */
    moveIssuesToBacklog(body: IssueAssignRequestBean): Promise<void> {
        let url_ = this.baseUrl + "/agile/1.0/backlog/issue";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMoveIssuesToBacklog(_response);
        });
    }

    protected processMoveIssuesToBacklog(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user does not a have valid license or does not have permission to assign issues.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if sprint does not exist or the user cannot view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all boards
     * @param maxResults (optional) 
     * @param name (optional) 
     * @param projectKeyOrId (optional) 
     * @param type (optional) 
     * @param startAt (optional) 
     * @return Returns the requested boards, at the specified page of the results.
     */
    getAllBoards(maxResults?: number | undefined, name?: string | undefined, projectKeyOrId?: string | undefined, type?: StringList | undefined, startAt?: number | undefined): Promise<BoardBean> {
        let url_ = this.baseUrl + "/agile/1.0/board?";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (projectKeyOrId === null)
            throw new Error("The parameter 'projectKeyOrId' cannot be null.");
        else if (projectKeyOrId !== undefined)
            url_ += "projectKeyOrId=" + encodeURIComponent("" + projectKeyOrId) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllBoards(_response);
        });
    }

    protected processGetAllBoards(response: Response): Promise<BoardBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoardBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have valid license.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BoardBean>(null as any);
    }

    /**
     * Create a new board
     * @param body Bean which contains board name, type and filter Id.
     * @return Returns the created board.
     */
    createBoard(body: BoardCreateBean): Promise<BoardBean> {
        let url_ = this.baseUrl + "/agile/1.0/board";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateBoard(_response);
        });
    }

    protected processCreateBoard(response: Response): Promise<BoardBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = BoardBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BoardBean>(null as any);
    }

    /**
     * Get a single board
     * @return Returns the requested board.
     */
    getBoard(boardId: number): Promise<BoardBean> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}";
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBoard(_response);
        });
    }

    protected processGetBoard(response: Response): Promise<BoardBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoardBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the board does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BoardBean>(null as any);
    }

    /**
     * Delete the board
     * @return Returned if the board has been successfully removed.
     */
    deleteBoard(boardId: number): Promise<void> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}";
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteBoard(_response);
        });
    }

    protected processDeleteBoard(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license, or when the user does not have the permission to delete the board.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if a board with the given id does not exist or the user does not have the permission to view the board.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all issues from the board's backlog
     * @param expand (optional) 
     * @param jql (optional) 
     * @param maxResults (optional) 
     * @param validateQuery (optional) 
     * @param fields (optional) 
     * @param startAt (optional) 
     * @return Returns the requested issues.
     */
    getIssuesForBacklog(boardId: number, expand?: string | undefined, jql?: string | undefined, maxResults?: number | undefined, validateQuery?: boolean | undefined, fields?: StringList[] | undefined, startAt?: number | undefined): Promise<IssueBean> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}/backlog?";
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (jql === null)
            throw new Error("The parameter 'jql' cannot be null.");
        else if (jql !== undefined)
            url_ += "jql=" + encodeURIComponent("" + jql) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (validateQuery === null)
            throw new Error("The parameter 'validateQuery' cannot be null.");
        else if (validateQuery !== undefined)
            url_ += "validateQuery=" + encodeURIComponent("" + validateQuery) + "&";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "fields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssuesForBacklog(_response);
        });
    }

    protected processGetIssuesForBacklog(response: Response): Promise<IssueBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the board does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueBean>(null as any);
    }

    /**
     * Get the board configuration
     * @return Returns the configuration of the board for given boardId.
     */
    getConfiguration(boardId: number): Promise<BoardConfigBean> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}/configuration";
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetConfiguration(_response);
        });
    }

    protected processGetConfiguration(response: Response): Promise<BoardConfigBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BoardConfigBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if board does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BoardConfigBean>(null as any);
    }

    /**
     * Get all epics from the board
     * @param maxResults (optional) 
     * @param done (optional) 
     * @param startAt (optional) 
     * @return Returns the requested epics, at the specified page of the results.
     */
    getEpics(boardId: number, maxResults?: number | undefined, done?: string | undefined, startAt?: number | undefined): Promise<EpicBean> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}/epic?";
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (done === null)
            throw new Error("The parameter 'done' cannot be null.");
        else if (done !== undefined)
            url_ += "done=" + encodeURIComponent("" + done) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEpics(_response);
        });
    }

    protected processGetEpics(response: Response): Promise<EpicBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EpicBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if board does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EpicBean>(null as any);
    }

    /**
     * Get all issues without an epic
     * @param expand (optional) 
     * @param jql (optional) 
     * @param maxResults (optional) 
     * @param validateQuery (optional) 
     * @param fields (optional) 
     * @param startAt (optional) 
     * @return Returns the requested issues, at the specified page of the results.
     */
    getIssuesWithoutEpic(boardId: number, expand?: string | undefined, jql?: string | undefined, maxResults?: number | undefined, validateQuery?: boolean | undefined, fields?: StringList[] | undefined, startAt?: number | undefined): Promise<IssueBean> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}/epic/none/issue?";
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (jql === null)
            throw new Error("The parameter 'jql' cannot be null.");
        else if (jql !== undefined)
            url_ += "jql=" + encodeURIComponent("" + jql) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (validateQuery === null)
            throw new Error("The parameter 'validateQuery' cannot be null.");
        else if (validateQuery !== undefined)
            url_ += "validateQuery=" + encodeURIComponent("" + validateQuery) + "&";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "fields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssuesWithoutEpic(_response);
        });
    }

    protected processGetIssuesWithoutEpic(response: Response): Promise<IssueBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the board does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueBean>(null as any);
    }

    /**
     * Get all issues for a specific epic
     * @param expand (optional) 
     * @param jql (optional) 
     * @param maxResults (optional) 
     * @param validateQuery (optional) 
     * @param fields (optional) 
     * @param startAt (optional) 
     * @return Returns the requested issues, at the specified page of the results.
     */
    getIssuesForEpic(epicId: number, boardId: number, expand?: string | undefined, jql?: string | undefined, maxResults?: number | undefined, validateQuery?: boolean | undefined, fields?: StringList[] | undefined, startAt?: number | undefined): Promise<IssueBean> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}/epic/{epicId}/issue?";
        if (epicId === undefined || epicId === null)
            throw new Error("The parameter 'epicId' must be defined.");
        url_ = url_.replace("{epicId}", encodeURIComponent("" + epicId));
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (jql === null)
            throw new Error("The parameter 'jql' cannot be null.");
        else if (jql !== undefined)
            url_ += "jql=" + encodeURIComponent("" + jql) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (validateQuery === null)
            throw new Error("The parameter 'validateQuery' cannot be null.");
        else if (validateQuery !== undefined)
            url_ += "validateQuery=" + encodeURIComponent("" + validateQuery) + "&";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "fields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssuesForEpic(_response);
        });
    }

    protected processGetIssuesForEpic(response: Response): Promise<IssueBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the board does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueBean>(null as any);
    }

    /**
     * Get all issues from a board
     * @param expand (optional) 
     * @param jql (optional) 
     * @param maxResults (optional) 
     * @param validateQuery (optional) 
     * @param fields (optional) 
     * @param startAt (optional) 
     * @return Returns the requested issues.
     */
    getIssuesForBoard(boardId: number, expand?: string | undefined, jql?: string | undefined, maxResults?: number | undefined, validateQuery?: boolean | undefined, fields?: StringList[] | undefined, startAt?: number | undefined): Promise<IssueBean> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}/issue?";
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (jql === null)
            throw new Error("The parameter 'jql' cannot be null.");
        else if (jql !== undefined)
            url_ += "jql=" + encodeURIComponent("" + jql) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (validateQuery === null)
            throw new Error("The parameter 'validateQuery' cannot be null.");
        else if (validateQuery !== undefined)
            url_ += "validateQuery=" + encodeURIComponent("" + validateQuery) + "&";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "fields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssuesForBoard(_response);
        });
    }

    protected processGetIssuesForBoard(response: Response): Promise<IssueBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the board does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueBean>(null as any);
    }

    /**
     * Get all projects associated with the board
     * @param maxResults (optional) 
     * @param startAt (optional) 
     * @return Returns the board's projects, at the specified page of the results.
     */
    getProjects(boardId: number, maxResults?: number | undefined, startAt?: number | undefined): Promise<ProjectJsonBean> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}/project?";
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjects(_response);
        });
    }

    protected processGetProjects(response: Response): Promise<ProjectJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if board does not exist or the user does not have permission to access it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectJsonBean>(null as any);
    }

    /**
     * Get all properties keys for a board
     * @return Returns the requested property keys.
     */
    getPropertiesKeys(boardId: string): Promise<EntityPropertiesKeysBean> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}/properties";
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPropertiesKeys(_response);
        });
    }

    protected processGetPropertiesKeys(response: Response): Promise<EntityPropertiesKeysBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityPropertiesKeysBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the board does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityPropertiesKeysBean>(null as any);
    }

    /**
     * Get a property from a board
     * @return Returns the requested property.
     */
    getProperty(propertyKey: string, boardId: string): Promise<EntityPropertiesKeysBean> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProperty(_response);
        });
    }

    protected processGetProperty(response: Response): Promise<EntityPropertiesKeysBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityPropertiesKeysBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the board does not exist or the property with given key is not found or the user doesn\'t have permissions to see it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityPropertiesKeysBean>(null as any);
    }

    /**
     * Update a board's property
     * @return Returned if the board property is successfully updated.
     */
    setProperty(propertyKey: string, boardId: string): Promise<EntityPropertiesKeysBean> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetProperty(_response);
        });
    }

    protected processSetProperty(response: Response): Promise<EntityPropertiesKeysBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityPropertiesKeysBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the board property is successfully created.", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the board does not exist or the user doesn\'t have permissions to see it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityPropertiesKeysBean>(null as any);
    }

    /**
     * Delete a property from a board
     * @return Returned if the board property was removed successfully.
     */
    deleteProperty(propertyKey: string, boardId: string): Promise<void> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProperty(_response);
        });
    }

    protected processDeleteProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the board does not exist or if the property with given key is not found or the user doesn\'t have permissions to see it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get the value of the refined velocity setting
     * @return Returned if the board exists and the property was found.
     */
    getRefinedVelocity(boardId: number): Promise<BooleanSettingBean> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}/settings/refined-velocity";
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRefinedVelocity(_response);
        });
    }

    protected processGetRefinedVelocity(response: Response): Promise<BooleanSettingBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanSettingBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the boardId is invalid (negative or not a number).", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the board with given id does not exist or if the property with given key is not found or the user doesn\'t have permissions to see it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BooleanSettingBean>(null as any);
    }

    /**
     * Update the board's refined velocity setting
     * @param body The request containing value of the board's property. The value has to a valid, non-empty JSON conforming to http://tools.ietf.org/html/rfc4627. The maximum length of the property value is 32768 bytes.
     * @return Returned if the board property is successfully updated.
     */
    setRefinedVelocity(boardId: number, body: BooleanSettingBean): Promise<void> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}/settings/refined-velocity";
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetRefinedVelocity(_response);
        });
    }

    protected processSetRefinedVelocity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the boardId is invalid (negative or not a number).", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the board with given id does not exist or if the property with given key is not found or the user doesn\'t have permissions to see it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all sprints from a board
     * @param maxResults (optional) 
     * @param state (optional) 
     * @param startAt (optional) 
     * @return Returns the requested sprints, at the specified page of the results. Sprints will be ordered first by state (i.e. closed, active, future) then by their position in the backlog.
     */
    getAllSprints(boardId: number, maxResults?: number | undefined, state?: StringList | undefined, startAt?: number | undefined): Promise<SprintBean> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}/sprint?";
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSprints(_response);
        });
    }

    protected processGetAllSprints(response: Response): Promise<SprintBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SprintBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if board does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SprintBean>(null as any);
    }

    /**
     * Get all issues for a sprint
     * @param expand (optional) 
     * @param jql (optional) 
     * @param maxResults (optional) 
     * @param validateQuery (optional) 
     * @param fields (optional) 
     * @param startAt (optional) 
     * @return Returns the requested issues, at the specified page of the results.
     */
    getIssuesForSprint(sprintId: number, boardId: number, expand?: string | undefined, jql?: string | undefined, maxResults?: number | undefined, validateQuery?: boolean | undefined, fields?: StringList[] | undefined, startAt?: number | undefined): Promise<SprintBean> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}/sprint/{sprintId}/issue?";
        if (sprintId === undefined || sprintId === null)
            throw new Error("The parameter 'sprintId' must be defined.");
        url_ = url_.replace("{sprintId}", encodeURIComponent("" + sprintId));
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (jql === null)
            throw new Error("The parameter 'jql' cannot be null.");
        else if (jql !== undefined)
            url_ += "jql=" + encodeURIComponent("" + jql) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (validateQuery === null)
            throw new Error("The parameter 'validateQuery' cannot be null.");
        else if (validateQuery !== undefined)
            url_ += "validateQuery=" + encodeURIComponent("" + validateQuery) + "&";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "fields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssuesForSprint(_response);
        });
    }

    protected processGetIssuesForSprint(response: Response): Promise<SprintBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SprintBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the board does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SprintBean>(null as any);
    }

    /**
     * Get all versions from a board
     * @param maxResults (optional) 
     * @param released (optional) 
     * @param startAt (optional) 
     * @return Returns the requested versions, at the specified page of the results.
     */
    getAllVersions(boardId: number, maxResults?: number | undefined, released?: string | undefined, startAt?: number | undefined): Promise<VersionBean> {
        let url_ = this.baseUrl + "/agile/1.0/board/{boardId}/version?";
        if (boardId === undefined || boardId === null)
            throw new Error("The parameter 'boardId' must be defined.");
        url_ = url_.replace("{boardId}", encodeURIComponent("" + boardId));
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (released === null)
            throw new Error("The parameter 'released' cannot be null.");
        else if (released !== undefined)
            url_ += "released=" + encodeURIComponent("" + released) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllVersions(_response);
        });
    }

    protected processGetAllVersions(response: Response): Promise<VersionBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VersionBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if board does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionBean>(null as any);
    }

    /**
     * Remove issues from any epic
     * @param body The issues to remove from epics.
     * @return Empty response is returned if operation was successful.
     */
    removeIssuesFromEpic(body: IssueAssignRequestBean): Promise<void> {
        let url_ = this.baseUrl + "/agile/1.0/epic/none/issue";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveIssuesFromEpic(_response);
        });
    }

    protected processRemoveIssuesFromEpic(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license or does not have permission to assign issues.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the epic does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get an epic by id or key
     * @return Returns the requested epic.
     */
    getEpic(epicIdOrKey: string): Promise<EpicBean> {
        let url_ = this.baseUrl + "/agile/1.0/epic/{epicIdOrKey}";
        if (epicIdOrKey === undefined || epicIdOrKey === null)
            throw new Error("The parameter 'epicIdOrKey' must be defined.");
        url_ = url_.replace("{epicIdOrKey}", encodeURIComponent("" + epicIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEpic(_response);
        });
    }

    protected processGetEpic(response: Response): Promise<EpicBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EpicBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the epic does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EpicBean>(null as any);
    }

    /**
     * Update an epic's details
     * @param body The epic properties to update.
     * @return Updated epic
     */
    partiallyUpdateEpic(epicIdOrKey: string, body: EpicUpdateBean): Promise<EpicBean> {
        let url_ = this.baseUrl + "/agile/1.0/epic/{epicIdOrKey}";
        if (epicIdOrKey === undefined || epicIdOrKey === null)
            throw new Error("The parameter 'epicIdOrKey' must be defined.");
        url_ = url_.replace("{epicIdOrKey}", encodeURIComponent("" + epicIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPartiallyUpdateEpic(_response);
        });
    }

    protected processPartiallyUpdateEpic(response: Response): Promise<EpicBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EpicBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license or edit issue permission.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the epic does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EpicBean>(null as any);
    }

    /**
     * Move issues to a specific epic
     * @param body The issues to move to the epic.
     * @return Empty response is returned if operation was successful.
     */
    moveIssuesToEpic(epicIdOrKey: string, body: IssueAssignRequestBean): Promise<void> {
        let url_ = this.baseUrl + "/agile/1.0/epic/{epicIdOrKey}/issue";
        if (epicIdOrKey === undefined || epicIdOrKey === null)
            throw new Error("The parameter 'epicIdOrKey' must be defined.");
        url_ = url_.replace("{epicIdOrKey}", encodeURIComponent("" + epicIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMoveIssuesToEpic(_response);
        });
    }

    protected processMoveIssuesToEpic(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license or does not have edit issue permission for all issues to assign or for the epic.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the epic does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Rank an epic relative to another
     * @param body Bean which contains the information where the given epic should be ranked.
     * @return Empty response is returned if operation was successful.
     */
    rankEpics(epicIdOrKey: string, body: EpicRankRequestBean): Promise<void> {
        let url_ = this.baseUrl + "/agile/1.0/epic/{epicIdOrKey}/rank";
        if (epicIdOrKey === undefined || epicIdOrKey === null)
            throw new Error("The parameter 'epicIdOrKey' must be defined.");
        url_ = url_.replace("{epicIdOrKey}", encodeURIComponent("" + epicIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRankEpics(_response);
        });
    }

    protected processRankEpics(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user does not a have valid license or does not have permission to rank. To rank issues user have to have schedule issue permission for epics that they want to rank.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned when the given epics in the path parameter or the request body do not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Rank issues before or after a given issue
     * @param body Bean which contains list of issues to rank and information where it should be ranked.
     * @return Empty response is returned if operation was successful.
     */
    rankIssues(body: IssueRankRequestBean): Promise<void> {
        let url_ = this.baseUrl + "/agile/1.0/issue/rank";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRankIssues(_response);
        });
    }

    protected processRankIssues(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 207) {
            return response.text().then((_responseText) => {
            let result207: any = null;
            let resultData207 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result207 = PartialSuccessBean.fromJS(resultData207);
            return throwException("Returns the list of issue with status of rank operation.", status, _responseText, _headers, result207);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user does not a have valid license or does not have permission to rank.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a single issue with Agile fields
     * @param expand (optional) 
     * @param fields (optional) 
     * @param updateHistory (optional) 
     * @return Returns the requested issue.
     */
    getIssue(issueIdOrKey: string, expand?: string | undefined, fields?: StringList[] | undefined, updateHistory?: boolean | undefined): Promise<IssueBean> {
        let url_ = this.baseUrl + "/agile/1.0/issue/{issueIdOrKey}?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "fields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (updateHistory === null)
            throw new Error("The parameter 'updateHistory' cannot be null.");
        else if (updateHistory !== undefined)
            url_ += "updateHistory=" + encodeURIComponent("" + updateHistory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssue(_response);
        });
    }

    protected processGetIssue(response: Response): Promise<IssueBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue does not exist or the user does not have permission to view issue.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueBean>(null as any);
    }

    /**
     * Get the estimation of an issue for a board
     * @param boardId (optional) 
     * @return Returns the estimation of the issue and a fieldId of the field that is used for it.
     */
    getIssueEstimationForBoard(issueIdOrKey: string, boardId?: number | undefined): Promise<FieldValueBean> {
        let url_ = this.baseUrl + "/agile/1.0/issue/{issueIdOrKey}/estimation?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (boardId === null)
            throw new Error("The parameter 'boardId' cannot be null.");
        else if (boardId !== undefined)
            url_ += "boardId=" + encodeURIComponent("" + boardId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssueEstimationForBoard(_response);
        });
    }

    protected processGetIssueEstimationForBoard(response: Response): Promise<FieldValueBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FieldValueBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the boardId was not provided, field does not exists or value was in wrong format.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user does not a have valid license or does not have permission to edit issue.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue does not exist or the user does not have permission to view issue or the board does not exist or the user does not have permission to view board or the issue does not belong to the board.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FieldValueBean>(null as any);
    }

    /**
     * Update the estimation of an issue for a board
     * @param body Bean that contains value of a new estimation.
     * @param boardId (optional) 
     * @return Returns the estimation of the issue and a fieldId of the field that is used for it.
     */
    estimateIssueForBoard(issueIdOrKey: string, body: FieldEditBean, boardId?: number | undefined): Promise<FieldValueBean> {
        let url_ = this.baseUrl + "/agile/1.0/issue/{issueIdOrKey}/estimation?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (boardId === null)
            throw new Error("The parameter 'boardId' cannot be null.");
        else if (boardId !== undefined)
            url_ += "boardId=" + encodeURIComponent("" + boardId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEstimateIssueForBoard(_response);
        });
    }

    protected processEstimateIssueForBoard(response: Response): Promise<FieldValueBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FieldValueBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the boardId was not provided, field does not exists or value was in wrong format.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user does not a have valid license or does not have permission to edit issue.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue does not exist or the user does not have permission to view issue or the board does not exist or the user does not have permission to view board or the issue does not belong to the board.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FieldValueBean>(null as any);
    }

    /**
     * Create a future sprint
     * @param body The sprint to create.
     * @return Returns the created sprint.
     */
    createSprint(body: SprintCreateBean): Promise<SprintBean> {
        let url_ = this.baseUrl + "/agile/1.0/sprint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSprint(_response);
        });
    }

    protected processCreateSprint(response: Response): Promise<SprintBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SprintBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the board does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SprintBean>(null as any);
    }

    /**
     * Unmap sprints from being synced
     * @param body The sprints to unmap.
     * @return Empty response is returned if operation was successful.
     */
    unmapSprints(body: UnmapSprintsBean): Promise<void> {
        let url_ = this.baseUrl + "/agile/1.0/sprint/unmap";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnmapSprints(_response);
        });
    }

    protected processUnmapSprints(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license or does not have permission to unmap sprints.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if at least one sprint does not exist or user does not have permission to view to at least one sprint.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Unmap all sprints from being synced
     * @return Empty response is returned if operation was successful.
     */
    unmapAllSprints(): Promise<void> {
        let url_ = this.baseUrl + "/agile/1.0/sprint/unmap-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnmapAllSprints(_response);
        });
    }

    protected processUnmapAllSprints(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license or does not have permission to unmap sprints.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if at least one sprint does not exist or user does not have permission to view to at least one sprint.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get sprint by id
     * @return Returns the requested sprint.
     */
    getSprint(sprintId: number): Promise<SprintBean> {
        let url_ = this.baseUrl + "/agile/1.0/sprint/{sprintId}";
        if (sprintId === undefined || sprintId === null)
            throw new Error("The parameter 'sprintId' must be defined.");
        url_ = url_.replace("{sprintId}", encodeURIComponent("" + sprintId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSprint(_response);
        });
    }

    protected processGetSprint(response: Response): Promise<SprintBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SprintBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the sprint does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SprintBean>(null as any);
    }

    /**
     * Update a sprint fully
     * @param body The updated sprint.
     * @return Returns the updated sprint.
     */
    updateSprint(sprintId: number, body: SprintBean): Promise<SprintBean> {
        let url_ = this.baseUrl + "/agile/1.0/sprint/{sprintId}";
        if (sprintId === undefined || sprintId === null)
            throw new Error("The parameter 'sprintId' must be defined.");
        url_ = url_.replace("{sprintId}", encodeURIComponent("" + sprintId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSprint(_response);
        });
    }

    protected processUpdateSprint(response: Response): Promise<SprintBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SprintBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the sprint does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SprintBean>(null as any);
    }

    /**
     * Partially update a sprint
     * @param body The updated sprint.
     * @return Returns the updated sprint.
     */
    partiallyUpdateSprint(sprintId: number, body: SprintBean): Promise<SprintBean> {
        let url_ = this.baseUrl + "/agile/1.0/sprint/{sprintId}";
        if (sprintId === undefined || sprintId === null)
            throw new Error("The parameter 'sprintId' must be defined.");
        url_ = url_.replace("{sprintId}", encodeURIComponent("" + sprintId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPartiallyUpdateSprint(_response);
        });
    }

    protected processPartiallyUpdateSprint(response: Response): Promise<SprintBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SprintBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the sprint does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SprintBean>(null as any);
    }

    /**
     * Delete a sprint
     * @return Returned if the sprint was deleted successfully.
     */
    deleteSprint(sprintId: number): Promise<void> {
        let url_ = this.baseUrl + "/agile/1.0/sprint/{sprintId}";
        if (sprintId === undefined || sprintId === null)
            throw new Error("The parameter 'sprintId' must be defined.");
        url_ = url_.replace("{sprintId}", encodeURIComponent("" + sprintId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSprint(_response);
        });
    }

    protected processDeleteSprint(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the sprint is active or completed.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license or does not have permission to delete sprints.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the sprint does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Move issues to a sprint
     * @param body The issues to move.
     * @return Empty response is returned if operation was successful.
     */
    moveIssuesToSprint(sprintId: number, body: IssueAssignRequestBean): Promise<void> {
        let url_ = this.baseUrl + "/agile/1.0/sprint/{sprintId}/issue";
        if (sprintId === undefined || sprintId === null)
            throw new Error("The parameter 'sprintId' must be defined.");
        url_ = url_.replace("{sprintId}", encodeURIComponent("" + sprintId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMoveIssuesToSprint(_response);
        });
    }

    protected processMoveIssuesToSprint(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license or does not have permission to assign issues.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the sprint does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Swap the position of two sprints
     * @param body The sprint to swap with.
     * @return Returned if the sprint swap was performed successfully.
     */
    swapSprint(sprintId: number, body: SprintSwapBean): Promise<void> {
        let url_ = this.baseUrl + "/agile/1.0/sprint/{sprintId}/swap";
        if (sprintId === undefined || sprintId === null)
            throw new Error("The parameter 'sprintId' must be defined.");
        url_ = url_.replace("{sprintId}", encodeURIComponent("" + sprintId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSwapSprint(_response);
        });
    }

    protected processSwapSprint(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license or does not have permission to at least one sprint.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if at least one sprint does not exist or user does not have permission to view to at least one sprint.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get an application property by key
     * @param permissionLevel when fetching a list specifies the permission level of all items in the list
    see {@link com.atlassian.jira.bc.admin.ApplicationPropertiesService.EditPermissionLevel}
     * @param key a String containing the property key.
     * @param keyFilter (optional) when fetching a list allows the list to be filtered by the property's start of key
    e.g. "jira.lf.*" whould fetch only those permissions that are editable and whose keys start with
         *                        "jira.lf.". This is a regex.
     * @return Returned if the property exists and the currently authenticated user has permission to view it. Contains a full representation of the property.
     */
    getProperty2(permissionLevel: string, key: string, keyFilter?: string | undefined): Promise<Property> {
        let url_ = this.baseUrl + "/api/2/application-properties?";
        if (permissionLevel === undefined || permissionLevel === null)
            throw new Error("The parameter 'permissionLevel' must be defined and cannot be null.");
        else
            url_ += "permissionLevel=" + encodeURIComponent("" + permissionLevel) + "&";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined and cannot be null.");
        else
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (keyFilter === null)
            throw new Error("The parameter 'keyFilter' cannot be null.");
        else if (keyFilter !== undefined)
            url_ += "keyFilter=" + encodeURIComponent("" + keyFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProperty2(_response);
        });
    }

    protected processGetProperty2(response: Response): Promise<Property> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Property.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("The action performed requires a logged in user.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Property>(null as any);
    }

    /**
     * Get all advanced settings properties
     * @return Returns all properties to display in the "General Configuration > Advanced Settings" page.
     */
    getAdvancedSettings(): Promise<Property> {
        let url_ = this.baseUrl + "/api/2/application-properties/advanced-settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAdvancedSettings(_response);
        });
    }

    protected processGetAdvancedSettings(response: Response): Promise<Property> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Property.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not an administrator.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Property>(null as any);
    }

    /**
     * Update an application property
     * @param id a String containing the property key.
     * @return Returned if the property exists and the currently authenticated user has permission to edit it.
     */
    setPropertyViaRestfulTable(id: string): Promise<Property> {
        let url_ = this.baseUrl + "/api/2/application-properties/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPropertyViaRestfulTable(_response);
        });
    }

    protected processSetPropertyViaRestfulTable(response: Response): Promise<Property> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Property.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to edit the property.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the property does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Property>(null as any);
    }

    /**
     * Get all application roles in the system
     * @return Returns all ApplicationRoles in the system
     */
    getAll(): Promise<ApplicationRoleBean> {
        let url_ = this.baseUrl + "/api/2/applicationrole";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<ApplicationRoleBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not an administrator.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationRoleBean>(null as any);
    }

    /**
     * Update application roles
     * @param if_Match (optional) 
     * @param body (optional) the data to update the roles with.
     * @return Returns the updated ApplicationRoles if the update was successful.
     */
    putBulk(if_Match?: string | undefined, body?: ApplicationRoleBean | undefined): Promise<ApplicationRoleBean> {
        let url_ = this.baseUrl + "/api/2/applicationrole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "If-Match": if_Match !== undefined && if_Match !== null ? "" + if_Match : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutBulk(_response);
        });
    }

    protected processPutBulk(response: Response): Promise<ApplicationRoleBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user does not have permission to edit roles.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not an administrator.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the role does not exist.", status, _responseText, _headers);
            });
        } else if (status === 412) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the versionHash is not null and contains a different version to the server.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationRoleBean>(null as any);
    }

    /**
     * Get attachment capabilities
     * @return JSON representation of the attachment capabilities. Consumers of this resource may also need to check if the logged in user has permission to upload or otherwise manipulate attachments using the com.atlassian.jira.rest.v2.permission.PermissionsResource
     */
    getAttachmentMeta(): Promise<AttachmentMetaBean> {
        let url_ = this.baseUrl + "/api/2/attachment/meta";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAttachmentMeta(_response);
        });
    }

    protected processGetAttachmentMeta(response: Response): Promise<AttachmentMetaBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentMetaBean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AttachmentMetaBean>(null as any);
    }

    /**
     * Get the meta-data for an attachment, including the URI of the actual attached file
     * @param id id of the attachment to view
     * @return JSON representation of the attachment meta-data. The representation does not contain the attachment itself, but contains a URI that can be used to download the actual attached file.
     */
    getAttachment(id: string): Promise<AttachmentBean> {
        let url_ = this.baseUrl + "/api/2/attachment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAttachment(_response);
        });
    }

    protected processGetAttachment(response: Response): Promise<AttachmentBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("The calling user is not permitted to view the requested attachment.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Any of: there is no attachment with the requested id, attachments feature is disabled", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AttachmentBean>(null as any);
    }

    /**
     * Delete an attachment from an issue
     * @param id id of the attachment to remove
     * @return Removal was successful
     */
    removeAttachment(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/attachment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveAttachment(_response);
        });
    }

    protected processRemoveAttachment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("The calling user is not permitted to remove the requested attachment.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get human-readable attachment expansion
     * @param id the id of the attachment to expand.
     * @return JSON representation of the attachment expanded contents. Empty entry list means that attachment cannot be expanded. It's either empty, corrupt or not an archive at all.
     */
    expandForHumans(id: string): Promise<HumanReadableArchive> {
        let url_ = this.baseUrl + "/api/2/attachment/{id}/expand/human";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExpandForHumans(_response);
        });
    }

    protected processExpandForHumans(response: Response): Promise<HumanReadableArchive> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HumanReadableArchive.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("The calling user is not permitted to view the requested attachment.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Any of: there is no attachment with the requested id, attachments feature is disabled", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("The archive format is not supported. since v6.4", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HumanReadableArchive>(null as any);
    }

    /**
     * Get raw attachment expansion
     * @param id the id of the attachment to expand.
     * @return JSON representation of the attachment expanded contents. Empty entry list means that attachment cannot be expanded. It's either empty, corrupt or not an archive at all.
     */
    expandForMachines(id: string): Promise<AttachmentArchiveImpl> {
        let url_ = this.baseUrl + "/api/2/attachment/{id}/expand/raw";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExpandForMachines(_response);
        });
    }

    protected processExpandForMachines(response: Response): Promise<AttachmentArchiveImpl> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentArchiveImpl.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("The calling user is not permitted to view the requested attachment.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Any of: there is no attachment with the requested id, attachments feature is disabled", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("The archive format is not supported. since v6.4", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AttachmentArchiveImpl>(null as any);
    }

    /**
     * Get all system avatars
     * @param type the avatar type
     * @return Returns a map containing a list of system avatars. A map is returned to be consistent with the shape of the project/KEY/avatars REST end point.
     */
    getAllSystemAvatars(type: string): Promise<AvatarBean> {
        let url_ = this.baseUrl + "/api/2/avatar/{type}/system";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSystemAvatars(_response);
        });
    }

    protected processGetAllSystemAvatars(response: Response): Promise<AvatarBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AvatarBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if accessed by anonymous user", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while retrieving the list of avatars.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvatarBean>(null as any);
    }

    /**
     * Create temporary avatar
     * @param type the avatar type
     * @param filename (optional) name of file being uploaded
     * @param size (optional) size of file
     * @return temporary avatar cropping instructions
     */
    storeTemporaryAvatar(type: string, filename?: string | undefined, size?: string | undefined): Promise<AvatarCroppingBean> {
        let url_ = this.baseUrl + "/api/2/avatar/{type}/temporary?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (filename === null)
            throw new Error("The parameter 'filename' cannot be null.");
        else if (filename !== undefined)
            url_ += "filename=" + encodeURIComponent("" + filename) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStoreTemporaryAvatar(_response);
        });
    }

    protected processStoreTemporaryAvatar(response: Response): Promise<AvatarCroppingBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AvatarCroppingBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Validation failed. For example filesize is beyond max attachment size.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request does not contain a valid XSRF token", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while converting temporary avatar to real avatar", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvatarCroppingBean>(null as any);
    }

    /**
     * Update avatar cropping
     * @param type the avatar type
     * @param body (optional) cropping instructions
     */
    createAvatarFromTemporary(type: string, body?: AvatarCroppingBean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/avatar/{type}/temporaryCrop";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateAvatarFromTemporary(_response);
        });
    }

    protected processCreateAvatarFromTemporary(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the cropping coordinates are invalid", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while cropping the temporary avatar", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Request node index snapshot
     * @param nodeId ID of the node to request index from
     * @return Request was successful
     * @deprecated
     */
    requestCurrentIndexFromNode(nodeId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/cluster/index-snapshot/{nodeId}";
        if (nodeId === undefined || nodeId === null)
            throw new Error("The parameter 'nodeId' must be defined.");
        url_ = url_.replace("{nodeId}", encodeURIComponent("" + nodeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestCurrentIndexFromNode(_response);
        });
    }

    protected processRequestCurrentIndexFromNode(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user doesn\'t have admin permissions", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the node with this nodeID doesn\'t exist", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Returned if you call this method, but don\'t have Jira Data Center", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete a cluster node
     * @param nodeId ID of the node to delete
     * @return Removal was successful
     */
    deleteNode(nodeId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/cluster/node/{nodeId}";
        if (nodeId === undefined || nodeId === null)
            throw new Error("The parameter 'nodeId' must be defined.");
        url_ = url_.replace("{nodeId}", encodeURIComponent("" + nodeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteNode(_response);
        });
    }

    protected processDeleteNode(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user doesn\'t have admin permissions", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the node with this nodeID doesn\'t exist", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Returned if you call this method, but don\'t have Jira Data Center", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the server can\'t delete the node", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update node state to offline
     * @param nodeId ID of the node to change state
     * @return State change was successful
     */
    changeNodeStateToOffline(nodeId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/cluster/node/{nodeId}/offline";
        if (nodeId === undefined || nodeId === null)
            throw new Error("The parameter 'nodeId' must be defined.");
        url_ = url_.replace("{nodeId}", encodeURIComponent("" + nodeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeNodeStateToOffline(_response);
        });
    }

    protected processChangeNodeStateToOffline(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user doesn\'t have admin permissions", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the node with this nodeID doesn\'t exist", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Returned if you call this method, but don\'t have Jira Data Center", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the server can\'t change the node\'s state", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all cluster nodes
     * @return Returns a list of all nodes in the cluster.
     */
    getAllNodes(): Promise<NodeBean> {
        let url_ = this.baseUrl + "/api/2/cluster/nodes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllNodes(_response);
        });
    }

    protected processGetAllNodes(response: Response): Promise<NodeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NodeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user doesn\'t have admin permissions", status, _responseText, _headers);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            return throwException("Returned if you call this method, but don\'t have Jira Data Center", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NodeBean>(null as any);
    }

    /**
     * Approve cluster upgrade
     * @return Upgrade approval was successful
     */
    approveUpgrade(): Promise<void> {
        let url_ = this.baseUrl + "/api/2/cluster/zdu/approve";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApproveUpgrade(_response);
        });
    }

    protected processApproveUpgrade(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user doesn\'t have admin permissions", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no ongoing upgrade to approve", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Cancel cluster upgrade
     * @return Upgrade cancellation was successful
     */
    cancelUpgrade(): Promise<void> {
        let url_ = this.baseUrl + "/api/2/cluster/zdu/cancel";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelUpgrade(_response);
        });
    }

    protected processCancelUpgrade(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user doesn\'t have admin permissions", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no ongoing upgrade to cancel", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Retry cluster upgrade
     * @return Upgrade retry was successful
     */
    acknowledgeErrors(): Promise<void> {
        let url_ = this.baseUrl + "/api/2/cluster/zdu/retryUpgrade";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAcknowledgeErrors(_response);
        });
    }

    protected processAcknowledgeErrors(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user doesn\'t have admin permissions", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no failed upgrade to retry", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Start cluster upgrade
     * @return Upgrade start was successful
     */
    setReadyToUpgrade(): Promise<void> {
        let url_ = this.baseUrl + "/api/2/cluster/zdu/start";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetReadyToUpgrade(_response);
        });
    }

    protected processSetReadyToUpgrade(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user doesn\'t have admin permissions", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is already an ongoing upgrade", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get cluster upgrade state
     * @return Returns the current state of the cluster upgrade.
     */
    getState(): Promise<ClusterState> {
        let url_ = this.baseUrl + "/api/2/cluster/zdu/state";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetState(_response);
        });
    }

    protected processGetState(response: Response): Promise<ClusterState> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClusterState.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user doesn\'t have admin permissions", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClusterState>(null as any);
    }

    /**
     * Create component
     * @param body (optional) the request containing value of the component's property. The value has to be a valid, non-empty JSON conforming to http://tools.ietf.org/html/rfc4627. The maximum length of the property value is 32768 bytes.
     * @return Returned if the component is created successfully.
     */
    createComponent(body?: ComponentBean | undefined): Promise<ComponentBean> {
        let url_ = this.baseUrl + "/api/2/component";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateComponent(_response);
        });
    }

    protected processCreateComponent(response: Response): Promise<ComponentBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ComponentBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller is not logged in and does not have permission to create components in the project.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller is authenticated and does not have permission to create components in the project.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ComponentBean>(null as any);
    }

    /**
     * Get paginated components
     * @param maxResults (optional) the maximum number of components to return
     * @param query (optional) the string that components names will be matched with
     * @param projectIds (optional) the set of project ids to filter components
     * @param startAt (optional) the index of the first components to return
     * @return Returns paginated list of components
     */
    getPaginatedComponents(maxResults?: string | undefined, query?: string | undefined, projectIds?: string | undefined, startAt?: string | undefined): Promise<PageBean> {
        let url_ = this.baseUrl + "/api/2/component/page?";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (projectIds === null)
            throw new Error("The parameter 'projectIds' cannot be null.");
        else if (projectIds !== undefined)
            url_ += "projectIds=" + encodeURIComponent("" + projectIds) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaginatedComponents(_response);
        });
    }

    protected processGetPaginatedComponents(response: Response): Promise<PageBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PageBean>(null as any);
    }

    /**
     * Get project component
     * @param id a String containing the component key
     * @return Returns a full JSON representation of a project component.
     */
    getComponent(id: string): Promise<ComponentBean> {
        let url_ = this.baseUrl + "/api/2/component/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetComponent(_response);
        });
    }

    protected processGetComponent(response: Response): Promise<ComponentBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ComponentBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no component with the given key, or if the calling user does not have permission to view the component.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ComponentBean>(null as any);
    }

    /**
     * Update a component
     * @param id The component to delete.
     * @param body (optional) the request containing value of the component's property. The value has to be a valid, non-empty JSON conforming to http://tools.ietf.org/html/rfc4627. The maximum length of the property value is 32768 bytes.
     * @return Returned if the component is successfully updated.
     */
    updateComponent(id: string, body?: ComponentBean | undefined): Promise<ComponentBean> {
        let url_ = this.baseUrl + "/api/2/component/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateComponent(_response);
        });
    }

    protected processUpdateComponent(response: Response): Promise<ComponentBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ComponentBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to edit the component.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the component does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ComponentBean>(null as any);
    }

    /**
     * Delete a project component
     * @param id The component to delete.
     * @param moveIssuesTo (optional) The new component applied to issues whose 'id' component will be deleted. If this value is null, then the 'id' component is simply removed from the related isues.
     * @return Returned if the component is successfully deleted.
     */
    delete(id: string, moveIssuesTo?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/component/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (moveIssuesTo === null)
            throw new Error("The parameter 'moveIssuesTo' cannot be null.");
        else if (moveIssuesTo !== undefined)
            url_ += "moveIssuesTo=" + encodeURIComponent("" + moveIssuesTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to delete the component.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the component does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get component related issues
     * @param id a String containing the component id
     * @return Returns counts of issues related to this component.
     */
    getComponentRelatedIssues(id: string): Promise<ComponentIssueCountsBean> {
        let url_ = this.baseUrl + "/api/2/component/{id}/relatedIssueCounts";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetComponentRelatedIssues(_response);
        });
    }

    protected processGetComponentRelatedIssues(response: Response): Promise<ComponentIssueCountsBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ComponentIssueCountsBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the component does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ComponentIssueCountsBean>(null as any);
    }

    /**
     * Get custom field option by ID
     * @param id a String containing an Custom Field Option id.
     * @return Returned if the Custom Field Option exists and is visible by the calling user.
     */
    getCustomFieldOption(id: string): Promise<CustomFieldOptionBean> {
        let url_ = this.baseUrl + "/api/2/customFieldOption/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCustomFieldOption(_response);
        });
    }

    protected processGetCustomFieldOption(response: Response): Promise<CustomFieldOptionBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomFieldOptionBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the Custom Field Option does not exist, or is not visible to the calling user.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomFieldOptionBean>(null as any);
    }

    /**
     * Get custom fields with pagination
     * @param sortColumn (optional) The column by which to sort the returned custom fields.
     * @param types (optional) A list of custom field types to filter the custom fields.
     * @param search (optional) A query string used to search custom fields.
     * @param maxResults (optional) The maximum number of custom fields to return.
     * @param sortOrder (optional) The order in which to sort the returned custom fields.
     * @param screenIds (optional) A list of screen IDs to filter the custom fields.
     * @param lastValueUpdate (optional) The last value update to filter the custom fields.
     * @param projectIds (optional) A list of project IDs to filter the custom fields.
     * @param startAt (optional) The starting index of the returned custom fields.
     * @return Returned if a custom field with the given customFieldId exists and user has permission to it.
     */
    getCustomFields(sortColumn?: string | undefined, types?: string | undefined, search?: string | undefined, maxResults?: string | undefined, sortOrder?: string | undefined, screenIds?: string | undefined, lastValueUpdate?: string | undefined, projectIds?: string | undefined, startAt?: string | undefined): Promise<CustomFieldBean> {
        let url_ = this.baseUrl + "/api/2/customFields?";
        if (sortColumn === null)
            throw new Error("The parameter 'sortColumn' cannot be null.");
        else if (sortColumn !== undefined)
            url_ += "sortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (types === null)
            throw new Error("The parameter 'types' cannot be null.");
        else if (types !== undefined)
            url_ += "types=" + encodeURIComponent("" + types) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (sortOrder === null)
            throw new Error("The parameter 'sortOrder' cannot be null.");
        else if (sortOrder !== undefined)
            url_ += "sortOrder=" + encodeURIComponent("" + sortOrder) + "&";
        if (screenIds === null)
            throw new Error("The parameter 'screenIds' cannot be null.");
        else if (screenIds !== undefined)
            url_ += "screenIds=" + encodeURIComponent("" + screenIds) + "&";
        if (lastValueUpdate === null)
            throw new Error("The parameter 'lastValueUpdate' cannot be null.");
        else if (lastValueUpdate !== undefined)
            url_ += "lastValueUpdate=" + encodeURIComponent("" + lastValueUpdate) + "&";
        if (projectIds === null)
            throw new Error("The parameter 'projectIds' cannot be null.");
        else if (projectIds !== undefined)
            url_ += "projectIds=" + encodeURIComponent("" + projectIds) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCustomFields(_response);
        });
    }

    protected processGetCustomFields(response: Response): Promise<CustomFieldBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomFieldBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if a custom field with the given customFieldId does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomFieldBean>(null as any);
    }

    /**
     * Delete custom fields in bulk
     * @param ids A list of custom field IDs to delete.
     * @return Returned if at least one custom field was deleted
     */
    bulkDeleteCustomFields(ids: string): Promise<BulkDeleteResponseBean> {
        let url_ = this.baseUrl + "/api/2/customFields?";
        if (ids === undefined || ids === null)
            throw new Error("The parameter 'ids' must be defined and cannot be null.");
        else
            url_ += "ids=" + encodeURIComponent("" + ids) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkDeleteCustomFields(_response);
        });
    }

    protected processBulkDeleteCustomFields(response: Response): Promise<BulkDeleteResponseBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkDeleteResponseBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if no fields were removed", status, _responseText, _headers);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            return throwException("Returned if could not obtain a cluster lock", status, _responseText, _headers);
            });
        } else if (status === 503) {
            return response.text().then((_responseText) => {
            return throwException("Returned if license or feature flag check failed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkDeleteResponseBean>(null as any);
    }

    /**
     * Get custom field options
     * @param customFieldId The ID of the custom field.
     * @param maxResults (optional) The maximum number of results to return.
     * @param issueTypeIds (optional) A list of issue type IDs in a context.
     * @param query (optional) A string used to filter options.
     * @param sortByOptionName (optional) Flag to sort options by their names.
     * @param useAllContexts (optional) Flag to fetch all options regardless of context, project IDs, or issue type IDs.
     * @param page (optional) The page of options to return.
     * @param projectIds (optional) A list of project IDs in a context.
     * @return Returned if a custom field with the given customFieldId exists and user has permission to it.
     */
    getCustomFieldOptions(customFieldId: string, maxResults?: string | undefined, issueTypeIds?: string | undefined, query?: string | undefined, sortByOptionName?: string | undefined, useAllContexts?: string | undefined, page?: string | undefined, projectIds?: string | undefined): Promise<CustomFieldOptionsBean> {
        let url_ = this.baseUrl + "/api/2/customFields/{customFieldId}/options?";
        if (customFieldId === undefined || customFieldId === null)
            throw new Error("The parameter 'customFieldId' must be defined.");
        url_ = url_.replace("{customFieldId}", encodeURIComponent("" + customFieldId));
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (issueTypeIds === null)
            throw new Error("The parameter 'issueTypeIds' cannot be null.");
        else if (issueTypeIds !== undefined)
            url_ += "issueTypeIds=" + encodeURIComponent("" + issueTypeIds) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (sortByOptionName === null)
            throw new Error("The parameter 'sortByOptionName' cannot be null.");
        else if (sortByOptionName !== undefined)
            url_ += "sortByOptionName=" + encodeURIComponent("" + sortByOptionName) + "&";
        if (useAllContexts === null)
            throw new Error("The parameter 'useAllContexts' cannot be null.");
        else if (useAllContexts !== undefined)
            url_ += "useAllContexts=" + encodeURIComponent("" + useAllContexts) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (projectIds === null)
            throw new Error("The parameter 'projectIds' cannot be null.");
        else if (projectIds !== undefined)
            url_ += "projectIds=" + encodeURIComponent("" + projectIds) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCustomFieldOptions(_response);
        });
    }

    protected processGetCustomFieldOptions(response: Response): Promise<CustomFieldOptionsBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomFieldOptionsBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if a custom field with the given customFieldId does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomFieldOptionsBean>(null as any);
    }

    /**
     * Get all dashboards with optional filtering
     * @param filter (optional) An optional filter that is applied to the list of dashboards.
     * @param maxResults (optional) A hint as to the maximum number of dashboards to return in each call.
     * @param startAt (optional) The index of the first dashboard to return (0-based).
     * @return Returns a list of dashboards.
     */
    list(filter?: string | undefined, maxResults?: string | undefined, startAt?: string | undefined): Promise<DashboardsBean> {
        let url_ = this.baseUrl + "/api/2/dashboard?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<DashboardsBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardsBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is an invalid startAt parameter.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardsBean>(null as any);
    }

    /**
     * Get all properties keys for a dashboard item
     * @param itemId The dashboard item from which keys will be returned.
     * @param dashboardId The dashboard id.
     * @return Returned if the dashboard item was found.
     */
    getPropertiesKeys2(itemId: string, dashboardId: string): Promise<EntityPropertiesKeysBean> {
        let url_ = this.baseUrl + "/api/2/dashboard/{dashboardId}/items/{itemId}/properties";
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPropertiesKeys2(_response);
        });
    }

    protected processGetPropertiesKeys2(response: Response): Promise<EntityPropertiesKeysBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityPropertiesKeysBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the dashboard item id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the dashboard item with given id does not exist or user does not have permissions to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityPropertiesKeysBean>(null as any);
    }

    /**
     * Set a property on a dashboard item
     * @param propertyKey The key of the dashboard item's property. The maximum length of the key is 255 bytes.
     * @param itemId The dashboard item on which the property will be set.
     * @param dashboardId The dashboard id.
     * @return Returned if the dashboard item property is successfully updated.
     */
    setProperty2(propertyKey: string, itemId: string, dashboardId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetProperty2(_response);
        });
    }

    protected processSetProperty2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the dashboard item id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer the dashboard item.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the dashboard item with given id does not exist or user does not have permissions to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a single dashboard by ID
     * @param id The dashboard id.
     * @return Returns a single dashboard.
     */
    getDashboard(id: string): Promise<DashboardBean> {
        let url_ = this.baseUrl + "/api/2/dashboard/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDashboard(_response);
        });
    }

    protected processGetDashboard(response: Response): Promise<DashboardBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no dashboard with the specified id, or if the user does not have permission to see it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardBean>(null as any);
    }

    /**
     * Get email templates as zip file
     * @return Zipping was successful
     */
    downloadEmailTemplates(): Promise<void> {
        let url_ = this.baseUrl + "/api/2/email-templates";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownloadEmailTemplates(_response);
        });
    }

    protected processDownloadEmailTemplates(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User is not a system admin", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("IOException happen or any unexpected exception was thrown", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update email templates with zip file
     * @param body (optional) 
     * @return Templates has extracted
     */
    uploadEmailTemplates(body?: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/email-templates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/zip",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadEmailTemplates(_response);
        });
    }

    protected processUploadEmailTemplates(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User is not a system admin", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("IOException happen or any unexpected exception is thrown", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update email templates with previously uploaded pack
     * @return Templates were replaced
     */
    applyEmailTemplates(): Promise<void> {
        let url_ = this.baseUrl + "/api/2/email-templates/apply";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplyEmailTemplates(_response);
        });
    }

    protected processApplyEmailTemplates(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("There were no templates previously uploaded", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Exception happened during applying process", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update email templates to default
     * @return Templates were restored to default
     */
    revertEmailTemplatesToDefault(): Promise<void> {
        let url_ = this.baseUrl + "/api/2/email-templates/revert";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRevertEmailTemplatesToDefault(_response);
        });
    }

    protected processRevertEmailTemplatesToDefault(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User is not a system admin", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Any unexpected exception is thrown", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get email types for templates
     * @return Reading email types was successful
     */
    getEmailTypes(): Promise<void> {
        let url_ = this.baseUrl + "/api/2/email-templates/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEmailTypes(_response);
        });
    }

    protected processGetEmailTypes(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("User is not a system admin", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Any unexpected exception is thrown", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all fields, both System and Custom
     * @return Returns a list of all fields
     */
    getFields(): Promise<FieldBean> {
        let url_ = this.baseUrl + "/api/2/field";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFields(_response);
        });
    }

    protected processGetFields(response: Response): Promise<FieldBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FieldBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not logged-in and don\'t have access to any project", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FieldBean>(null as any);
    }

    /**
     * Create a custom field using a definition
     * @param body (optional) 
     * @return Custom field was created
     */
    createCustomField(body?: CustomFieldDefinitionJsonBean | undefined): Promise<FieldBean> {
        let url_ = this.baseUrl + "/api/2/field";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCustomField(_response);
        });
    }

    protected processCreateCustomField(response: Response): Promise<FieldBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = FieldBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the input is invalid", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if exception occured during custom field creation", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FieldBean>(null as any);
    }

    /**
     * Create a new filter
     * @param expand (optional) 
     * @param body (optional) 
     * @return Returns a newly created filter
     */
    createFilter(expand?: StringList | undefined, body?: FilterBean | undefined): Promise<FilterBean> {
        let url_ = this.baseUrl + "/api/2/filter?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateFilter(_response);
        });
    }

    protected processCreateFilter(response: Response): Promise<FilterBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilterBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the input is invalid (e.g. filter name was not provided).", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FilterBean>(null as any);
    }

    /**
     * Get default share scope
     * @return Returns the default share scope of the logged-in user
     */
    getDefaultShareScope(): Promise<DefaultShareScopeBean> {
        let url_ = this.baseUrl + "/api/2/filter/defaultShareScope";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDefaultShareScope(_response);
        });
    }

    protected processGetDefaultShareScope(response: Response): Promise<DefaultShareScopeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DefaultShareScopeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is a problem looking up preferences for the logged-in user", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DefaultShareScopeBean>(null as any);
    }

    /**
     * Set default share scope
     * @param body (optional) 
     * @return Returns the new default share scope of the logged-in user
     */
    setDefaultShareScope(body?: DefaultShareScopeBean | undefined): Promise<DefaultShareScopeBean> {
        let url_ = this.baseUrl + "/api/2/filter/defaultShareScope";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetDefaultShareScope(_response);
        });
    }

    protected processSetDefaultShareScope(response: Response): Promise<DefaultShareScopeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DefaultShareScopeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is a problem setting the preferences for the logged-in user", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DefaultShareScopeBean>(null as any);
    }

    /**
     * Get favourite filters
     * @param expand (optional) 
     * @return Returns a list of favourite filters
     */
    getFavouriteFilters(expand?: StringList | undefined): Promise<FilterBean> {
        let url_ = this.baseUrl + "/api/2/filter/favourite?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFavouriteFilters(_response);
        });
    }

    protected processGetFavouriteFilters(response: Response): Promise<FilterBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilterBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not logged-in and don\'t have access to any project", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FilterBean>(null as any);
    }

    /**
     * Get a filter by ID
     * @param id The filter id.
     * @param expand (optional) 
     * @return Returns a filter
     */
    getFilter(id: string, expand?: StringList | undefined): Promise<FilterBean> {
        let url_ = this.baseUrl + "/api/2/filter/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFilter(_response);
        });
    }

    protected processGetFilter(response: Response): Promise<FilterBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilterBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not logged-in and don\'t have access to any project", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FilterBean>(null as any);
    }

    /**
     * Update an existing filter
     * @param id The filter id.
     * @param expand (optional) 
     * @param body (optional) 
     * @return Returns the updated filter
     */
    editFilter(id: string, expand?: StringList | undefined, body?: FilterBean | undefined): Promise<FilterBean> {
        let url_ = this.baseUrl + "/api/2/filter/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEditFilter(_response);
        });
    }

    protected processEditFilter(response: Response): Promise<FilterBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilterBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the input is invalid (e.g. filter name was not provided).", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FilterBean>(null as any);
    }

    /**
     * Delete a filter
     * @param id The ID of the filter to delete.
     * @return Returned if the filter was removed successfully.
     */
    deleteFilter(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/filter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFilter(_response);
        });
    }

    protected processDeleteFilter(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all share permissions of filter
     * @param id The filter id.
     * @return Returns a list of share permissions associated with the given filter
     */
    getSharePermissions(id: string): Promise<FilterPermissionBean> {
        let url_ = this.baseUrl + "/api/2/filter/{id}/permission";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSharePermissions(_response);
        });
    }

    protected processGetSharePermissions(response: Response): Promise<FilterPermissionBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilterPermissionBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned when filter with given id does not exist or when the user does not have permissions to view the filter.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FilterPermissionBean>(null as any);
    }

    /**
     * Add share permissions to filter
     * @param id The filter id.
     * @param body (optional) 
     * @return Returns share permissions associated with the given filter
     */
    addSharePermission(id: string, body?: SharePermissionInputBean | undefined): Promise<FilterPermissionBean> {
        let url_ = this.baseUrl + "/api/2/filter/{id}/permission";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddSharePermission(_response);
        });
    }

    protected processAddSharePermission(response: Response): Promise<FilterPermissionBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = FilterPermissionBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned given permission input bean is invalid or when user does not have the permission to share filters or when the user cannot edit the given filter.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned when filter with given id does not exist or when the user does not have permissions to view the filter.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FilterPermissionBean>(null as any);
    }

    /**
     * Remove share permissions from filter
     * @param permissionId The permission id.
     * @param id The filter id.
     * @return Returned if successful.
     */
    deleteSharePermission(permissionId: string, id: string, permission_id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/2/filter/{id}/permission/{permission-id}";
        if (permissionId === undefined || permissionId === null)
            throw new Error("The parameter 'permissionId' must be defined.");
        url_ = url_.replace("{permissionId}", encodeURIComponent("" + permissionId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (permission_id === undefined || permission_id === null)
            throw new Error("The parameter 'permission_id' must be defined.");
        url_ = url_.replace("{permission-id}", encodeURIComponent("" + permission_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSharePermission(_response);
        });
    }

    protected processDeleteSharePermission(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned when filter or permission with given id does not exist or when the user does not have permissions to view the filter.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a single share permission of filter
     * @param permissionId The permission id.
     * @param id The filter id.
     * @return Returns a share permission associated with the given filter and permission-id
     */
    getSharePermission(permissionId: string, id: string): Promise<FilterPermissionBean> {
        let url_ = this.baseUrl + "/api/2/filter/{id}/permission/{permissionId}";
        if (permissionId === undefined || permissionId === null)
            throw new Error("The parameter 'permissionId' must be defined.");
        url_ = url_.replace("{permissionId}", encodeURIComponent("" + permissionId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSharePermission(_response);
        });
    }

    protected processGetSharePermission(response: Response): Promise<FilterPermissionBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FilterPermissionBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned when filter or permission with given id does not exist or when the user does not have permissions to view the filter.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FilterPermissionBean>(null as any);
    }

    /**
     * Create a group with given parameters
     * @param body (optional) 
     * @return Returns full representation of a Jira group in JSON format.
     */
    createGroup(body?: AddGroupBean | undefined): Promise<GroupBean> {
        let url_ = this.baseUrl + "/api/2/group";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateGroup(_response);
        });
    }

    protected processCreateGroup(response: Response): Promise<GroupBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = GroupBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user requested an empty group name or group already exists", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user does not have administrator permissions.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupBean>(null as any);
    }

    /**
     * Delete a specified group
     * @param groupname The name of the group to delete.
     * @param swapGroup (optional) A different group to transfer the restrictions to.
     * @return Returned if the group was deleted.
     */
    removeGroup(groupname: string, swapGroup?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/group?";
        if (groupname === undefined || groupname === null)
            throw new Error("The parameter 'groupname' must be defined and cannot be null.");
        else
            url_ += "groupname=" + encodeURIComponent("" + groupname) + "&";
        if (swapGroup === null)
            throw new Error("The parameter 'swapGroup' cannot be null.");
        else if (swapGroup !== undefined)
            url_ += "swapGroup=" + encodeURIComponent("" + swapGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveGroup(_response);
        });
    }

    protected processRemoveGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user requested a group that does not exist", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user does not have administrator permissions.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested group was not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get users from a specified group
     * @param groupname The group name.
     * @param includeInactiveUsers (optional) Include inactive users.
     * @param maxResults (optional) The maximum number of users to return.
     * @param startAt (optional) The index of the first user in group to return.
     * @return Returns a paginated list of users in the group
     */
    getUsersFromGroup(groupname: string, includeInactiveUsers?: string | undefined, maxResults?: string | undefined, startAt?: string | undefined): Promise<UserJsonBean> {
        let url_ = this.baseUrl + "/api/2/group/member?";
        if (groupname === undefined || groupname === null)
            throw new Error("The parameter 'groupname' must be defined and cannot be null.");
        else
            url_ += "groupname=" + encodeURIComponent("" + groupname) + "&";
        if (includeInactiveUsers === null)
            throw new Error("The parameter 'includeInactiveUsers' cannot be null.");
        else if (includeInactiveUsers !== undefined)
            url_ += "includeInactiveUsers=" + encodeURIComponent("" + includeInactiveUsers) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUsersFromGroup(_response);
        });
    }

    protected processGetUsersFromGroup(response: Response): Promise<UserJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the name of the provided group is empty", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not admin or sysadmin", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the specified group does not exist", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserJsonBean>(null as any);
    }

    /**
     * Add a user to a specified group
     * @param groupname A name of requested group.
     * @param body (optional) 
     * @return Returns full representation of a Jira group in JSON format.
     */
    addUserToGroup(groupname: string, body?: UpdateUserToGroupBean | undefined): Promise<GroupBean> {
        let url_ = this.baseUrl + "/api/2/group/user?";
        if (groupname === undefined || groupname === null)
            throw new Error("The parameter 'groupname' must be defined and cannot be null.");
        else
            url_ += "groupname=" + encodeURIComponent("" + groupname) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddUserToGroup(_response);
        });
    }

    protected processAddUserToGroup(response: Response): Promise<GroupBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = GroupBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user requested an empty group name or the user already belongs to the group.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user does not have administrator permissions.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested group was not found or requested user was not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupBean>(null as any);
    }

    /**
     * Remove a user from a specified group
     * @param groupname A name of requested group.
     * @param username User to remove from a group
     * @return If the user was removed from the group.
     */
    removeUserFromGroup(groupname: string, username: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/group/user?";
        if (groupname === undefined || groupname === null)
            throw new Error("The parameter 'groupname' must be defined and cannot be null.");
        else
            url_ += "groupname=" + encodeURIComponent("" + groupname) + "&";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined and cannot be null.");
        else
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveUserFromGroup(_response);
        });
    }

    protected processRemoveUserFromGroup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user requested an empty group name", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user does not have administrator permissions.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested group was not found or the requested user wan not found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get groups matching a query
     * @param maxResults (optional) Maximum number of results to return
     * @param query (optional) A String to match groups against
     * @param exclude (optional) List of groups to exclude
     * @param userName (optional) Username for the context
     * @return Returns a collection of matching groups
     */
    findGroups(maxResults?: string | undefined, query?: string | undefined, exclude?: string | undefined, userName?: string | undefined): Promise<GroupSuggestionsBean> {
        let url_ = this.baseUrl + "/api/2/groups/picker?";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (exclude === null)
            throw new Error("The parameter 'exclude' cannot be null.");
        else if (exclude !== undefined)
            url_ += "exclude=" + encodeURIComponent("" + exclude) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindGroups(_response);
        });
    }

    protected processFindGroups(response: Response): Promise<GroupSuggestionsBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GroupSuggestionsBean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupSuggestionsBean>(null as any);
    }

    /**
     * Get users and groups matching query with highlighting
     * @param issueTypeId (optional) The list of issue type ids to further restrict the search
     * @param maxResults (optional) The maximum number of users to return
     * @param query (optional) A string used to search username, Name or e-mail address
     * @param showAvatar (optional) Show avatar
     * @param projectId (optional) The list of project ids to further restrict the search
     * @param fieldId (optional) The custom field id
     * @return Returns a list of users and groups matching query with highlighting
     */
    findUsersAndGroups(issueTypeId?: string | undefined, maxResults?: string | undefined, query?: string | undefined, showAvatar?: string | undefined, projectId?: string | undefined, fieldId?: string | undefined): Promise<UsersAndGroupsBean> {
        let url_ = this.baseUrl + "/api/2/groupuserpicker?";
        if (issueTypeId === null)
            throw new Error("The parameter 'issueTypeId' cannot be null.");
        else if (issueTypeId !== undefined)
            url_ += "issueTypeId=" + encodeURIComponent("" + issueTypeId) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (showAvatar === null)
            throw new Error("The parameter 'showAvatar' cannot be null.");
        else if (showAvatar !== undefined)
            url_ += "showAvatar=" + encodeURIComponent("" + showAvatar) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (fieldId === null)
            throw new Error("The parameter 'fieldId' cannot be null.");
        else if (fieldId !== undefined)
            url_ += "fieldId=" + encodeURIComponent("" + fieldId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindUsersAndGroups(_response);
        });
    }

    protected processFindUsersAndGroups(response: Response): Promise<UsersAndGroupsBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UsersAndGroupsBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have permission to view users and groups", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UsersAndGroupsBean>(null as any);
    }

    /**
     * Get list of available index snapshots
     * @return Returns the list consisting of absolute paths to currently available index snapshots
     */
    listIndexSnapshot(): Promise<IndexSnapshotBean> {
        let url_ = this.baseUrl + "/api/2/index-snapshot";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListIndexSnapshot(_response);
        });
    }

    protected processListIndexSnapshot(response: Response): Promise<IndexSnapshotBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IndexSnapshotBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller doesn\'t have sufficient privileges", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IndexSnapshotBean>(null as any);
    }

    /**
     * Create index snapshot if not in progress
     * @return Returns the absolute path which index snapshot will be placed in, after it's created
     */
    createIndexSnapshot(): Promise<IndexSnapshotPromiseBean> {
        let url_ = this.baseUrl + "/api/2/index-snapshot";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateIndexSnapshot(_response);
        });
    }

    protected processCreateIndexSnapshot(response: Response): Promise<IndexSnapshotPromiseBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = IndexSnapshotPromiseBean.fromJS(resultData202);
            return result202;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller doesn\'t have sufficient privileges", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("Returned if snapshot creation is already in progress", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IndexSnapshotPromiseBean>(null as any);
    }

    /**
     * Get index snapshot creation status
     * @return Returns status of current snapshot creation
     */
    isIndexSnapshotRunning(): Promise<IndexSnapshotStatusBean> {
        let url_ = this.baseUrl + "/api/2/index-snapshot/isRunning";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsIndexSnapshotRunning(_response);
        });
    }

    protected processIsIndexSnapshotRunning(response: Response): Promise<IndexSnapshotStatusBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IndexSnapshotStatusBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller doesn\'t have sufficient privileges", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IndexSnapshotStatusBean>(null as any);
    }

    /**
     * Get index condition summary
     * @return Returns an object with data about the condition of the Jira node's index
     */
    getIndexSummary(): Promise<IndexSummaryBean> {
        let url_ = this.baseUrl + "/api/2/index/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIndexSummary(_response);
        });
    }

    protected processGetIndexSummary(response: Response): Promise<IndexSummaryBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IndexSummaryBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned when the current authenticated user does not have admin permission", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IndexSummaryBean>(null as any);
    }

    /**
     * Create an issue or sub-task from json
     * @param updateHistory (optional) 
     * @param body (optional) Issue update bean
     * @return Returns a link to the created issue.
     */
    createIssue(updateHistory?: boolean | undefined, body?: IssueUpdateBean | undefined): Promise<IssueCreateResponse> {
        let url_ = this.baseUrl + "/api/2/issue?";
        if (updateHistory === null)
            throw new Error("The parameter 'updateHistory' cannot be null.");
        else if (updateHistory !== undefined)
            url_ += "updateHistory=" + encodeURIComponent("" + updateHistory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateIssue(_response);
        });
    }

    protected processCreateIssue(response: Response): Promise<IssueCreateResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = IssueCreateResponse.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the input is invalid (e.g. missing required fields, invalid field values, and so forth).", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueCreateResponse>(null as any);
    }

    /**
     * Archive list of issues
     * @param notifyUsers (optional) Send the email with notification that the issue was updated to users that watch it. Admin or project admin permissions are required to disable the notification.
     * @param body (optional) List of issue keys
     * @return Returns a stream of issues archiving results.
     */
    archiveIssues(notifyUsers?: string | undefined, body?: string | undefined): Promise<any> {
        let url_ = this.baseUrl + "/api/2/issue/archive?";
        if (notifyUsers === null)
            throw new Error("The parameter 'notifyUsers' cannot be null.");
        else if (notifyUsers !== undefined)
            url_ += "notifyUsers=" + encodeURIComponent("" + notifyUsers) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "text/plain",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processArchiveIssues(_response);
        });
    }

    protected processArchiveIssues(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to archive the issue or doesn\'t have DC license or issue is already archived.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Create an issue or sub-task from json - bulk operation.
     * @param body (optional) Issues update bean
     * @return Returns a link to the created issues.
     */
    createIssues(body?: IssuesUpdateBean | undefined): Promise<IssuesCreateResponse> {
        let url_ = this.baseUrl + "/api/2/issue/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateIssues(_response);
        });
    }

    protected processCreateIssues(response: Response): Promise<IssuesCreateResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = IssuesCreateResponse.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the input is invalid (e.g. missing required fields, invalid field values, and so forth).", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssuesCreateResponse>(null as any);
    }

    /**
     * Get metadata for project issue types
     * @param projectIdOrKey Project id or key
     * @param maxResults (optional) How many results on the page should be included
     * @param startAt (optional) The page offset
     * @return Returns the metadata for issue types used for creating issues.
     */
    getCreateIssueMetaProjectIssueTypes(projectIdOrKey: string, maxResults?: string | undefined, startAt?: string | undefined): Promise<CreateMetaIssueTypeBean> {
        let url_ = this.baseUrl + "/api/2/issue/createmeta/{projectIdOrKey}/issuetypes?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCreateIssueMetaProjectIssueTypes(_response);
        });
    }

    protected processGetCreateIssueMetaProjectIssueTypes(response: Response): Promise<CreateMetaIssueTypeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateMetaIssueTypeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have permission to view the requested project or project doesn\'t exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateMetaIssueTypeBean>(null as any);
    }

    /**
     * Get metadata for issue types used for creating issues
     * @param issueTypeId Issue type id
     * @param projectIdOrKey Project id or key
     * @param maxResults (optional) How many results on the page should be included
     * @param startAt (optional) The page offset
     * @return Returns the metadata for issue types used for creating issues.
     */
    getCreateIssueMetaFields(issueTypeId: string, projectIdOrKey: string, maxResults?: string | undefined, startAt?: string | undefined): Promise<FieldMetaBean> {
        let url_ = this.baseUrl + "/api/2/issue/createmeta/{projectIdOrKey}/issuetypes/{issueTypeId}?";
        if (issueTypeId === undefined || issueTypeId === null)
            throw new Error("The parameter 'issueTypeId' must be defined.");
        url_ = url_.replace("{issueTypeId}", encodeURIComponent("" + issueTypeId));
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCreateIssueMetaFields(_response);
        });
    }

    protected processGetCreateIssueMetaFields(response: Response): Promise<FieldMetaBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FieldMetaBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have permission to view the requested project or project doesn\'t exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FieldMetaBean>(null as any);
    }

    /**
     * Get suggested issues for auto-completion
     * @param currentProjectId (optional) the id of the project in context of which the request is executed
     * @param query (optional) the query
     * @param currentIssueKey (optional) the key of the issue in context of which the request is executed
     * @param showSubTasks (optional) if set to false, subtasks will not be included in the list
     * @param currentJQL (optional) the JQL in context of which the request is executed
     * @param showSubTaskParent (optional) if set to false and request is executed in context of a subtask, the parent issue will not be included in the auto-completion result, even if it matches the query
     * @return Returns a response containing issue picker resource.
     */
    getIssuePickerResource(currentProjectId?: string | undefined, query?: string | undefined, currentIssueKey?: string | undefined, showSubTasks?: string | undefined, currentJQL?: string | undefined, showSubTaskParent?: string | undefined): Promise<IssuePickerResult> {
        let url_ = this.baseUrl + "/api/2/issue/picker?";
        if (currentProjectId === null)
            throw new Error("The parameter 'currentProjectId' cannot be null.");
        else if (currentProjectId !== undefined)
            url_ += "currentProjectId=" + encodeURIComponent("" + currentProjectId) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (currentIssueKey === null)
            throw new Error("The parameter 'currentIssueKey' cannot be null.");
        else if (currentIssueKey !== undefined)
            url_ += "currentIssueKey=" + encodeURIComponent("" + currentIssueKey) + "&";
        if (showSubTasks === null)
            throw new Error("The parameter 'showSubTasks' cannot be null.");
        else if (showSubTasks !== undefined)
            url_ += "showSubTasks=" + encodeURIComponent("" + showSubTasks) + "&";
        if (currentJQL === null)
            throw new Error("The parameter 'currentJQL' cannot be null.");
        else if (currentJQL !== undefined)
            url_ += "currentJQL=" + encodeURIComponent("" + currentJQL) + "&";
        if (showSubTaskParent === null)
            throw new Error("The parameter 'showSubTaskParent' cannot be null.");
        else if (showSubTaskParent !== undefined)
            url_ += "showSubTaskParent=" + encodeURIComponent("" + showSubTaskParent) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssuePickerResource(_response);
        });
    }

    protected processGetIssuePickerResource(response: Response): Promise<IssuePickerResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssuePickerResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssuePickerResult>(null as any);
    }

    /**
     * Get issue for key
     * @param issueIdOrKey Issue id or key
     * @param expand (optional) The expand param is used to include, hidden by default, parts of response. This can be used to include: renderedFields, names, schema, transitions, operations, editmeta, changelog, versionedRepresentations.
     * @param fields (optional) The list of fields to return for the issue. By default, all fields are returned.
     * @param updateHistory (optional) The updateHistory param adds the issues retrieved by this method to the current user's issue history
     * @param properties (optional) The list of properties to return for the issue. By default no properties are returned.
     * @return Returns a full representation of a Jira issue in JSON format.
     */
    getIssue2(issueIdOrKey: string, expand?: string | undefined, fields?: string | undefined, updateHistory?: string | undefined, properties?: string | undefined): Promise<IssueBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            url_ += "fields=" + encodeURIComponent("" + fields) + "&";
        if (updateHistory === null)
            throw new Error("The parameter 'updateHistory' cannot be null.");
        else if (updateHistory !== undefined)
            url_ += "updateHistory=" + encodeURIComponent("" + updateHistory) + "&";
        if (properties === null)
            throw new Error("The parameter 'properties' cannot be null.");
        else if (properties !== undefined)
            url_ += "properties=" + encodeURIComponent("" + properties) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssue2(_response);
        });
    }

    protected processGetIssue2(response: Response): Promise<IssueBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested issue is not found, or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueBean>(null as any);
    }

    /**
     * Edit an issue from a JSON representation
     * @param issueIdOrKey Issue id or key
     * @param notifyUsers (optional) Send the email with notification that the issue was updated to users that watch it. Admin or project admin permissions are required to disable the notification.
     * @param body (optional) Issue update bean
     * @return Returned if it updated the issue successfully.
     */
    editIssue(issueIdOrKey: string, notifyUsers?: string | undefined, body?: IssueUpdateBean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (notifyUsers === null)
            throw new Error("The parameter 'notifyUsers' cannot be null.");
        else if (notifyUsers !== undefined)
            url_ += "notifyUsers=" + encodeURIComponent("" + notifyUsers) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEditIssue(_response);
        });
    }

    protected processEditIssue(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested issue update failed.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user doesn\'t have permissions to disable users notification.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete an issue
     * @param issueIdOrKey Issue id or key
     * @param deleteSubtasks (optional) A String of true or false indicating that any subtasks should also be deleted. If the issue has no subtasks this parameter is ignored. If the issue has subtasks and this parameter is missing or false, then the issue will not be deleted and an error will be returned.
     * @return Returned if the issue was removed successfully.
     */
    deleteIssue(issueIdOrKey: string, deleteSubtasks?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (deleteSubtasks === null)
            throw new Error("The parameter 'deleteSubtasks' cannot be null.");
        else if (deleteSubtasks !== undefined)
            url_ += "deleteSubtasks=" + encodeURIComponent("" + deleteSubtasks) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteIssue(_response);
        });
    }

    protected processDeleteIssue(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to delete the issue.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Archive an issue
     * @param issueIdOrKey Issue id or key
     * @param notifyUsers (optional) Send the email with notification that the issue was updated to users that watch it. Admin or project admin permissions are required to disable the notification.
     * @return Returns a response indicating the result of the archive operation.
     */
    archiveIssue(issueIdOrKey: string, notifyUsers?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/archive?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (notifyUsers === null)
            throw new Error("The parameter 'notifyUsers' cannot be null.");
        else if (notifyUsers !== undefined)
            url_ += "notifyUsers=" + encodeURIComponent("" + notifyUsers) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processArchiveIssue(_response);
        });
    }

    protected processArchiveIssue(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to archive the issue or doesn\'t have DC license or issue is already archived.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Assign an issue to a user
     * @param issueIdOrKey Issue id or key
     * @param body (optional) UserBean containing the username
     * @return Returns a response indicating the result of the assign operation.
     */
    assign(issueIdOrKey: string, body?: UserBean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/assignee";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssign(_response);
        });
    }

    protected processAssign(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is a problem with the received user representation.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to assign the issue.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if either the issue or the user does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Add one or more attachments to an issue
     * @param issueIdOrKey Issue id or key
     * @param body (optional) Attachments to be added
     * @return Returns a JSON representation of the attachments added.
     */
    addAttachment(issueIdOrKey: string, body?: Blob | undefined): Promise<AttachmentJsonBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/attachments";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "multipart/form-data",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddAttachment(_response);
        });
    }

    protected processAddAttachment(response: Response): Promise<AttachmentJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if attachments is disabled or if you don\'t have permission to add attachments to this issue.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested issue is not found, the user does not have permission to view it, or if the attachments exceeds the maximum configured attachment size.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AttachmentJsonBean>(null as any);
    }

    /**
     * Get comments for an issue
     * @param issueIdOrKey Issue id or key
     * @param expand (optional) Optional flags: renderedBody (provides body rendered in HTML)
     * @param maxResults (optional) How many results on the page should be included. Defaults to 50.
     * @param orderBy (optional) Ordering of the results
     * @param startAt (optional) The page offset, if not specified then defaults to 0
     * @return Returns a collection of comments associated with the issue, with count and pagination information.
     */
    getComments(issueIdOrKey: string, expand?: string | undefined, maxResults?: string | undefined, orderBy?: string | undefined, startAt?: string | undefined): Promise<CommentsWithPaginationJsonBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/comment?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetComments(_response);
        });
    }

    protected processGetComments(response: Response): Promise<CommentsWithPaginationJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentsWithPaginationJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue with the given id/key does not exist or if the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommentsWithPaginationJsonBean>(null as any);
    }

    /**
     * Add a comment
     * @param issueIdOrKey Issue id or key
     * @param expand (optional) Optional flags: renderedBody (provides body rendered in HTML)
     * @param body (optional) Comment create request
     * @return Returned if add was successful.
     */
    addComment(issueIdOrKey: string, expand?: string | undefined, body?: CommentJsonBean | undefined): Promise<CommentJsonBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/comment?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddComment(_response);
        });
    }

    protected processAddComment(response: Response): Promise<CommentJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CommentJsonBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the input is invalid (e.g. missing required fields, invalid values, and so forth).", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommentJsonBean>(null as any);
    }

    /**
     * Get a comment by id
     * @param issueIdOrKey Issue id or key
     * @param id Comment id
     * @param expand (optional) Optional flags: renderedBody (provides body rendered in HTML)
     * @return Returns a full representation of a Jira comment in JSON format.
     */
    getComment(issueIdOrKey: string, id: string, expand?: string | undefined): Promise<CommentJsonBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/comment/{id}?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetComment(_response);
        });
    }

    protected processGetComment(response: Response): Promise<CommentJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested comment is not found, or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommentJsonBean>(null as any);
    }

    /**
     * Update a comment
     * @param issueIdOrKey Issue id or key
     * @param id Comment id
     * @param expand (optional) Optional flags: renderedBody (provides body rendered in HTML)
     * @param body (optional) Comment update request
     * @return Returned if update was successful.
     */
    updateComment(issueIdOrKey: string, id: string, expand?: string | undefined, body?: CommentJsonBean | undefined): Promise<CommentJsonBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/comment/{id}?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateComment(_response);
        });
    }

    protected processUpdateComment(response: Response): Promise<CommentJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommentJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the input is invalid (e.g. missing required fields, invalid values, and so forth).", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CommentJsonBean>(null as any);
    }

    /**
     * Delete a comment
     * @param issueIdOrKey Issue id or key
     * @param id Comment id
     * @return Returned if delete was successful.
     */
    deleteComment(issueIdOrKey: string, id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/comment/{id}";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteComment(_response);
        });
    }

    protected processDeleteComment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the input is invalid (e.g. missing required fields, invalid values, and so forth).", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Pin a comment
     * @param issueIdOrKey Issue id or key
     * @param id Comment id
     * @param body 'true' must be included as raw data
     * @return Returned if the comment was pinned successfully.
     */
    setPinComment(issueIdOrKey: string, id: string, body: boolean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/comment/{id}/pin";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPinComment(_response);
        });
    }

    protected processSetPinComment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the comment with the given id does not exist or if the currently authenticated user does not have permission to pin it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get metadata for issue types used for editing issues
     * @param issueIdOrKey Issue id or key
     * @return Returns a response containing a Map of FieldBeans for fields editable by the current user.
     */
    getEditIssueMeta(issueIdOrKey: string): Promise<EditMetaBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/editmeta";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEditIssueMeta(_response);
        });
    }

    protected processGetEditIssueMeta(response: Response): Promise<EditMetaBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditMetaBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested issue is not found or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EditMetaBean>(null as any);
    }

    /**
     * Send notification to recipients
     * @param issueIdOrKey Issue id or key
     * @param body (optional) Notification request
     * @return Returned if adding to the mail queue was successful.
     */
    notify(issueIdOrKey: string, body?: NotificationJsonBean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/notify";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotify(_response);
        });
    }

    protected processNotify(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the input is invalid (e.g. missing required fields, invalid values, and so forth).", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned is outgoing emails are disabled OR no SMTP server is defined.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get pinned comments for an issue
     * @param issueIdOrKey Issue id or key
     * @return Returns a collection of pinned comments associated with the issue.
     */
    getPinnedComments(issueIdOrKey: string): Promise<PinnedCommentJsonBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/pinned-comments";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPinnedComments(_response);
        });
    }

    protected processGetPinnedComments(response: Response): Promise<PinnedCommentJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PinnedCommentJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue with the given id/key does not exist or if the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PinnedCommentJsonBean>(null as any);
    }

    /**
     * Get remote issue links for an issue
     * @param issueIdOrKey Issue id or key
     * @param globalId (optional) Global id of the remote issue link
     * @return Returns a response containing remote issue links for the issue.
     */
    getRemoteIssueLinks(issueIdOrKey: string, globalId?: string | undefined): Promise<RemoteIssueLinkBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/remotelink?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (globalId === null)
            throw new Error("The parameter 'globalId' cannot be null.");
        else if (globalId !== undefined)
            url_ += "globalId=" + encodeURIComponent("" + globalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRemoteIssueLinks(_response);
        });
    }

    protected processGetRemoteIssueLinks(response: Response): Promise<RemoteIssueLinkBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RemoteIssueLinkBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the linkId is not a valid number, or if the remote issue link with the given id does not belong to the given issue.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to view the remote issue link, or if issue linking is disabled.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue or remote issue link do not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RemoteIssueLinkBean>(null as any);
    }

    /**
     * Create or update remote issue link
     * @param issueIdOrKey Issue id or key
     * @param body (optional) Remote issue link create or update request
     * @return Returns a link to the created/updated remote issue link.
     */
    createOrUpdateRemoteIssueLink(issueIdOrKey: string, body?: RemoteIssueLinkCreateOrUpdateRequest | undefined): Promise<RemoteIssueLinkBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/remotelink";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrUpdateRemoteIssueLink(_response);
        });
    }

    protected processCreateOrUpdateRemoteIssueLink(response: Response): Promise<RemoteIssueLinkBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RemoteIssueLinkBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the input is invalid (e.g. missing required fields, invalid values, and so forth).", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to create/update the remote issue link, or if issue linking is disabled.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RemoteIssueLinkBean>(null as any);
    }

    /**
     * Delete remote issue link
     * @param issueIdOrKey Issue id or key
     * @param globalId Global id of the remote issue link
     * @return Returned if the remote issue link was removed successfully.
     */
    deleteRemoteIssueLinkByGlobalId(issueIdOrKey: string, globalId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/remotelink?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (globalId === undefined || globalId === null)
            throw new Error("The parameter 'globalId' must be defined and cannot be null.");
        else
            url_ += "globalId=" + encodeURIComponent("" + globalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRemoteIssueLinkByGlobalId(_response);
        });
    }

    protected processDeleteRemoteIssueLinkByGlobalId(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to delete the remote issue link, or if issue linking is disabled.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue or remote issue link do not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a remote issue link by its id
     * @param linkId Id of the remote issue link
     * @param issueIdOrKey Issue id or key
     * @return Returns a response containing a remote issue link.
     */
    getRemoteIssueLinkById(linkId: string, issueIdOrKey: string): Promise<RemoteIssueLinkBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/remotelink/{linkId}";
        if (linkId === undefined || linkId === null)
            throw new Error("The parameter 'linkId' must be defined.");
        url_ = url_.replace("{linkId}", encodeURIComponent("" + linkId));
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRemoteIssueLinkById(_response);
        });
    }

    protected processGetRemoteIssueLinkById(response: Response): Promise<RemoteIssueLinkBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RemoteIssueLinkBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the linkId is not a valid number, or if the remote issue link with the given id does not belong to the given issue.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to view the remote issue link, or if issue linking is disabled.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue or remote issue link do not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RemoteIssueLinkBean>(null as any);
    }

    /**
     * Update remote issue link
     * @param linkId Id of the remote issue link
     * @param issueIdOrKey Issue id or key
     * @param body (optional) Remote issue link create or update request
     * @return Returns a response indicating the result of the update operation.
     */
    updateRemoteIssueLink(linkId: string, issueIdOrKey: string, body?: RemoteIssueLinkCreateOrUpdateRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/remotelink/{linkId}";
        if (linkId === undefined || linkId === null)
            throw new Error("The parameter 'linkId' must be defined.");
        url_ = url_.replace("{linkId}", encodeURIComponent("" + linkId));
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRemoteIssueLink(_response);
        });
    }

    protected processUpdateRemoteIssueLink(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the input is invalid (e.g. missing required fields, invalid values, and so forth).", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to update the remote issue link, or if issue linking is disabled.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete remote issue link by id
     * @param linkId Id of the remote issue link
     * @param issueIdOrKey Issue id or key
     * @return Returned if the remote issue link was removed successfully.
     */
    deleteRemoteIssueLinkById(linkId: string, issueIdOrKey: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/remotelink/{linkId}";
        if (linkId === undefined || linkId === null)
            throw new Error("The parameter 'linkId' must be defined.");
        url_ = url_.replace("{linkId}", encodeURIComponent("" + linkId));
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRemoteIssueLinkById(_response);
        });
    }

    protected processDeleteRemoteIssueLinkById(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to delete the remote issue link, or if issue linking is disabled.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue or remote issue link do not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Restore an archived issue
     * @param issueIdOrKey Issue id or key
     * @param notifyUsers (optional) Send the email with notification that the issue was updated to users that watch it. Admin or project admin permissions are required to disable the notification.
     * @return Returns a response indicating the result of the restore operation.
     */
    restoreIssue(issueIdOrKey: string, notifyUsers?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/restore?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (notifyUsers === null)
            throw new Error("The parameter 'notifyUsers' cannot be null.");
        else if (notifyUsers !== undefined)
            url_ += "notifyUsers=" + encodeURIComponent("" + notifyUsers) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRestoreIssue(_response);
        });
    }

    protected processRestoreIssue(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to restore the issue or doesn\'t have DC license or issue is not archived.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get an issue's subtask list
     * @param issueIdOrKey The parent issue's key or id
     * @return Returned if the request was successful.
     */
    getSubTasks(issueIdOrKey: string): Promise<IssueRefJsonBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/subtask";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSubTasks(_response);
        });
    }

    protected processGetSubTasks(response: Response): Promise<IssueRefJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueRefJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not allowed to edit the issue", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue doesn\'t exist", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueRefJsonBean>(null as any);
    }

    /**
     * Check if a subtask can be moved
     * @param issueIdOrKey The parent issue's key or id
     * @return Returned if the request was successful.
     */
    canMoveSubTask(issueIdOrKey: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/subtask/move";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCanMoveSubTask(_response);
        });
    }

    protected processCanMoveSubTask(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Reorder an issue's subtasks
     * @param issueIdOrKey The parent issue's key or id
     * @param body The description of previous and current position of subtask in the sequence.
     * @return Returned if the request was successful
     */
    moveSubTasks(issueIdOrKey: string, body: IssueSubTaskMovePositionBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/subtask/move";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMoveSubTasks(_response);
        });
    }

    protected processMoveSubTasks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the from or to parameters are out of bounds", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not allowed to edit the issue", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the parent issue doesn\'t exist", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get list of transitions possible for an issue
     * @param issueIdOrKey Issue id or key
     * @param transitionId (optional) Transition id
     * @return Returns a response containing a Map of TransitionFieldBeans for each transition possible by the current user.
     */
    getTransitions(issueIdOrKey: string, transitionId?: string | undefined): Promise<TransitionsMetaBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/transitions?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (transitionId === null)
            throw new Error("The parameter 'transitionId' cannot be null.");
        else if (transitionId !== undefined)
            url_ += "transitionId=" + encodeURIComponent("" + transitionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTransitions(_response);
        });
    }

    protected processGetTransitions(response: Response): Promise<TransitionsMetaBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransitionsMetaBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransitionsMetaBean>(null as any);
    }

    /**
     * Perform a transition on an issue
     * @param issueIdOrKey Issue id or key
     * @param body (optional) Issue update bean
     * @return Returns a response indicating the result of the transition operation.
     */
    doTransition(issueIdOrKey: string, body?: IssueUpdateBean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/transitions";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDoTransition(_response);
        });
    }

    protected processDoTransition(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the transition is not valid for the issue, or the user does not have permission to transition the issue.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue does not exist.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("If transition ID is incorrect.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get votes for issue
     * @param issueIdOrKey Issue id or key
     * @return Returns a response containing information about voting on the current issue
     */
    getVotes(issueIdOrKey: string): Promise<VoteBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/votes";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVotes(_response);
        });
    }

    protected processGetVotes(response: Response): Promise<VoteBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VoteBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user cannot view the issue in question or voting is disabled.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VoteBean>(null as any);
    }

    /**
     * Add vote to issue
     * @param issueIdOrKey Issue id.
     * @return Returns the vote count for particular ticket.
     */
    addVote(issueIdOrKey: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/votes";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddVote(_response);
        });
    }

    protected processAddVote(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user cannot vote for any reason. (The user is the reporter, the user does not have permission to vote, voting is disabled in the instance, the issue does not exist, etc.)", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove vote from issue
     * @param issueIdOrKey Issue id or key
     * @return Returns a response indicating the result of the remove vote operation.
     */
    removeVote(issueIdOrKey: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/votes";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveVote(_response);
        });
    }

    protected processRemoveVote(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user cannot remove a vote for any reason. (The user did not vote on the issue, the user is the reporter, voting is disabled, the issue does not exist, etc.)", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get list of watchers of issue
     * @param issueIdOrKey Issue id or key
     * @return Returns the list of watchers for an issue.
     */
    getIssueWatchers(issueIdOrKey: string): Promise<WatchersBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/watchers";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssueWatchers(_response);
        });
    }

    protected processGetIssueWatchers(response: Response): Promise<WatchersBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WatchersBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested issue is not found, or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WatchersBean>(null as any);
    }

    /**
     * Get worklogs for an issue
     * @param issueIdOrKey Issue id or key
     * @return Returns a collection of worklogs associated with the issue, with count and pagination information.
     */
    getIssueWorklog(issueIdOrKey: string): Promise<WorklogWithPaginationBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/worklog";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssueWorklog(_response);
        });
    }

    protected processGetIssueWorklog(response: Response): Promise<WorklogWithPaginationBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorklogWithPaginationBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue with the given id/key does not exist or if the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorklogWithPaginationBean>(null as any);
    }

    /**
     * Add a worklog entry
     * @param issueIdOrKey a string containing the issue id or key the worklog will be added to
     * @param newEstimate (optional) Required when 'new' is selected for adjustEstimate. e.g. "2d"
     * @param adjustEstimate (optional) Allows you to provide specific instructions to update the remaining time estimate of the issue. Valid values are: new, leave, manual, auto
     * @param reduceBy (optional) Required when 'manual' is selected for adjustEstimate. e.g. "2d"
     * @param body (optional) Worklog create request
     * @return Returned if add was successful.
     */
    addWorklog(issueIdOrKey: string, newEstimate?: string | undefined, adjustEstimate?: string | undefined, reduceBy?: string | undefined, body?: Worklog | undefined): Promise<Worklog> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/worklog?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (newEstimate === null)
            throw new Error("The parameter 'newEstimate' cannot be null.");
        else if (newEstimate !== undefined)
            url_ += "newEstimate=" + encodeURIComponent("" + newEstimate) + "&";
        if (adjustEstimate === null)
            throw new Error("The parameter 'adjustEstimate' cannot be null.");
        else if (adjustEstimate !== undefined)
            url_ += "adjustEstimate=" + encodeURIComponent("" + adjustEstimate) + "&";
        if (reduceBy === null)
            throw new Error("The parameter 'reduceBy' cannot be null.");
        else if (reduceBy !== undefined)
            url_ += "reduceBy=" + encodeURIComponent("" + reduceBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddWorklog(_response);
        });
    }

    protected processAddWorklog(response: Response): Promise<Worklog> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Worklog.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the input is invalid (e.g. missing required fields, invalid values, and so forth).", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to add the worklog.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Worklog>(null as any);
    }

    /**
     * Get a worklog by id
     * @param issueIdOrKey Issue id or key
     * @param id Worklog id
     * @return Returns a response containing a worklog.
     */
    getWorklog(issueIdOrKey: string, id: string): Promise<Worklog> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/worklog/{id}";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorklog(_response);
        });
    }

    protected processGetWorklog(response: Response): Promise<Worklog> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Worklog.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the work log with the given id does not exist or if the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Worklog>(null as any);
    }

    /**
     * Update a worklog entry
     * @param issueIdOrKey a string containing the issue id or key the worklog belongs to
     * @param id id of the worklog to be updated
     * @param newEstimate (optional) required when 'new' is selected for adjustEstimate
     * @param adjustEstimate (optional) allows you to provide specific instructions to update the remaining time estimate of the issue. Valid values are: new, leave, auto
     * @param body (optional) Worklog update request
     * @return Returned if update was successful.
     */
    updateWorklog(issueIdOrKey: string, id: string, newEstimate?: string | undefined, adjustEstimate?: string | undefined, body?: Worklog | undefined): Promise<Worklog> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/worklog/{id}?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (newEstimate === null)
            throw new Error("The parameter 'newEstimate' cannot be null.");
        else if (newEstimate !== undefined)
            url_ += "newEstimate=" + encodeURIComponent("" + newEstimate) + "&";
        if (adjustEstimate === null)
            throw new Error("The parameter 'adjustEstimate' cannot be null.");
        else if (adjustEstimate !== undefined)
            url_ += "adjustEstimate=" + encodeURIComponent("" + adjustEstimate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWorklog(_response);
        });
    }

    protected processUpdateWorklog(response: Response): Promise<Worklog> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Worklog.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the input is invalid (e.g. missing required fields, invalid values, and so forth).", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to update the worklog.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Worklog>(null as any);
    }

    /**
     * Delete a worklog entry
     * @param issueIdOrKey a string containing the issue id or key the worklog belongs to
     * @param id Id of the worklog to be deleted
     * @param newEstimate (optional) Required when 'new' is selected for adjustEstimate. e.g. "2d"
     * @param adjustEstimate (optional) Allows you to provide specific instructions to update the remaining time estimate of the issue. Valid values are: new, leave, manual, auto
     * @param increaseBy (optional) Required when 'manual' is selected for adjustEstimate. e.g. "2d"
     * @return Returned if delete was successful.
     */
    deleteWorklog(issueIdOrKey: string, id: string, newEstimate?: string | undefined, adjustEstimate?: string | undefined, increaseBy?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/worklog/{id}?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (newEstimate === null)
            throw new Error("The parameter 'newEstimate' cannot be null.");
        else if (newEstimate !== undefined)
            url_ += "newEstimate=" + encodeURIComponent("" + newEstimate) + "&";
        if (adjustEstimate === null)
            throw new Error("The parameter 'adjustEstimate' cannot be null.");
        else if (adjustEstimate !== undefined)
            url_ += "adjustEstimate=" + encodeURIComponent("" + adjustEstimate) + "&";
        if (increaseBy === null)
            throw new Error("The parameter 'increaseBy' cannot be null.");
        else if (increaseBy !== undefined)
            url_ += "increaseBy=" + encodeURIComponent("" + increaseBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteWorklog(_response);
        });
    }

    protected processDeleteWorklog(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the input is invalid (e.g. missing required fields, invalid values, and so forth).", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to delete the worklog.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create an issue link between two issues
     * @param body All information about the link relationship. Which issues to link, which issue link type to use and an optional comment that will be added to the first issue.
     * @return Returned if the issue link was created successfully.
     */
    linkIssues(body: LinkIssueRequestJsonBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issueLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLinkIssues(_response);
        });
    }

    protected processLinkIssues(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if it can\'t create the supplied comment.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have the link issue permission for the issue, which will be linked to another issue.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if issue linking is disabled or it failed to find one of the issues (issue might exist, but it is not visible for this user) or it failed to find the specified issue link type.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurred when creating the issue link or the comment.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get an issue link with the specified id
     * @param linkId The issue link id.
     * @return Returned if the request was successful.
     */
    getIssueLink(linkId: string): Promise<IssueLinks> {
        let url_ = this.baseUrl + "/api/2/issueLink/{linkId}";
        if (linkId === undefined || linkId === null)
            throw new Error("The parameter 'linkId' must be defined.");
        url_ = url_.replace("{linkId}", encodeURIComponent("" + linkId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssueLink(_response);
        });
    }

    protected processGetIssueLink(response: Response): Promise<IssueLinks> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueLinks.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the specified issue link id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have the link issue permission for the issue, which will be linked to another issue.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if issue linking is disabled or it failed to find an issue link with the specified id. Either because none exists with this id, or the user doesn\'t have the permission to see one of the linked issues.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurred when creating the issue link or the comment.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueLinks>(null as any);
    }

    /**
     * Delete an issue link with the specified id
     * @param linkId The issue link id.
     * @return Returned if it successfully deleted the issue link.
     */
    deleteIssueLink(linkId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issueLink/{linkId}";
        if (linkId === undefined || linkId === null)
            throw new Error("The parameter 'linkId' must be defined.");
        url_ = url_.replace("{linkId}", encodeURIComponent("" + linkId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteIssueLink(_response);
        });
    }

    protected processDeleteIssueLink(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the specified issue link id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have the link issue permission for the source or destination issue of the issue link.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if issue linking is disabled or it failed to find an issue link with the specified id. Either because none exists with this id, or the user doesn\'t have the permission to see one of the linked issues.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurred when deleting the issue link or the comment.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get list of available issue link types
     * @return Returns a list of all available issue link types.
     */
    getIssueLinkTypes(): Promise<IssueLinkTypesBean> {
        let url_ = this.baseUrl + "/api/2/issueLinkType";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssueLinkTypes(_response);
        });
    }

    protected processGetIssueLinkTypes(response: Response): Promise<IssueLinkTypesBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueLinkTypesBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not logged-in.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if issue linking is disabled.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueLinkTypesBean>(null as any);
    }

    /**
     * Create a new issue link type
     * @param body All information about the link relationship.
     * @return The new issue link type has been created.
     */
    createIssueLinkType(body: IssueLinkTypeJsonBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issueLinkType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateIssueLinkType(_response);
        });
    }

    protected processCreateIssueLinkType(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if issue linking is disabled or you do not have permission to create issue link types.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Reset the order of issue link types alphabetically.
     * @param body The sort direction for ordering the list alphabetically. Acceptable values are 'asc' or 'desc' (case-insensitive).
     * @return Returns all issue link types in reset order.
     */
    resetOrder(body: IssueLinkTypeResetOrderRequest): Promise<IssueLinkTypesBean> {
        let url_ = this.baseUrl + "/api/2/issueLinkType/order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetOrder(_response);
        });
    }

    protected processResetOrder(response: Response): Promise<IssueLinkTypesBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueLinkTypesBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the direction is invalid.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have permission to do the operation.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if issue linking is disabled.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueLinkTypesBean>(null as any);
    }

    /**
     * Get information about an issue link type
     * @param issueLinkTypeId The issue link type id.
     * @return Returns the issue link type with the given id.
     */
    getIssueLinkType(issueLinkTypeId: string): Promise<IssueLinkTypeJsonBean> {
        let url_ = this.baseUrl + "/api/2/issueLinkType/{issueLinkTypeId}";
        if (issueLinkTypeId === undefined || issueLinkTypeId === null)
            throw new Error("The parameter 'issueLinkTypeId' must be defined.");
        url_ = url_.replace("{issueLinkTypeId}", encodeURIComponent("" + issueLinkTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssueLinkType(_response);
        });
    }

    protected processGetIssueLinkType(response: Response): Promise<IssueLinkTypeJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueLinkTypeJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the supplied id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not logged-in.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if issue linking is disabled or no issue link type with the given id exists.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueLinkTypeJsonBean>(null as any);
    }

    /**
     * Update the specified issue link type
     * @param issueLinkTypeId The issue link type id.
     * @param body All information about the link relationship.
     * @return Returned if the issue link type was updated successfully.
     */
    updateIssueLinkType(issueLinkTypeId: string, body: IssueLinkTypeJsonBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issueLinkType/{issueLinkTypeId}";
        if (issueLinkTypeId === undefined || issueLinkTypeId === null)
            throw new Error("The parameter 'issueLinkTypeId' must be defined.");
        url_ = url_.replace("{issueLinkTypeId}", encodeURIComponent("" + issueLinkTypeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateIssueLinkType(_response);
        });
    }

    protected processUpdateIssueLinkType(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the supplied id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if issue linking is disabled or no issue link type with the given id exists.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete the specified issue link type
     * @param issueLinkTypeId The issue link type id.
     * @return Returns NO_CONTENT if successful.
     */
    deleteIssueLinkType(issueLinkTypeId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issueLinkType/{issueLinkTypeId}";
        if (issueLinkTypeId === undefined || issueLinkTypeId === null)
            throw new Error("The parameter 'issueLinkTypeId' must be defined.");
        url_ = url_.replace("{issueLinkTypeId}", encodeURIComponent("" + issueLinkTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteIssueLinkType(_response);
        });
    }

    protected processDeleteIssueLinkType(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the supplied id is not a number.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if issue linking is disabled or no issue link type with the given id exists.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update the order of the issue link type.
     * @param issueLinkTypeId Id of the issue link type to move.
     * @param body The new position to move the issue link type
     * @return Returns the updated issue link type.
     */
    moveIssueLinkType(issueLinkTypeId: string, body: IssueLinkTypeOrderUpdateRequest): Promise<IssueLinkTypeJsonBean> {
        let url_ = this.baseUrl + "/api/2/issueLinkType/{issueLinkTypeId}/order";
        if (issueLinkTypeId === undefined || issueLinkTypeId === null)
            throw new Error("The parameter 'issueLinkTypeId' must be defined.");
        url_ = url_.replace("{issueLinkTypeId}", encodeURIComponent("" + issueLinkTypeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMoveIssueLinkType(_response);
        });
    }

    protected processMoveIssueLinkType(response: Response): Promise<IssueLinkTypeJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueLinkTypeJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the position is invalid.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have permission to do the operation.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if issue linking is disabled or no issue link type with the given id exists.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueLinkTypeJsonBean>(null as any);
    }

    /**
     * Get all issue security schemes
     * @return Returns a list of all available issue security schemes.
     */
    getIssueSecuritySchemes(): Promise<SecuritySchemesJsonBean> {
        let url_ = this.baseUrl + "/api/2/issuesecurityschemes";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssueSecuritySchemes(_response);
        });
    }

    protected processGetIssueSecuritySchemes(response: Response): Promise<SecuritySchemesJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecuritySchemesJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have the administrator permission.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecuritySchemesJsonBean>(null as any);
    }

    /**
     * Get specific issue security scheme by id
     * @param id The issue security scheme id.
     * @return Returns the issue security scheme with the given id.
     */
    getIssueSecurityScheme(id: string): Promise<SecuritySchemeJsonBean> {
        let url_ = this.baseUrl + "/api/2/issuesecurityschemes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssueSecurityScheme(_response);
        });
    }

    protected processGetIssueSecurityScheme(response: Response): Promise<SecuritySchemeJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecuritySchemeJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have the administrator permission and the scheme is not used in any project where the user has administrative permission.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecuritySchemeJsonBean>(null as any);
    }

    /**
     * Get list of all issue types visible to user
     * @return Returns a list of issue types.
     */
    getIssueAllTypes(): Promise<IssueTypeJsonBean> {
        let url_ = this.baseUrl + "/api/2/issuetype";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssueAllTypes(_response);
        });
    }

    protected processGetIssueAllTypes(response: Response): Promise<IssueTypeJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueTypeJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have the administrator permission.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueTypeJsonBean>(null as any);
    }

    /**
     * Create an issue type from JSON representation
     * @param body All information about the issue type.
     * @return The new issue type has been created.
     */
    createIssueType(body: IssueTypeCreateBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issuetype";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateIssueType(_response);
        });
    }

    protected processCreateIssueType(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid. This happens when the name is invalid or issue type is subtask on instance which has subtasks disabled.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer Jira.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there already exists an issue type with the specified name.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get paginated list of filtered issue types
     * @param x_Requested_With (optional) 
     * @param maxResults (optional) 
     * @param query (optional) 
     * @param projectIds (optional) 
     * @param startAt (optional) 
     * @return Returns paginated list of issue types.
     */
    getPaginatedIssueTypes(x_Requested_With?: string | undefined, maxResults?: number | undefined, query?: string | undefined, projectIds?: number[] | undefined, startAt?: number | undefined): Promise<IssueTypeJsonBean> {
        let url_ = this.baseUrl + "/api/2/issuetype/page?";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (projectIds === null)
            throw new Error("The parameter 'projectIds' cannot be null.");
        else if (projectIds !== undefined)
            projectIds && projectIds.forEach(item => { url_ += "projectIds=" + encodeURIComponent("" + item) + "&"; });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "X-Requested-With": x_Requested_With !== undefined && x_Requested_With !== null ? "" + x_Requested_With : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaginatedIssueTypes(_response);
        });
    }

    protected processGetPaginatedIssueTypes(response: Response): Promise<IssueTypeJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueTypeJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueTypeJsonBean>(null as any);
    }

    /**
     * Update specified issue type from JSON representation
     * @param id The issue type id.
     * @param body All information about the issue type.
     * @return Returned if the issue type was updated successfully.
     */
    updateIssueType(id: string, body: IssueTypeUpdateBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issuetype/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateIssueType(_response);
        });
    }

    protected processUpdateIssueType(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid. This happens when the name is invalid or if the avatar with given id does not exist.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer Jira.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type to update does not exist.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there already exists an issue type with the specified name.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get list of alternative issue types for given id
     * @param id The issue type id.
     * @return Returns a list of issue types.
     */
    getAlternativeIssueTypes(id: string): Promise<IssueTypeJsonBean> {
        let url_ = this.baseUrl + "/api/2/issuetype/{id}/alternatives";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAlternativeIssueTypes(_response);
        });
    }

    protected processGetAlternativeIssueTypes(response: Response): Promise<IssueTypeJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueTypeJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type does not exist, or is not visible to the calling user.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueTypeJsonBean>(null as any);
    }

    /**
     * Create temporary avatar using multipart for issue type
     * @param id The issue type id.
     * @param contentType (optional) 
     * @param formField (optional) 
     * @param inputStream (optional) 
     * @param name (optional) 
     * @param size (optional) 
     * @param value (optional) 
     * @return Temporary avatar cropping instructions embeded in HTML page. Error messages will also be embeded in the page.
     */
    storeTemporaryAvatarUsingMultiPart(id: string, contentType?: string | undefined, formField?: boolean | undefined, inputStream?: any | undefined, name?: string | undefined, size?: number | undefined, value?: string | undefined): Promise<AvatarCroppingBean> {
        let url_ = this.baseUrl + "/api/2/issuetype/{id}/avatar/temporary";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("contentType", contentType.toString());
        if (formField === null || formField === undefined)
            throw new Error("The parameter 'formField' cannot be null.");
        else
            content_.append("formField", formField.toString());
        if (inputStream === null || inputStream === undefined)
            throw new Error("The parameter 'inputStream' cannot be null.");
        else
            content_.append("inputStream", JSON.stringify(inputStream));
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("name", name.toString());
        if (size === null || size === undefined)
            throw new Error("The parameter 'size' cannot be null.");
        else
            content_.append("size", size.toString());
        if (value === null || value === undefined)
            throw new Error("The parameter 'value' cannot be null.");
        else
            content_.append("value", value.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "text/html"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStoreTemporaryAvatarUsingMultiPart(_response);
        });
    }

    protected processStoreTemporaryAvatarUsingMultiPart(response: Response): Promise<AvatarCroppingBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AvatarCroppingBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer Jira.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type to update does not exist or if the request does not contain valid XSRF token.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvatarCroppingBean>(null as any);
    }

    /**
     * Get all properties keys for issue type
     * @param issueTypeId The issue type from which the keys will be returned.
     * @return Returns keys of all properties for the issue type.
     */
    getPropertyKeys(issueTypeId: string): Promise<EntityPropertiesKeysBean> {
        let url_ = this.baseUrl + "/api/2/issuetype/{issueTypeId}/properties";
        if (issueTypeId === undefined || issueTypeId === null)
            throw new Error("The parameter 'issueTypeId' must be defined.");
        url_ = url_.replace("{issueTypeId}", encodeURIComponent("" + issueTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPropertyKeys(_response);
        });
    }

    protected processGetPropertyKeys(response: Response): Promise<EntityPropertiesKeysBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityPropertiesKeysBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type with given id does not exist or if the user does not have permissions to view this issue type.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityPropertiesKeysBean>(null as any);
    }

    /**
     * Get list of all issue type schemes visible to user
     * @return Returns a list of issue type schemes.
     */
    getAllIssueTypeSchemes(): Promise<IssueTypeSchemeListBean> {
        let url_ = this.baseUrl + "/api/2/issuetypescheme";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllIssueTypeSchemes(_response);
        });
    }

    protected processGetAllIssueTypeSchemes(response: Response): Promise<IssueTypeSchemeListBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueTypeSchemeListBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer Jira.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueTypeSchemeListBean>(null as any);
    }

    /**
     * Create an issue type scheme from JSON representation
     * @param body Issue type scheme creation details.
     * @return Returns a JSON representation of the newly created IssueTypeScheme if successful.
     */
    createIssueTypeScheme(body: IssueTypeSchemeCreateUpdateBean): Promise<IssueTypeSchemeBean> {
        let url_ = this.baseUrl + "/api/2/issuetypescheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateIssueTypeScheme(_response);
        });
    }

    protected processCreateIssueTypeScheme(response: Response): Promise<IssueTypeSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueTypeSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer Jira.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueTypeSchemeBean>(null as any);
    }

    /**
     * Get full representation of issue type scheme by id
     * @param schemeId A String containing an issue type scheme's id.
     * @return Returns a full representation of the issue type scheme with the given id.
     */
    getIssueTypeScheme(schemeId: string): Promise<IssueTypeSchemeBean> {
        let url_ = this.baseUrl + "/api/2/issuetypescheme/{schemeId}";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssueTypeScheme(_response);
        });
    }

    protected processGetIssueTypeScheme(response: Response): Promise<IssueTypeSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueTypeSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer Jira.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueTypeSchemeBean>(null as any);
    }

    /**
     * Update specified issue type scheme from JSON representation
     * @param schemeId The id of the issue type scheme to update.
     * @param body Specifies the new set of attributes that the issue type scheme will take on.
     * @return Returns a JSON representation of the updated issue type scheme.
     */
    updateIssueTypeScheme(schemeId: string, body: IssueTypeSchemeCreateUpdateBean): Promise<IssueTypeSchemeBean> {
        let url_ = this.baseUrl + "/api/2/issuetypescheme/{schemeId}";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateIssueTypeScheme(_response);
        });
    }

    protected processUpdateIssueTypeScheme(response: Response): Promise<IssueTypeSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueTypeSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid. This happens when the name or issue types are invalid. It also occurs when the default issue type isn\'t found in the associated issue types collection.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer Jira.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type scheme to update does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueTypeSchemeBean>(null as any);
    }

    /**
     * Delete specified issue type scheme
     * @param schemeId The id of the issue type scheme to remove.
     * @return Confirmation that the delete was successful.
     */
    deleteIssueTypeScheme(schemeId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issuetypescheme/{schemeId}";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteIssueTypeScheme(_response);
        });
    }

    protected processDeleteIssueTypeScheme(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid. It happens when there are associated issues with the issue type which is being removed, but it is impossible to migrate these issues to the alternative issue type.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer Jira or if an attempt is made to delete the default IssueTypeScheme.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type scheme which is supposed to be removed does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all of the associated projects for specified scheme
     * @param schemeId Id of the issue type scheme whose projects we're accessing
     * @param expand (optional) 
     * @return The collection of projects associated with this issue type scheme.
     */
    getAssociatedProjects(schemeId: string, expand?: string | undefined): Promise<ProjectBean> {
        let url_ = this.baseUrl + "/api/2/issuetypescheme/{schemeId}/associations?";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAssociatedProjects(_response);
        });
    }

    protected processGetAssociatedProjects(response: Response): Promise<ProjectBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer Jira.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the specified issue type scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectBean>(null as any);
    }

    /**
     * Set project associations for scheme
     * @param schemeId The id of the issue type scheme whose project associations we're replacing.
     * @param body Collection of projects, specified by id or key, to associate with this issue type scheme
     * @return Confirmation that the association was successful.
     */
    setProjectAssociationsForScheme(schemeId: string, body: AssociateProjectsBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issuetypescheme/{schemeId}/associations";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetProjectAssociationsForScheme(_response);
        });
    }

    protected processSetProjectAssociationsForScheme(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid. This occurs when the supplied project ids/keys are invalid. It also happens if performing the association would require an issue type migration for any of the newly associated projects.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer Jira.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type scheme to update does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Add project associations to scheme
     * @param schemeId The id of the issue type scheme whose project associations we're adding to.
     * @param body Collection of projects, specified by id or key, to associate with this issue type scheme
     * @return Confirmation that the association was successful.
     */
    addProjectAssociationsToScheme(schemeId: string, body: AssociateProjectsBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issuetypescheme/{schemeId}/associations";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddProjectAssociationsToScheme(_response);
        });
    }

    protected processAddProjectAssociationsToScheme(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid. This occurs when the supplied project ids/keys are invalid. It also happens if performing the association would require an issue type migration for any of the projects.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer Jira.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type scheme to update does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove all project associations for specified scheme
     * @param schemeId The id of the issue type scheme whose project associations we're removing
     * @return Confirmation that the associations were removed.
     */
    removeAllProjectAssociations(schemeId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issuetypescheme/{schemeId}/associations";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveAllProjectAssociations(_response);
        });
    }

    protected processRemoveAllProjectAssociations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer Jira or if an attempt is made to remove associations for the default/global issue type scheme.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the specified issue type scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Remove given project association for specified scheme
     * @param projIdOrKey The id or key of the project that is to be un-associated with the issue type scheme
     * @param schemeId The id of the issue type scheme whose project association we're removing
     * @return Confirmation that the association was removed.
     */
    removeProjectAssociation(projIdOrKey: string, schemeId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issuetypescheme/{schemeId}/associations/{projIdOrKey}";
        if (projIdOrKey === undefined || projIdOrKey === null)
            throw new Error("The parameter 'projIdOrKey' must be defined.");
        url_ = url_.replace("{projIdOrKey}", encodeURIComponent("" + projIdOrKey));
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveProjectAssociation(_response);
        });
    }

    protected processRemoveProjectAssociation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer Jira or if an attempt is made to remove an association for the default/global issue type scheme.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the specified issue type scheme or project does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get auto complete data for JQL searches
     * @return The auto complete data required for JQL searches.
     */
    getAutoComplete(): Promise<AutoCompleteResponseBean> {
        let url_ = this.baseUrl + "/api/2/jql/autocompletedata";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAutoComplete(_response);
        });
    }

    protected processGetAutoComplete(response: Response): Promise<AutoCompleteResponseBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoCompleteResponseBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while generating the response.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AutoCompleteResponseBean>(null as any);
    }

    /**
     * Get auto complete suggestions for JQL search
     * @param predicateValue (optional) 
     * @param predicateName (optional) 
     * @param fieldName (optional) 
     * @param fieldValue (optional) 
     * @return The autocompletion suggestions for JQL search.
     */
    getFieldAutoCompleteForQueryString(predicateValue?: string | undefined, predicateName?: string | undefined, fieldName?: string | undefined, fieldValue?: string | undefined): Promise<AutoCompleteResultWrapper> {
        let url_ = this.baseUrl + "/api/2/jql/autocompletedata/suggestions?";
        if (predicateValue === null)
            throw new Error("The parameter 'predicateValue' cannot be null.");
        else if (predicateValue !== undefined)
            url_ += "predicateValue=" + encodeURIComponent("" + predicateValue) + "&";
        if (predicateName === null)
            throw new Error("The parameter 'predicateName' cannot be null.");
        else if (predicateName !== undefined)
            url_ += "predicateName=" + encodeURIComponent("" + predicateName) + "&";
        if (fieldName === null)
            throw new Error("The parameter 'fieldName' cannot be null.");
        else if (fieldName !== undefined)
            url_ += "fieldName=" + encodeURIComponent("" + fieldName) + "&";
        if (fieldValue === null)
            throw new Error("The parameter 'fieldValue' cannot be null.");
        else if (fieldValue !== undefined)
            url_ += "fieldValue=" + encodeURIComponent("" + fieldValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFieldAutoCompleteForQueryString(_response);
        });
    }

    protected processGetFieldAutoCompleteForQueryString(response: Response): Promise<AutoCompleteResultWrapper> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoCompleteResultWrapper.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AutoCompleteResultWrapper>(null as any);
    }

    /**
     * Validate a Jira license
     * @param body The license string to validate.
     * @return The validation results of the license.
     */
    validate(body: string): Promise<LicenseValidationResults> {
        let url_ = this.baseUrl + "/api/2/licenseValidator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidate(_response);
        });
    }

    protected processValidate(response: Response): Promise<LicenseValidationResults> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LicenseValidationResults.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LicenseValidationResults>(null as any);
    }

    /**
     * Get App Monitoring status
     * @return Returns the status of App Monitoring.
     */
    isAppMonitoringEnabled(): Promise<AppMonitoringRestEntity> {
        let url_ = this.baseUrl + "/api/2/monitoring/app";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsAppMonitoringEnabled(_response);
        });
    }

    protected processIsAppMonitoringEnabled(response: Response): Promise<AppMonitoringRestEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppMonitoringRestEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AppMonitoringRestEntity>(null as any);
    }

    /**
     * Update App Monitoring status
     * @param body The status to set for App Monitoring.
     * @return Sets the status of App Monitoring.
     */
    setAppMonitoringEnabled(body: AppMonitoringRestEntity): Promise<void> {
        let url_ = this.baseUrl + "/api/2/monitoring/app";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetAppMonitoringEnabled(_response);
        });
    }

    protected processSetAppMonitoringEnabled(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get if IPD Monitoring is enabled
     * @return Returns the status of IPD Monitoring.
     */
    isIpdMonitoringEnabled(): Promise<IpdMonitoringRestEntity> {
        let url_ = this.baseUrl + "/api/2/monitoring/ipd";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsIpdMonitoringEnabled(_response);
        });
    }

    protected processIsIpdMonitoringEnabled(response: Response): Promise<IpdMonitoringRestEntity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IpdMonitoringRestEntity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IpdMonitoringRestEntity>(null as any);
    }

    /**
     * Check if JMX metrics are being exposed
     * @return Returns whether JMX metrics are being exposed.
     */
    areMetricsExposed(): Promise<boolean> {
        let url_ = this.baseUrl + "/api/2/monitoring/jmx/areMetricsExposed";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAreMetricsExposed(_response);
        });
    }

    protected processAreMetricsExposed(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * Get the available JMX metrics
     * @return Returns the available JMX metrics.
     */
    getAvailableMetrics(): Promise<string> {
        let url_ = this.baseUrl + "/api/2/monitoring/jmx/getAvailableMetrics";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAvailableMetrics(_response);
        });
    }

    protected processGetAvailableMetrics(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Start exposing JMX metrics
     * @return Confirmation that the JMX metrics are being exposed.
     */
    start(): Promise<void> {
        let url_ = this.baseUrl + "/api/2/monitoring/jmx/startExposing";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStart(_response);
        });
    }

    protected processStart(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Stop exposing JMX metrics
     * @return Confirmation that the JMX metrics are no longer being exposed.
     */
    stop(): Promise<void> {
        let url_ = this.baseUrl + "/api/2/monitoring/jmx/stopExposing";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStop(_response);
        });
    }

    protected processStop(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get permissions for the logged in user
     * @param issueId (optional) id of the issue to scope returned permissions for.
     * @param projectKey (optional) key of project to scope returned permissions for.
     * @param issueKey (optional) key of the issue to scope returned permissions for.
     * @param projectId (optional) id of project to scope returned permissions for.
     * @return Returns a list of all permissions in Jira and whether the user has them.
     */
    getPermissions(issueId?: string | undefined, projectKey?: string | undefined, issueKey?: string | undefined, projectId?: string | undefined): Promise<PermissionsJsonBean> {
        let url_ = this.baseUrl + "/api/2/mypermissions?";
        if (issueId === null)
            throw new Error("The parameter 'issueId' cannot be null.");
        else if (issueId !== undefined)
            url_ += "issueId=" + encodeURIComponent("" + issueId) + "&";
        if (projectKey === null)
            throw new Error("The parameter 'projectKey' cannot be null.");
        else if (projectKey !== undefined)
            url_ += "projectKey=" + encodeURIComponent("" + projectKey) + "&";
        if (issueKey === null)
            throw new Error("The parameter 'issueKey' cannot be null.");
        else if (issueKey !== undefined)
            url_ += "issueKey=" + encodeURIComponent("" + issueKey) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPermissions(_response);
        });
    }

    protected processGetPermissions(response: Response): Promise<PermissionsJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionsJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project or issue id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if request is on behalf of anonymous user.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project or issue id or key is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionsJsonBean>(null as any);
    }

    /**
     * Get user preference by key
     * @param key (optional) 
     * @return Returns the value of one preference of currently logged in user.
     */
    getPreference(key?: string | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/2/mypreferences?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPreference(_response);
        });
    }

    protected processGetPreference(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Key not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Update user preference
     * @param key (optional) 
     * @param body (optional) 
     * @return Confirmation that the preference was set.
     */
    setPreference(key?: string | undefined, body?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/mypreferences?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPreference(_response);
        });
    }

    protected processSetPreference(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete user preference
     * @param key (optional) 
     * @return Confirmation that the preference was removed.
     */
    removePreference(key?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/mypreferences?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemovePreference(_response);
        });
    }

    protected processRemovePreference(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get currently logged user
     * @return Returns a full representation of a Jira user in JSON format.
     */
    getUser(): Promise<UserBean> {
        let url_ = this.baseUrl + "/api/2/myself";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: Response): Promise<UserBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserBean>(null as any);
    }

    /**
     * Update currently logged user
     * @param body The new user details to be set.
     * @return Confirmation that the user was updated.
     */
    updateUser(body: UserWriteBean): Promise<UserWriteBean> {
        let url_ = this.baseUrl + "/api/2/myself";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<UserWriteBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserWriteBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("The request is invalid including incorrect password.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("The user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("The directory is read-only.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("The user could not be found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserWriteBean>(null as any);
    }

    /**
     * Update caller password
     * @param body The new password to be set.
     * @return Confirmation that the password was changed.
     */
    changeMyPassword(body: PasswordBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/myself/password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeMyPassword(_response);
        });
    }

    protected processChangeMyPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("The request is invalid including incorrect password.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("The user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("The directory is read-only.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("The user could not be found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get paginated notification schemes
     * @param expand (optional) 
     * @param maxResults (optional) 
     * @param startAt (optional) 
     * @return Paginated list of notification schemes to which the user has permissions.
     */
    getNotificationSchemes(expand?: string | undefined, maxResults?: number | undefined, startAt?: number | undefined): Promise<PageBean> {
        let url_ = this.baseUrl + "/api/2/notificationscheme?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNotificationSchemes(_response);
        });
    }

    protected processGetNotificationSchemes(response: Response): Promise<PageBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PageBean>(null as any);
    }

    /**
     * Get full notification scheme details
     * @param expand (optional) 
     * @return Returns a full representation of the notification scheme with given id
     */
    getNotificationScheme(id: number, expand?: string | undefined): Promise<NotificationSchemeBean> {
        let url_ = this.baseUrl + "/api/2/notificationscheme/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNotificationScheme(_response);
        });
    }

    protected processGetNotificationScheme(response: Response): Promise<NotificationSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("The notification scheme does not exist, or is not visible to the calling user", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationSchemeBean>(null as any);
    }

    /**
     * Get current password policy requirements
     * @param hasOldPassword (optional) 
     * @return Returns a JSON array of the user-facing messages.
     */
    getPasswordPolicy(hasOldPassword?: boolean | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/2/password/policy?";
        if (hasOldPassword === null)
            throw new Error("The parameter 'hasOldPassword' cannot be null.");
        else if (hasOldPassword !== undefined)
            url_ += "hasOldPassword=" + encodeURIComponent("" + hasOldPassword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPasswordPolicy(_response);
        });
    }

    protected processGetPasswordPolicy(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get reasons for password policy disallowance on user creation
     * @param body The intended parameters for the user that would be created.
    The username and new password must be specified.  The old password should be specified for
    updates where the user would be required to enter it and omitted for those like a password
    reset or forced change by the administrator where the old password would not be known.
     * @return Returns a JSON array of the user-facing messages.
     */
    policyCheckCreateUser(body: PasswordPolicyCreateUserBean): Promise<string> {
        let url_ = this.baseUrl + "/api/2/password/policy/createUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPolicyCheckCreateUser(_response);
        });
    }

    protected processPolicyCheckCreateUser(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid, such as if the username or password is left unspecified.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get reasons for password policy disallowance on user password update
     * @param body The intended parameters for the update that would be performed.
    The username and new password must be specified.  The old password should be specified for
    updates where the user would be required to enter it and omitted for those like a password
    reset or forced change by the administrator where the old password would not be known.
     * @return Returns a JSON array of the user-facing messages. If no policy is set, then his will be an empty list.
     */
    policyCheckUpdateUser(body: PasswordPolicyUpdateUserBean): Promise<string> {
        let url_ = this.baseUrl + "/api/2/password/policy/updateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPolicyCheckUpdateUser(_response);
        });
    }

    protected processPolicyCheckUpdateUser(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid, such as if the username or new password is left unspecified.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the username does not correspond to any existing user.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Get all permissions present in Jira instance
     * @return Returns a list of all permissions in Jira.
     */
    getAllPermissions(): Promise<PermissionsJsonBean> {
        let url_ = this.baseUrl + "/api/2/permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPermissions(_response);
        });
    }

    protected processGetAllPermissions(response: Response): Promise<PermissionsJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionsJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned for unauthenticated requests", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned for users without administer permissions", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionsJsonBean>(null as any);
    }

    /**
     * Get all permission schemes
     * @param expand (optional) 
     * @return List of all permission schemes
     */
    getPermissionSchemes(expand?: string | undefined): Promise<PermissionSchemesBean> {
        let url_ = this.baseUrl + "/api/2/permissionscheme?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPermissionSchemes(_response);
        });
    }

    protected processGetPermissionSchemes(response: Response): Promise<PermissionSchemesBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionSchemesBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not allowed to view permission schemes.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the scheme doesn\'t exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionSchemesBean>(null as any);
    }

    /**
     * Create a new permission scheme
     * @param expand (optional) 
     * @param body (optional) 
     * @return Returned if the scheme is created successfully.
     */
    createPermissionScheme(expand?: string | undefined, body?: PermissionSchemeBean | undefined): Promise<PermissionSchemeBean> {
        let url_ = this.baseUrl + "/api/2/permissionscheme?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePermissionScheme(_response);
        });
    }

    protected processCreatePermissionScheme(response: Response): Promise<PermissionSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PermissionSchemeBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not allowed to create permission schemes.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionSchemeBean>(null as any);
    }

    /**
     * Get scheme attribute by key
     * @return Permission scheme attribute
     */
    getSchemeAttribute(permissionSchemeId: number, attributeKey: string): Promise<PermissionSchemeAttributeBean> {
        let url_ = this.baseUrl + "/api/2/permissionscheme/{permissionSchemeId}/attribute/{attributeKey}";
        if (permissionSchemeId === undefined || permissionSchemeId === null)
            throw new Error("The parameter 'permissionSchemeId' must be defined.");
        url_ = url_.replace("{permissionSchemeId}", encodeURIComponent("" + permissionSchemeId));
        if (attributeKey === undefined || attributeKey === null)
            throw new Error("The parameter 'attributeKey' must be defined.");
        url_ = url_.replace("{attributeKey}", encodeURIComponent("" + attributeKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSchemeAttribute(_response);
        });
    }

    protected processGetSchemeAttribute(response: Response): Promise<PermissionSchemeAttributeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionSchemeAttributeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not an admin.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no such attribute.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionSchemeAttributeBean>(null as any);
    }

    /**
     * Update or insert a scheme attribute
     * @param body (optional) 
     * @return Returned if the attribute is updated successfully.
     */
    setSchemeAttribute(permissionSchemeId: number, key: string, body?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/permissionscheme/{permissionSchemeId}/attribute/{key}";
        if (permissionSchemeId === undefined || permissionSchemeId === null)
            throw new Error("The parameter 'permissionSchemeId' must be defined.");
        url_ = url_.replace("{permissionSchemeId}", encodeURIComponent("" + permissionSchemeId));
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "text/plain",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetSchemeAttribute(_response);
        });
    }

    protected processSetSchemeAttribute(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not an admin.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there was an error related to attribute upsert.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get a permission scheme by ID
     * @param expand (optional) 
     * @return Permission scheme
     */
    getPermissionScheme(schemeId: number, expand?: string | undefined): Promise<PermissionSchemeBean> {
        let url_ = this.baseUrl + "/api/2/permissionscheme/{schemeId}?";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPermissionScheme(_response);
        });
    }

    protected processGetPermissionScheme(response: Response): Promise<PermissionSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not allowed to view permission schemes.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the scheme doesn\'t exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionSchemeBean>(null as any);
    }

    /**
     * Update a permission scheme
     * @param expand (optional) 
     * @param body (optional) 
     * @return Returned if the scheme is updated successfully.
     */
    updatePermissionScheme(schemeId: number, expand?: string | undefined, body?: PermissionSchemeBean | undefined): Promise<PermissionSchemeBean> {
        let url_ = this.baseUrl + "/api/2/permissionscheme/{schemeId}?";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePermissionScheme(_response);
        });
    }

    protected processUpdatePermissionScheme(response: Response): Promise<PermissionSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not allowed to edit permission schemes.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the permission is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionSchemeBean>(null as any);
    }

    /**
     * Delete a permission scheme by ID
     * @return Returned if the permission scheme is successfully deleted.
     */
    deletePermissionScheme(schemeId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/2/permissionscheme/{schemeId}";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePermissionScheme(_response);
        });
    }

    protected processDeletePermissionScheme(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not allowed to delete permission schemes.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all permission grants of a scheme
     * @param expand (optional) 
     * @return Permission grants
     */
    getPermissionSchemeGrants(schemeId: number, expand?: string | undefined): Promise<PermissionGrantsBean> {
        let url_ = this.baseUrl + "/api/2/permissionscheme/{schemeId}/permission?";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPermissionSchemeGrants(_response);
        });
    }

    protected processGetPermissionSchemeGrants(response: Response): Promise<PermissionGrantsBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionGrantsBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not allowed to view permission schemes.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the scheme doesn\'t exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionGrantsBean>(null as any);
    }

    /**
     * Create a permission grant in a scheme
     * @param expand (optional) 
     * @param body (optional) 
     * @return Returned if the scheme permission is created successfully.
     */
    createPermissionGrant(schemeId: number, expand?: string | undefined, body?: PermissionGrantBean | undefined): Promise<PermissionGrantBean> {
        let url_ = this.baseUrl + "/api/2/permissionscheme/{schemeId}/permission?";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePermissionGrant(_response);
        });
    }

    protected processCreatePermissionGrant(response: Response): Promise<PermissionGrantBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PermissionGrantBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not allowed to edit permission schemes.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionGrantBean>(null as any);
    }

    /**
     * Get a permission grant by ID
     * @param expand (optional) 
     * @return Permission grant
     */
    getPermissionSchemeGrant(permissionId: number, schemeId: number, expand?: string | undefined): Promise<PermissionGrantBean> {
        let url_ = this.baseUrl + "/api/2/permissionscheme/{schemeId}/permission/{permissionId}?";
        if (permissionId === undefined || permissionId === null)
            throw new Error("The parameter 'permissionId' must be defined.");
        url_ = url_.replace("{permissionId}", encodeURIComponent("" + permissionId));
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPermissionSchemeGrant(_response);
        });
    }

    protected processGetPermissionSchemeGrant(response: Response): Promise<PermissionGrantBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionGrantBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not allowed to view permission schemes.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the scheme doesn\'t exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionGrantBean>(null as any);
    }

    /**
     * Delete a permission grant from a scheme
     * @return Returned if the permission grant is deleted successfully.
     */
    deletePermissionSchemeEntity(permissionId: number, schemeId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/2/permissionscheme/{schemeId}/permission/{permissionId}";
        if (permissionId === undefined || permissionId === null)
            throw new Error("The parameter 'permissionId' must be defined.");
        url_ = url_.replace("{permissionId}", encodeURIComponent("" + permissionId));
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePermissionSchemeEntity(_response);
        });
    }

    protected processDeletePermissionSchemeEntity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not allowed to edit permission schemes.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all issue priorities
     * @return List of priorities
     */
    getPriorities(): Promise<PriorityJsonBean> {
        let url_ = this.baseUrl + "/api/2/priority";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPriorities(_response);
        });
    }

    protected processGetPriorities(response: Response): Promise<PriorityJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PriorityJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PriorityJsonBean>(null as any);
    }

    /**
     * Get an issue priority by ID
     * @return Returned if the issue priority exists and is visible by the calling user. Contains a full representation of the issue priority in JSON
     */
    getPriority(id: string): Promise<PriorityJsonBean> {
        let url_ = this.baseUrl + "/api/2/priority/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPriority(_response);
        });
    }

    protected processGetPriority(response: Response): Promise<PriorityJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PriorityJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue priority does not exist or is not visible to the calling user", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PriorityJsonBean>(null as any);
    }

    /**
     * Get all priority schemes
     * @param maxResults (optional) 
     * @param startAt (optional) 
     * @return Priority schemes
     */
    getPrioritySchemes(maxResults?: number | undefined, startAt?: number | undefined): Promise<PrioritySchemeListBean> {
        let url_ = this.baseUrl + "/api/2/priorityschemes?";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPrioritySchemes(_response);
        });
    }

    protected processGetPrioritySchemes(response: Response): Promise<PrioritySchemeListBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrioritySchemeListBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller user does not have permission to view priority schemes.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PrioritySchemeListBean>(null as any);
    }

    /**
     * Create new priority scheme
     * @param body Data of priority scheme to create
     * @return Newly created priority scheme
     */
    createPriorityScheme(body: PrioritySchemeUpdateBean): Promise<PrioritySchemeBean> {
        let url_ = this.baseUrl + "/api/2/priorityschemes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePriorityScheme(_response);
        });
    }

    protected processCreatePriorityScheme(response: Response): Promise<PrioritySchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PrioritySchemeBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller user does not have permission to create priority scheme.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the priority scheme was not created because of other error.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PrioritySchemeBean>(null as any);
    }

    /**
     * Get a priority scheme by ID
     * @return Priority scheme
     */
    getPriorityScheme(schemeId: number): Promise<PrioritySchemeBean> {
        let url_ = this.baseUrl + "/api/2/priorityschemes/{schemeId}";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPriorityScheme(_response);
        });
    }

    protected processGetPriorityScheme(response: Response): Promise<PrioritySchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrioritySchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller user does not have permission to view priority scheme.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the priority scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PrioritySchemeBean>(null as any);
    }

    /**
     * Update a priority scheme
     * @param body New scheme data
     * @return Updated priority scheme
     */
    updatePriorityScheme(schemeId: number, body: PrioritySchemeUpdateBean): Promise<PrioritySchemeBean> {
        let url_ = this.baseUrl + "/api/2/priorityschemes/{schemeId}";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePriorityScheme(_response);
        });
    }

    protected processUpdatePriorityScheme(response: Response): Promise<PrioritySchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrioritySchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller user does not have permission to update priority scheme.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the priority scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the priority scheme was not updated because of other error.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PrioritySchemeBean>(null as any);
    }

    /**
     * Delete a priority scheme
     * @return Returned if the priority scheme is successfully deleted.
     */
    deletePriorityScheme(schemeId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/2/priorityschemes/{schemeId}";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePriorityScheme(_response);
        });
    }

    protected processDeletePriorityScheme(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to delete priority scheme.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the priority scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all visible projects
     * @param includeArchived (optional) 
     * @param expand (optional) 
     * @param recent (optional) 
     * @param browseArchive (optional) 
     * @return Project data
     */
    getAllProjects(includeArchived?: boolean | undefined, expand?: string | undefined, recent?: number | undefined, browseArchive?: boolean | undefined): Promise<ProjectBean> {
        let url_ = this.baseUrl + "/api/2/project?";
        if (includeArchived === null)
            throw new Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (recent === null)
            throw new Error("The parameter 'recent' cannot be null.");
        else if (recent !== undefined)
            url_ += "recent=" + encodeURIComponent("" + recent) + "&";
        if (browseArchive === null)
            throw new Error("The parameter 'browseArchive' cannot be null.");
        else if (browseArchive !== undefined)
            url_ += "browseArchive=" + encodeURIComponent("" + browseArchive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllProjects(_response);
        });
    }

    protected processGetAllProjects(response: Response): Promise<ProjectBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have rights to view projects", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectBean>(null as any);
    }

    /**
     * Create a new project
     * @param body Project data
     * @return Created project data
     */
    createProject(body: ProjectInputBean): Promise<ProjectIdentity> {
        let url_ = this.baseUrl + "/api/2/project";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProject(_response);
        });
    }

    protected processCreateProject(response: Response): Promise<ProjectIdentity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProjectIdentity.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is not valid and the project could not be created", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have rights to create projects", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("Returned if requested workflowScheme could not be assigned to created project", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectIdentity>(null as any);
    }

    /**
     * Get all project types
     * @return Returns a list with all the project types defined on the Jira instance
     */
    getAllProjectTypes(): Promise<ProjectTypeBean> {
        let url_ = this.baseUrl + "/api/2/project/type";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllProjectTypes(_response);
        });
    }

    protected processGetAllProjectTypes(response: Response): Promise<ProjectTypeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectTypeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A response status of 401 indicates that there is not a logged in user and therefore this operation can\'t be performed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectTypeBean>(null as any);
    }

    /**
     * Get project type by key
     * @return Returns a representation of the project type with the given id
     */
    getProjectTypeByKey(projectTypeKey: string): Promise<ProjectTypeBean> {
        let url_ = this.baseUrl + "/api/2/project/type/{projectTypeKey}";
        if (projectTypeKey === undefined || projectTypeKey === null)
            throw new Error("The parameter 'projectTypeKey' must be defined.");
        url_ = url_.replace("{projectTypeKey}", encodeURIComponent("" + projectTypeKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjectTypeByKey(_response);
        });
    }

    protected processGetProjectTypeByKey(response: Response): Promise<ProjectTypeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectTypeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A response status of 401 indicates that there is not a logged in user and therefore this operation can\'t be performed", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectTypeBean>(null as any);
    }

    /**
     * Get project type by key
     * @return Returns a representation of the project type with the given id
     */
    getAccessibleProjectTypeByKey(projectTypeKey: string): Promise<ProjectTypeBean> {
        let url_ = this.baseUrl + "/api/2/project/type/{projectTypeKey}/accessible";
        if (projectTypeKey === undefined || projectTypeKey === null)
            throw new Error("The parameter 'projectTypeKey' must be defined.");
        url_ = url_.replace("{projectTypeKey}", encodeURIComponent("" + projectTypeKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAccessibleProjectTypeByKey(_response);
        });
    }

    protected processGetAccessibleProjectTypeByKey(response: Response): Promise<ProjectTypeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectTypeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("A response status of 401 indicates that there is not a logged in user and therefore this operation can\'t be performed", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("A response status of 404 indicates that the project type is not accessible for the logged in user", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectTypeBean>(null as any);
    }

    /**
     * Get a project by ID or key
     * @param expand (optional) 
     * @return Project data
     */
    getProject(projectIdOrKey: string, expand?: string | undefined): Promise<ProjectBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProject(_response);
        });
    }

    protected processGetProject(response: Response): Promise<ProjectBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project is not found, or the calling user does not have permission to view it", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectBean>(null as any);
    }

    /**
     * Update a project
     * @param body Project update data
     * @param expand (optional) 
     * @return Updated project data
     */
    updateProject(projectIdOrKey: string, body: ProjectUpdateBean, expand?: string | undefined): Promise<ProjectBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProject(_response);
        });
    }

    protected processUpdateProject(response: Response): Promise<ProjectBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is not valid and the project could not be updated", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have rights to update projects", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project does not exist", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectBean>(null as any);
    }

    /**
     * Delete a project
     * @return Returned if the project is successfully deleted
     */
    deleteProject(projectIdOrKey: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProject(_response);
        });
    }

    protected processDeleteProject(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to delete the project", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project does not exist", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Archive a project
     * @return Returned if the project is successfully archived
     */
    archiveProject(projectIdOrKey: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/archive";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processArchiveProject(_response);
        });
    }

    protected processArchiveProject(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to archive the project or doesn\'t have DC license or project is already archived", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project does not exist", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update project avatar
     * @param body Avatar data
     * @return Returned if the avatar was updated successfully
     */
    updateProjectAvatar(projectIdOrKey: string, body: AvatarBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/avatar";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProjectAvatar(_response);
        });
    }

    protected processUpdateProjectAvatar(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the avatar does not exist", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project does not exist", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete an avatar
     * @return Returned if the avatar is successfully deleted
     */
    deleteAvatar(projectIdOrKey: string, id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/avatar/{id}";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAvatar(_response);
        });
    }

    protected processDeleteAvatar(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to delete the avatar", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the avatar or project does not exist", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all avatars for a project
     * @return Avatars
     */
    getAllAvatars(projectIdOrKey: string): Promise<AvatarBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/avatars";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllAvatars(_response);
        });
    }

    protected processGetAllAvatars(response: Response): Promise<AvatarBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AvatarBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project is not found, or the calling user does not have permission to view it", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvatarBean>(null as any);
    }

    /**
     * Get project components
     * @return Project components
     */
    getProjectComponents(projectIdOrKey: string): Promise<ComponentBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/components";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjectComponents(_response);
        });
    }

    protected processGetProjectComponents(response: Response): Promise<ComponentBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ComponentBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project is not found, or the calling user does not have permission to view it", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ComponentBean>(null as any);
    }

    /**
     * Restore an archived project
     * @return Returned if the project is successfully restored
     */
    restoreProject(projectIdOrKey: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/restore";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRestoreProject(_response);
        });
    }

    protected processRestoreProject(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to restore the project or doesn\'t have DC license or project is already restored", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project does not exist", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all roles in project
     * @return List of roles and URIs to full details
     */
    getProjectRoles(projectIdOrKey: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/role";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjectRoles(_response);
        });
    }

    protected processGetProjectRoles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project is not found, or the calling user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get details for a project role
     * @return Role details and its actors
     */
    getProjectRole(projectIdOrKey: string, id: number): Promise<ProjectRoleBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/role/{id}";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjectRole(_response);
        });
    }

    protected processGetProjectRole(response: Response): Promise<ProjectRoleBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRoleBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project or role is not found, or the calling user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectRoleBean>(null as any);
    }

    /**
     * Update project role with actors
     * @param body The actors to set for the role
     * @return Role details and its actors after modification
     */
    setActors(projectIdOrKey: string, id: number, body: ProjectRoleActorsUpdateBean): Promise<ProjectRoleBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/role/{id}";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetActors(_response);
        });
    }

    protected processSetActors(response: Response): Promise<ProjectRoleBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRoleBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the actor could not be added to the project role", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectRoleBean>(null as any);
    }

    /**
     * Add actor to project role
     * @param body The actors to add to the role
     * @return Role details and its actors after modification
     */
    addActorUsers(projectIdOrKey: string, id: number, body: ActorsMap): Promise<ProjectRoleBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/role/{id}";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddActorUsers(_response);
        });
    }

    protected processAddActorUsers(response: Response): Promise<ProjectRoleBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRoleBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project or role is not found, the calling user does not have permission to view it or does not have permission to modify the actors in the project role.", status, _responseText, _headers);
            });
        } else if (status === 410) {
            return response.text().then((_responseText) => {
            return throwException("Returned if none of the specified groups and users exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectRoleBean>(null as any);
    }

    /**
     * Delete actors from project role
     * @param user (optional) 
     * @param group (optional) 
     * @return No content on success
     */
    deleteActor(projectIdOrKey: string, id: number, user?: string | undefined, group?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/role/{id}?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        if (group === null)
            throw new Error("The parameter 'group' cannot be null.");
        else if (group !== undefined)
            url_ += "group=" + encodeURIComponent("" + group) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteActor(_response);
        });
    }

    protected processDeleteActor(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project or role is not found, the calling user does not have permission to view it or does not have permission to modify the actors in the project role.", status, _responseText, _headers);
            });
        } else if (status === 410) {
            return response.text().then((_responseText) => {
            return throwException("Returned if none of the specified groups and users exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all issue types with statuses for a project
     * @return Issue types with status values
     */
    getAllStatuses(projectIdOrKey: string): Promise<IssueTypeWithStatusJsonBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/statuses";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllStatuses(_response);
        });
    }

    protected processGetAllStatuses(response: Response): Promise<IssueTypeWithStatusJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueTypeWithStatusJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project is not found, or the calling user does not have permission to view it", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueTypeWithStatusJsonBean>(null as any);
    }

    /**
     * Update project type
     * @return Updated project data
     */
    updateProjectType(projectIdOrKey: string, newProjectTypeKey: string): Promise<ProjectBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/type/{newProjectTypeKey}";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (newProjectTypeKey === undefined || newProjectTypeKey === null)
            throw new Error("The parameter 'newProjectTypeKey' must be defined.");
        url_ = url_.replace("{newProjectTypeKey}", encodeURIComponent("" + newProjectTypeKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProjectType(_response);
        });
    }

    protected processUpdateProjectType(response: Response): Promise<ProjectBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is not valid and the project type could not be updated", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have rights to update projects", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project does not exist", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectBean>(null as any);
    }

    /**
     * Get paginated project versions
     * @param expand (optional) 
     * @param maxResults (optional) 
     * @param orderBy (optional) 
     * @param startAt (optional) 
     * @return Project versions
     */
    getProjectVersionsPaginated(projectIdOrKey: string, expand?: string | undefined, maxResults?: number | undefined, orderBy?: string | undefined, startAt?: number | undefined): Promise<PageBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/version?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjectVersionsPaginated(_response);
        });
    }

    protected processGetProjectVersionsPaginated(response: Response): Promise<PageBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project is not found, or the calling user does not have permission to view it", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PageBean>(null as any);
    }

    /**
     * Get project versions
     * @param expand (optional) 
     * @return Project versions
     */
    getProjectVersions(projectIdOrKey: string, expand?: string | undefined): Promise<VersionBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/versions?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjectVersions(_response);
        });
    }

    protected processGetProjectVersions(response: Response): Promise<VersionBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VersionBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project is not found, or the calling user does not have permission to view it", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionBean>(null as any);
    }

    /**
     * Get assigned permission scheme
     * @param expand (optional) 
     * @return The associated permission scheme.
     */
    getAssignedPermissionScheme(projectKeyOrId: string, expand?: string | undefined): Promise<PermissionSchemeBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectKeyOrId}/permissionscheme?";
        if (projectKeyOrId === undefined || projectKeyOrId === null)
            throw new Error("The parameter 'projectKeyOrId' must be defined.");
        url_ = url_.replace("{projectKeyOrId}", encodeURIComponent("" + projectKeyOrId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAssignedPermissionScheme(_response);
        });
    }

    protected processGetAssignedPermissionScheme(response: Response): Promise<PermissionSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have permissions to view the project\'s configuration. In practice the user needs to be a Jira administrator.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project is not found (or the user does not have permissions to view the project).", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionSchemeBean>(null as any);
    }

    /**
     * Assign permission scheme to project
     * @param body Object that contains an id of the scheme
     * @param expand (optional) 
     * @return Shortened details of the newly associated permission scheme.
     */
    assignPermissionScheme(projectKeyOrId: string, body: IdBean, expand?: string | undefined): Promise<PermissionSchemeBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectKeyOrId}/permissionscheme?";
        if (projectKeyOrId === undefined || projectKeyOrId === null)
            throw new Error("The parameter 'projectKeyOrId' must be defined.");
        url_ = url_.replace("{projectKeyOrId}", encodeURIComponent("" + projectKeyOrId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignPermissionScheme(_response);
        });
    }

    protected processAssignPermissionScheme(response: Response): Promise<PermissionSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have permissions to edit project\'s permission schemes. In practice the user needs to be a Jira administrator.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project or permission scheme is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PermissionSchemeBean>(null as any);
    }

    /**
     * Get assigned priority scheme
     * @return Returned if the priority scheme exists and the user has permission to view it.
     */
    getAssignedPriorityScheme(projectKeyOrId: string): Promise<PrioritySchemeBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectKeyOrId}/priorityscheme";
        if (projectKeyOrId === undefined || projectKeyOrId === null)
            throw new Error("The parameter 'projectKeyOrId' must be defined.");
        url_ = url_.replace("{projectKeyOrId}", encodeURIComponent("" + projectKeyOrId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAssignedPriorityScheme(_response);
        });
    }

    protected processGetAssignedPriorityScheme(response: Response): Promise<PrioritySchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrioritySchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have rights to view priority scheme.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if project or priority scheme is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PrioritySchemeBean>(null as any);
    }

    /**
     * Assign project with priority scheme
     * @param body Object that contains an id of the scheme
     * @return Affected priority scheme.
     */
    assignPriorityScheme(projectKeyOrId: string, body: IdBean): Promise<PrioritySchemeBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectKeyOrId}/priorityscheme";
        if (projectKeyOrId === undefined || projectKeyOrId === null)
            throw new Error("The parameter 'projectKeyOrId' must be defined.");
        url_ = url_.replace("{projectKeyOrId}", encodeURIComponent("" + projectKeyOrId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignPriorityScheme(_response);
        });
    }

    protected processAssignPriorityScheme(response: Response): Promise<PrioritySchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrioritySchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is not valid and the priority scheme could not be updated. Eg. migration is needed as a result of operation.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have rights to assign priority schemes.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if project or priority scheme is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PrioritySchemeBean>(null as any);
    }

    /**
     * Unassign project from priority scheme
     * @return Affected priority scheme.
     */
    unassignPriorityScheme(schemeId: number, projectKeyOrId: string): Promise<PrioritySchemeBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectKeyOrId}/priorityscheme/{schemeId}";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (projectKeyOrId === undefined || projectKeyOrId === null)
            throw new Error("The parameter 'projectKeyOrId' must be defined.");
        url_ = url_.replace("{projectKeyOrId}", encodeURIComponent("" + projectKeyOrId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnassignPriorityScheme(_response);
        });
    }

    protected processUnassignPriorityScheme(response: Response): Promise<PrioritySchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrioritySchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is not valid and the priority scheme could not be updated. Eg. provided scheme is default priority scheme or project is not associated with scheme.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have rights to assign priority schemes.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if project or priority scheme is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PrioritySchemeBean>(null as any);
    }

    /**
     * Get all security levels for project
     * @return Returns a list of all security levels in a project for which the current user has access.
     */
    getSecurityLevelsForProject(projectKeyOrId: string): Promise<SecurityListLevelJsonBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectKeyOrId}/securitylevel";
        if (projectKeyOrId === undefined || projectKeyOrId === null)
            throw new Error("The parameter 'projectKeyOrId' must be defined.");
        url_ = url_.replace("{projectKeyOrId}", encodeURIComponent("" + projectKeyOrId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSecurityLevelsForProject(_response);
        });
    }

    protected processGetSecurityLevelsForProject(response: Response): Promise<SecurityListLevelJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityListLevelJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project is not found or the user does not have permissions to browse it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityListLevelJsonBean>(null as any);
    }

    /**
     * Get workflow scheme for project
     * @return Returned if requested project exist and has associated workflow scheme, and the user has permission to see it.
     */
    getWorkflowSchemeForProject(projectKeyOrId: string): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectKeyOrId}/workflowscheme";
        if (projectKeyOrId === undefined || projectKeyOrId === null)
            throw new Error("The parameter 'projectKeyOrId' must be defined.");
        url_ = url_.replace("{projectKeyOrId}", encodeURIComponent("" + projectKeyOrId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkflowSchemeForProject(_response);
        });
    }

    protected processGetWorkflowSchemeForProject(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested user does not have permission to administer Jira.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested project does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Get all project categories
     * @return Returns a list of all project categories.
     */
    getAllProjectCategories(): Promise<ProjectCategoryJsonBean> {
        let url_ = this.baseUrl + "/api/2/projectCategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllProjectCategories(_response);
        });
    }

    protected processGetAllProjectCategories(response: Response): Promise<ProjectCategoryJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectCategoryJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while retrieving the list of projects.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectCategoryJsonBean>(null as any);
    }

    /**
     * Create project category
     * @param body The project category to create.
     * @return Returned if the project category is created successfully.
     */
    createProjectCategory(body: ProjectCategoryBean): Promise<ProjectCategoryJsonBean> {
        let url_ = this.baseUrl + "/api/2/projectCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProjectCategory(_response);
        });
    }

    protected processCreateProjectCategory(response: Response): Promise<ProjectCategoryJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProjectCategoryJsonBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller is not logged in so does not have permission to create project categories.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller is authenticated and does not have permission to create project categories (is not global admin).", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("Returned if a project category with the given name already exists.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectCategoryJsonBean>(null as any);
    }

    /**
     * Get project category by ID
     * @return Returned if the project category exists and is visible by the calling user.
     */
    getProjectCategoryById(id: number): Promise<ProjectCategoryJsonBean> {
        let url_ = this.baseUrl + "/api/2/projectCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjectCategoryById(_response);
        });
    }

    protected processGetProjectCategoryById(response: Response): Promise<ProjectCategoryJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectCategoryJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project category does not exist, or is not visible to the calling user.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectCategoryJsonBean>(null as any);
    }

    /**
     * Update project category
     * @param body The project category to modify.
     * @return Returned if the project category exists and the currently authenticated user has permission to edit it.
     */
    updateProjectCategory(id: number, body: ProjectCategoryBean): Promise<ProjectCategoryJsonBean> {
        let url_ = this.baseUrl + "/api/2/projectCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProjectCategory(_response);
        });
    }

    protected processUpdateProjectCategory(response: Response): Promise<ProjectCategoryJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectCategoryJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller is not logged in so does not have permission to change project categories.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller is authenticated and does not have permission to change project categories (is not global admin).", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project category does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectCategoryJsonBean>(null as any);
    }

    /**
     * Delete project category
     * @return Returned if the project category is successfully deleted.
     */
    removeProjectCategory(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/2/projectCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveProjectCategory(_response);
        });
    }

    protected processRemoveProjectCategory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller is not logged in so does not have permission to delete project categories.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller is authenticated and does not have permission to delete project categories (is not global admin).", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project category does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get projects matching query
     * @param maxResults (optional) 
     * @param query (optional) 
     * @param allowEmptyQuery (optional) 
     * @return Returned even when no projects match the given query.
     */
    searchForProjects(maxResults?: number | undefined, query?: string | undefined, allowEmptyQuery?: boolean | undefined): Promise<ProjectPickerResultWrapper> {
        let url_ = this.baseUrl + "/api/2/projects/picker?";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (allowEmptyQuery === null)
            throw new Error("The parameter 'allowEmptyQuery' cannot be null.");
        else if (allowEmptyQuery !== undefined)
            url_ += "allowEmptyQuery=" + encodeURIComponent("" + allowEmptyQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchForProjects(_response);
        });
    }

    protected processSearchForProjects(response: Response): Promise<ProjectPickerResultWrapper> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectPickerResultWrapper.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectPickerResultWrapper>(null as any);
    }

    /**
     * Get reindex information
     * @param taskId (optional) 
     * @return Returns a representation of the progress of the re-index operation.
     */
    getReindexInfo(taskId?: number | undefined): Promise<ReindexBean> {
        let url_ = this.baseUrl + "/api/2/reindex?";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReindexInfo(_response);
        });
    }

    protected processGetReindexInfo(response: Response): Promise<ReindexBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReindexBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no re-indexing task found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReindexBean>(null as any);
    }

    /**
     * Start a reindex operation
     * @param indexChangeHistory (optional) 
     * @param type (optional) 
     * @param indexWorklogs (optional) 
     * @param indexComments (optional) 
     * @return Returns a representation of the progress of the re-index operation.
     */
    reindex(indexChangeHistory?: boolean | undefined, type?: string | undefined, indexWorklogs?: boolean | undefined, indexComments?: boolean | undefined): Promise<ReindexBean> {
        let url_ = this.baseUrl + "/api/2/reindex?";
        if (indexChangeHistory === null)
            throw new Error("The parameter 'indexChangeHistory' cannot be null.");
        else if (indexChangeHistory !== undefined)
            url_ += "indexChangeHistory=" + encodeURIComponent("" + indexChangeHistory) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (indexWorklogs === null)
            throw new Error("The parameter 'indexWorklogs' cannot be null.");
        else if (indexWorklogs !== undefined)
            url_ += "indexWorklogs=" + encodeURIComponent("" + indexWorklogs) + "&";
        if (indexComments === null)
            throw new Error("The parameter 'indexComments' cannot be null.");
        else if (indexComments !== undefined)
            url_ += "indexComments=" + encodeURIComponent("" + indexComments) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReindex(_response);
        });
    }

    protected processReindex(response: Response): Promise<ReindexBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = ReindexBean.fromJS(resultData202);
            return result202;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReindexBean>(null as any);
    }

    /**
     * Reindex individual issues
     * @param issueId (optional) 
     * @param indexChangeHistory (optional) 
     * @param indexWorklogs (optional) 
     * @param indexComments (optional) 
     * @return Returns response indicating reindex time.
     */
    reindexIssues(issueId?: string[] | undefined, indexChangeHistory?: boolean | undefined, indexWorklogs?: boolean | undefined, indexComments?: boolean | undefined): Promise<ReindexBean> {
        let url_ = this.baseUrl + "/api/2/reindex/issue?";
        if (issueId === null)
            throw new Error("The parameter 'issueId' cannot be null.");
        else if (issueId !== undefined)
            issueId && issueId.forEach(item => { url_ += "issueId=" + encodeURIComponent("" + item) + "&"; });
        if (indexChangeHistory === null)
            throw new Error("The parameter 'indexChangeHistory' cannot be null.");
        else if (indexChangeHistory !== undefined)
            url_ += "indexChangeHistory=" + encodeURIComponent("" + indexChangeHistory) + "&";
        if (indexWorklogs === null)
            throw new Error("The parameter 'indexWorklogs' cannot be null.");
        else if (indexWorklogs !== undefined)
            url_ += "indexWorklogs=" + encodeURIComponent("" + indexWorklogs) + "&";
        if (indexComments === null)
            throw new Error("The parameter 'indexComments' cannot be null.");
        else if (indexComments !== undefined)
            url_ += "indexComments=" + encodeURIComponent("" + indexComments) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReindexIssues(_response);
        });
    }

    protected processReindexIssues(response: Response): Promise<ReindexBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReindexBean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReindexBean>(null as any);
    }

    /**
     * Get reindex progress
     * @param taskId (optional) 
     * @return Returns a representation of the progress of the re-index operation.
     */
    getReindexProgress(taskId?: number | undefined): Promise<ReindexBean> {
        let url_ = this.baseUrl + "/api/2/reindex/progress?";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReindexProgress(_response);
        });
    }

    protected processGetReindexProgress(response: Response): Promise<ReindexBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReindexBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no re-indexing task found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReindexBean>(null as any);
    }

    /**
     * Execute pending reindex requests
     * @return Returns an array containing the reindex request IDs being processed.
     */
    processRequests(): Promise<number> {
        let url_ = this.baseUrl + "/api/2/reindex/request";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProcessRequests(_response);
        });
    }

    protected processProcessRequests(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authorized to process reindex requests.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is an error processing reindex requests.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * Get progress of multiple reindex requests
     * @param requestId (optional) 
     * @return An array of results describing the progress of each of the found requests.
     */
    getProgressBulk(requestId?: number[] | undefined): Promise<ReindexRequestBean> {
        let url_ = this.baseUrl + "/api/2/reindex/request/bulk?";
        if (requestId === null)
            throw new Error("The parameter 'requestId' cannot be null.");
        else if (requestId !== undefined)
            requestId && requestId.forEach(item => { url_ += "requestId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProgressBulk(_response);
        });
    }

    protected processGetProgressBulk(response: Response): Promise<ReindexRequestBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReindexRequestBean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReindexRequestBean>(null as any);
    }

    /**
     * Get progress of a single reindex request
     * @return Details and status of the reindex request.
     */
    getProgress(requestId: number): Promise<ReindexRequestBean> {
        let url_ = this.baseUrl + "/api/2/reindex/request/{requestId}";
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProgress(_response);
        });
    }

    protected processGetProgress(response: Response): Promise<ReindexRequestBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReindexRequestBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if no such reindex request exists.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReindexRequestBean>(null as any);
    }

    /**
     * Get all resolutions
     * @return Returns a list of Jira issue resolutions.
     */
    getResolutions(): Promise<ResolutionJsonBean> {
        let url_ = this.baseUrl + "/api/2/resolution";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetResolutions(_response);
        });
    }

    protected processGetResolutions(response: Response): Promise<ResolutionJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResolutionJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResolutionJsonBean>(null as any);
    }

    /**
     * Get paginated filtered resolutions
     * @param maxResults (optional) 
     * @param query (optional) 
     * @param startAt (optional) 
     * @return Returns paginated list of resolutions.
     */
    getPaginatedResolutions(maxResults?: number | undefined, query?: string | undefined, startAt?: number | undefined): Promise<ResolutionBean> {
        let url_ = this.baseUrl + "/api/2/resolution/page?";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaginatedResolutions(_response);
        });
    }

    protected processGetPaginatedResolutions(response: Response): Promise<ResolutionBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResolutionBean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResolutionBean>(null as any);
    }

    /**
     * Get a resolution by ID
     * @return Returns a Jira issue resolution.
     */
    getResolution(id: string): Promise<ResolutionJsonBean> {
        let url_ = this.baseUrl + "/api/2/resolution/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetResolution(_response);
        });
    }

    protected processGetResolution(response: Response): Promise<ResolutionJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResolutionJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the resolution does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResolutionJsonBean>(null as any);
    }

    /**
     * Create a new project role
     * @param body The role to create
     * @return Returns full details of the created role
     */
    createProjectRole(body: CreateUpdateRoleRequestBean): Promise<ProjectRoleBean> {
        let url_ = this.baseUrl + "/api/2/role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProjectRole(_response);
        });
    }

    protected processCreateProjectRole(response: Response): Promise<ProjectRoleBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRoleBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request json does not have a name field or the name field is invalid (empty or starts or ends with whitespace)", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if you are not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if you do not have permissions to create a role.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("Returned if a role with given name already exists.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectRoleBean>(null as any);
    }

    /**
     * Get a specific project role
     * @return Returns full details of the role available in Jira.
     */
    getProjectRolesById(id: number): Promise<ProjectRoleBean> {
        let url_ = this.baseUrl + "/api/2/role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjectRolesById(_response);
        });
    }

    protected processGetProjectRolesById(response: Response): Promise<ProjectRoleBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRoleBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requesting user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requesting user is not an admin or a sysadmin.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the role with the given id does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectRoleBean>(null as any);
    }

    /**
     * Fully updates a role's name and description
     * @param body (optional) 
     * @return Returns updated role.
     */
    fullyUpdateProjectRole(id: number, body?: CreateUpdateRoleRequestBean | undefined): Promise<ProjectRoleBean> {
        let url_ = this.baseUrl + "/api/2/role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFullyUpdateProjectRole(_response);
        });
    }

    protected processFullyUpdateProjectRole(response: Response): Promise<ProjectRoleBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRoleBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned when name or description is not given or the name field is invalid (empty or starts or ends with whitespace).", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requesting user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requesting user is not an admin or a sysadmin.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the role with the given id does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectRoleBean>(null as any);
    }

    /**
     * Partially updates a role's name or description
     * @param body (optional) 
     * @return Returns updated role.
     */
    partialUpdateProjectRole(id: number, body?: CreateUpdateRoleRequestBean | undefined): Promise<ProjectRoleBean> {
        let url_ = this.baseUrl + "/api/2/role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPartialUpdateProjectRole(_response);
        });
    }

    protected processPartialUpdateProjectRole(response: Response): Promise<ProjectRoleBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRoleBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned when both name and description are not given or name field is invalid (empty or starts or ends with whitespace).", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requesting user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requesting user is not an admin or a sysadmin.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the role with the given id does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectRoleBean>(null as any);
    }

    /**
     * Deletes a role
     * @param swap (optional) 
     * @return Returned if the delete was successful.
     */
    deleteProjectRole(id: number, swap?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/role/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (swap === null)
            throw new Error("The parameter 'swap' cannot be null.");
        else if (swap !== undefined)
            url_ += "swap=" + encodeURIComponent("" + swap) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProjectRole(_response);
        });
    }

    protected processDeleteProjectRole(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if given role with given swap id does not exist.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requesting user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requesting user is not an admin or a sysadmin.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the role with the given id does not exist.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project role is used in schemes and roleToSwap query parameter is not given.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get default actors for a role
     * @return Returns actor list.
     */
    getProjectRoleActorsForRole(id: number): Promise<ProjectRoleActorsBean> {
        let url_ = this.baseUrl + "/api/2/role/{id}/actors";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjectRoleActorsForRole(_response);
        });
    }

    protected processGetProjectRoleActorsForRole(response: Response): Promise<ProjectRoleActorsBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRoleActorsBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requesting user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requesting user is not an admin or a sysadmin.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the role with the given id does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectRoleActorsBean>(null as any);
    }

    /**
     * Adds default actors to a role
     * @param body (optional) 
     * @return Returns actor list.
     */
    addProjectRoleActorsToRole(id: number, body?: ActorInputBean | undefined): Promise<ProjectRoleActorsBean> {
        let url_ = this.baseUrl + "/api/2/role/{id}/actors";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddProjectRoleActorsToRole(_response);
        });
    }

    protected processAddProjectRoleActorsToRole(response: Response): Promise<ProjectRoleActorsBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRoleActorsBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request json does not have a user or group field or both user and group fields are given.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requesting user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requesting user is not an admin or a sysadmin.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the role with the given id does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectRoleActorsBean>(null as any);
    }

    /**
     * Removes default actor from a role
     * @param user (optional) 
     * @param group (optional) 
     * @return Returns updated actors list.
     */
    deleteProjectRoleActorsFromRole(id: number, user?: string | undefined, group?: string | undefined): Promise<ProjectRoleActorsBean> {
        let url_ = this.baseUrl + "/api/2/role/{id}/actors?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        if (group === null)
            throw new Error("The parameter 'group' cannot be null.");
        else if (group !== undefined)
            url_ += "group=" + encodeURIComponent("" + group) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProjectRoleActorsFromRole(_response);
        });
    }

    protected processDeleteProjectRoleActorsFromRole(response: Response): Promise<ProjectRoleActorsBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRoleActorsBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user and group are not given, both user and group are given or provided group or user does not exist.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requesting user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requesting user is not an admin or a sysadmin.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the role with the given id does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectRoleActorsBean>(null as any);
    }

    /**
     * Get available field screens
     * @param search (optional) 
     * @param expand (optional) 
     * @param maxResults (optional) 
     * @param startAt (optional) 
     * @return Returns response indicating successful addition of field to default screen / default tab.
     */
    getAllScreens(search?: string | undefined, expand?: string | undefined, maxResults?: string | undefined, startAt?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/screens?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllScreens(_response);
        });
    }

    protected processGetAllScreens(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if screen, tab or field does not exist or field is already present on a selected tab.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have administrator permissions.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Add field to default screen
     * @return Returns response indicating field movement.
     */
    addFieldToDefaultScreen(fieldId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/screens/addToDefault/{fieldId}";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddFieldToDefaultScreen(_response);
        });
    }

    protected processAddFieldToDefaultScreen(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the screen, tab or field does not exist.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authorized to move a field.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get available fields for screen
     * @return Returns a list of available fields for the screen.
     */
    getFieldsToAdd(screenId: number): Promise<ScreenableFieldBean> {
        let url_ = this.baseUrl + "/api/2/screens/{screenId}/availableFields";
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFieldsToAdd(_response);
        });
    }

    protected processGetFieldsToAdd(response: Response): Promise<ScreenableFieldBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScreenableFieldBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the screen does not exist.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authorized to view the available fields.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScreenableFieldBean>(null as any);
    }

    /**
     * Get all tabs for a screen
     * @param projectKey (optional) 
     * @return Returns a list of Jira issue tabs.
     */
    getAllTabs(screenId: number, projectKey?: string | undefined): Promise<ScreenableTabBean> {
        let url_ = this.baseUrl + "/api/2/screens/{screenId}/tabs?";
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        if (projectKey === null)
            throw new Error("The parameter 'projectKey' cannot be null.");
        else if (projectKey !== undefined)
            url_ += "projectKey=" + encodeURIComponent("" + projectKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTabs(_response);
        });
    }

    protected processGetAllTabs(response: Response): Promise<ScreenableTabBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScreenableTabBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the screen does not exist.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authorized to view the tabs.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScreenableTabBean>(null as any);
    }

    /**
     * Create tab for a screen
     * @param body (optional) 
     * @return Returns newly created tab.
     */
    addTab(screenId: number, body?: ScreenableTabBean | undefined): Promise<ScreenableTabBean> {
        let url_ = this.baseUrl + "/api/2/screens/{screenId}/tabs";
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddTab(_response);
        });
    }

    protected processAddTab(response: Response): Promise<ScreenableTabBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScreenableTabBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the screen does not exist or the user is not authorized to create a tab.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authorized to create a tab.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScreenableTabBean>(null as any);
    }

    /**
     * Rename a tab on a screen
     * @param body (optional) 
     * @return Returns renamed tab.
     */
    renameTab(tabId: number, screenId: number, body?: ScreenableTabBean | undefined): Promise<ScreenableTabBean> {
        let url_ = this.baseUrl + "/api/2/screens/{screenId}/tabs/{tabId}";
        if (tabId === undefined || tabId === null)
            throw new Error("The parameter 'tabId' must be defined.");
        url_ = url_.replace("{tabId}", encodeURIComponent("" + tabId));
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenameTab(_response);
        });
    }

    protected processRenameTab(response: Response): Promise<ScreenableTabBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScreenableTabBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the screen does not exist or the user is not authorized to rename a tab.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authorized to rename a tab.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScreenableTabBean>(null as any);
    }

    /**
     * Delete a tab from a screen
     * @return Returns response indicating tab deletion.
     */
    deleteTab(tabId: number, screenId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/2/screens/{screenId}/tabs/{tabId}";
        if (tabId === undefined || tabId === null)
            throw new Error("The parameter 'tabId' must be defined.");
        url_ = url_.replace("{tabId}", encodeURIComponent("" + tabId));
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTab(_response);
        });
    }

    protected processDeleteTab(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the screen does not exist or the user is not authorized to delete a tab.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authorized to delete a tab.", status, _responseText, _headers);
            });
        } else if (status === 412) {
            return response.text().then((_responseText) => {
            return throwException("Returned if tab can not be deleted due to a pre-condition (there has to be at least one tab left).", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all fields for a tab
     * @param projectKey (optional) 
     * @return Returns a list of all fields for the given tab.
     */
    getAllFields(tabId: number, screenId: number, projectKey?: string | undefined): Promise<ScreenableFieldBean> {
        let url_ = this.baseUrl + "/api/2/screens/{screenId}/tabs/{tabId}/fields?";
        if (tabId === undefined || tabId === null)
            throw new Error("The parameter 'tabId' must be defined.");
        url_ = url_.replace("{tabId}", encodeURIComponent("" + tabId));
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        if (projectKey === null)
            throw new Error("The parameter 'projectKey' cannot be null.");
        else if (projectKey !== undefined)
            url_ += "projectKey=" + encodeURIComponent("" + projectKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllFields(_response);
        });
    }

    protected processGetAllFields(response: Response): Promise<ScreenableFieldBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScreenableFieldBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the screen or tab does not exist.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authorized to view the fields.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScreenableFieldBean>(null as any);
    }

    /**
     * Add field to a tab
     * @param body (optional) 
     * @return Returns newly added field.
     */
    addField(tabId: number, screenId: number, body?: AddFieldBean | undefined): Promise<ScreenableFieldBean> {
        let url_ = this.baseUrl + "/api/2/screens/{screenId}/tabs/{tabId}/fields";
        if (tabId === undefined || tabId === null)
            throw new Error("The parameter 'tabId' must be defined.");
        url_ = url_.replace("{tabId}", encodeURIComponent("" + tabId));
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddField(_response);
        });
    }

    protected processAddField(response: Response): Promise<ScreenableFieldBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScreenableFieldBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the screen, tab or field does not exist.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authorized to add a field.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScreenableFieldBean>(null as any);
    }

    /**
     * Remove field from tab
     * @return Returns response indicating field removal.
     */
    removeField(tabId: number, screenId: number, id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/screens/{screenId}/tabs/{tabId}/fields/{id}";
        if (tabId === undefined || tabId === null)
            throw new Error("The parameter 'tabId' must be defined.");
        url_ = url_.replace("{tabId}", encodeURIComponent("" + tabId));
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveField(_response);
        });
    }

    protected processRemoveField(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the screen or tab does not exist.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authorized to remove a field.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Move field on a tab
     * @param body (optional) 
     * @return Returns response indicating field movement.
     */
    moveField(tabId: number, screenId: number, id: string, body?: MoveFieldBean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/screens/{screenId}/tabs/{tabId}/fields/{id}/move";
        if (tabId === undefined || tabId === null)
            throw new Error("The parameter 'tabId' must be defined.");
        url_ = url_.replace("{tabId}", encodeURIComponent("" + tabId));
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMoveField(_response);
        });
    }

    protected processMoveField(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the screen, tab or field does not exist.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authorized to move a field.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update 'showWhenEmptyIndicator' for a field
     * @return Returns response indicating the update of 'showWhenEmptyIndicator'.
     */
    updateShowWhenEmptyIndicator(tabId: number, screenId: number, newValue: boolean, id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/screens/{screenId}/tabs/{tabId}/fields/{id}/updateShowWhenEmptyIndicator/{newValue}";
        if (tabId === undefined || tabId === null)
            throw new Error("The parameter 'tabId' must be defined.");
        url_ = url_.replace("{tabId}", encodeURIComponent("" + tabId));
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        if (newValue === undefined || newValue === null)
            throw new Error("The parameter 'newValue' must be defined.");
        url_ = url_.replace("{newValue}", encodeURIComponent("" + newValue));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateShowWhenEmptyIndicator(_response);
        });
    }

    protected processUpdateShowWhenEmptyIndicator(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the screen, tab or field does not exist.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authorized to update \'showWhenEmptyIndicator\'.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Move tab position
     * @return Returns response indicating tab movement.
     */
    moveTab(tabId: number, screenId: number, pos: number): Promise<void> {
        let url_ = this.baseUrl + "/api/2/screens/{screenId}/tabs/{tabId}/move/{pos}";
        if (tabId === undefined || tabId === null)
            throw new Error("The parameter 'tabId' must be defined.");
        url_ = url_.replace("{tabId}", encodeURIComponent("" + tabId));
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        if (pos === undefined || pos === null)
            throw new Error("The parameter 'pos' must be defined.");
        url_ = url_.replace("{pos}", encodeURIComponent("" + pos));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMoveTab(_response);
        });
    }

    protected processMoveTab(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the screen does not exist or the user is not authorized to move a tab.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authorized to move a tab.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Perform search with JQL
     * @param body a JSON object containing the search request
     * @return Returns a JSON representation of the search results.
     */
    searchUsingSearchRequest(body: SearchRequestBean): Promise<SearchResultsBean> {
        let url_ = this.baseUrl + "/api/2/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchUsingSearchRequest(_response);
        });
    }

    protected processSearchUsingSearchRequest(response: Response): Promise<SearchResultsBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResultsBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is a problem with the JQL query.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchResultsBean>(null as any);
    }

    /**
     * Get a security level by ID
     * @return Returned if the issue type exists and is visible by the calling user.
     */
    getIssuesecuritylevel(id: string): Promise<SecurityLevelJsonBean> {
        let url_ = this.baseUrl + "/api/2/securitylevel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssuesecuritylevel(_response);
        });
    }

    protected processGetIssuesecuritylevel(response: Response): Promise<SecurityLevelJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityLevelJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type does not exist, or is not visible to the calling user.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityLevelJsonBean>(null as any);
    }

    /**
     * Get general information about the current Jira server
     * @return Returns a full representation of the server info in JSON format.
     */
    getServerInfo(): Promise<ServerInfoBean> {
        let url_ = this.baseUrl + "/api/2/serverInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetServerInfo(_response);
        });
    }

    protected processGetServerInfo(response: Response): Promise<ServerInfoBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServerInfoBean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServerInfoBean>(null as any);
    }

    /**
     * Update base URL for Jira instance
     * @param body (optional) 
     * @return Returned when the base url is saved successfully.
     */
    setBaseURL(body?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/settings/baseUrl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetBaseURL(_response);
        });
    }

    protected processSetBaseURL(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the specified base URL is not valid.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get default system columns for issue navigator
     * @return Returns a list of columns for configured for the given user.
     */
    getIssueNavigatorDefaultColumns(): Promise<ColumnOptions> {
        let url_ = this.baseUrl + "/api/2/settings/columns";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssueNavigatorDefaultColumns(_response);
        });
    }

    protected processGetIssueNavigatorDefaultColumns(response: Response): Promise<ColumnOptions> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ColumnOptions.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have admin permission.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while retrieving the column configuration.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ColumnOptions>(null as any);
    }

    /**
     * Set default system columns for issue navigator using form
     * @param body (optional) 
     * @return Returned when the columns is saved successfully.
     */
    setIssueNavigatorDefaultColumnsForm(body?: Body2 | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/settings/columns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = Object.keys(body as any).map((key) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent((body as any)[key]);
        }).join('&')

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetIssueNavigatorDefaultColumnsForm(_response);
        });
    }

    protected processSetIssueNavigatorDefaultColumnsForm(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while retrieving the column configuration.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all statuses
     * @return Returns a list of all Jira issue statuses in JSON format, that are visible to the user.
     */
    getStatuses(): Promise<StatusJsonBean> {
        let url_ = this.baseUrl + "/api/2/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatuses(_response);
        });
    }

    protected processGetStatuses(response: Response): Promise<StatusJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested issue status is not found, or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StatusJsonBean>(null as any);
    }

    /**
     * Get paginated filtered statuses
     * @param issueTypeIds (optional) 
     * @param maxResults (optional) 
     * @param query (optional) 
     * @param projectIds (optional) 
     * @param startAt (optional) 
     * @return Returns paginated list of statuses.
     */
    getPaginatedStatuses(issueTypeIds?: string[] | undefined, maxResults?: number | undefined, query?: string | undefined, projectIds?: number[] | undefined, startAt?: number | undefined): Promise<StatusJsonBean> {
        let url_ = this.baseUrl + "/api/2/status/page?";
        if (issueTypeIds === null)
            throw new Error("The parameter 'issueTypeIds' cannot be null.");
        else if (issueTypeIds !== undefined)
            issueTypeIds && issueTypeIds.forEach(item => { url_ += "issueTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (projectIds === null)
            throw new Error("The parameter 'projectIds' cannot be null.");
        else if (projectIds !== undefined)
            projectIds && projectIds.forEach(item => { url_ += "projectIds=" + encodeURIComponent("" + item) + "&"; });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaginatedStatuses(_response);
        });
    }

    protected processGetPaginatedStatuses(response: Response): Promise<StatusJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StatusJsonBean>(null as any);
    }

    /**
     * Get status by ID or name
     * @return Returns a full representation of a Jira issue status in JSON format.
     */
    getStatus(idOrName: string): Promise<StatusJsonBean> {
        let url_ = this.baseUrl + "/api/2/status/{idOrName}";
        if (idOrName === undefined || idOrName === null)
            throw new Error("The parameter 'idOrName' must be defined.");
        url_ = url_.replace("{idOrName}", encodeURIComponent("" + idOrName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatus(_response);
        });
    }

    protected processGetStatus(response: Response): Promise<StatusJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested issue status is not found, or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StatusJsonBean>(null as any);
    }

    /**
     * Get all status categories
     * @param request (optional) a Request
     * @param uriInfo (optional) a UriInfo
     * @return Returns a list of all Jira issue status categories in JSON format, that are visible to the user.
     */
    getStatusCategories(request?: string | undefined, uriInfo?: string | undefined): Promise<StatusCategoryJsonBean> {
        let url_ = this.baseUrl + "/api/2/statuscategory?";
        if (request === null)
            throw new Error("The parameter 'request' cannot be null.");
        else if (request !== undefined)
            url_ += "request=" + encodeURIComponent("" + request) + "&";
        if (uriInfo === null)
            throw new Error("The parameter 'uriInfo' cannot be null.");
        else if (uriInfo !== undefined)
            url_ += "uriInfo=" + encodeURIComponent("" + uriInfo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatusCategories(_response);
        });
    }

    protected processGetStatusCategories(response: Response): Promise<StatusCategoryJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusCategoryJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if no status categories are found, or the user does not have permission to view them.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StatusCategoryJsonBean>(null as any);
    }

    /**
     * Get status category by ID or key
     * @return Returns a full representation of a Jira issue status category in JSON format.
     */
    getStatusCategory(idOrKey: string): Promise<StatusCategoryJsonBean> {
        let url_ = this.baseUrl + "/api/2/statuscategory/{idOrKey}";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatusCategory(_response);
        });
    }

    protected processGetStatusCategory(response: Response): Promise<StatusCategoryJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusCategoryJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested issue status category is not found, or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StatusCategoryJsonBean>(null as any);
    }

    /**
     * Get all defined names for 'epic' and 'sprint'
     * @return Returns a list of all defined names for the default words 'epic' and 'sprint'
     */
    getAllTerminologyEntries(): Promise<TerminologyResponseBean> {
        let url_ = this.baseUrl + "/api/2/terminology/entries";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllTerminologyEntries(_response);
        });
    }

    protected processGetAllTerminologyEntries(response: Response): Promise<TerminologyResponseBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TerminologyResponseBean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TerminologyResponseBean>(null as any);
    }

    /**
     * Update epic/sprint names from original to new
     * @param body Collection of TerminologyRequestBean
     */
    setTerminologyEntries(body: TerminologyRequestBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/terminology/entries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetTerminologyEntries(_response);
        });
    }

    protected processSetTerminologyEntries(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the provided data isn\'t valid.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user doesn\'t have admin permissions.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the feature is turned off via a feature flag.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get epic or sprint name by original name
     * @return Returns epic or sprint name.
     */
    getTerminologyEntry(originalName: string): Promise<TerminologyResponseBean> {
        let url_ = this.baseUrl + "/api/2/terminology/entries/{originalName}";
        if (originalName === undefined || originalName === null)
            throw new Error("The parameter 'originalName' must be defined.");
        url_ = url_.replace("{originalName}", encodeURIComponent("" + originalName));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTerminologyEntry(_response);
        });
    }

    protected processGetTerminologyEntry(response: Response): Promise<TerminologyResponseBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TerminologyResponseBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no epic or sprint name defined in the {originalName}.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TerminologyResponseBean>(null as any);
    }

    /**
     * Get all avatars for a type and owner
     * @return Returns a list of all Jira avatars in JSON format, that are visible to the user.
     */
    getAvatars(type: string, owningObjectId: string): Promise<AvatarBean> {
        let url_ = this.baseUrl + "/api/2/universal_avatar/type/{type}/owner/{owningObjectId}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (owningObjectId === undefined || owningObjectId === null)
            throw new Error("The parameter 'owningObjectId' must be defined.");
        url_ = url_.replace("{owningObjectId}", encodeURIComponent("" + owningObjectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAvatars(_response);
        });
    }

    protected processGetAvatars(response: Response): Promise<AvatarBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AvatarBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if no avatars are found, or the user does not have permission to view them.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvatarBean>(null as any);
    }

    /**
     * Get result of the last upgrade task
     * @return Returns the result of the last upgrade.
     */
    getUpgradeResult(): Promise<UpgradeResultBean> {
        let url_ = this.baseUrl + "/api/2/upgrade";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUpgradeResult(_response);
        });
    }

    protected processGetUpgradeResult(response: Response): Promise<UpgradeResultBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpgradeResultBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 303) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the upgrade task is still running.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if no prior upgrade task exists.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UpgradeResultBean>(null as any);
    }

    /**
     * Run pending upgrade tasks
     * @return OK response if successful, array of error messages if schedule fails.
     */
    runUpgradesNow(): Promise<void> {
        let url_ = this.baseUrl + "/api/2/upgrade";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRunUpgradesNow(_response);
        });
    }

    protected processRunUpgradesNow(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have admin permissions.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("Returned if ZDU cluster upgrade in progress.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create new user
     * @param body User details
     * @return Returned if the user was created.
     */
    createUser(body: UserWriteBean): Promise<UserWriteBean> {
        let url_ = this.baseUrl + "/api/2/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<UserWriteBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UserWriteBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller user does not have permission to create the user.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user was not created because of other error.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserWriteBean>(null as any);
    }

    /**
     * Delete user
     * @param key (optional) 
     * @param username (optional) 
     * @return Returned if the user was deleted successfully.
     */
    removeUser(key?: string | undefined, username?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/user?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveUser(_response);
        });
    }

    protected processRemoveUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid or some other server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller does not have permission to remove the user.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller does have permission to remove user but the user does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get available accessibility personal settings
     * @return Returned when validation succeeded.
     */
    getA11yPersonalSettings(): Promise<A11yPersonalSettingBean> {
        let url_ = this.baseUrl + "/api/2/user/a11y/personal-settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetA11yPersonalSettings(_response);
        });
    }

    protected processGetA11yPersonalSettings(response: Response): Promise<A11yPersonalSettingBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = A11yPersonalSettingBean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<A11yPersonalSettingBean>(null as any);
    }

    /**
     * Get validation for user anonymization
     * @param expand (optional) 
     * @param userKey (optional) 
     * @return Returned when validation succeeded.
     */
    validateUserAnonymization(expand?: string | undefined, userKey?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/user/anonymization?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (userKey === null)
            throw new Error("The parameter 'userKey' cannot be null.");
        else if (userKey !== undefined)
            url_ += "userKey=" + encodeURIComponent("" + userKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateUserAnonymization(_response);
        });
    }

    protected processValidateUserAnonymization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if a mandatory parameter was not provided or validation failed.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the logged-in user cannot anonymize users.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Schedule user anonymization
     * @param body JSON containing parameters to schedule the anonymization process with
     * @return Returned if the process was scheduled. Note that it can still fail the extended validation once its execution starts.
     */
    scheduleUserAnonymization(body: UserAnonymizationRequestBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/user/anonymization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processScheduleUserAnonymization(_response);
        });
    }

    protected processScheduleUserAnonymization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if a mandatory parameter was not provided.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the logged-in user cannot anonymize users.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("Returned if another user anonymization process is already in progress.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get validation for user anonymization rerun
     * @param expand (optional) 
     * @param oldUserKey (optional) 
     * @param oldUserName (optional) 
     * @param userKey (optional) 
     * @return Returned when validation succeeded.
     */
    validateUserAnonymizationRerun(expand?: string | undefined, oldUserKey?: string | undefined, oldUserName?: string | undefined, userKey?: string | undefined): Promise<UserAnonymizationValidationBean> {
        let url_ = this.baseUrl + "/api/2/user/anonymization/rerun?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (oldUserKey === null)
            throw new Error("The parameter 'oldUserKey' cannot be null.");
        else if (oldUserKey !== undefined)
            url_ += "oldUserKey=" + encodeURIComponent("" + oldUserKey) + "&";
        if (oldUserName === null)
            throw new Error("The parameter 'oldUserName' cannot be null.");
        else if (oldUserName !== undefined)
            url_ += "oldUserName=" + encodeURIComponent("" + oldUserName) + "&";
        if (userKey === null)
            throw new Error("The parameter 'userKey' cannot be null.");
        else if (userKey !== undefined)
            url_ += "userKey=" + encodeURIComponent("" + userKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateUserAnonymizationRerun(_response);
        });
    }

    protected processValidateUserAnonymizationRerun(response: Response): Promise<UserAnonymizationValidationBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAnonymizationValidationBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if a mandatory parameter was not provided or validation failed.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the logged-in user cannot anonymize users.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserAnonymizationValidationBean>(null as any);
    }

    /**
     * Schedule user anonymization rerun
     * @param body JSON containing parameters to schedule the anonymization process with
     * @return Returned if the process was scheduled. Note that it can still fail the extended validation once its execution starts.
     */
    scheduleUserAnonymizationRerun(body: UserAnonymizationRerunRequestBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/user/anonymization/rerun";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processScheduleUserAnonymizationRerun(_response);
        });
    }

    protected processScheduleUserAnonymizationRerun(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if a mandatory parameter was not provided.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the logged-in user cannot anonymize users.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("Returned if another user anonymization process is already in progress.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete stale user anonymization task
     * @return Returned when anonymization task has been successfully removed.
     */
    unlockAnonymization(): Promise<void> {
        let url_ = this.baseUrl + "/api/2/user/anonymization/unlock";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnlockAnonymization(_response);
        });
    }

    protected processUnlockAnonymization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if called when Jira is running in a non-clustered mode.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the logged-in user cannot remove anonymization tasks.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user anonymization task found.", status, _responseText, _headers);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the node executing the anonymization is still running.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Find bulk assignable users
     * @param maxResults (optional) 
     * @param projectKeys (optional) 
     * @param username (optional) 
     * @return Returns a list of users that match the search string.
     */
    findBulkAssignableUsers(maxResults?: number | undefined, projectKeys?: string | undefined, username?: string | undefined): Promise<UserBean> {
        let url_ = this.baseUrl + "/api/2/user/assignable/multiProjectSearch?";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (projectKeys === null)
            throw new Error("The parameter 'projectKeys' cannot be null.");
        else if (projectKeys !== undefined)
            url_ += "projectKeys=" + encodeURIComponent("" + projectKeys) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindBulkAssignableUsers(_response);
        });
    }

    protected processFindBulkAssignableUsers(response: Response): Promise<UserBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user has no permission to browse project.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested user is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserBean>(null as any);
    }

    /**
     * Get default columns for user
     * @param username (optional) 
     * @return Returns a list of columns for configured for the given user
     */
    defaultColumns(username?: string | undefined): Promise<ColumnOptions> {
        let url_ = this.baseUrl + "/api/2/user/columns?";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDefaultColumns(_response);
        });
    }

    protected processDefaultColumns(response: Response): Promise<ColumnOptions> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ColumnOptions.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not permitted to request the columns for the given user.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested user is not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while retrieving the column configuration.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ColumnOptions>(null as any);
    }

    /**
     * Set default columns for user
     * @param body (optional) 
     * @return Returned when the columns is saved successfully
     */
    setColumnsUrlEncoded(body?: Body3 | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/user/columns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = Object.keys(body as any).map((key) => {
            return encodeURIComponent(key) + '=' + encodeURIComponent((body as any)[key]);
        }).join('&')

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetColumnsUrlEncoded(_response);
        });
    }

    protected processSetColumnsUrlEncoded(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while retrieving the column configuration.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Reset default columns to system default
     * @param username (optional) 
     * @return Returned when the columns are reset successfully
     */
    resetColumns(username?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/user/columns?";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetColumns(_response);
        });
    }

    protected processResetColumns(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not permitted to request the columns for the given user.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while resetting the column configuration.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get duplicated users count
     * @param flush (optional) 
     * @return Returns a list of users that match the search string.
     */
    getDuplicatedUsersCount(flush?: boolean | undefined): Promise<UserBean> {
        let url_ = this.baseUrl + "/api/2/user/duplicated/count?";
        if (flush === null)
            throw new Error("The parameter 'flush' cannot be null.");
        else if (flush !== undefined)
            url_ += "flush=" + encodeURIComponent("" + flush) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDuplicatedUsersCount(_response);
        });
    }

    protected processGetDuplicatedUsersCount(response: Response): Promise<UserBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested user is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserBean>(null as any);
    }

    /**
     * Get duplicated users mapping
     * @param flush (optional) 
     * @return Returns all avatars which are visible for the currently logged in user.
     */
    getDuplicatedUsersMapping(flush?: boolean | undefined): Promise<AvatarBean> {
        let url_ = this.baseUrl + "/api/2/user/duplicated/list?";
        if (flush === null)
            throw new Error("The parameter 'flush' cannot be null.");
        else if (flush !== undefined)
            url_ += "flush=" + encodeURIComponent("" + flush) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDuplicatedUsersMapping(_response);
        });
    }

    protected processGetDuplicatedUsersMapping(response: Response): Promise<AvatarBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AvatarBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user is not an admin.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested user is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvatarBean>(null as any);
    }

    /**
     * Update user password
     * @param body Password details
     * @param key (optional) 
     * @param username (optional) 
     * @return Returned if the user exists and the caller has permission to edit it.
     */
    changeUserPassword(body: PasswordBean, key?: string | undefined, username?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/user/password?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeUserPassword(_response);
        });
    }

    protected processChangeUserPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller does not have permission to change the user password.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller does have permission to change user password but the user does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Find users with all specified permissions
     * @param projectKey (optional) 
     * @param issueKey (optional) 
     * @param maxResults (optional) 
     * @param permissions (optional) 
     * @param startAt (optional) 
     * @param username (optional) 
     * @return Returns a list of users that match the search string.
     * @deprecated
     */
    findUsersWithAllPermissions(projectKey?: string | undefined, issueKey?: string | undefined, maxResults?: number | undefined, permissions?: string | undefined, startAt?: number | undefined, username?: string | undefined): Promise<UserBean> {
        let url_ = this.baseUrl + "/api/2/user/permission/search?";
        if (projectKey === null)
            throw new Error("The parameter 'projectKey' cannot be null.");
        else if (projectKey !== undefined)
            url_ += "projectKey=" + encodeURIComponent("" + projectKey) + "&";
        if (issueKey === null)
            throw new Error("The parameter 'issueKey' cannot be null.");
        else if (issueKey !== undefined)
            url_ += "issueKey=" + encodeURIComponent("" + issueKey) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (permissions === null)
            throw new Error("The parameter 'permissions' cannot be null.");
        else if (permissions !== undefined)
            url_ += "permissions=" + encodeURIComponent("" + permissions) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindUsersWithAllPermissions(_response);
        });
    }

    protected processFindUsersWithAllPermissions(response: Response): Promise<UserBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if no project or issue key was provided or when permissions list is empty or contains an invalid entry", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user does not have admin rights for the project.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested issue or project is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserBean>(null as any);
    }

    /**
     * Find users for picker by query
     * @param maxResults (optional) 
     * @param query (optional) 
     * @param exclude (optional) 
     * @param showAvatar (optional) 
     * @return Returns a list of users matching query with highlighting.
     */
    findUsersForPicker(maxResults?: number | undefined, query?: string | undefined, exclude?: string[] | undefined, showAvatar?: boolean | undefined): Promise<UserPickerResultsBean> {
        let url_ = this.baseUrl + "/api/2/user/picker?";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (exclude === null)
            throw new Error("The parameter 'exclude' cannot be null.");
        else if (exclude !== undefined)
            exclude && exclude.forEach(item => { url_ += "exclude=" + encodeURIComponent("" + item) + "&"; });
        if (showAvatar === null)
            throw new Error("The parameter 'showAvatar' cannot be null.");
        else if (showAvatar !== undefined)
            url_ += "showAvatar=" + encodeURIComponent("" + showAvatar) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindUsersForPicker(_response);
        });
    }

    protected processFindUsersForPicker(response: Response): Promise<UserPickerResultsBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserPickerResultsBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested user is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserPickerResultsBean>(null as any);
    }

    /**
     * Find users by username
     * @param includeInactive (optional) 
     * @param maxResults (optional) 
     * @param includeActive (optional) 
     * @param startAt (optional) 
     * @param username (optional) 
     * @return Returns a list of users.
     */
    findUsers(includeInactive?: boolean | undefined, maxResults?: number | undefined, includeActive?: boolean | undefined, startAt?: number | undefined, username?: string | undefined): Promise<UserBean> {
        let url_ = this.baseUrl + "/api/2/user/search?";
        if (includeInactive === null)
            throw new Error("The parameter 'includeInactive' cannot be null.");
        else if (includeInactive !== undefined)
            url_ += "includeInactive=" + encodeURIComponent("" + includeInactive) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (includeActive === null)
            throw new Error("The parameter 'includeActive' cannot be null.");
        else if (includeActive !== undefined)
            url_ += "includeActive=" + encodeURIComponent("" + includeActive) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindUsers(_response);
        });
    }

    protected processFindUsers(response: Response): Promise<UserBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an invalid parameter value was provided with more details in the response body.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested user is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserBean>(null as any);
    }

    /**
     * Delete user session
     * @param username a String containing username.
     * @return Returned when the session is invalidated successfully.
     */
    deleteSession(username: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/user/session/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSession(_response);
        });
    }

    protected processDeleteSession(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not have admin permission.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the username does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Find users with browse permission
     * @param projectKey (optional) 
     * @param issueKey (optional) 
     * @param maxResults (optional) 
     * @param username (optional) 
     * @return Returns a list of users that match the search string.
     */
    findUsersWithBrowsePermission(projectKey?: string | undefined, issueKey?: string | undefined, maxResults?: number | undefined, username?: string | undefined): Promise<UserBean> {
        let url_ = this.baseUrl + "/api/2/user/viewissue/search?";
        if (projectKey === null)
            throw new Error("The parameter 'projectKey' cannot be null.");
        else if (projectKey !== undefined)
            url_ += "projectKey=" + encodeURIComponent("" + projectKey) + "&";
        if (issueKey === null)
            throw new Error("The parameter 'issueKey' cannot be null.");
        else if (issueKey !== undefined)
            url_ += "issueKey=" + encodeURIComponent("" + issueKey) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindUsersWithBrowsePermission(_response);
        });
    }

    protected processFindUsersWithBrowsePermission(response: Response): Promise<UserBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if no project or issue key was provided", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested issue or project is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserBean>(null as any);
    }

    /**
     * Get paginated versions
     * @param maxResults (optional) 
     * @param query (optional) 
     * @param projectIds (optional) 
     * @param startAt (optional) 
     * @return Returned if the versions are successfully retrieved.
     */
    getPaginatedVersions(maxResults?: number | undefined, query?: string | undefined, projectIds?: number[] | undefined, startAt?: number | undefined): Promise<VersionBean> {
        let url_ = this.baseUrl + "/api/2/version?";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (projectIds === null)
            throw new Error("The parameter 'projectIds' cannot be null.");
        else if (projectIds !== undefined)
            projectIds && projectIds.forEach(item => { url_ += "projectIds=" + encodeURIComponent("" + item) + "&"; });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaginatedVersions(_response);
        });
    }

    protected processGetPaginatedVersions(response: Response): Promise<VersionBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VersionBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to view the versions.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionBean>(null as any);
    }

    /**
     * Create new version
     * @param body JSON containing parameters to create the version with
     * @return Returned if the version is successfully created.
     */
    createVersion(body: VersionBean): Promise<VersionBean> {
        let url_ = this.baseUrl + "/api/2/version";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateVersion(_response);
        });
    }

    protected processCreateVersion(response: Response): Promise<VersionBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = VersionBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the version could not be created.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to edit the version.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionBean>(null as any);
    }

    /**
     * Get remote version links by global ID
     * @param globalId (optional) 
     * @return Returned if the remote version links are successfully retrieved.
     */
    getRemoteVersionLinks(globalId?: string | undefined): Promise<RemoteEntityLinksJsonBean> {
        let url_ = this.baseUrl + "/api/2/version/remotelink?";
        if (globalId === null)
            throw new Error("The parameter 'globalId' cannot be null.");
        else if (globalId !== undefined)
            url_ += "globalId=" + encodeURIComponent("" + globalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRemoteVersionLinks(_response);
        });
    }

    protected processGetRemoteVersionLinks(response: Response): Promise<RemoteEntityLinksJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RemoteEntityLinksJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the remote version links could not be retrieved.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RemoteEntityLinksJsonBean>(null as any);
    }

    /**
     * Get version details
     * @param expand (optional) 
     * @return Returned if the version was found.
     */
    getVersion(id: string, expand?: string | undefined): Promise<VersionBean> {
        let url_ = this.baseUrl + "/api/2/version/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVersion(_response);
        });
    }

    protected processGetVersion(response: Response): Promise<VersionBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VersionBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the version does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionBean>(null as any);
    }

    /**
     * Update version details
     * @param body JSON containing parameters to update the version with
     * @return Returned if the version is successfully updated.
     */
    updateVersion(id: string, body: VersionBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/version/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateVersion(_response);
        });
    }

    protected processUpdateVersion(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to edit the version.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the version does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Merge versions
     * @return Returned if the version is successfully deleted.
     */
    merge(moveIssuesTo: string, id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/version/{id}/mergeto/{moveIssuesTo}";
        if (moveIssuesTo === undefined || moveIssuesTo === null)
            throw new Error("The parameter 'moveIssuesTo' must be defined.");
        url_ = url_.replace("{moveIssuesTo}", encodeURIComponent("" + moveIssuesTo));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMerge(_response);
        });
    }

    protected processMerge(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to delete the version.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the version does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Modify version's sequence
     * @param body JSON containing parameters to move the version with
     * @return Returned if the version is successfully moved.
     */
    moveVersion(id: string, body: VersionMoveBean): Promise<VersionBean> {
        let url_ = this.baseUrl + "/api/2/version/{id}/move";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMoveVersion(_response);
        });
    }

    protected processMoveVersion(response: Response): Promise<VersionBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VersionBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to move the version.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the version does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionBean>(null as any);
    }

    /**
     * Get version related issues count
     * @return Returned if the version exists and the currently authenticated user has permission to view it.
     */
    getVersionRelatedIssues(id: string): Promise<VersionIssueCountsBean> {
        let url_ = this.baseUrl + "/api/2/version/{id}/relatedIssueCounts";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVersionRelatedIssues(_response);
        });
    }

    protected processGetVersionRelatedIssues(response: Response): Promise<VersionIssueCountsBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VersionIssueCountsBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the version does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionIssueCountsBean>(null as any);
    }

    /**
     * Get version unresolved issues count
     * @return Returned if the version exists and the currently authenticated user has permission to view it.
     */
    getVersionUnresolvedIssues(id: string): Promise<VersionUnresolvedIssueCountsBean> {
        let url_ = this.baseUrl + "/api/2/version/{id}/unresolvedIssueCount";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVersionUnresolvedIssues(_response);
        });
    }

    protected processGetVersionUnresolvedIssues(response: Response): Promise<VersionUnresolvedIssueCountsBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VersionUnresolvedIssueCountsBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the version does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VersionUnresolvedIssueCountsBean>(null as any);
    }

    /**
     * Get remote version links by version ID
     * @return Returned if the version exists and the currently authenticated user has permission to view it.
     */
    getRemoteVersionLinksByVersionId(versionId: string): Promise<RemoteEntityLinksJsonBean> {
        let url_ = this.baseUrl + "/api/2/version/{versionId}/remotelink";
        if (versionId === undefined || versionId === null)
            throw new Error("The parameter 'versionId' must be defined.");
        url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRemoteVersionLinksByVersionId(_response);
        });
    }

    protected processGetRemoteVersionLinksByVersionId(response: Response): Promise<RemoteEntityLinksJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RemoteEntityLinksJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the version does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RemoteEntityLinksJsonBean>(null as any);
    }

    /**
     * Create or update remote version link without global ID
     * @param body JSON containing parameters to create the remote version link with
     * @return Returned if the remote version link is created or updated successfully.
     */
    createOrUpdateRemoteVersionLink(versionId: string, body: RemoteEntityLinkJsonBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/version/{versionId}/remotelink";
        if (versionId === undefined || versionId === null)
            throw new Error("The parameter 'versionId' must be defined.");
        url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrUpdateRemoteVersionLink(_response);
        });
    }

    protected processCreateOrUpdateRemoteVersionLink(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the JSON payload is empty or malformed", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to edit the version.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the version does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete all remote version links for version
     * @return Returned if the remote version links are successfully deleted.
     */
    deleteRemoteVersionLinksByVersionId(versionId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/version/{versionId}/remotelink";
        if (versionId === undefined || versionId === null)
            throw new Error("The parameter 'versionId' must be defined.");
        url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRemoteVersionLinksByVersionId(_response);
        });
    }

    protected processDeleteRemoteVersionLinksByVersionId(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to delete the remote version links.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the version does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get specific remote version link
     * @return Returned if the version exists and the currently authenticated user has permission to view it.
     */
    getRemoteVersionLink(versionId: string, globalId: string): Promise<RemoteEntityLinkJsonBean> {
        let url_ = this.baseUrl + "/api/2/version/{versionId}/remotelink/{globalId}";
        if (versionId === undefined || versionId === null)
            throw new Error("The parameter 'versionId' must be defined.");
        url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
        if (globalId === undefined || globalId === null)
            throw new Error("The parameter 'globalId' must be defined.");
        url_ = url_.replace("{globalId}", encodeURIComponent("" + globalId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRemoteVersionLink(_response);
        });
    }

    protected processGetRemoteVersionLink(response: Response): Promise<RemoteEntityLinkJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RemoteEntityLinkJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the version does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RemoteEntityLinkJsonBean>(null as any);
    }

    /**
     * Delete specific remote version link
     * @return Returned if the remote version link is successfully deleted.
     */
    deleteRemoteVersionLink(versionId: string, globalId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/version/{versionId}/remotelink/{globalId}";
        if (versionId === undefined || versionId === null)
            throw new Error("The parameter 'versionId' must be defined.");
        url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
        if (globalId === undefined || globalId === null)
            throw new Error("The parameter 'globalId' must be defined.");
        url_ = url_.replace("{globalId}", encodeURIComponent("" + globalId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRemoteVersionLink(_response);
        });
    }

    protected processDeleteRemoteVersionLink(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to delete the remote version link.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the version does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all workflows
     * @param workflowName (optional) an optional String containing workflow name. If not passed then all workflows are returned
     * @return Returned if the currently authenticated user has administration permission. Contains a full representation of every workflow.
     */
    getAllWorkflows(workflowName?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/workflow?";
        if (workflowName === null)
            throw new Error("The parameter 'workflowName' cannot be null.");
        else if (workflowName !== undefined)
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllWorkflows(_response);
        });
    }

    protected processGetAllWorkflows(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have administration permission.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create a new workflow scheme
     * @param body The body contains a representation of the new scheme. Values not passed are assumed to be set to their defaults.
     * @return The newly created scheme.
     */
    createScheme(body: WorkflowSchemeBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/workflowscheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateScheme(_response);
        });
    }

    protected processCreateScheme(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get requested workflow scheme by ID
     * @param returnDraftIfExists (optional) 
     * @return Returned if the scheme exists and the caller has permission to see it.
     */
    getById(id: number, returnDraftIfExists?: boolean | undefined): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (returnDraftIfExists === null)
            throw new Error("The parameter 'returnDraftIfExists' cannot be null.");
        else if (returnDraftIfExists !== undefined)
            url_ += "returnDraftIfExists=" + encodeURIComponent("" + returnDraftIfExists) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Update a specified workflow scheme
     * @param body The body of the request is a representation of the workflow scheme. Values not passed are assumed to indicate no change for that field.
     * @return The updated scheme.
     */
    update(id: number, body: WorkflowSchemeBean): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Delete the specified workflow scheme
     * @return If the scheme was deleted.
     */
    deleteScheme(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteScheme(_response);
        });
    }

    protected processDeleteScheme(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested scheme is active (i.e. being used by Jira).", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create a draft for a workflow scheme
     * @return The newly created scheme.
     */
    createDraftForParent(id: number): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/createdraft";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDraftForParent(_response);
        });
    }

    protected processCreateDraftForParent(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = WorkflowSchemeBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Get default workflow for a scheme
     * @param returnDraftIfExists (optional) 
     * @return Returned on success.
     */
    getDefault(id: number, returnDraftIfExists?: boolean | undefined): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/default?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (returnDraftIfExists === null)
            throw new Error("The parameter 'returnDraftIfExists' cannot be null.");
        else if (returnDraftIfExists !== undefined)
            url_ += "returnDraftIfExists=" + encodeURIComponent("" + returnDraftIfExists) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDefault(_response);
        });
    }

    protected processGetDefault(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the workflow scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Update default workflow for a scheme
     * @param body The new default.
     * @return Returned on success.
     */
    updateDefault(id: number, body: DefaultBean): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/default";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDefault(_response);
        });
    }

    protected processUpdateDefault(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Remove default workflow from a scheme
     * @param updateDraftIfNeeded (optional) 
     * @return Returned on success.
     */
    deleteDefault(id: number, updateDraftIfNeeded?: boolean | undefined): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/default?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (updateDraftIfNeeded === null)
            throw new Error("The parameter 'updateDraftIfNeeded' cannot be null.");
        else if (updateDraftIfNeeded !== undefined)
            url_ += "updateDraftIfNeeded=" + encodeURIComponent("" + updateDraftIfNeeded) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDefault(_response);
        });
    }

    protected processDeleteDefault(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Get requested draft workflow scheme by ID
     * @return Returned if the scheme exists and the caller has permission to see it.
     */
    getDraftById(id: number): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/draft";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDraftById(_response);
        });
    }

    protected processGetDraftById(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested draft scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Update a draft workflow scheme
     * @param body The body of the request is a representation of the workflow scheme. Values not passed are assumed to indicate no change for that field.
     * @return The updated/created scheme.
     */
    updateDraft(id: number, body: WorkflowSchemeBean): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/draft";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDraft(_response);
        });
    }

    protected processUpdateDraft(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Delete the specified draft workflow scheme
     * @return If the scheme was deleted.
     */
    deleteDraftById(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/draft";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDraftById(_response);
        });
    }

    protected processDeleteDraftById(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested draft scheme or parent scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get default workflow for a draft scheme
     * @return Returned on success.
     */
    getDraftDefault(id: number): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/draft/default";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDraftDefault(_response);
        });
    }

    protected processGetDraftDefault(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the workflow scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Update default workflow for a draft scheme
     * @param body The new default.
     * @return Returned on success.
     */
    updateDraftDefault(id: number, body: DefaultBean): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/draft/default";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDraftDefault(_response);
        });
    }

    protected processUpdateDraftDefault(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Remove default workflow from a draft scheme
     * @return Returned on success.
     */
    deleteDraftDefault(id: number): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/draft/default";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDraftDefault(_response);
        });
    }

    protected processDeleteDraftDefault(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the scheme does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Get issue type mapping for a draft scheme
     * @return Returned on success.
     */
    getDraftIssueType(issueType: string, id: number): Promise<IssueTypeMappingBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/draft/issuetype/{issueType}";
        if (issueType === undefined || issueType === null)
            throw new Error("The parameter 'issueType' must be defined.");
        url_ = url_.replace("{issueType}", encodeURIComponent("" + issueType));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDraftIssueType(_response);
        });
    }

    protected processGetDraftIssueType(response: Response): Promise<IssueTypeMappingBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueTypeMappingBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if either the requested scheme or issue type does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueTypeMappingBean>(null as any);
    }

    /**
     * Set an issue type mapping for a draft scheme
     * @param body The new mapping for the issue type.
     * @return Returned on success.
     */
    setDraftIssueType(issueType: string, id: number, body: IssueTypeMappingBean): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/draft/issuetype/{issueType}";
        if (issueType === undefined || issueType === null)
            throw new Error("The parameter 'issueType' must be defined.");
        url_ = url_.replace("{issueType}", encodeURIComponent("" + issueType));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetDraftIssueType(_response);
        });
    }

    protected processSetDraftIssueType(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if either the requested scheme or issue type does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Delete an issue type mapping from a draft scheme
     * @return Returned on success.
     */
    deleteDraftIssueType(issueType: string, id: number): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/draft/issuetype/{issueType}";
        if (issueType === undefined || issueType === null)
            throw new Error("The parameter 'issueType' must be defined.");
        url_ = url_.replace("{issueType}", encodeURIComponent("" + issueType));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDraftIssueType(_response);
        });
    }

    protected processDeleteDraftIssueType(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if either the requested scheme or issue type does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Get draft workflow mappings
     * @param workflowName (optional) 
     * @return Returned on success.
     */
    getDraftWorkflow(id: number, workflowName?: string | undefined): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/draft/workflow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (workflowName === null)
            throw new Error("The parameter 'workflowName' cannot be null.");
        else if (workflowName !== undefined)
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDraftWorkflow(_response);
        });
    }

    protected processGetDraftWorkflow(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if either the requested scheme or workflow does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Update a workflow mapping in a draft scheme
     * @param body The body is a representation of the workflow mapping. Values not passed are assumed to indicate no change for that field.
     * @param workflowName (optional) 
     * @return The updated scheme.
     */
    updateDraftWorkflowMapping(id: number, body: WorkflowMappingBean, workflowName?: string | undefined): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/draft/workflow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (workflowName === null)
            throw new Error("The parameter 'workflowName' cannot be null.");
        else if (workflowName !== undefined)
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDraftWorkflowMapping(_response);
        });
    }

    protected processUpdateDraftWorkflowMapping(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Delete a workflow mapping from a draft scheme
     * @param workflowName (optional) 
     * @return The scheme with the workflow deleted.
     */
    deleteDraftWorkflowMapping(id: number, workflowName?: string | undefined): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/draft/workflow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (workflowName === null)
            throw new Error("The parameter 'workflowName' cannot be null.");
        else if (workflowName !== undefined)
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDraftWorkflowMapping(_response);
        });
    }

    protected processDeleteDraftWorkflowMapping(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested scheme or workflow does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Get issue type mapping for a scheme
     * @param returnDraftIfExists (optional) 
     * @return Returned on success.
     */
    getIssueType(issueType: string, id: number, returnDraftIfExists?: boolean | undefined): Promise<IssueTypeMappingBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/issuetype/{issueType}?";
        if (issueType === undefined || issueType === null)
            throw new Error("The parameter 'issueType' must be defined.");
        url_ = url_.replace("{issueType}", encodeURIComponent("" + issueType));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (returnDraftIfExists === null)
            throw new Error("The parameter 'returnDraftIfExists' cannot be null.");
        else if (returnDraftIfExists !== undefined)
            url_ += "returnDraftIfExists=" + encodeURIComponent("" + returnDraftIfExists) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIssueType(_response);
        });
    }

    protected processGetIssueType(response: Response): Promise<IssueTypeMappingBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueTypeMappingBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if either the requested scheme or issue type does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueTypeMappingBean>(null as any);
    }

    /**
     * Set an issue type mapping for a scheme
     * @param body The new mapping for the issue type.
     * @return Returned on success.
     */
    setIssueType(issueType: string, id: number, body: IssueTypeMappingBean): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/issuetype/{issueType}";
        if (issueType === undefined || issueType === null)
            throw new Error("The parameter 'issueType' must be defined.");
        url_ = url_.replace("{issueType}", encodeURIComponent("" + issueType));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetIssueType(_response);
        });
    }

    protected processSetIssueType(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if either the requested scheme or issue type does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Delete an issue type mapping from a scheme
     * @param updateDraftIfNeeded (optional) 
     * @return Returned on success.
     */
    deleteIssueType(issueType: string, id: number, updateDraftIfNeeded?: boolean | undefined): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/issuetype/{issueType}?";
        if (issueType === undefined || issueType === null)
            throw new Error("The parameter 'issueType' must be defined.");
        url_ = url_.replace("{issueType}", encodeURIComponent("" + issueType));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (updateDraftIfNeeded === null)
            throw new Error("The parameter 'updateDraftIfNeeded' cannot be null.");
        else if (updateDraftIfNeeded !== undefined)
            url_ += "updateDraftIfNeeded=" + encodeURIComponent("" + updateDraftIfNeeded) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteIssueType(_response);
        });
    }

    protected processDeleteIssueType(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if either the requested scheme or issue type does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Get workflow mappings for a scheme
     * @param workflowName (optional) 
     * @param returnDraftIfExists (optional) 
     * @return Returned on success.
     */
    getWorkflow(id: number, workflowName?: string | undefined, returnDraftIfExists?: boolean | undefined): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/workflow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (workflowName === null)
            throw new Error("The parameter 'workflowName' cannot be null.");
        else if (workflowName !== undefined)
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        if (returnDraftIfExists === null)
            throw new Error("The parameter 'returnDraftIfExists' cannot be null.");
        else if (returnDraftIfExists !== undefined)
            url_ += "returnDraftIfExists=" + encodeURIComponent("" + returnDraftIfExists) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkflow(_response);
        });
    }

    protected processGetWorkflow(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if either the requested scheme or workflow does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Update a workflow mapping in a scheme
     * @param body The body is a representation of the workflow mapping. Values not passed are assumed to indicate no change for that field.
     * @param workflowName (optional) 
     * @return The updated scheme.
     */
    updateWorkflowMapping(id: number, body: WorkflowMappingBean, workflowName?: string | undefined): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/workflow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (workflowName === null)
            throw new Error("The parameter 'workflowName' cannot be null.");
        else if (workflowName !== undefined)
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateWorkflowMapping(_response);
        });
    }

    protected processUpdateWorkflowMapping(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Delete a workflow mapping from a scheme
     * @param updateDraftIfNeeded (optional) 
     * @param workflowName (optional) 
     * @return The scheme with the workflow deleted.
     */
    deleteWorkflowMapping(id: number, updateDraftIfNeeded?: boolean | undefined, workflowName?: string | undefined): Promise<WorkflowSchemeBean> {
        let url_ = this.baseUrl + "/api/2/workflowscheme/{id}/workflow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (updateDraftIfNeeded === null)
            throw new Error("The parameter 'updateDraftIfNeeded' cannot be null.");
        else if (updateDraftIfNeeded !== undefined)
            url_ += "updateDraftIfNeeded=" + encodeURIComponent("" + updateDraftIfNeeded) + "&";
        if (workflowName === null)
            throw new Error("The parameter 'workflowName' cannot be null.");
        else if (workflowName !== undefined)
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteWorkflowMapping(_response);
        });
    }

    protected processDeleteWorkflowMapping(response: Response): Promise<WorkflowSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user or if the user has not entered a websudo session.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested scheme or workflow does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkflowSchemeBean>(null as any);
    }

    /**
     * Returns worklogs deleted since given time.
     * @param since (optional) 
     * @return Returns a JSON representation of the worklog changes.
     */
    getIdsOfWorklogsDeletedSince(since?: number | undefined): Promise<WorklogChangedSinceBean> {
        let url_ = this.baseUrl + "/api/2/worklog/deleted?";
        if (since === null)
            throw new Error("The parameter 'since' cannot be null.");
        else if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIdsOfWorklogsDeletedSince(_response);
        });
    }

    protected processGetIdsOfWorklogsDeletedSince(response: Response): Promise<WorklogChangedSinceBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorklogChangedSinceBean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorklogChangedSinceBean>(null as any);
    }

    /**
     * Returns worklogs for given ids.
     * @param body a JSON object containing ids of worklogs to return
     * @return Returns a JSON representation of the worklogs.
     */
    getWorklogsForIds(body: WorklogIdsRequestBean): Promise<Worklog> {
        let url_ = this.baseUrl + "/api/2/worklog/list";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorklogsForIds(_response);
        });
    }

    protected processGetWorklogsForIds(response: Response): Promise<Worklog> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Worklog.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request contains more than 1000 ids or is null", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Worklog>(null as any);
    }

    /**
     * Returns worklogs updated since given time.
     * @param since (optional) 
     * @return Returns a JSON representation of the worklog changes.
     */
    getIdsOfWorklogsModifiedSince(since?: number | undefined): Promise<WorklogChangedSinceBean> {
        let url_ = this.baseUrl + "/api/2/worklog/updated?";
        if (since === null)
            throw new Error("The parameter 'since' cannot be null.");
        else if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetIdsOfWorklogsModifiedSince(_response);
        });
    }

    protected processGetIdsOfWorklogsModifiedSince(response: Response): Promise<WorklogChangedSinceBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorklogChangedSinceBean.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorklogChangedSinceBean>(null as any);
    }

    /**
     * Get current user session information
     * @return Returned if the currently authenticated user is returned.
     */
    currentUser(): Promise<CurrentUser> {
        let url_ = this.baseUrl + "/auth/1/session";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrentUser(_response);
        });
    }

    protected processCurrentUser(response: Response): Promise<CurrentUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentUser.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user is not returned.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CurrentUser>(null as any);
    }

    /**
     * Create new user session
     * @param body the username and password to authenticate
     * @return Returned if the caller is authenticated. Contains information about the caller's session.
     */
    login(body: AuthParams): Promise<AuthSuccess> {
        let url_ = this.baseUrl + "/auth/1/session";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<AuthSuccess> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthSuccess.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the login fails due to invalid credentials.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the login is denied due to a CAPTCHA requirement, throtting, or any other reason. In case of a 403 status code it is possible that the supplied credentials are valid but the user is not allowed to log in at this point in time.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthSuccess>(null as any);
    }

    /**
     * Delete current user session
     * @return Returned if the user was successfully logged out.
     */
    logout(): Promise<void> {
        let url_ = this.baseUrl + "/auth/1/session";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller is not authenticated.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Invalidate the current WebSudo session
     * @param body (optional) No request body is needed
     * @return Returned if no error occurs
     */
    release(body?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/auth/1/websudo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRelease(_response);
        });
    }

    protected processRelease(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class GetIssuesWithoutEpicClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get issues without an epic
     * @param expand (optional) 
     * @param jql (optional) 
     * @param maxResults (optional) 
     * @param validateQuery (optional) 
     * @param fields (optional) 
     * @param startAt (optional) 
     * @return Returns the requested issues, at the specified page of the results.
     */
    1(expand?: string | undefined, jql?: string | undefined, maxResults?: number | undefined, validateQuery?: boolean | undefined, fields?: StringList[] | undefined, startAt?: number | undefined): Promise<SearchResultsBean> {
        let url_ = this.baseUrl + "/agile/1.0/epic/none/issue?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (jql === null)
            throw new Error("The parameter 'jql' cannot be null.");
        else if (jql !== undefined)
            url_ += "jql=" + encodeURIComponent("" + jql) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (validateQuery === null)
            throw new Error("The parameter 'validateQuery' cannot be null.");
        else if (validateQuery !== undefined)
            url_ += "validateQuery=" + encodeURIComponent("" + validateQuery) + "&";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "fields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<SearchResultsBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResultsBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchResultsBean>(null as any);
    }
}

export class GetIssuesForEpicClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get issues for a specific epic
     * @param expand (optional) 
     * @param jql (optional) 
     * @param maxResults (optional) 
     * @param validateQuery (optional) 
     * @param fields (optional) 
     * @param startAt (optional) 
     * @return Returns the requested issues, at the specified page of the results.
     */
    1(epicIdOrKey: string, expand?: string | undefined, jql?: string | undefined, maxResults?: number | undefined, validateQuery?: boolean | undefined, fields?: StringList[] | undefined, startAt?: number | undefined): Promise<SearchResultsBean> {
        let url_ = this.baseUrl + "/agile/1.0/epic/{epicIdOrKey}/issue?";
        if (epicIdOrKey === undefined || epicIdOrKey === null)
            throw new Error("The parameter 'epicIdOrKey' must be defined.");
        url_ = url_.replace("{epicIdOrKey}", encodeURIComponent("" + epicIdOrKey));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (jql === null)
            throw new Error("The parameter 'jql' cannot be null.");
        else if (jql !== undefined)
            url_ += "jql=" + encodeURIComponent("" + jql) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (validateQuery === null)
            throw new Error("The parameter 'validateQuery' cannot be null.");
        else if (validateQuery !== undefined)
            url_ += "validateQuery=" + encodeURIComponent("" + validateQuery) + "&";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "fields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<SearchResultsBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResultsBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the epic does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchResultsBean>(null as any);
    }
}

export class GetIssuesForSprintClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get all issues in a sprint
     * @param expand (optional) 
     * @param jql (optional) 
     * @param maxResults (optional) 
     * @param validateQuery (optional) 
     * @param fields (optional) 
     * @param startAt (optional) 
     * @return Returns the requested issues, at the specified page of the results.
     */
    1(sprintId: number, expand?: string | undefined, jql?: string | undefined, maxResults?: number | undefined, validateQuery?: boolean | undefined, fields?: StringList[] | undefined, startAt?: number | undefined): Promise<SearchResultsBean> {
        let url_ = this.baseUrl + "/agile/1.0/sprint/{sprintId}/issue?";
        if (sprintId === undefined || sprintId === null)
            throw new Error("The parameter 'sprintId' must be defined.");
        url_ = url_.replace("{sprintId}", encodeURIComponent("" + sprintId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (jql === null)
            throw new Error("The parameter 'jql' cannot be null.");
        else if (jql !== undefined)
            url_ += "jql=" + encodeURIComponent("" + jql) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (validateQuery === null)
            throw new Error("The parameter 'validateQuery' cannot be null.");
        else if (validateQuery !== undefined)
            url_ += "validateQuery=" + encodeURIComponent("" + validateQuery) + "&";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "fields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<SearchResultsBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResultsBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user does not a have valid license.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if sprint does not exist or the user cannot view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchResultsBean>(null as any);
    }
}

export class GetPropertiesKeysClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get all properties keys for a sprint
     * @return Returns the requested property keys.
     */
    1(sprintId: string): Promise<EntityPropertiesKeysBean> {
        let url_ = this.baseUrl + "/agile/1.0/sprint/{sprintId}/properties";
        if (sprintId === undefined || sprintId === null)
            throw new Error("The parameter 'sprintId' must be defined.");
        url_ = url_.replace("{sprintId}", encodeURIComponent("" + sprintId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<EntityPropertiesKeysBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityPropertiesKeysBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to view the sprint.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the sprint does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityPropertiesKeysBean>(null as any);
    }

    /**
     * Get properties keys of a comment
     * @param commentId the comment from which keys will be returned.
     * @return Returns a list of all properties in the comment.
     */
    12(commentId: string): Promise<EntityPropertiesKeysBean> {
        let url_ = this.baseUrl + "/api/2/comment/{commentId}/properties";
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process12(_response);
        });
    }

    protected process12(response: Response): Promise<EntityPropertiesKeysBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityPropertiesKeysBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the comment key or id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to browse the comment.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the comment with given key or id does not exist or if the property with given key is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityPropertiesKeysBean>(null as any);
    }

    /**
     * Get keys of all properties for an issue
     * @param issueIdOrKey Issue id or key
     * @return Returns a response containing EntityPropertiesKeysBean.
     */
    2(issueIdOrKey: string): Promise<EntityPropertiesKeysBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/properties";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process2(_response);
        });
    }

    protected process2(response: Response): Promise<EntityPropertiesKeysBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityPropertiesKeysBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue key or id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to view the issue.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue with given key or id does not exist or if the property with given key is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityPropertiesKeysBean>(null as any);
    }

    /**
     * Get keys of all properties for project
     * @return Returned if the project was found.
     */
    3(projectIdOrKey: string): Promise<EntityPropertiesKeysBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/properties";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process3(_response);
        });
    }

    protected process3(response: Response): Promise<EntityPropertiesKeysBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityPropertiesKeysBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project key or id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to browse the project.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project with given key or id does not exist or if the property with given key is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityPropertiesKeysBean>(null as any);
    }

    /**
     * Get keys of all properties for a user
     * @param userKey (optional) 
     * @param username (optional) 
     * @return Returned if the user was found.
     */
    4(userKey?: string | undefined, username?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/user/properties?";
        if (userKey === null)
            throw new Error("The parameter 'userKey' cannot be null.");
        else if (userKey !== undefined)
            url_ += "userKey=" + encodeURIComponent("" + userKey) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process4(_response);
        });
    }

    protected process4(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user key or id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to browse the user.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user with given key or id does not exist or if the property with given key is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class GetPropertyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get a property for a sprint
     * @return Returns the requested property.
     */
    1(propertyKey: string, sprintId: string): Promise<EntityPropertyBean> {
        let url_ = this.baseUrl + "/agile/1.0/sprint/{sprintId}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (sprintId === undefined || sprintId === null)
            throw new Error("The parameter 'sprintId' must be defined.");
        url_ = url_.replace("{sprintId}", encodeURIComponent("" + sprintId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<EntityPropertyBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityPropertyBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to view the sprint.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the sprint does not exist or the user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityPropertyBean>(null as any);
    }

    /**
     * Get a property from a comment
     * @param propertyKey the key of the property to return.
     * @param commentId the comment from which the property will be returned.
     * @return Returns the value of the property with a given key from the comment.
     */
    2(propertyKey: string, commentId: string): Promise<EntityPropertyBean> {
        let url_ = this.baseUrl + "/api/2/comment/{commentId}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process2(_response);
        });
    }

    protected process2(response: Response): Promise<EntityPropertyBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityPropertyBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the comment key or id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to browse the comment.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the comment with given key or id does not exist or if the property with given key is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityPropertyBean>(null as any);
    }

    /**
     * Get a property from a dashboard item
     * @param propertyKey The key of the property to return.
     * @param itemId The dashboard item from which the property will be returned.
     * @param dashboardId The dashboard id.
     * @return Returned if the dashboard item property was found.
     */
    12(propertyKey: string, itemId: string, dashboardId: string): Promise<EntityPropertyBean> {
        let url_ = this.baseUrl + "/api/2/dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process12(_response);
        });
    }

    protected process12(response: Response): Promise<EntityPropertyBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityPropertyBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the dashboard item id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the dashboard item with given id does not exist or user does not have permissions to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityPropertyBean>(null as any);
    }

    /**
     * Get the value of a specific property from an issue
     * @param propertyKey The key of the property to return
     * @param issueIdOrKey Issue id or key
     * @return Returned if the issue property was found.
     */
    3(propertyKey: string, issueIdOrKey: string): Promise<EntityPropertyBean> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process3(_response);
        });
    }

    protected process3(response: Response): Promise<EntityPropertyBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityPropertyBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue key or id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to view the issue.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue with given key or id does not exist or if the property with given key is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityPropertyBean>(null as any);
    }

    /**
     * Get value of specified issue type's property
     * @param propertyKey The key of the property to return.
     * @param issueTypeId The issue type from which the property will be returned.
     * @return Returns the value of the property with a given key from the issue type.
     */
    4(propertyKey: string, issueTypeId: string): Promise<EntityPropertyBean> {
        let url_ = this.baseUrl + "/api/2/issuetype/{issueTypeId}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (issueTypeId === undefined || issueTypeId === null)
            throw new Error("The parameter 'issueTypeId' must be defined.");
        url_ = url_.replace("{issueTypeId}", encodeURIComponent("" + issueTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process4(_response);
        });
    }

    protected process4(response: Response): Promise<EntityPropertyBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityPropertyBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type with given id does not exist or if the property with given key is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityPropertyBean>(null as any);
    }

    /**
     * Get value of property from project
     * @return Returned if the project property was found.
     */
    5(propertyKey: string, projectIdOrKey: string): Promise<EntityPropertyBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process5(_response);
        });
    }

    protected process5(response: Response): Promise<EntityPropertyBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityPropertyBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project key or id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to browse the project.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project with given key or id does not exist or if the property with given key is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntityPropertyBean>(null as any);
    }

    /**
     * Get the value of a specified user's property
     * @param userKey (optional) 
     * @param username (optional) 
     * @return Returned if the user property was found.
     */
    6(propertyKey: string, userKey?: string | undefined, username?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/user/properties/{propertyKey}?";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (userKey === null)
            throw new Error("The parameter 'userKey' cannot be null.");
        else if (userKey !== undefined)
            url_ += "userKey=" + encodeURIComponent("" + userKey) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process6(_response);
        });
    }

    protected process6(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user key or id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to browse the user.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user with given key or id does not exist or if the property with given key is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class SetPropertyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Update a sprint's property
     * @return Returned if the sprint property is successfully updated.
     */
    1(propertyKey: string, sprintId: string): Promise<void> {
        let url_ = this.baseUrl + "/agile/1.0/sprint/{sprintId}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (sprintId === undefined || sprintId === null)
            throw new Error("The parameter 'sprintId' must be defined.");
        url_ = url_.replace("{sprintId}", encodeURIComponent("" + sprintId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the sprintId is invalid (negative or not a number).", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to edit the sprint", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the sprint with given id does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Set a property on a comment
     * @param propertyKey the key of the comment's property. The maximum length of the key is 255 bytes.
     * @param commentId the comment on which the property will be set.
     * @param body (optional) the request containing value of the comment's property. The value has to be a valid, non-empty JSON conforming to http://tools.ietf.org/html/rfc4627. The maximum length of the property value is 32768 bytes.
     * @return Returned if the comment property is successfully updated.
     */
    12(propertyKey: string, commentId: string, body?: any | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/comment/{commentId}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process12(_response);
        });
    }

    protected process12(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the comment key or id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer the comment.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the comment with given key or id does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update the value of a specific issue's property
     * @param propertyKey The key of the issue's property
     * @param issueIdOrKey Issue id or key
     * @param body The value of the issue's property
     * @return Returned if the issue property is successfully updated.
     */
    2(propertyKey: string, issueIdOrKey: string, body: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process2(_response);
        });
    }

    protected process2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue key or id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to edit the issue.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue with given key or id does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Update specified issue type's property
     * @param propertyKey The key of the issue type's property. The maximum length of the key is 255 bytes
     * @param issueTypeId The issue type on which the property will be set.
     * @param body The value of the issue type's property. The value has to be a valid, non-empty JSON conforming to http://tools.ietf.org/html/rfc4627. The maximum length of the property value is 32768 bytes.
     * @return Returned if the issue type property is successfully updated.
     */
    3(propertyKey: string, issueTypeId: string, body: PropertyBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issuetype/{issueTypeId}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (issueTypeId === undefined || issueTypeId === null)
            throw new Error("The parameter 'issueTypeId' must be defined.");
        url_ = url_.replace("{issueTypeId}", encodeURIComponent("" + issueTypeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process3(_response);
        });
    }

    protected process3(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type with given id does not exist or if the user does not have permissions to edit this issue type.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Set value of specified project's property
     * @param body The request containing value of the project's property. The value has to be a valid, non-empty JSON conforming to http://tools.ietf.org/html/rfc4627. The maximum length of the property value is 32768 bytes.
     * @return Returned if the project property is successfully updated.
     */
    4(propertyKey: string, projectIdOrKey: string, body: PropertyBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process4(_response);
        });
    }

    protected process4(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project key or id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer the project.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project with given key or id does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Set the value of a specified user's property
     * @param userKey (optional) 
     * @param username (optional) 
     * @param body (optional) The request containing value of the user's property. The value has to be a valid, non-empty JSON conforming to http://tools.ietf.org/html/rfc4627. The maximum length of the property value is 32768 bytes.
     * @return Returned if the user property is successfully updated.
     */
    5(propertyKey: string, userKey?: string | undefined, username?: string | undefined, body?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/user/properties/{propertyKey}?";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (userKey === null)
            throw new Error("The parameter 'userKey' cannot be null.");
        else if (userKey !== undefined)
            url_ += "userKey=" + encodeURIComponent("" + userKey) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process5(_response);
        });
    }

    protected process5(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user key or id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer the user.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user with given key or id does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class DeletePropertyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Delete a sprint's property
     * @return Returned if the sprint property was removed successfully.
     */
    1(propertyKey: string, sprintId: string): Promise<void> {
        let url_ = this.baseUrl + "/agile/1.0/sprint/{sprintId}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (sprintId === undefined || sprintId === null)
            throw new Error("The parameter 'sprintId' must be defined.");
        url_ = url_.replace("{sprintId}", encodeURIComponent("" + sprintId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the sprintId is invalid (negative or not a number).", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to modify the sprint.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the sprint with given id does not exist or if the property with given key is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete a property from a comment
     * @param propertyKey the key of the property to remove.
     * @param commentId the comment from which the property will be removed.
     * @return Returned if the comment property was removed successfully.
     */
    2(propertyKey: string, commentId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/comment/{commentId}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process2(_response);
        });
    }

    protected process2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the comment key or id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to edit the comment.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the comment with given key or id does not exist or if the property with given key is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete a property from a dashboard item
     * @param propertyKey The key of the property to remove.
     * @param itemId The dashboard item from which the property will be removed.
     * @param dashboardId The dashboard id.
     * @return Returned if the dashboard item property was removed successfully.
     */
    12(propertyKey: string, itemId: string, dashboardId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process12(_response);
        });
    }

    protected process12(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the dashboard item id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to edit the dashboard item.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the dashboard item with given id does not exist or user does not have permissions to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete a property from an issue
     * @param propertyKey The key of the property to remove
     * @param issueIdOrKey Issue id or key
     * @return Returned if the issue property was removed successfully.
     */
    3(propertyKey: string, issueIdOrKey: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process3(_response);
        });
    }

    protected process3(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue key or id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to edit the issue.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue with given key or id does not exist or if the property with given key is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete specified issue type's property
     * @param propertyKey The key of the property to remove.
     * @param issueTypeId The issue type from which the property will be removed.
     * @return Removes the property from the issue type.
     */
    4(propertyKey: string, issueTypeId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issuetype/{issueTypeId}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (issueTypeId === undefined || issueTypeId === null)
            throw new Error("The parameter 'issueTypeId' must be defined.");
        url_ = url_.replace("{issueTypeId}", encodeURIComponent("" + issueTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process4(_response);
        });
    }

    protected process4(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type with given id does not exist or if the property with given key is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete property from project
     * @return Returned if the project property was removed successfully.
     */
    5(propertyKey: string, projectIdOrKey: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process5(_response);
        });
    }

    protected process5(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project key or id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to edit the project.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project with given key or id does not exist or if the property with given key is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete a specified user's property
     * @param userKey (optional) 
     * @param username (optional) 
     * @return Returned if the user property was removed successfully.
     */
    6(propertyKey: string, userKey?: string | undefined, username?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/user/properties/{propertyKey}?";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (userKey === null)
            throw new Error("The parameter 'userKey' cannot be null.");
        else if (userKey !== undefined)
            url_ += "userKey=" + encodeURIComponent("" + userKey) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process6(_response);
        });
    }

    protected process6(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user key or id is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to edit the user.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user with given key or id does not exist or if the property with given key is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class GetClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get application role by key
     * @param key the key of the role to use.
     * @return Returns the ApplicationRole if it exists.
     */
    4(key: string): Promise<ApplicationRoleBean> {
        let url_ = this.baseUrl + "/api/2/applicationrole/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process4(_response);
        });
    }

    protected process4(response: Response): Promise<ApplicationRoleBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not an administrator.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the role does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationRoleBean>(null as any);
    }
}

export class PutClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Update application role
     * @param key the key of the role to update.
     * @param if_Match (optional) 
     * @param versionHash (optional) the hash of the version to update. Optional Param
     * @param body (optional) the data to update the role with.
     * @return Returns the updated ApplicationRole if the update was successful.
     */
    2(key: string, if_Match?: string | undefined, versionHash?: string | undefined, body?: ApplicationRoleBean | undefined): Promise<ApplicationRoleBean> {
        let url_ = this.baseUrl + "/api/2/applicationrole/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "If-Match": if_Match !== undefined && if_Match !== null ? "" + if_Match : "",
                "versionHash": versionHash !== undefined && versionHash !== null ? "" + versionHash : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process2(_response);
        });
    }

    protected process2(response: Response): Promise<ApplicationRoleBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRoleBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user does not have permission to edit roles.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not an administrator.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the role does not exist.", status, _responseText, _headers);
            });
        } else if (status === 412) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the versionHash is not null and contains a different version to the server.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationRoleBean>(null as any);
    }
}

export class GetConfigurationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get Jira configuration details
     * @return Returned the configuration of optional features in Jira.
     */
    1(): Promise<ConfigurationBean> {
        let url_ = this.baseUrl + "/api/2/configuration";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<ConfigurationBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigurationBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConfigurationBean>(null as any);
    }
}

export class DefaultColumnsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get default columns for filter
     * @param id The filter id.
     * @return Returns a list of columns for configured for the given user
     */
    1(id: string): Promise<ColumnLayout> {
        let url_ = this.baseUrl + "/api/2/filter/{id}/columns";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<ColumnLayout> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ColumnLayout.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the filter does not have any columns.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while retrieving the column configuration.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ColumnLayout>(null as any);
    }
}

export class SetColumnsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Set default columns for filter
     * @param id The filter id.
     * @param body (optional) 
     * @return Returned when the columns are saved successfully
     */
    1(id: string, body?: Body | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/filter/{id}/columns";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "*/*",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while retrieving the column configuration.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ResetColumnsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Reset columns for filter
     * @param id The filter id.
     * @return Returned when the columns are reset/removed successfully
     */
    1(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/filter/{id}/columns";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while retrieving the column configuration.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AddWatcherClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Add a user as watcher
     * @param issueIdOrKey Issue id or key
     * @param userName (optional) The name of the user to add to the watcher list. If no name is specified, the current user is added.
     * @param body (optional) 
     * @return Returned if the watcher was added successfully.
     */
    1(issueIdOrKey: string, userName?: string | undefined, body?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/watchers?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if a user name query parameter is not supplied.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to add the watcher to the issue\'s list of watchers.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if either the issue does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class RemoveWatcherClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Delete watcher from issue
     * @param issueIdOrKey Issue id or key
     * @param userName (optional) The name of the user to remove from the watcher list.
     * @param username (optional) 
     * @return Returned if the watcher was removed successfully.
     */
    1(issueIdOrKey: string, userName?: string | undefined, username?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issue/{issueIdOrKey}/watchers?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if a user name query parameter is not supplied.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to remove the watcher from the issue\'s list of watchers.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if either the issue does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class GetIssueTypeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get full representation of issue type by id
     * @param id The issue type id.
     * @return Returns the issue type with the given id.
     */
    1(id: string): Promise<IssueTypeJsonBean> {
        let url_ = this.baseUrl + "/api/2/issuetype/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<IssueTypeJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueTypeJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type does not exist, or is not visible to the calling user.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IssueTypeJsonBean>(null as any);
    }
}

export class DeleteIssueTypeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Delete specified issue type and migrate associated issues
     * @param id The issue type id.
     * @param alternativeIssueTypeId The id of an issue type to which issues associated with the removed issue type will be migrated.
     * @return Returns NO_CONTENT if successful.
     */
    1(id: string, alternativeIssueTypeId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/issuetype/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (alternativeIssueTypeId === undefined || alternativeIssueTypeId === null)
            throw new Error("The parameter 'alternativeIssueTypeId' must be defined.");
        url_ = url_.replace("{alternativeIssueTypeId}", encodeURIComponent("" + alternativeIssueTypeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid. It happens when there are associated issues with the issue type which is being removed, but it is impossible to migrate these issues to the alternative issue type.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the calling user does not have permission to administer Jira.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the issue type to update does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CreateAvatarFromTemporaryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Convert temporary avatar into a real avatar
     * @param id The issue type id.
     * @param body Cropping instructions.
     * @return Returns created avatar.
     */
    1(id: string, body: AvatarCroppingBean): Promise<AvatarBean> {
        let url_ = this.baseUrl + "/api/2/issuetype/{id}/avatar";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<AvatarBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AvatarBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the cropping coordinates are invalid.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to pick avatar.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have EDIT PROJECT permission.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while converting temporary avatar to real avatar.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvatarBean>(null as any);
    }

    /**
     * Create avatar from temporary
     * @param body Cropping instructions
     * @return Avatar data
     */
    2(projectIdOrKey: string, body: AvatarCroppingBean): Promise<AvatarBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/avatar";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process2(_response);
        });
    }

    protected process2(response: Response): Promise<AvatarBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AvatarBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the cropping coordinates are invalid", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to pick avatar", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have EDIT PROJECT permission", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvatarBean>(null as any);
    }

    /**
     * Create avatar from temporary
     * @param body (optional) 
     * @return Returns the created avatar.
     */
    3(type: string, owningObjectId: string, body?: AvatarCroppingBean | undefined): Promise<AvatarBean> {
        let url_ = this.baseUrl + "/api/2/universal_avatar/type/{type}/owner/{owningObjectId}/avatar";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (owningObjectId === undefined || owningObjectId === null)
            throw new Error("The parameter 'owningObjectId' must be defined.");
        url_ = url_.replace("{owningObjectId}", encodeURIComponent("" + owningObjectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process3(_response);
        });
    }

    protected process3(response: Response): Promise<AvatarBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AvatarBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the provided data isn\'t valid.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user doesn\'t have admin permissions.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the feature is turned off via a feature flag.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvatarBean>(null as any);
    }

    /**
     * Create avatar from temporary
     * @param body Cropping instructions
     * @param username (optional) 
     * @return Returns created avatar
     */
    4(body: AvatarCroppingBean, username?: string | undefined): Promise<AvatarBean> {
        let url_ = this.baseUrl + "/api/2/user/avatar?";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process4(_response);
        });
    }

    protected process4(response: Response): Promise<AvatarBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AvatarBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the cropping coordinates are invalid", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to pick avatar", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user from parameter does not exist", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while converting temporary avatar to real avatar", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvatarBean>(null as any);
    }
}

export class SetAppMonitoringEnabledClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Update IPD Monitoring status
     * @param body The status to set for IPD Monitoring.
     * @return Confirmation that the status was set.
     */
    1(body: IpdMonitoringRestEntity): Promise<void> {
        let url_ = this.baseUrl + "/api/2/monitoring/ipd";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class GetPrioritiesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get paginated issue priorities
     * @param maxResults (optional) 
     * @param query (optional) 
     * @param projectIds (optional) 
     * @param startAt (optional) 
     * @return List of priorities
     */
    1(maxResults?: number | undefined, query?: string | undefined, projectIds?: number[] | undefined, startAt?: number | undefined): Promise<PriorityJsonBean> {
        let url_ = this.baseUrl + "/api/2/priority/page?";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (projectIds === null)
            throw new Error("The parameter 'projectIds' cannot be null.");
        else if (projectIds !== undefined)
            projectIds && projectIds.forEach(item => { url_ += "projectIds=" + encodeURIComponent("" + item) + "&"; });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<PriorityJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PriorityJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PriorityJsonBean>(null as any);
    }
}

export class StoreTemporaryAvatarUsingMultiPartClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Store temporary avatar using multipart
     * @param contentType (optional) 
     * @param formField (optional) 
     * @param inputStream (optional) 
     * @param name (optional) 
     * @param size (optional) 
     * @param value (optional) 
     * @return Temporary avatar cropping instructions embeded in HTML page. Error messages will also be embeded in the page.
     */
    1(projectIdOrKey: string, contentType?: string | undefined, formField?: boolean | undefined, inputStream?: any | undefined, name?: string | undefined, size?: number | undefined, value?: string | undefined): Promise<AvatarCroppingBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectIdOrKey}/avatar/temporary";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("contentType", contentType.toString());
        if (formField === null || formField === undefined)
            throw new Error("The parameter 'formField' cannot be null.");
        else
            content_.append("formField", formField.toString());
        if (inputStream === null || inputStream === undefined)
            throw new Error("The parameter 'inputStream' cannot be null.");
        else
            content_.append("inputStream", JSON.stringify(inputStream));
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("name", name.toString());
        if (size === null || size === undefined)
            throw new Error("The parameter 'size' cannot be null.");
        else
            content_.append("size", size.toString());
        if (value === null || value === undefined)
            throw new Error("The parameter 'value' cannot be null.");
        else
            content_.append("value", value.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "text/html"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<AvatarCroppingBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AvatarCroppingBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have EDIT PROJECT permission", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvatarCroppingBean>(null as any);
    }

    /**
     * Create temporary avatar using multipart upload
     * @param contentType (optional) 
     * @param formField (optional) 
     * @param inputStream (optional) 
     * @param name (optional) 
     * @param size (optional) 
     * @param value (optional) 
     * @return Returns temporary avatar cropping instructions.
     */
    2(type: string, owningObjectId: string, contentType?: string | undefined, formField?: boolean | undefined, inputStream?: any | undefined, name?: string | undefined, size?: number | undefined, value?: string | undefined): Promise<AvatarCroppingBean> {
        let url_ = this.baseUrl + "/api/2/universal_avatar/type/{type}/owner/{owningObjectId}/temp";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (owningObjectId === undefined || owningObjectId === null)
            throw new Error("The parameter 'owningObjectId' must be defined.");
        url_ = url_.replace("{owningObjectId}", encodeURIComponent("" + owningObjectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType === null || contentType === undefined)
            throw new Error("The parameter 'contentType' cannot be null.");
        else
            content_.append("contentType", contentType.toString());
        if (formField === null || formField === undefined)
            throw new Error("The parameter 'formField' cannot be null.");
        else
            content_.append("formField", formField.toString());
        if (inputStream === null || inputStream === undefined)
            throw new Error("The parameter 'inputStream' cannot be null.");
        else
            content_.append("inputStream", JSON.stringify(inputStream));
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("name", name.toString());
        if (size === null || size === undefined)
            throw new Error("The parameter 'size' cannot be null.");
        else
            content_.append("size", size.toString());
        if (value === null || value === undefined)
            throw new Error("The parameter 'value' cannot be null.");
        else
            content_.append("value", value.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process2(_response);
        });
    }

    protected process2(response: Response): Promise<AvatarCroppingBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AvatarCroppingBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the provided data isn\'t valid.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user doesn\'t have admin permissions.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the feature is turned off via a feature flag.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvatarCroppingBean>(null as any);
    }

    /**
     * Store temporary avatar using multipart
     * @param body The file data
     * @param username (optional) 
     * @return Returns temporary avatar cropping instructions embeded in HTML page. Error messages will also be embeded in the page.
     */
    3(body: Blob, username?: string | undefined): Promise<AvatarCroppingBean> {
        let url_ = this.baseUrl + "/api/2/user/avatar/temporary?";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "multipart/form-data",
                "Accept": "text/html"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process3(_response);
        });
    }

    protected process3(response: Response): Promise<AvatarCroppingBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AvatarCroppingBean.fromJS(resultData201);
            return result201;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to store the avatar or XSRF token is invalid.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user does NOT exist", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while converting temporary avatar to real avatar", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvatarCroppingBean>(null as any);
    }
}

export class GetIssueSecuritySchemeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get issue security scheme for project
     * @return Issue security scheme
     */
    1(projectKeyOrId: string): Promise<SecuritySchemeJsonBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectKeyOrId}/issuesecuritylevelscheme";
        if (projectKeyOrId === undefined || projectKeyOrId === null)
            throw new Error("The parameter 'projectKeyOrId' must be defined.");
        url_ = url_.replace("{projectKeyOrId}", encodeURIComponent("" + projectKeyOrId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<SecuritySchemeJsonBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecuritySchemeJsonBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project is visible for calling user, but the user doesn\'t have administrative permissions", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the project does not exist, or is not visible to the calling user", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecuritySchemeJsonBean>(null as any);
    }
}

export class GetNotificationSchemeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get notification scheme associated with the project
     * @param expand (optional) 
     * @return Returns a full representation of the notification scheme with given id
     */
    1(projectKeyOrId: string, expand?: string | undefined): Promise<NotificationSchemeBean> {
        let url_ = this.baseUrl + "/api/2/project/{projectKeyOrId}/notificationscheme?";
        if (projectKeyOrId === undefined || projectKeyOrId === null)
            throw new Error("The parameter 'projectKeyOrId' must be defined.");
        url_ = url_.replace("{projectKeyOrId}", encodeURIComponent("" + projectKeyOrId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<NotificationSchemeBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationSchemeBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("The user is not logged in", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("The user is allowed to access the project, but is not an administrator of the project or Jira and therefore can\'t see the notification scheme of the project", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("The notification scheme does not exist, or is not visible to the calling user", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationSchemeBean>(null as any);
    }
}

export class GetProjectClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get project key validation
     * @param key (optional) 
     * @return Returns an ErrorCollection containing any validation errors for the project key. If the project key is valid, the ErrorCollection will be empty.
     */
    1(key?: string | undefined): Promise<ErrorCollection> {
        let url_ = this.baseUrl + "/api/2/projectvalidate/key?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<ErrorCollection> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ErrorCollection.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ErrorCollection>(null as any);
    }
}

export class GetProjectRolesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get all project roles
     * @return Returns full details of the roles available in Jira.
     */
    1(): Promise<ProjectRoleBean> {
        let url_ = this.baseUrl + "/api/2/role";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<ProjectRoleBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRoleBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not logged in.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requesting user is not an admin or a sysadmin.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectRoleBean>(null as any);
    }
}

export class SearchClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get issues using JQL
     * @param expand (optional) 
     * @param jql (optional) 
     * @param maxResults (optional) 
     * @param validateQuery (optional) 
     * @param fields (optional) 
     * @param startAt (optional) 
     * @return Returns a JSON representation of the search results.
     */
    1(expand?: StringList | undefined, jql?: string | undefined, maxResults?: number | undefined, validateQuery?: boolean | undefined, fields?: StringList[] | undefined, startAt?: number | undefined): Promise<SearchResultsBean> {
        let url_ = this.baseUrl + "/api/2/search?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (jql === null)
            throw new Error("The parameter 'jql' cannot be null.");
        else if (jql !== undefined)
            url_ += "jql=" + encodeURIComponent("" + jql) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (validateQuery === null)
            throw new Error("The parameter 'validateQuery' cannot be null.");
        else if (validateQuery !== undefined)
            url_ += "validateQuery=" + encodeURIComponent("" + validateQuery) + "&";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "fields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<SearchResultsBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResultsBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is a problem with the JQL query.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchResultsBean>(null as any);
    }
}

export class DeleteAvatarClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Delete avatar by ID
     * @return Returns the status of the deletion.
     */
    1(id: number, type: string, owningObjectId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/2/universal_avatar/type/{type}/owner/{owningObjectId}/avatar/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (owningObjectId === undefined || owningObjectId === null)
            throw new Error("The parameter 'owningObjectId' must be defined.");
        url_ = url_.replace("{owningObjectId}", encodeURIComponent("" + owningObjectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the provided data isn\'t valid.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user doesn\'t have admin permissions.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the feature is turned off via a feature flag.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Delete avatar
     * @param username (optional) 
     * @return Returned if the avatar is successfully deleted.
     */
    2(id: number, username?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/user/avatar/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process2(_response);
        });
    }

    protected process2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to delete the avatar.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the avatar does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class GetUserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get user by username or key
     * @param includeDeleted (optional) 
     * @param key (optional) 
     * @param username (optional) 
     * @return Returns a user.
     */
    1(includeDeleted?: boolean | undefined, key?: string | undefined, username?: string | undefined): Promise<UserBean> {
        let url_ = this.baseUrl + "/api/2/user?";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<UserBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller does not have permission to perform operation.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested user is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserBean>(null as any);
    }
}

export class UpdateUserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Update user details
     * @param body User details
     * @param key (optional) 
     * @param username (optional) 
     * @return Returned if the user exists and the caller has permission to edit it.
     */
    1(body: UserWriteBean, key?: string | undefined, username?: string | undefined): Promise<UserWriteBean> {
        let url_ = this.baseUrl + "/api/2/user?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<UserWriteBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserWriteBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller user does not have permission to edit the user.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller does have permission to edit the user but the user does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserWriteBean>(null as any);
    }
}

export class GetProgressClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get user anonymization progress
     * @param taskId (optional) 
     * @return Returns a representation of the progress of the user anonymization operation.
     */
    1(taskId?: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/user/anonymization/progress?";
        if (taskId === null)
            throw new Error("The parameter 'taskId' cannot be null.");
        else if (taskId !== undefined)
            url_ += "taskId=" + encodeURIComponent("" + taskId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the logged-in user cannot anonymize users.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if there is no user anonymization task found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AddUserToApplicationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Add user to application
     * @param applicationKey (optional) 
     * @param username (optional) 
     * @return Returned if the user exists, the caller has permission to add user to application and user was successfully added to application.
     */
    1(applicationKey?: string | undefined, username?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/user/application?";
        if (applicationKey === null)
            throw new Error("The parameter 'applicationKey' cannot be null.");
        else if (applicationKey !== undefined)
            url_ += "applicationKey=" + encodeURIComponent("" + applicationKey) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller user does not have permission to add user to application.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class RemoveUserFromApplicationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Remove user from application
     * @param applicationKey (optional) 
     * @param username (optional) 
     * @return Returned if the user exists, the caller has permission to remove user from application and the user was successfully removed from application.
     */
    1(applicationKey?: string | undefined, username?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/2/user/application?";
        if (applicationKey === null)
            throw new Error("The parameter 'applicationKey' cannot be null.");
        else if (applicationKey !== undefined)
            url_ += "applicationKey=" + encodeURIComponent("" + applicationKey) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the request is invalid.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the caller user does not have permission to remove user from application.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class FindAssignableUsersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Find assignable users by username
     * @param issueKey (optional) 
     * @param maxResults (optional) 
     * @param project (optional) 
     * @param actionDescriptorId (optional) 
     * @param username (optional) 
     * @return Returns a list of users that match the search string.
     */
    1(issueKey?: string | undefined, maxResults?: number | undefined, project?: string | undefined, actionDescriptorId?: number | undefined, username?: string | undefined): Promise<UserBean> {
        let url_ = this.baseUrl + "/api/2/user/assignable/search?";
        if (issueKey === null)
            throw new Error("The parameter 'issueKey' cannot be null.");
        else if (issueKey !== undefined)
            url_ += "issueKey=" + encodeURIComponent("" + issueKey) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (project === null)
            throw new Error("The parameter 'project' cannot be null.");
        else if (project !== undefined)
            url_ += "project=" + encodeURIComponent("" + project) + "&";
        if (actionDescriptorId === null)
            throw new Error("The parameter 'actionDescriptorId' cannot be null.");
        else if (actionDescriptorId !== undefined)
            url_ += "actionDescriptorId=" + encodeURIComponent("" + actionDescriptorId) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<UserBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested user is not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserBean>(null as any);
    }
}

export class UpdateUserAvatarClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Update user avatar
     * @param body New avatar details
     * @param username (optional) 
     * @return Returns updated avatar
     */
    1(body: AvatarBean, username?: string | undefined): Promise<AvatarBean> {
        let url_ = this.baseUrl + "/api/2/user/avatar?";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<AvatarBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AvatarBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the avatar details are invalid", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to update avatar", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if user from parameter does not exist", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while updating the avatar", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvatarBean>(null as any);
    }
}

export class GetAllAvatarsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Get all avatars for user
     * @param username (optional) 
     * @return Returns a map containing a list of avatars for both custom an system avatars
     */
    1(username?: string | undefined): Promise<AvatarBean> {
        let url_ = this.baseUrl + "/api/2/user/avatars?";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<AvatarBean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AvatarBean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the current user is not authenticated.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the requested user is not found.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Returned if an error occurs while retrieving the list of avatars.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AvatarBean>(null as any);
    }
}

export class DeleteClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Delete version and replace values
     * @param body JSON containing parameters to replace the deleted version with
     * @return Returned if the version is successfully deleted.
     */
    1(id: string, body: DeleteAndReplaceVersionBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/version/{id}/removeAndSwap";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the replacement didn\'t succeed", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the version does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CreateOrUpdateRemoteVersionLinkClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "http://{baseurl}/rest";
    }

    /**
     * Create or update remote version link with global ID
     * @param body JSON containing parameters to create the remote version link with
     * @return Returned if the remote version link is created or updated successfully.
     */
    1(versionId: string, globalId: string, body: RemoteEntityLinkJsonBean): Promise<void> {
        let url_ = this.baseUrl + "/api/2/version/{versionId}/remotelink/{globalId}";
        if (versionId === undefined || versionId === null)
            throw new Error("The parameter 'versionId' must be defined.");
        url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
        if (globalId === undefined || globalId === null)
            throw new Error("The parameter 'globalId' must be defined.");
        url_ = url_.replace("{globalId}", encodeURIComponent("" + globalId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.process1(_response);
        });
    }

    protected process1(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the JSON payload is empty or malformed", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the currently authenticated user does not have permission to edit the version.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Returned if the version does not exist or the currently authenticated user does not have permission to view it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class BoardBean implements IBoardBean {
    id?: number;
    name?: string;
    self?: string;
    type?: string;

    [key: string]: any;

    constructor(data?: IBoardBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.self = _data["self"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): BoardBean {
        data = typeof data === 'object' ? data : {};
        let result = new BoardBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        data["type"] = this.type;
        return data;
    }
}

export interface IBoardBean {
    id?: number;
    name?: string;
    self?: string;
    type?: string;

    [key: string]: any;
}

export class BoardConfigBean implements IBoardConfigBean {
    columnConfig?: ColumnConfigBean;
    estimation?: EstimationConfigBean;
    filter?: RelationBean;
    id?: number;
    name?: string;
    ranking?: RankingConfigBean;
    self?: string;
    subQuery?: SubqueryBean;
    type?: string;

    [key: string]: any;

    constructor(data?: IBoardConfigBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.columnConfig = _data["columnConfig"] ? ColumnConfigBean.fromJS(_data["columnConfig"]) : <any>undefined;
            this.estimation = _data["estimation"] ? EstimationConfigBean.fromJS(_data["estimation"]) : <any>undefined;
            this.filter = _data["filter"] ? RelationBean.fromJS(_data["filter"]) : <any>undefined;
            this.id = _data["id"];
            this.name = _data["name"];
            this.ranking = _data["ranking"] ? RankingConfigBean.fromJS(_data["ranking"]) : <any>undefined;
            this.self = _data["self"];
            this.subQuery = _data["subQuery"] ? SubqueryBean.fromJS(_data["subQuery"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): BoardConfigBean {
        data = typeof data === 'object' ? data : {};
        let result = new BoardConfigBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["columnConfig"] = this.columnConfig ? this.columnConfig.toJSON() : <any>undefined;
        data["estimation"] = this.estimation ? this.estimation.toJSON() : <any>undefined;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["name"] = this.name;
        data["ranking"] = this.ranking ? this.ranking.toJSON() : <any>undefined;
        data["self"] = this.self;
        data["subQuery"] = this.subQuery ? this.subQuery.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

export interface IBoardConfigBean {
    columnConfig?: ColumnConfigBean;
    estimation?: EstimationConfigBean;
    filter?: RelationBean;
    id?: number;
    name?: string;
    ranking?: RankingConfigBean;
    self?: string;
    subQuery?: SubqueryBean;
    type?: string;

    [key: string]: any;
}

export class BoardCreateBean implements IBoardCreateBean {
    filterId?: number;
    name?: string;
    type?: string;

    [key: string]: any;

    constructor(data?: IBoardCreateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.filterId = _data["filterId"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): BoardCreateBean {
        data = typeof data === 'object' ? data : {};
        let result = new BoardCreateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["filterId"] = this.filterId;
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

export interface IBoardCreateBean {
    filterId?: number;
    name?: string;
    type?: string;

    [key: string]: any;
}

export class BooleanSettingBean implements IBooleanSettingBean {
    value?: boolean;

    [key: string]: any;

    constructor(data?: IBooleanSettingBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): BooleanSettingBean {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanSettingBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

export interface IBooleanSettingBean {
    value?: boolean;

    [key: string]: any;
}

export class ChangeHistoryBean implements IChangeHistoryBean {
    author?: UserJsonBean;
    created?: Date;
    historyMetadata?: HistoryMetadata;
    id?: string;
    items?: ChangeItemBean[];

    [key: string]: any;

    constructor(data?: IChangeHistoryBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.author = _data["author"] ? UserJsonBean.fromJS(_data["author"]) : <any>undefined;
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.historyMetadata = _data["historyMetadata"] ? HistoryMetadata.fromJS(_data["historyMetadata"]) : <any>undefined;
            this.id = _data["id"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChangeItemBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChangeHistoryBean {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeHistoryBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["historyMetadata"] = this.historyMetadata ? this.historyMetadata.toJSON() : <any>undefined;
        data["id"] = this.id;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChangeHistoryBean {
    author?: UserJsonBean;
    created?: Date;
    historyMetadata?: HistoryMetadata;
    id?: string;
    items?: ChangeItemBean[];

    [key: string]: any;
}

export class ChangeItemBean implements IChangeItemBean {
    field?: string;
    fieldtype?: string;
    from?: string;
    fromString?: string;
    to?: string;
    toString?: string;

    [key: string]: any;

    constructor(data?: IChangeItemBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.field = _data["field"];
            this.fieldtype = _data["fieldtype"];
            this.from = _data["from"];
            this.fromString = _data["fromString"];
            this.to = _data["to"];
            this.toString = _data["toString"];
        }
    }

    static fromJS(data: any): ChangeItemBean {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeItemBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["field"] = this.field;
        data["fieldtype"] = this.fieldtype;
        data["from"] = this.from;
        data["fromString"] = this.fromString;
        data["to"] = this.to;
        data["toString"] = this.toString;
        return data;
    }
}

export interface IChangeItemBean {
    field?: string;
    fieldtype?: string;
    from?: string;
    fromString?: string;
    to?: string;
    toString?: string;

    [key: string]: any;
}

export class ChangelogBean implements IChangelogBean {
    histories?: ChangeHistoryBean[];
    maxResults?: number;
    startAt?: number;
    total?: number;

    [key: string]: any;

    constructor(data?: IChangelogBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["histories"])) {
                this.histories = [] as any;
                for (let item of _data["histories"])
                    this.histories!.push(ChangeHistoryBean.fromJS(item));
            }
            this.maxResults = _data["maxResults"];
            this.startAt = _data["startAt"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): ChangelogBean {
        data = typeof data === 'object' ? data : {};
        let result = new ChangelogBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.histories)) {
            data["histories"] = [];
            for (let item of this.histories)
                data["histories"].push(item.toJSON());
        }
        data["maxResults"] = this.maxResults;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        return data;
    }
}

export interface IChangelogBean {
    histories?: ChangeHistoryBean[];
    maxResults?: number;
    startAt?: number;
    total?: number;

    [key: string]: any;
}

export class ColorBean implements IColorBean {
    key?: ColorBeanKey;

    [key: string]: any;

    constructor(data?: IColorBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): ColorBean {
        data = typeof data === 'object' ? data : {};
        let result = new ColorBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["key"] = this.key;
        return data;
    }
}

export interface IColorBean {
    key?: ColorBeanKey;

    [key: string]: any;
}

export class ColumnBean implements IColumnBean {
    max?: number;
    min?: number;
    name?: string;
    statuses?: RelationBean[];

    [key: string]: any;

    constructor(data?: IColumnBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.max = _data["max"];
            this.min = _data["min"];
            this.name = _data["name"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(RelationBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ColumnBean {
        data = typeof data === 'object' ? data : {};
        let result = new ColumnBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["max"] = this.max;
        data["min"] = this.min;
        data["name"] = this.name;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        return data;
    }
}

export interface IColumnBean {
    max?: number;
    min?: number;
    name?: string;
    statuses?: RelationBean[];

    [key: string]: any;
}

export class ColumnConfigBean implements IColumnConfigBean {
    columns?: ColumnBean[];
    constraintType?: string;

    [key: string]: any;

    constructor(data?: IColumnConfigBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(ColumnBean.fromJS(item));
            }
            this.constraintType = _data["constraintType"];
        }
    }

    static fromJS(data: any): ColumnConfigBean {
        data = typeof data === 'object' ? data : {};
        let result = new ColumnConfigBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        data["constraintType"] = this.constraintType;
        return data;
    }
}

export interface IColumnConfigBean {
    columns?: ColumnBean[];
    constraintType?: string;

    [key: string]: any;
}

export class EditMetaBean implements IEditMetaBean {

    [key: string]: any;

    constructor(data?: IEditMetaBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): EditMetaBean {
        data = typeof data === 'object' ? data : {};
        let result = new EditMetaBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IEditMetaBean {

    [key: string]: any;
}

export class EntityPropertiesKeysBean implements IEntityPropertiesKeysBean {
    keys?: EntityPropertyKeyBean[];

    [key: string]: any;

    constructor(data?: IEntityPropertiesKeysBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["keys"])) {
                this.keys = [] as any;
                for (let item of _data["keys"])
                    this.keys!.push(EntityPropertyKeyBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityPropertiesKeysBean {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertiesKeysBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.keys)) {
            data["keys"] = [];
            for (let item of this.keys)
                data["keys"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEntityPropertiesKeysBean {
    keys?: EntityPropertyKeyBean[];

    [key: string]: any;
}

export class EntityPropertyBean implements IEntityPropertyBean {
    key?: string;
    value?: string;

    [key: string]: any;

    constructor(data?: IEntityPropertyBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): EntityPropertyBean {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IEntityPropertyBean {
    key?: string;
    value?: string;

    [key: string]: any;
}

export class EntityPropertyKeyBean implements IEntityPropertyKeyBean {
    key?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IEntityPropertyKeyBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.key = _data["key"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): EntityPropertyKeyBean {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyKeyBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["key"] = this.key;
        data["self"] = this.self;
        return data;
    }
}

export interface IEntityPropertyKeyBean {
    key?: string;
    self?: string;

    [key: string]: any;
}

export class Entry implements IEntry {
    errors?: string[];
    issueId?: number;
    issueKey?: string;
    status?: number;

    [key: string]: any;

    constructor(data?: IEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.issueId = _data["issueId"];
            this.issueKey = _data["issueKey"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Entry {
        data = typeof data === 'object' ? data : {};
        let result = new Entry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["issueId"] = this.issueId;
        data["issueKey"] = this.issueKey;
        data["status"] = this.status;
        return data;
    }
}

export interface IEntry {
    errors?: string[];
    issueId?: number;
    issueKey?: string;
    status?: number;

    [key: string]: any;
}

export class EpicBean implements IEpicBean {
    color?: ColorBean;
    done?: boolean;
    id?: number;
    key?: string;
    name?: string;
    self?: string;
    summary?: string;

    [key: string]: any;

    constructor(data?: IEpicBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.color = _data["color"] ? ColorBean.fromJS(_data["color"]) : <any>undefined;
            this.done = _data["done"];
            this.id = _data["id"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.self = _data["self"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): EpicBean {
        data = typeof data === 'object' ? data : {};
        let result = new EpicBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["color"] = this.color ? this.color.toJSON() : <any>undefined;
        data["done"] = this.done;
        data["id"] = this.id;
        data["key"] = this.key;
        data["name"] = this.name;
        data["self"] = this.self;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IEpicBean {
    color?: ColorBean;
    done?: boolean;
    id?: number;
    key?: string;
    name?: string;
    self?: string;
    summary?: string;

    [key: string]: any;
}

export class EpicRankRequestBean implements IEpicRankRequestBean {
    rankAfterEpic?: string;
    rankBeforeEpic?: string;
    rankCustomFieldId?: number;

    [key: string]: any;

    constructor(data?: IEpicRankRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.rankAfterEpic = _data["rankAfterEpic"];
            this.rankBeforeEpic = _data["rankBeforeEpic"];
            this.rankCustomFieldId = _data["rankCustomFieldId"];
        }
    }

    static fromJS(data: any): EpicRankRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new EpicRankRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["rankAfterEpic"] = this.rankAfterEpic;
        data["rankBeforeEpic"] = this.rankBeforeEpic;
        data["rankCustomFieldId"] = this.rankCustomFieldId;
        return data;
    }
}

export interface IEpicRankRequestBean {
    rankAfterEpic?: string;
    rankBeforeEpic?: string;
    rankCustomFieldId?: number;

    [key: string]: any;
}

export class EpicUpdateBean implements IEpicUpdateBean {
    color?: ColorBean;
    done?: boolean;
    name?: string;
    summary?: string;

    [key: string]: any;

    constructor(data?: IEpicUpdateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.color = _data["color"] ? ColorBean.fromJS(_data["color"]) : <any>undefined;
            this.done = _data["done"];
            this.name = _data["name"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): EpicUpdateBean {
        data = typeof data === 'object' ? data : {};
        let result = new EpicUpdateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["color"] = this.color ? this.color.toJSON() : <any>undefined;
        data["done"] = this.done;
        data["name"] = this.name;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IEpicUpdateBean {
    color?: ColorBean;
    done?: boolean;
    name?: string;
    summary?: string;

    [key: string]: any;
}

export class EstimationConfigBean implements IEstimationConfigBean {
    field?: EstimationFieldBean;
    type?: string;

    [key: string]: any;

    constructor(data?: IEstimationConfigBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.field = _data["field"] ? EstimationFieldBean.fromJS(_data["field"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): EstimationConfigBean {
        data = typeof data === 'object' ? data : {};
        let result = new EstimationConfigBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["field"] = this.field ? this.field.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

export interface IEstimationConfigBean {
    field?: EstimationFieldBean;
    type?: string;

    [key: string]: any;
}

export class EstimationFieldBean implements IEstimationFieldBean {
    displayName?: string;
    fieldId?: string;

    [key: string]: any;

    constructor(data?: IEstimationFieldBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.displayName = _data["displayName"];
            this.fieldId = _data["fieldId"];
        }
    }

    static fromJS(data: any): EstimationFieldBean {
        data = typeof data === 'object' ? data : {};
        let result = new EstimationFieldBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["displayName"] = this.displayName;
        data["fieldId"] = this.fieldId;
        return data;
    }
}

export interface IEstimationFieldBean {
    displayName?: string;
    fieldId?: string;

    [key: string]: any;
}

export class FieldEditBean implements IFieldEditBean {
    value?: string;

    [key: string]: any;

    constructor(data?: IFieldEditBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): FieldEditBean {
        data = typeof data === 'object' ? data : {};
        let result = new FieldEditBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

export interface IFieldEditBean {
    value?: string;

    [key: string]: any;
}

export class FieldMetaBean implements IFieldMetaBean {
    allowedValues?: any[];
    autoCompleteUrl?: string;
    defaultValue?: any;
    fieldId?: string;
    hasDefaultValue?: boolean;
    name?: string;
    operations?: string[];
    required?: boolean;
    schema?: JsonTypeBean;

    [key: string]: any;

    constructor(data?: IFieldMetaBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["allowedValues"])) {
                this.allowedValues = [] as any;
                for (let item of _data["allowedValues"])
                    this.allowedValues!.push(item);
            }
            this.autoCompleteUrl = _data["autoCompleteUrl"];
            this.defaultValue = _data["defaultValue"];
            this.fieldId = _data["fieldId"];
            this.hasDefaultValue = _data["hasDefaultValue"];
            this.name = _data["name"];
            if (Array.isArray(_data["operations"])) {
                this.operations = [] as any;
                for (let item of _data["operations"])
                    this.operations!.push(item);
            }
            this.required = _data["required"];
            this.schema = _data["schema"] ? JsonTypeBean.fromJS(_data["schema"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FieldMetaBean {
        data = typeof data === 'object' ? data : {};
        let result = new FieldMetaBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.allowedValues)) {
            data["allowedValues"] = [];
            for (let item of this.allowedValues)
                data["allowedValues"].push(item);
        }
        data["autoCompleteUrl"] = this.autoCompleteUrl;
        data["defaultValue"] = this.defaultValue;
        data["fieldId"] = this.fieldId;
        data["hasDefaultValue"] = this.hasDefaultValue;
        data["name"] = this.name;
        if (Array.isArray(this.operations)) {
            data["operations"] = [];
            for (let item of this.operations)
                data["operations"].push(item);
        }
        data["required"] = this.required;
        data["schema"] = this.schema ? this.schema.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFieldMetaBean {
    allowedValues?: any[];
    autoCompleteUrl?: string;
    defaultValue?: any;
    fieldId?: string;
    hasDefaultValue?: boolean;
    name?: string;
    operations?: string[];
    required?: boolean;
    schema?: JsonTypeBean;

    [key: string]: any;
}

export class FieldValueBean implements IFieldValueBean {
    fieldId?: string;
    value?: any;

    [key: string]: any;

    constructor(data?: IFieldValueBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.fieldId = _data["fieldId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): FieldValueBean {
        data = typeof data === 'object' ? data : {};
        let result = new FieldValueBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["fieldId"] = this.fieldId;
        data["value"] = this.value;
        return data;
    }
}

export interface IFieldValueBean {
    fieldId?: string;
    value?: any;

    [key: string]: any;
}

export class HistoryMetadata implements IHistoryMetadata {
    activityDescription?: string;
    activityDescriptionKey?: string;
    actor?: HistoryMetadataParticipant;
    cause?: HistoryMetadataParticipant;
    description?: string;
    descriptionKey?: string;
    emailDescription?: string;
    emailDescriptionKey?: string;
    extraData?: { [key: string]: string; };
    generator?: HistoryMetadataParticipant;
    type?: string;

    [key: string]: any;

    constructor(data?: IHistoryMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.activityDescription = _data["activityDescription"];
            this.activityDescriptionKey = _data["activityDescriptionKey"];
            this.actor = _data["actor"] ? HistoryMetadataParticipant.fromJS(_data["actor"]) : <any>undefined;
            this.cause = _data["cause"] ? HistoryMetadataParticipant.fromJS(_data["cause"]) : <any>undefined;
            this.description = _data["description"];
            this.descriptionKey = _data["descriptionKey"];
            this.emailDescription = _data["emailDescription"];
            this.emailDescriptionKey = _data["emailDescriptionKey"];
            if (_data["extraData"]) {
                this.extraData = {} as any;
                for (let key in _data["extraData"]) {
                    if (_data["extraData"].hasOwnProperty(key))
                        (<any>this.extraData)![key] = _data["extraData"][key];
                }
            }
            this.generator = _data["generator"] ? HistoryMetadataParticipant.fromJS(_data["generator"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): HistoryMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new HistoryMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["activityDescription"] = this.activityDescription;
        data["activityDescriptionKey"] = this.activityDescriptionKey;
        data["actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        data["cause"] = this.cause ? this.cause.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["descriptionKey"] = this.descriptionKey;
        data["emailDescription"] = this.emailDescription;
        data["emailDescriptionKey"] = this.emailDescriptionKey;
        if (this.extraData) {
            data["extraData"] = {};
            for (let key in this.extraData) {
                if (this.extraData.hasOwnProperty(key))
                    (<any>data["extraData"])[key] = (<any>this.extraData)[key];
            }
        }
        data["generator"] = this.generator ? this.generator.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

export interface IHistoryMetadata {
    activityDescription?: string;
    activityDescriptionKey?: string;
    actor?: HistoryMetadataParticipant;
    cause?: HistoryMetadataParticipant;
    description?: string;
    descriptionKey?: string;
    emailDescription?: string;
    emailDescriptionKey?: string;
    extraData?: { [key: string]: string; };
    generator?: HistoryMetadataParticipant;
    type?: string;

    [key: string]: any;
}

export class HistoryMetadataParticipant implements IHistoryMetadataParticipant {
    avatarUrl?: string;
    displayName?: string;
    displayNameKey?: string;
    id?: string;
    type?: string;
    url?: string;

    [key: string]: any;

    constructor(data?: IHistoryMetadataParticipant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.avatarUrl = _data["avatarUrl"];
            this.displayName = _data["displayName"];
            this.displayNameKey = _data["displayNameKey"];
            this.id = _data["id"];
            this.type = _data["type"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): HistoryMetadataParticipant {
        data = typeof data === 'object' ? data : {};
        let result = new HistoryMetadataParticipant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["avatarUrl"] = this.avatarUrl;
        data["displayName"] = this.displayName;
        data["displayNameKey"] = this.displayNameKey;
        data["id"] = this.id;
        data["type"] = this.type;
        data["url"] = this.url;
        return data;
    }
}

export interface IHistoryMetadataParticipant {
    avatarUrl?: string;
    displayName?: string;
    displayNameKey?: string;
    id?: string;
    type?: string;
    url?: string;

    [key: string]: any;
}

export class IncludedFields implements IIncludedFields {
    included?: string[];

    [key: string]: any;

    constructor(data?: IIncludedFields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["included"])) {
                this.included = [] as any;
                for (let item of _data["included"])
                    this.included!.push(item);
            }
        }
    }

    static fromJS(data: any): IncludedFields {
        data = typeof data === 'object' ? data : {};
        let result = new IncludedFields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.included)) {
            data["included"] = [];
            for (let item of this.included)
                data["included"].push(item);
        }
        return data;
    }
}

export interface IIncludedFields {
    included?: string[];

    [key: string]: any;
}

export class IssueAssignRequestBean implements IIssueAssignRequestBean {
    issues?: string[];

    [key: string]: any;

    constructor(data?: IIssueAssignRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["issues"])) {
                this.issues = [] as any;
                for (let item of _data["issues"])
                    this.issues!.push(item);
            }
        }
    }

    static fromJS(data: any): IssueAssignRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueAssignRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item);
        }
        return data;
    }
}

export interface IIssueAssignRequestBean {
    issues?: string[];

    [key: string]: any;
}

export class IssueBean implements IIssueBean {
    changelog?: ChangelogBean;
    editmeta?: EditMetaBean;
    fields?: { [key: string]: any; };
    fieldsToInclude?: IncludedFields;
    id?: string;
    key?: string;
    names?: { [key: string]: string; };
    operations?: OpsbarBean;
    properties?: PropertiesBean;
    renderedFields?: { [key: string]: any; };
    schema?: { [key: string]: JsonTypeBean; };
    self?: string;
    transitionBeans?: TransitionBean[];
    transitions?: TransitionBean[];
    versionedRepresentations?: { [key: string]: { [key: string]: any; }; };

    [key: string]: any;

    constructor(data?: IIssueBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.changelog = _data["changelog"] ? ChangelogBean.fromJS(_data["changelog"]) : <any>undefined;
            this.editmeta = _data["editmeta"] ? EditMetaBean.fromJS(_data["editmeta"]) : <any>undefined;
            if (_data["fields"]) {
                this.fields = {} as any;
                for (let key in _data["fields"]) {
                    if (_data["fields"].hasOwnProperty(key))
                        (<any>this.fields)![key] = _data["fields"][key];
                }
            }
            this.fieldsToInclude = _data["fieldsToInclude"] ? IncludedFields.fromJS(_data["fieldsToInclude"]) : <any>undefined;
            this.id = _data["id"];
            this.key = _data["key"];
            if (_data["names"]) {
                this.names = {} as any;
                for (let key in _data["names"]) {
                    if (_data["names"].hasOwnProperty(key))
                        (<any>this.names)![key] = _data["names"][key];
                }
            }
            this.operations = _data["operations"] ? OpsbarBean.fromJS(_data["operations"]) : <any>undefined;
            this.properties = _data["properties"] ? PropertiesBean.fromJS(_data["properties"]) : <any>undefined;
            if (_data["renderedFields"]) {
                this.renderedFields = {} as any;
                for (let key in _data["renderedFields"]) {
                    if (_data["renderedFields"].hasOwnProperty(key))
                        (<any>this.renderedFields)![key] = _data["renderedFields"][key];
                }
            }
            if (_data["schema"]) {
                this.schema = {} as any;
                for (let key in _data["schema"]) {
                    if (_data["schema"].hasOwnProperty(key))
                        (<any>this.schema)![key] = _data["schema"][key] ? JsonTypeBean.fromJS(_data["schema"][key]) : new JsonTypeBean();
                }
            }
            this.self = _data["self"];
            if (Array.isArray(_data["transitionBeans"])) {
                this.transitionBeans = [] as any;
                for (let item of _data["transitionBeans"])
                    this.transitionBeans!.push(TransitionBean.fromJS(item));
            }
            if (Array.isArray(_data["transitions"])) {
                this.transitions = [] as any;
                for (let item of _data["transitions"])
                    this.transitions!.push(TransitionBean.fromJS(item));
            }
            if (_data["versionedRepresentations"]) {
                this.versionedRepresentations = {} as any;
                for (let key in _data["versionedRepresentations"]) {
                    if (_data["versionedRepresentations"].hasOwnProperty(key))
                        (<any>this.versionedRepresentations)![key] = _data["versionedRepresentations"][key] !== undefined ? _data["versionedRepresentations"][key] : {};
                }
            }
        }
    }

    static fromJS(data: any): IssueBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["changelog"] = this.changelog ? this.changelog.toJSON() : <any>undefined;
        data["editmeta"] = this.editmeta ? this.editmeta.toJSON() : <any>undefined;
        if (this.fields) {
            data["fields"] = {};
            for (let key in this.fields) {
                if (this.fields.hasOwnProperty(key))
                    (<any>data["fields"])[key] = (<any>this.fields)[key];
            }
        }
        data["fieldsToInclude"] = this.fieldsToInclude ? this.fieldsToInclude.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["key"] = this.key;
        if (this.names) {
            data["names"] = {};
            for (let key in this.names) {
                if (this.names.hasOwnProperty(key))
                    (<any>data["names"])[key] = (<any>this.names)[key];
            }
        }
        data["operations"] = this.operations ? this.operations.toJSON() : <any>undefined;
        data["properties"] = this.properties ? this.properties.toJSON() : <any>undefined;
        if (this.renderedFields) {
            data["renderedFields"] = {};
            for (let key in this.renderedFields) {
                if (this.renderedFields.hasOwnProperty(key))
                    (<any>data["renderedFields"])[key] = (<any>this.renderedFields)[key];
            }
        }
        if (this.schema) {
            data["schema"] = {};
            for (let key in this.schema) {
                if (this.schema.hasOwnProperty(key))
                    (<any>data["schema"])[key] = this.schema[key] ? this.schema[key].toJSON() : <any>undefined;
            }
        }
        data["self"] = this.self;
        if (Array.isArray(this.transitionBeans)) {
            data["transitionBeans"] = [];
            for (let item of this.transitionBeans)
                data["transitionBeans"].push(item.toJSON());
        }
        if (Array.isArray(this.transitions)) {
            data["transitions"] = [];
            for (let item of this.transitions)
                data["transitions"].push(item.toJSON());
        }
        if (this.versionedRepresentations) {
            data["versionedRepresentations"] = {};
            for (let key in this.versionedRepresentations) {
                if (this.versionedRepresentations.hasOwnProperty(key))
                    (<any>data["versionedRepresentations"])[key] = (<any>this.versionedRepresentations)[key];
            }
        }
        return data;
    }
}

export interface IIssueBean {
    changelog?: ChangelogBean;
    editmeta?: EditMetaBean;
    fields?: { [key: string]: any; };
    fieldsToInclude?: IncludedFields;
    id?: string;
    key?: string;
    names?: { [key: string]: string; };
    operations?: OpsbarBean;
    properties?: PropertiesBean;
    renderedFields?: { [key: string]: any; };
    schema?: { [key: string]: JsonTypeBean; };
    self?: string;
    transitionBeans?: TransitionBean[];
    transitions?: TransitionBean[];
    versionedRepresentations?: { [key: string]: { [key: string]: any; }; };

    [key: string]: any;
}

export class IssueRankRequestBean implements IIssueRankRequestBean {
    issues?: string[];
    rankAfterIssue?: string;
    rankBeforeIssue?: string;
    rankCustomFieldId?: number;

    [key: string]: any;

    constructor(data?: IIssueRankRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["issues"])) {
                this.issues = [] as any;
                for (let item of _data["issues"])
                    this.issues!.push(item);
            }
            this.rankAfterIssue = _data["rankAfterIssue"];
            this.rankBeforeIssue = _data["rankBeforeIssue"];
            this.rankCustomFieldId = _data["rankCustomFieldId"];
        }
    }

    static fromJS(data: any): IssueRankRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueRankRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item);
        }
        data["rankAfterIssue"] = this.rankAfterIssue;
        data["rankBeforeIssue"] = this.rankBeforeIssue;
        data["rankCustomFieldId"] = this.rankCustomFieldId;
        return data;
    }
}

export interface IIssueRankRequestBean {
    issues?: string[];
    rankAfterIssue?: string;
    rankBeforeIssue?: string;
    rankCustomFieldId?: number;

    [key: string]: any;
}

export class JsonTypeBean implements IJsonTypeBean {
    custom?: string;
    customId?: number;
    items?: string;
    system?: string;
    type?: string;

    [key: string]: any;

    constructor(data?: IJsonTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.custom = _data["custom"];
            this.customId = _data["customId"];
            this.items = _data["items"];
            this.system = _data["system"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): JsonTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new JsonTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["custom"] = this.custom;
        data["customId"] = this.customId;
        data["items"] = this.items;
        data["system"] = this.system;
        data["type"] = this.type;
        return data;
    }
}

export interface IJsonTypeBean {
    custom?: string;
    customId?: number;
    items?: string;
    system?: string;
    type?: string;

    [key: string]: any;
}

export class LinkGroupBean implements ILinkGroupBean {
    groups?: LinkGroupBean[];
    header?: SimpleLinkBean;
    id?: string;
    links?: SimpleLinkBean[];
    styleClass?: string;
    weight?: number;

    [key: string]: any;

    constructor(data?: ILinkGroupBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(LinkGroupBean.fromJS(item));
            }
            this.header = _data["header"] ? SimpleLinkBean.fromJS(_data["header"]) : <any>undefined;
            this.id = _data["id"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(SimpleLinkBean.fromJS(item));
            }
            this.styleClass = _data["styleClass"];
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): LinkGroupBean {
        data = typeof data === 'object' ? data : {};
        let result = new LinkGroupBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["id"] = this.id;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["styleClass"] = this.styleClass;
        data["weight"] = this.weight;
        return data;
    }
}

export interface ILinkGroupBean {
    groups?: LinkGroupBean[];
    header?: SimpleLinkBean;
    id?: string;
    links?: SimpleLinkBean[];
    styleClass?: string;
    weight?: number;

    [key: string]: any;
}

export class OpsbarBean implements IOpsbarBean {
    linkGroups?: LinkGroupBean[];

    [key: string]: any;

    constructor(data?: IOpsbarBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["linkGroups"])) {
                this.linkGroups = [] as any;
                for (let item of _data["linkGroups"])
                    this.linkGroups!.push(LinkGroupBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OpsbarBean {
        data = typeof data === 'object' ? data : {};
        let result = new OpsbarBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.linkGroups)) {
            data["linkGroups"] = [];
            for (let item of this.linkGroups)
                data["linkGroups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOpsbarBean {
    linkGroups?: LinkGroupBean[];

    [key: string]: any;
}

export class PartialSuccessBean implements IPartialSuccessBean {
    entries?: Entry[];

    [key: string]: any;

    constructor(data?: IPartialSuccessBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["entries"])) {
                this.entries = [] as any;
                for (let item of _data["entries"])
                    this.entries!.push(Entry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PartialSuccessBean {
        data = typeof data === 'object' ? data : {};
        let result = new PartialSuccessBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPartialSuccessBean {
    entries?: Entry[];

    [key: string]: any;
}

export class ProjectCategoryJsonBean implements IProjectCategoryJsonBean {
    description?: string;
    id?: string;
    name?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IProjectCategoryJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): ProjectCategoryJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectCategoryJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

export interface IProjectCategoryJsonBean {
    description?: string;
    id?: string;
    name?: string;
    self?: string;

    [key: string]: any;
}

export class ProjectJsonBean implements IProjectJsonBean {
    avatarUrls?: { [key: string]: string; };
    id?: string;
    key?: string;
    name?: string;
    projectCategory?: ProjectCategoryJsonBean;
    projectTypeKey?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IProjectJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["avatarUrls"]) {
                this.avatarUrls = {} as any;
                for (let key in _data["avatarUrls"]) {
                    if (_data["avatarUrls"].hasOwnProperty(key))
                        (<any>this.avatarUrls)![key] = _data["avatarUrls"][key];
                }
            }
            this.id = _data["id"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.projectCategory = _data["projectCategory"] ? ProjectCategoryJsonBean.fromJS(_data["projectCategory"]) : <any>undefined;
            this.projectTypeKey = _data["projectTypeKey"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): ProjectJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.avatarUrls) {
            data["avatarUrls"] = {};
            for (let key in this.avatarUrls) {
                if (this.avatarUrls.hasOwnProperty(key))
                    (<any>data["avatarUrls"])[key] = (<any>this.avatarUrls)[key];
            }
        }
        data["id"] = this.id;
        data["key"] = this.key;
        data["name"] = this.name;
        data["projectCategory"] = this.projectCategory ? this.projectCategory.toJSON() : <any>undefined;
        data["projectTypeKey"] = this.projectTypeKey;
        data["self"] = this.self;
        return data;
    }
}

export interface IProjectJsonBean {
    avatarUrls?: { [key: string]: string; };
    id?: string;
    key?: string;
    name?: string;
    projectCategory?: ProjectCategoryJsonBean;
    projectTypeKey?: string;
    self?: string;

    [key: string]: any;
}

export class PropertiesBean implements IPropertiesBean {
    properties?: { [key: string]: string; };

    [key: string]: any;

    constructor(data?: IPropertiesBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): PropertiesBean {
        data = typeof data === 'object' ? data : {};
        let result = new PropertiesBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

export interface IPropertiesBean {
    properties?: { [key: string]: string; };

    [key: string]: any;
}

export class RankingConfigBean implements IRankingConfigBean {
    rankCustomFieldId?: number;

    [key: string]: any;

    constructor(data?: IRankingConfigBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.rankCustomFieldId = _data["rankCustomFieldId"];
        }
    }

    static fromJS(data: any): RankingConfigBean {
        data = typeof data === 'object' ? data : {};
        let result = new RankingConfigBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["rankCustomFieldId"] = this.rankCustomFieldId;
        return data;
    }
}

export interface IRankingConfigBean {
    rankCustomFieldId?: number;

    [key: string]: any;
}

export class RelationBean implements IRelationBean {
    id?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IRelationBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): RelationBean {
        data = typeof data === 'object' ? data : {};
        let result = new RelationBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["self"] = this.self;
        return data;
    }
}

export interface IRelationBean {
    id?: string;
    self?: string;

    [key: string]: any;
}

export class SearchResultsBean implements ISearchResultsBean {
    expand?: string;
    issues?: IssueBean[];
    maxResults?: number;
    names?: { [key: string]: string; };
    schema?: { [key: string]: JsonTypeBean; };
    startAt?: number;
    total?: number;
    warningMessages?: string[];

    [key: string]: any;

    constructor(data?: ISearchResultsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.expand = _data["expand"];
            if (Array.isArray(_data["issues"])) {
                this.issues = [] as any;
                for (let item of _data["issues"])
                    this.issues!.push(IssueBean.fromJS(item));
            }
            this.maxResults = _data["maxResults"];
            if (_data["names"]) {
                this.names = {} as any;
                for (let key in _data["names"]) {
                    if (_data["names"].hasOwnProperty(key))
                        (<any>this.names)![key] = _data["names"][key];
                }
            }
            if (_data["schema"]) {
                this.schema = {} as any;
                for (let key in _data["schema"]) {
                    if (_data["schema"].hasOwnProperty(key))
                        (<any>this.schema)![key] = _data["schema"][key] ? JsonTypeBean.fromJS(_data["schema"][key]) : new JsonTypeBean();
                }
            }
            this.startAt = _data["startAt"];
            this.total = _data["total"];
            if (Array.isArray(_data["warningMessages"])) {
                this.warningMessages = [] as any;
                for (let item of _data["warningMessages"])
                    this.warningMessages!.push(item);
            }
        }
    }

    static fromJS(data: any): SearchResultsBean {
        data = typeof data === 'object' ? data : {};
        let result = new SearchResultsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["expand"] = this.expand;
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item.toJSON());
        }
        data["maxResults"] = this.maxResults;
        if (this.names) {
            data["names"] = {};
            for (let key in this.names) {
                if (this.names.hasOwnProperty(key))
                    (<any>data["names"])[key] = (<any>this.names)[key];
            }
        }
        if (this.schema) {
            data["schema"] = {};
            for (let key in this.schema) {
                if (this.schema.hasOwnProperty(key))
                    (<any>data["schema"])[key] = this.schema[key] ? this.schema[key].toJSON() : <any>undefined;
            }
        }
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.warningMessages)) {
            data["warningMessages"] = [];
            for (let item of this.warningMessages)
                data["warningMessages"].push(item);
        }
        return data;
    }
}

export interface ISearchResultsBean {
    expand?: string;
    issues?: IssueBean[];
    maxResults?: number;
    names?: { [key: string]: string; };
    schema?: { [key: string]: JsonTypeBean; };
    startAt?: number;
    total?: number;
    warningMessages?: string[];

    [key: string]: any;
}

export class SimpleLinkBean implements ISimpleLinkBean {
    href?: string;
    iconClass?: string;
    id?: string;
    label?: string;
    params?: { [key: string]: string; };
    styleClass?: string;
    title?: string;
    weight?: number;

    [key: string]: any;

    constructor(data?: ISimpleLinkBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.href = _data["href"];
            this.iconClass = _data["iconClass"];
            this.id = _data["id"];
            this.label = _data["label"];
            if (_data["params"]) {
                this.params = {} as any;
                for (let key in _data["params"]) {
                    if (_data["params"].hasOwnProperty(key))
                        (<any>this.params)![key] = _data["params"][key];
                }
            }
            this.styleClass = _data["styleClass"];
            this.title = _data["title"];
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): SimpleLinkBean {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleLinkBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["href"] = this.href;
        data["iconClass"] = this.iconClass;
        data["id"] = this.id;
        data["label"] = this.label;
        if (this.params) {
            data["params"] = {};
            for (let key in this.params) {
                if (this.params.hasOwnProperty(key))
                    (<any>data["params"])[key] = (<any>this.params)[key];
            }
        }
        data["styleClass"] = this.styleClass;
        data["title"] = this.title;
        data["weight"] = this.weight;
        return data;
    }
}

export interface ISimpleLinkBean {
    href?: string;
    iconClass?: string;
    id?: string;
    label?: string;
    params?: { [key: string]: string; };
    styleClass?: string;
    title?: string;
    weight?: number;

    [key: string]: any;
}

export class SprintBean implements ISprintBean {
    activatedDate?: string;
    autoStartStop?: boolean;
    completeDate?: string;
    endDate?: string;
    goal?: string;
    id?: number;
    incompleteIssuesDestinationId?: number;
    name?: string;
    originBoardId?: number;
    self?: string;
    startDate?: string;
    state?: string;
    synced?: boolean;

    [key: string]: any;

    constructor(data?: ISprintBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.activatedDate = _data["activatedDate"];
            this.autoStartStop = _data["autoStartStop"];
            this.completeDate = _data["completeDate"];
            this.endDate = _data["endDate"];
            this.goal = _data["goal"];
            this.id = _data["id"];
            this.incompleteIssuesDestinationId = _data["incompleteIssuesDestinationId"];
            this.name = _data["name"];
            this.originBoardId = _data["originBoardId"];
            this.self = _data["self"];
            this.startDate = _data["startDate"];
            this.state = _data["state"];
            this.synced = _data["synced"];
        }
    }

    static fromJS(data: any): SprintBean {
        data = typeof data === 'object' ? data : {};
        let result = new SprintBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["activatedDate"] = this.activatedDate;
        data["autoStartStop"] = this.autoStartStop;
        data["completeDate"] = this.completeDate;
        data["endDate"] = this.endDate;
        data["goal"] = this.goal;
        data["id"] = this.id;
        data["incompleteIssuesDestinationId"] = this.incompleteIssuesDestinationId;
        data["name"] = this.name;
        data["originBoardId"] = this.originBoardId;
        data["self"] = this.self;
        data["startDate"] = this.startDate;
        data["state"] = this.state;
        data["synced"] = this.synced;
        return data;
    }
}

export interface ISprintBean {
    activatedDate?: string;
    autoStartStop?: boolean;
    completeDate?: string;
    endDate?: string;
    goal?: string;
    id?: number;
    incompleteIssuesDestinationId?: number;
    name?: string;
    originBoardId?: number;
    self?: string;
    startDate?: string;
    state?: string;
    synced?: boolean;

    [key: string]: any;
}

export class SprintCreateBean implements ISprintCreateBean {
    autoStartStop?: boolean;
    endDate?: string;
    goal?: string;
    incompleteIssuesDestinationId?: number;
    name?: string;
    originBoardId?: number;
    startDate?: string;
    synced?: boolean;
    userProfileTimeZone?: string;

    [key: string]: any;

    constructor(data?: ISprintCreateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.autoStartStop = _data["autoStartStop"];
            this.endDate = _data["endDate"];
            this.goal = _data["goal"];
            this.incompleteIssuesDestinationId = _data["incompleteIssuesDestinationId"];
            this.name = _data["name"];
            this.originBoardId = _data["originBoardId"];
            this.startDate = _data["startDate"];
            this.synced = _data["synced"];
            this.userProfileTimeZone = _data["userProfileTimeZone"];
        }
    }

    static fromJS(data: any): SprintCreateBean {
        data = typeof data === 'object' ? data : {};
        let result = new SprintCreateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["autoStartStop"] = this.autoStartStop;
        data["endDate"] = this.endDate;
        data["goal"] = this.goal;
        data["incompleteIssuesDestinationId"] = this.incompleteIssuesDestinationId;
        data["name"] = this.name;
        data["originBoardId"] = this.originBoardId;
        data["startDate"] = this.startDate;
        data["synced"] = this.synced;
        data["userProfileTimeZone"] = this.userProfileTimeZone;
        return data;
    }
}

export interface ISprintCreateBean {
    autoStartStop?: boolean;
    endDate?: string;
    goal?: string;
    incompleteIssuesDestinationId?: number;
    name?: string;
    originBoardId?: number;
    startDate?: string;
    synced?: boolean;
    userProfileTimeZone?: string;

    [key: string]: any;
}

export class SprintSwapBean implements ISprintSwapBean {
    sprintToSwapWith?: number;
    swap?: number;

    [key: string]: any;

    constructor(data?: ISprintSwapBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.sprintToSwapWith = _data["sprintToSwapWith"];
            this.swap = _data["swap"];
        }
    }

    static fromJS(data: any): SprintSwapBean {
        data = typeof data === 'object' ? data : {};
        let result = new SprintSwapBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["sprintToSwapWith"] = this.sprintToSwapWith;
        data["swap"] = this.swap;
        return data;
    }
}

export interface ISprintSwapBean {
    sprintToSwapWith?: number;
    swap?: number;

    [key: string]: any;
}

export class StatusCategoryJsonBean implements IStatusCategoryJsonBean {
    colorName?: string;
    id?: number;
    key?: string;
    name?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IStatusCategoryJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.colorName = _data["colorName"];
            this.id = _data["id"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): StatusCategoryJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new StatusCategoryJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["colorName"] = this.colorName;
        data["id"] = this.id;
        data["key"] = this.key;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

export interface IStatusCategoryJsonBean {
    colorName?: string;
    id?: number;
    key?: string;
    name?: string;
    self?: string;

    [key: string]: any;
}

export class StatusJsonBean implements IStatusJsonBean {
    description?: string;
    iconUrl?: string;
    id?: string;
    name?: string;
    self?: string;
    statusCategory?: StatusCategoryJsonBean;
    statusColor?: string;

    [key: string]: any;

    constructor(data?: IStatusJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.self = _data["self"];
            this.statusCategory = _data["statusCategory"] ? StatusCategoryJsonBean.fromJS(_data["statusCategory"]) : <any>undefined;
            this.statusColor = _data["statusColor"];
        }
    }

    static fromJS(data: any): StatusJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new StatusJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        data["statusCategory"] = this.statusCategory ? this.statusCategory.toJSON() : <any>undefined;
        data["statusColor"] = this.statusColor;
        return data;
    }
}

export interface IStatusJsonBean {
    description?: string;
    iconUrl?: string;
    id?: string;
    name?: string;
    self?: string;
    statusCategory?: StatusCategoryJsonBean;
    statusColor?: string;

    [key: string]: any;
}

export class StringList implements IStringList {

    [key: string]: any;

    constructor(data?: IStringList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): StringList {
        data = typeof data === 'object' ? data : {};
        let result = new StringList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IStringList {

    [key: string]: any;
}

export class SubqueryBean implements ISubqueryBean {
    query?: string;

    [key: string]: any;

    constructor(data?: ISubqueryBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.query = _data["query"];
        }
    }

    static fromJS(data: any): SubqueryBean {
        data = typeof data === 'object' ? data : {};
        let result = new SubqueryBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["query"] = this.query;
        return data;
    }
}

export interface ISubqueryBean {
    query?: string;

    [key: string]: any;
}

export class TransitionBean implements ITransitionBean {
    description?: string;
    fields?: { [key: string]: FieldMetaBean; };
    id?: string;
    name?: string;
    opsbarSequence?: number;
    to?: StatusJsonBean;

    [key: string]: any;

    constructor(data?: ITransitionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            if (_data["fields"]) {
                this.fields = {} as any;
                for (let key in _data["fields"]) {
                    if (_data["fields"].hasOwnProperty(key))
                        (<any>this.fields)![key] = _data["fields"][key] ? FieldMetaBean.fromJS(_data["fields"][key]) : new FieldMetaBean();
                }
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.opsbarSequence = _data["opsbarSequence"];
            this.to = _data["to"] ? StatusJsonBean.fromJS(_data["to"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TransitionBean {
        data = typeof data === 'object' ? data : {};
        let result = new TransitionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        if (this.fields) {
            data["fields"] = {};
            for (let key in this.fields) {
                if (this.fields.hasOwnProperty(key))
                    (<any>data["fields"])[key] = this.fields[key] ? this.fields[key].toJSON() : <any>undefined;
            }
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["opsbarSequence"] = this.opsbarSequence;
        data["to"] = this.to ? this.to.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITransitionBean {
    description?: string;
    fields?: { [key: string]: FieldMetaBean; };
    id?: string;
    name?: string;
    opsbarSequence?: number;
    to?: StatusJsonBean;

    [key: string]: any;
}

export class UnmapSprintsBean implements IUnmapSprintsBean {
    sprintIds?: number[];

    [key: string]: any;

    constructor(data?: IUnmapSprintsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["sprintIds"])) {
                this.sprintIds = [] as any;
                for (let item of _data["sprintIds"])
                    this.sprintIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UnmapSprintsBean {
        data = typeof data === 'object' ? data : {};
        let result = new UnmapSprintsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.sprintIds)) {
            data["sprintIds"] = [];
            for (let item of this.sprintIds)
                data["sprintIds"].push(item);
        }
        return data;
    }
}

export interface IUnmapSprintsBean {
    sprintIds?: number[];

    [key: string]: any;
}

export class UserJsonBean implements IUserJsonBean {
    active?: boolean;
    avatarUrls?: { [key: string]: string; };
    displayName?: string;
    emailAddress?: string;
    key?: string;
    name?: string;
    self?: string;
    timeZone?: string;

    [key: string]: any;

    constructor(data?: IUserJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.active = _data["active"];
            if (_data["avatarUrls"]) {
                this.avatarUrls = {} as any;
                for (let key in _data["avatarUrls"]) {
                    if (_data["avatarUrls"].hasOwnProperty(key))
                        (<any>this.avatarUrls)![key] = _data["avatarUrls"][key];
                }
            }
            this.displayName = _data["displayName"];
            this.emailAddress = _data["emailAddress"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.self = _data["self"];
            this.timeZone = _data["timeZone"];
        }
    }

    static fromJS(data: any): UserJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new UserJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["active"] = this.active;
        if (this.avatarUrls) {
            data["avatarUrls"] = {};
            for (let key in this.avatarUrls) {
                if (this.avatarUrls.hasOwnProperty(key))
                    (<any>data["avatarUrls"])[key] = (<any>this.avatarUrls)[key];
            }
        }
        data["displayName"] = this.displayName;
        data["emailAddress"] = this.emailAddress;
        data["key"] = this.key;
        data["name"] = this.name;
        data["self"] = this.self;
        data["timeZone"] = this.timeZone;
        return data;
    }
}

export interface IUserJsonBean {
    active?: boolean;
    avatarUrls?: { [key: string]: string; };
    displayName?: string;
    emailAddress?: string;
    key?: string;
    name?: string;
    self?: string;
    timeZone?: string;

    [key: string]: any;
}

export class VersionBean implements IVersionBean {
    archived?: boolean;
    description?: string;
    expand?: string;
    id?: string;
    moveUnfixedIssuesTo?: string;
    name?: string;
    overdue?: boolean;
    project?: string;
    projectId?: number;
    releaseDate?: Date;
    releaseDateSet?: boolean;
    released?: boolean;
    self?: string;
    startDate?: Date;
    startDateSet?: boolean;
    userReleaseDate?: string;
    userStartDate?: string;

    [key: string]: any;

    constructor(data?: IVersionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.archived = _data["archived"];
            this.description = _data["description"];
            this.expand = _data["expand"];
            this.id = _data["id"];
            this.moveUnfixedIssuesTo = _data["moveUnfixedIssuesTo"];
            this.name = _data["name"];
            this.overdue = _data["overdue"];
            this.project = _data["project"];
            this.projectId = _data["projectId"];
            this.releaseDate = _data["releaseDate"] ? new Date(_data["releaseDate"].toString()) : <any>undefined;
            this.releaseDateSet = _data["releaseDateSet"];
            this.released = _data["released"];
            this.self = _data["self"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.startDateSet = _data["startDateSet"];
            this.userReleaseDate = _data["userReleaseDate"];
            this.userStartDate = _data["userStartDate"];
        }
    }

    static fromJS(data: any): VersionBean {
        data = typeof data === 'object' ? data : {};
        let result = new VersionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["archived"] = this.archived;
        data["description"] = this.description;
        data["expand"] = this.expand;
        data["id"] = this.id;
        data["moveUnfixedIssuesTo"] = this.moveUnfixedIssuesTo;
        data["name"] = this.name;
        data["overdue"] = this.overdue;
        data["project"] = this.project;
        data["projectId"] = this.projectId;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["releaseDateSet"] = this.releaseDateSet;
        data["released"] = this.released;
        data["self"] = this.self;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["startDateSet"] = this.startDateSet;
        data["userReleaseDate"] = this.userReleaseDate;
        data["userStartDate"] = this.userStartDate;
        return data;
    }
}

export interface IVersionBean {
    archived?: boolean;
    description?: string;
    expand?: string;
    id?: string;
    moveUnfixedIssuesTo?: string;
    name?: string;
    overdue?: boolean;
    project?: string;
    projectId?: number;
    releaseDate?: Date;
    releaseDateSet?: boolean;
    released?: boolean;
    self?: string;
    startDate?: Date;
    startDateSet?: boolean;
    userReleaseDate?: string;
    userStartDate?: string;

    [key: string]: any;
}

export class AppTypeBean implements IAppTypeBean {
    i18nKey?: string;
    iconUrl?: string;

    [key: string]: any;

    constructor(data?: IAppTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.i18nKey = _data["i18nKey"];
            this.iconUrl = _data["iconUrl"];
        }
    }

    static fromJS(data: any): AppTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new AppTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["i18nKey"] = this.i18nKey;
        data["iconUrl"] = this.iconUrl;
        return data;
    }
}

export interface IAppTypeBean {
    i18nKey?: string;
    iconUrl?: string;

    [key: string]: any;
}

export class BlogBean implements IBlogBean {

    [key: string]: any;

    constructor(data?: IBlogBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): BlogBean {
        data = typeof data === 'object' ? data : {};
        let result = new BlogBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IBlogBean {

    [key: string]: any;
}

export class CreateIndexBean implements ICreateIndexBean {
    entityName?: string;
    fieldNameToColumnName?: { [key: string]: string; };
    indexName?: string;
    tableName?: string;
    unique?: boolean;

    [key: string]: any;

    constructor(data?: ICreateIndexBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityName = _data["entityName"];
            if (_data["fieldNameToColumnName"]) {
                this.fieldNameToColumnName = {} as any;
                for (let key in _data["fieldNameToColumnName"]) {
                    if (_data["fieldNameToColumnName"].hasOwnProperty(key))
                        (<any>this.fieldNameToColumnName)![key] = _data["fieldNameToColumnName"][key];
                }
            }
            this.indexName = _data["indexName"];
            this.tableName = _data["tableName"];
            this.unique = _data["unique"];
        }
    }

    static fromJS(data: any): CreateIndexBean {
        data = typeof data === 'object' ? data : {};
        let result = new CreateIndexBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityName"] = this.entityName;
        if (this.fieldNameToColumnName) {
            data["fieldNameToColumnName"] = {};
            for (let key in this.fieldNameToColumnName) {
                if (this.fieldNameToColumnName.hasOwnProperty(key))
                    (<any>data["fieldNameToColumnName"])[key] = (<any>this.fieldNameToColumnName)[key];
            }
        }
        data["indexName"] = this.indexName;
        data["tableName"] = this.tableName;
        data["unique"] = this.unique;
        return data;
    }
}

export interface ICreateIndexBean {
    entityName?: string;
    fieldNameToColumnName?: { [key: string]: string; };
    indexName?: string;
    tableName?: string;
    unique?: boolean;

    [key: string]: any;
}

export class EntityList implements IEntityList {
    entities?: EntityRefBean[];

    [key: string]: any;

    constructor(data?: IEntityList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["entities"])) {
                this.entities = [] as any;
                for (let item of _data["entities"])
                    this.entities!.push(EntityRefBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityList {
        data = typeof data === 'object' ? data : {};
        let result = new EntityList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.entities)) {
            data["entities"] = [];
            for (let item of this.entities)
                data["entities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEntityList {
    entities?: EntityRefBean[];

    [key: string]: any;
}

export class EntityRefBean implements IEntityRefBean {
    key?: string;
    name?: string;
    type?: EntityTypeBean;

    [key: string]: any;

    constructor(data?: IEntityRefBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.key = _data["key"];
            this.name = _data["name"];
            this.type = _data["type"] ? EntityTypeBean.fromJS(_data["type"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityRefBean {
        data = typeof data === 'object' ? data : {};
        let result = new EntityRefBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["key"] = this.key;
        data["name"] = this.name;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEntityRefBean {
    key?: string;
    name?: string;
    type?: EntityTypeBean;

    [key: string]: any;
}

export class EntityTypeBean implements IEntityTypeBean {
    applicationTypeClassName?: string;
    i18nKey?: string;
    iconUrl?: string;
    pluralizedI18nKey?: string;

    [key: string]: any;

    constructor(data?: IEntityTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.applicationTypeClassName = _data["applicationTypeClassName"];
            this.i18nKey = _data["i18nKey"];
            this.iconUrl = _data["iconUrl"];
            this.pluralizedI18nKey = _data["pluralizedI18nKey"];
        }
    }

    static fromJS(data: any): EntityTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new EntityTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["applicationTypeClassName"] = this.applicationTypeClassName;
        data["i18nKey"] = this.i18nKey;
        data["iconUrl"] = this.iconUrl;
        data["pluralizedI18nKey"] = this.pluralizedI18nKey;
        return data;
    }
}

export interface IEntityTypeBean {
    applicationTypeClassName?: string;
    i18nKey?: string;
    iconUrl?: string;
    pluralizedI18nKey?: string;

    [key: string]: any;
}

export class EntityVersionBean implements IEntityVersionBean {
    deleted?: boolean;
    entityId?: number;
    entityType?: string;
    entityVersion?: number;
    hasVersion?: boolean;
    parentIssueId?: number;
    updateTime?: Date;

    [key: string]: any;

    constructor(data?: IEntityVersionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.deleted = _data["deleted"];
            this.entityId = _data["entityId"];
            this.entityType = _data["entityType"];
            this.entityVersion = _data["entityVersion"];
            this.hasVersion = _data["hasVersion"];
            this.parentIssueId = _data["parentIssueId"];
            this.updateTime = _data["updateTime"] ? new Date(_data["updateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityVersionBean {
        data = typeof data === 'object' ? data : {};
        let result = new EntityVersionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["deleted"] = this.deleted;
        data["entityId"] = this.entityId;
        data["entityType"] = this.entityType;
        data["entityVersion"] = this.entityVersion;
        data["hasVersion"] = this.hasVersion;
        data["parentIssueId"] = this.parentIssueId;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IEntityVersionBean {
    deleted?: boolean;
    entityId?: number;
    entityType?: string;
    entityVersion?: number;
    hasVersion?: boolean;
    parentIssueId?: number;
    updateTime?: Date;

    [key: string]: any;
}

export class JobBean implements IJobBean {
    cronExpression?: string;
    firstRunTime?: number;
    intervalInMillis?: number;
    jobId?: string;
    jobRunnerKey?: string;
    nextRunTime?: number;
    runMode?: string;
    runnable?: boolean;
    scheduleType?: string;
    timeZoneId?: string;

    [key: string]: any;

    constructor(data?: IJobBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.cronExpression = _data["cronExpression"];
            this.firstRunTime = _data["firstRunTime"];
            this.intervalInMillis = _data["intervalInMillis"];
            this.jobId = _data["jobId"];
            this.jobRunnerKey = _data["jobRunnerKey"];
            this.nextRunTime = _data["nextRunTime"];
            this.runMode = _data["runMode"];
            this.runnable = _data["runnable"];
            this.scheduleType = _data["scheduleType"];
            this.timeZoneId = _data["timeZoneId"];
        }
    }

    static fromJS(data: any): JobBean {
        data = typeof data === 'object' ? data : {};
        let result = new JobBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["cronExpression"] = this.cronExpression;
        data["firstRunTime"] = this.firstRunTime;
        data["intervalInMillis"] = this.intervalInMillis;
        data["jobId"] = this.jobId;
        data["jobRunnerKey"] = this.jobRunnerKey;
        data["nextRunTime"] = this.nextRunTime;
        data["runMode"] = this.runMode;
        data["runnable"] = this.runnable;
        data["scheduleType"] = this.scheduleType;
        data["timeZoneId"] = this.timeZoneId;
        return data;
    }
}

export interface IJobBean {
    cronExpression?: string;
    firstRunTime?: number;
    intervalInMillis?: number;
    jobId?: string;
    jobRunnerKey?: string;
    nextRunTime?: number;
    runMode?: string;
    runnable?: boolean;
    scheduleType?: string;
    timeZoneId?: string;

    [key: string]: any;
}

export class JobRunBean implements IJobRunBean {
    durationInMillis?: number;
    message?: string;
    runOutcome?: string;
    startTime?: Date;

    [key: string]: any;

    constructor(data?: IJobRunBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.durationInMillis = _data["durationInMillis"];
            this.message = _data["message"];
            this.runOutcome = _data["runOutcome"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): JobRunBean {
        data = typeof data === 'object' ? data : {};
        let result = new JobRunBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["durationInMillis"] = this.durationInMillis;
        data["message"] = this.message;
        data["runOutcome"] = this.runOutcome;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IJobRunBean {
    durationInMillis?: number;
    message?: string;
    runOutcome?: string;
    startTime?: Date;

    [key: string]: any;
}

export class PatternRepresentation implements IPatternRepresentation {
    delay?: number;
    enabled?: boolean;
    id?: number;
    pattern?: string;

    [key: string]: any;

    constructor(data?: IPatternRepresentation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.delay = _data["delay"];
            this.enabled = _data["enabled"];
            this.id = _data["id"];
            this.pattern = _data["pattern"];
        }
    }

    static fromJS(data: any): PatternRepresentation {
        data = typeof data === 'object' ? data : {};
        let result = new PatternRepresentation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["delay"] = this.delay;
        data["enabled"] = this.enabled;
        data["id"] = this.id;
        data["pattern"] = this.pattern;
        return data;
    }
}

export interface IPatternRepresentation {
    delay?: number;
    enabled?: boolean;
    id?: number;
    pattern?: string;

    [key: string]: any;
}

export class PermissionBean implements IPermissionBean {
    group?: string;
    permType?: string;

    [key: string]: any;

    constructor(data?: IPermissionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.group = _data["group"];
            this.permType = _data["permType"];
        }
    }

    static fromJS(data: any): PermissionBean {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["group"] = this.group;
        data["permType"] = this.permType;
        return data;
    }
}

export interface IPermissionBean {
    group?: string;
    permType?: string;

    [key: string]: any;
}

export class PrioritySchemeResponse implements IPrioritySchemeResponse {
    defaultPriority?: string;
    description?: string;
    id?: number;
    name?: string;
    priorities?: string[];

    [key: string]: any;

    constructor(data?: IPrioritySchemeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.defaultPriority = _data["defaultPriority"];
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["priorities"])) {
                this.priorities = [] as any;
                for (let item of _data["priorities"])
                    this.priorities!.push(item);
            }
        }
    }

    static fromJS(data: any): PrioritySchemeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PrioritySchemeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["defaultPriority"] = this.defaultPriority;
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.priorities)) {
            data["priorities"] = [];
            for (let item of this.priorities)
                data["priorities"].push(item);
        }
        return data;
    }
}

export interface IPrioritySchemeResponse {
    defaultPriority?: string;
    description?: string;
    id?: number;
    name?: string;
    priorities?: string[];

    [key: string]: any;
}

export class ProductLicenseTO implements IProductLicenseTO {
    isUnlimitedNumberOfUsers?: boolean;
    licenseKey?: string;
    locale?: Locale;
    numberOfUsers?: number;
    productDisplayName?: string;
    productKey?: string;

    [key: string]: any;

    constructor(data?: IProductLicenseTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.isUnlimitedNumberOfUsers = _data["isUnlimitedNumberOfUsers"];
            this.licenseKey = _data["licenseKey"];
            this.locale = _data["locale"] ? Locale.fromJS(_data["locale"]) : <any>undefined;
            this.numberOfUsers = _data["numberOfUsers"];
            this.productDisplayName = _data["productDisplayName"];
            this.productKey = _data["productKey"];
        }
    }

    static fromJS(data: any): ProductLicenseTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProductLicenseTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["isUnlimitedNumberOfUsers"] = this.isUnlimitedNumberOfUsers;
        data["licenseKey"] = this.licenseKey;
        data["locale"] = this.locale ? this.locale.toJSON() : <any>undefined;
        data["numberOfUsers"] = this.numberOfUsers;
        data["productDisplayName"] = this.productDisplayName;
        data["productKey"] = this.productKey;
        return data;
    }
}

export interface IProductLicenseTO {
    isUnlimitedNumberOfUsers?: boolean;
    licenseKey?: string;
    locale?: Locale;
    numberOfUsers?: number;
    productDisplayName?: string;
    productKey?: string;

    [key: string]: any;
}

export class ProjectInputBean implements IProjectInputBean {
    assigneeType?: ProjectInputBeanAssigneeType;
    avatarId?: number;
    categoryId?: number;
    description?: string;
    issueSecurityScheme?: number;
    key?: string;
    lead?: string;
    name?: string;
    notificationScheme?: number;
    permissionScheme?: number;
    projectTemplateKey?: string;
    projectTypeKey?: string;
    url?: string;
    workflowSchemeId?: number;

    [key: string]: any;

    constructor(data?: IProjectInputBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.assigneeType = _data["assigneeType"];
            this.avatarId = _data["avatarId"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            this.issueSecurityScheme = _data["issueSecurityScheme"];
            this.key = _data["key"];
            this.lead = _data["lead"];
            this.name = _data["name"];
            this.notificationScheme = _data["notificationScheme"];
            this.permissionScheme = _data["permissionScheme"];
            this.projectTemplateKey = _data["projectTemplateKey"];
            this.projectTypeKey = _data["projectTypeKey"];
            this.url = _data["url"];
            this.workflowSchemeId = _data["workflowSchemeId"];
        }
    }

    static fromJS(data: any): ProjectInputBean {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectInputBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["assigneeType"] = this.assigneeType;
        data["avatarId"] = this.avatarId;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        data["issueSecurityScheme"] = this.issueSecurityScheme;
        data["key"] = this.key;
        data["lead"] = this.lead;
        data["name"] = this.name;
        data["notificationScheme"] = this.notificationScheme;
        data["permissionScheme"] = this.permissionScheme;
        data["projectTemplateKey"] = this.projectTemplateKey;
        data["projectTypeKey"] = this.projectTypeKey;
        data["url"] = this.url;
        data["workflowSchemeId"] = this.workflowSchemeId;
        return data;
    }
}

export interface IProjectInputBean {
    assigneeType?: ProjectInputBeanAssigneeType;
    avatarId?: number;
    categoryId?: number;
    description?: string;
    issueSecurityScheme?: number;
    key?: string;
    lead?: string;
    name?: string;
    notificationScheme?: number;
    permissionScheme?: number;
    projectTemplateKey?: string;
    projectTypeKey?: string;
    url?: string;
    workflowSchemeId?: number;

    [key: string]: any;
}

export class RegisterItemHolder implements IRegisterItemHolder {
    isLocked?: boolean;
    isManaged?: boolean;

    [key: string]: any;

    constructor(data?: IRegisterItemHolder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.isLocked = _data["isLocked"];
            this.isManaged = _data["isManaged"];
        }
    }

    static fromJS(data: any): RegisterItemHolder {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterItemHolder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["isLocked"] = this.isLocked;
        data["isManaged"] = this.isManaged;
        return data;
    }
}

export interface IRegisterItemHolder {
    isLocked?: boolean;
    isManaged?: boolean;

    [key: string]: any;
}

export class Gadget implements IGadget {
    filterId?: number;
    filterName?: string;
    gadgetUri?: string;
    jql?: string;
    portalId?: number;
    userPrefs?: { [key: string]: string; };

    [key: string]: any;

    constructor(data?: IGadget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.filterId = _data["filterId"];
            this.filterName = _data["filterName"];
            this.gadgetUri = _data["gadgetUri"];
            this.jql = _data["jql"];
            this.portalId = _data["portalId"];
            if (_data["userPrefs"]) {
                this.userPrefs = {} as any;
                for (let key in _data["userPrefs"]) {
                    if (_data["userPrefs"].hasOwnProperty(key))
                        (<any>this.userPrefs)![key] = _data["userPrefs"][key];
                }
            }
        }
    }

    static fromJS(data: any): Gadget {
        data = typeof data === 'object' ? data : {};
        let result = new Gadget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["filterId"] = this.filterId;
        data["filterName"] = this.filterName;
        data["gadgetUri"] = this.gadgetUri;
        data["jql"] = this.jql;
        data["portalId"] = this.portalId;
        if (this.userPrefs) {
            data["userPrefs"] = {};
            for (let key in this.userPrefs) {
                if (this.userPrefs.hasOwnProperty(key))
                    (<any>data["userPrefs"])[key] = (<any>this.userPrefs)[key];
            }
        }
        return data;
    }
}

export interface IGadget {
    filterId?: number;
    filterName?: string;
    gadgetUri?: string;
    jql?: string;
    portalId?: number;
    userPrefs?: { [key: string]: string; };

    [key: string]: any;
}

export class Tooltip implements ITooltip {
    id?: string;

    [key: string]: any;

    constructor(data?: ITooltip) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Tooltip {
        data = typeof data === 'object' ? data : {};
        let result = new Tooltip();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }
}

export interface ITooltip {
    id?: string;

    [key: string]: any;
}

export class TypeParameter implements ITypeParameter {

    [key: string]: any;

    constructor(data?: ITypeParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): TypeParameter {
        data = typeof data === 'object' ? data : {};
        let result = new TypeParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ITypeParameter {

    [key: string]: any;
}

export class AssignIssueTypesRequest implements IAssignIssueTypesRequest {
    issueTypes?: string[];
    name?: string;
    valid?: boolean;

    [key: string]: any;

    constructor(data?: IAssignIssueTypesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["issueTypes"])) {
                this.issueTypes = [] as any;
                for (let item of _data["issueTypes"])
                    this.issueTypes!.push(item);
            }
            this.name = _data["name"];
            this.valid = _data["valid"];
        }
    }

    static fromJS(data: any): AssignIssueTypesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AssignIssueTypesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.issueTypes)) {
            data["issueTypes"] = [];
            for (let item of this.issueTypes)
                data["issueTypes"].push(item);
        }
        data["name"] = this.name;
        data["valid"] = this.valid;
        return data;
    }
}

export interface IAssignIssueTypesRequest {
    issueTypes?: string[];
    name?: string;
    valid?: boolean;

    [key: string]: any;
}

export class IssueContextParam implements IIssueContextParam {
    issueTypeId?: string;
    projectId?: number;

    [key: string]: any;

    constructor(data?: IIssueContextParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.issueTypeId = _data["issueTypeId"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): IssueContextParam {
        data = typeof data === 'object' ? data : {};
        let result = new IssueContextParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["issueTypeId"] = this.issueTypeId;
        data["projectId"] = this.projectId;
        return data;
    }
}

export interface IIssueContextParam {
    issueTypeId?: string;
    projectId?: number;

    [key: string]: any;
}

export class Option implements IOption {
    childOptions?: Option[];
    id?: number;
    name?: string;
    optionId?: number;
    value?: string;

    [key: string]: any;

    constructor(data?: IOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["childOptions"])) {
                this.childOptions = [] as any;
                for (let item of _data["childOptions"])
                    this.childOptions!.push(Option.fromJS(item));
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.optionId = _data["optionId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Option {
        data = typeof data === 'object' ? data : {};
        let result = new Option();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.childOptions)) {
            data["childOptions"] = [];
            for (let item of this.childOptions)
                data["childOptions"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["optionId"] = this.optionId;
        data["value"] = this.value;
        return data;
    }
}

export interface IOption {
    childOptions?: Option[];
    id?: number;
    name?: string;
    optionId?: number;
    value?: string;

    [key: string]: any;
}

export class OptionsSettings implements IOptionsSettings {
    issueContext?: IssueContextParam;
    options?: Option[];

    [key: string]: any;

    constructor(data?: IOptionsSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.issueContext = _data["issueContext"] ? IssueContextParam.fromJS(_data["issueContext"]) : <any>undefined;
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(Option.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OptionsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new OptionsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["issueContext"] = this.issueContext ? this.issueContext.toJSON() : <any>undefined;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOptionsSettings {
    issueContext?: IssueContextParam;
    options?: Option[];

    [key: string]: any;
}

export class RemoveWorkflowRequest implements IRemoveWorkflowRequest {
    nextDefaultWorkflow?: string;
    workflow?: string;

    [key: string]: any;

    constructor(data?: IRemoveWorkflowRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.nextDefaultWorkflow = _data["nextDefaultWorkflow"];
            this.workflow = _data["workflow"];
        }
    }

    static fromJS(data: any): RemoveWorkflowRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveWorkflowRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["nextDefaultWorkflow"] = this.nextDefaultWorkflow;
        data["workflow"] = this.workflow;
        return data;
    }
}

export interface IRemoveWorkflowRequest {
    nextDefaultWorkflow?: string;
    workflow?: string;

    [key: string]: any;
}

export class WorkflowSchemeRequest implements IWorkflowSchemeRequest {
    defaultWorkflow?: boolean;
    issueTypes?: string[];
    workflow?: string;

    [key: string]: any;

    constructor(data?: IWorkflowSchemeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.defaultWorkflow = _data["defaultWorkflow"];
            if (Array.isArray(_data["issueTypes"])) {
                this.issueTypes = [] as any;
                for (let item of _data["issueTypes"])
                    this.issueTypes!.push(item);
            }
            this.workflow = _data["workflow"];
        }
    }

    static fromJS(data: any): WorkflowSchemeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSchemeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["defaultWorkflow"] = this.defaultWorkflow;
        if (Array.isArray(this.issueTypes)) {
            data["issueTypes"] = [];
            for (let item of this.issueTypes)
                data["issueTypes"].push(item);
        }
        data["workflow"] = this.workflow;
        return data;
    }
}

export interface IWorkflowSchemeRequest {
    defaultWorkflow?: boolean;
    issueTypes?: string[];
    workflow?: string;

    [key: string]: any;
}

export class ShareBean implements IShareBean {
    emails?: string[];
    jql?: string;
    message?: string;
    usernames?: string[];

    [key: string]: any;

    constructor(data?: IShareBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            this.jql = _data["jql"];
            this.message = _data["message"];
            if (Array.isArray(_data["usernames"])) {
                this.usernames = [] as any;
                for (let item of _data["usernames"])
                    this.usernames!.push(item);
            }
        }
    }

    static fromJS(data: any): ShareBean {
        data = typeof data === 'object' ? data : {};
        let result = new ShareBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        data["jql"] = this.jql;
        data["message"] = this.message;
        if (Array.isArray(this.usernames)) {
            data["usernames"] = [];
            for (let item of this.usernames)
                data["usernames"].push(item);
        }
        return data;
    }
}

export interface IShareBean {
    emails?: string[];
    jql?: string;
    message?: string;
    usernames?: string[];

    [key: string]: any;
}

export class RestInvocationHistory implements IRestInvocationHistory {
    empty?: boolean;

    [key: string]: any;

    constructor(data?: IRestInvocationHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.empty = _data["empty"];
        }
    }

    static fromJS(data: any): RestInvocationHistory {
        data = typeof data === 'object' ? data : {};
        let result = new RestInvocationHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["empty"] = this.empty;
        return data;
    }
}

export interface IRestInvocationHistory {
    empty?: boolean;

    [key: string]: any;
}

export class RestWebhook implements IRestWebhook {
    active?: boolean;
    configuration?: { [key: string]: string; };
    credentials?: RestWebhookCredentials;
    empty?: boolean;
    events?: string[];
    name?: string;
    scopeType?: string;
    sslVerificationRequired?: boolean;
    statistics?: Statistics;
    url?: string;

    [key: string]: any;

    constructor(data?: IRestWebhook) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.active = _data["active"];
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
            this.credentials = _data["credentials"] ? RestWebhookCredentials.fromJS(_data["credentials"]) : <any>undefined;
            this.empty = _data["empty"];
            if (Array.isArray(_data["events"])) {
                this.events = [] as any;
                for (let item of _data["events"])
                    this.events!.push(item);
            }
            this.name = _data["name"];
            this.scopeType = _data["scopeType"];
            this.sslVerificationRequired = _data["sslVerificationRequired"];
            this.statistics = _data["statistics"] ? Statistics.fromJS(_data["statistics"]) : <any>undefined;
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): RestWebhook {
        data = typeof data === 'object' ? data : {};
        let result = new RestWebhook();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["active"] = this.active;
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        data["credentials"] = this.credentials ? this.credentials.toJSON() : <any>undefined;
        data["empty"] = this.empty;
        if (Array.isArray(this.events)) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item);
        }
        data["name"] = this.name;
        data["scopeType"] = this.scopeType;
        data["sslVerificationRequired"] = this.sslVerificationRequired;
        data["statistics"] = this.statistics ? this.statistics.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data;
    }
}

export interface IRestWebhook {
    active?: boolean;
    configuration?: { [key: string]: string; };
    credentials?: RestWebhookCredentials;
    empty?: boolean;
    events?: string[];
    name?: string;
    scopeType?: string;
    sslVerificationRequired?: boolean;
    statistics?: Statistics;
    url?: string;

    [key: string]: any;
}

export class RestWebhookCredentials implements IRestWebhookCredentials {
    empty?: boolean;
    password?: string;
    username?: string;

    [key: string]: any;

    constructor(data?: IRestWebhookCredentials) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.empty = _data["empty"];
            this.password = _data["password"];
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): RestWebhookCredentials {
        data = typeof data === 'object' ? data : {};
        let result = new RestWebhookCredentials();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["empty"] = this.empty;
        data["password"] = this.password;
        data["username"] = this.username;
        return data;
    }
}

export interface IRestWebhookCredentials {
    empty?: boolean;
    password?: string;
    username?: string;

    [key: string]: any;
}

export class A11yPersonalSettingBean implements IA11yPersonalSettingBean {
    enabled?: boolean;
    key?: string;

    [key: string]: any;

    constructor(data?: IA11yPersonalSettingBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.enabled = _data["enabled"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): A11yPersonalSettingBean {
        data = typeof data === 'object' ? data : {};
        let result = new A11yPersonalSettingBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["enabled"] = this.enabled;
        data["key"] = this.key;
        return data;
    }
}

export interface IA11yPersonalSettingBean {
    enabled?: boolean;
    key?: string;

    [key: string]: any;
}

export class ActiveCategory implements IActiveCategory {
    current?: string;

    [key: string]: any;

    constructor(data?: IActiveCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.current = _data["current"];
        }
    }

    static fromJS(data: any): ActiveCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["current"] = this.current;
        return data;
    }
}

export interface IActiveCategory {
    current?: string;

    [key: string]: any;
}

export class ActorInputBean implements IActorInputBean {
    group?: string[];
    user?: string[];

    [key: string]: any;

    constructor(data?: IActorInputBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["group"])) {
                this.group = [] as any;
                for (let item of _data["group"])
                    this.group!.push(item);
            }
            if (Array.isArray(_data["user"])) {
                this.user = [] as any;
                for (let item of _data["user"])
                    this.user!.push(item);
            }
        }
    }

    static fromJS(data: any): ActorInputBean {
        data = typeof data === 'object' ? data : {};
        let result = new ActorInputBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.group)) {
            data["group"] = [];
            for (let item of this.group)
                data["group"].push(item);
        }
        if (Array.isArray(this.user)) {
            data["user"] = [];
            for (let item of this.user)
                data["user"].push(item);
        }
        return data;
    }
}

export interface IActorInputBean {
    group?: string[];
    user?: string[];

    [key: string]: any;
}

export class ActorsMap implements IActorsMap {
    empty?: boolean;

    [key: string]: string[] | any;

    constructor(data?: IActorsMap) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.empty = _data["empty"];
        }
    }

    static fromJS(data: any): ActorsMap {
        data = typeof data === 'object' ? data : {};
        let result = new ActorsMap();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["empty"] = this.empty;
        return data;
    }
}

export interface IActorsMap {
    empty?: boolean;

    [key: string]: string[] | any;
}

export class AddFieldBean implements IAddFieldBean {
    fieldId?: string;

    [key: string]: any;

    constructor(data?: IAddFieldBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.fieldId = _data["fieldId"];
        }
    }

    static fromJS(data: any): AddFieldBean {
        data = typeof data === 'object' ? data : {};
        let result = new AddFieldBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["fieldId"] = this.fieldId;
        return data;
    }
}

export interface IAddFieldBean {
    fieldId?: string;

    [key: string]: any;
}

export class AddGroupBean implements IAddGroupBean {
    name?: string;

    [key: string]: any;

    constructor(data?: IAddGroupBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AddGroupBean {
        data = typeof data === 'object' ? data : {};
        let result = new AddGroupBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        return data;
    }
}

export interface IAddGroupBean {
    name?: string;

    [key: string]: any;
}

export class AddReactionRequestBean implements IAddReactionRequestBean {
    commentId?: number;
    emojiId?: string;

    [key: string]: any;

    constructor(data?: IAddReactionRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.commentId = _data["commentId"];
            this.emojiId = _data["emojiId"];
        }
    }

    static fromJS(data: any): AddReactionRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new AddReactionRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["commentId"] = this.commentId;
        data["emojiId"] = this.emojiId;
        return data;
    }
}

export interface IAddReactionRequestBean {
    commentId?: number;
    emojiId?: string;

    [key: string]: any;
}

export class AdminHistoryLink implements IAdminHistoryLink {

    [key: string]: any;

    constructor(data?: IAdminHistoryLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): AdminHistoryLink {
        data = typeof data === 'object' ? data : {};
        let result = new AdminHistoryLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IAdminHistoryLink {

    [key: string]: any;
}

export class AffectedEntityBean implements IAffectedEntityBean {
    description?: string;
    numberOfOccurrences?: number;
    type?: AffectedEntityBeanType;
    uri?: string;
    uriDisplayName?: string;

    [key: string]: any;

    constructor(data?: IAffectedEntityBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.numberOfOccurrences = _data["numberOfOccurrences"];
            this.type = _data["type"];
            this.uri = _data["uri"];
            this.uriDisplayName = _data["uriDisplayName"];
        }
    }

    static fromJS(data: any): AffectedEntityBean {
        data = typeof data === 'object' ? data : {};
        let result = new AffectedEntityBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["numberOfOccurrences"] = this.numberOfOccurrences;
        data["type"] = this.type;
        data["uri"] = this.uri;
        data["uriDisplayName"] = this.uriDisplayName;
        return data;
    }
}

export interface IAffectedEntityBean {
    description?: string;
    numberOfOccurrences?: number;
    type?: AffectedEntityBeanType;
    uri?: string;
    uriDisplayName?: string;

    [key: string]: any;
}

export class AppMonitoringRestEntity implements IAppMonitoringRestEntity {
    enabled?: boolean;

    [key: string]: any;

    constructor(data?: IAppMonitoringRestEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.enabled = _data["enabled"];
        }
    }

    static fromJS(data: any): AppMonitoringRestEntity {
        data = typeof data === 'object' ? data : {};
        let result = new AppMonitoringRestEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["enabled"] = this.enabled;
        return data;
    }
}

export interface IAppMonitoringRestEntity {
    enabled?: boolean;

    [key: string]: any;
}

export class Application implements IApplication {
    name?: string;
    type?: string;

    [key: string]: any;

    constructor(data?: IApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Application {
        data = typeof data === 'object' ? data : {};
        let result = new Application();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

export interface IApplication {
    name?: string;
    type?: string;

    [key: string]: any;
}

export class ApplicationPropertyBean implements IApplicationPropertyBean {
    id?: string;
    value?: string;

    [key: string]: any;

    constructor(data?: IApplicationPropertyBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ApplicationPropertyBean {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationPropertyBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["value"] = this.value;
        return data;
    }
}

export interface IApplicationPropertyBean {
    id?: string;
    value?: string;

    [key: string]: any;
}

export class ApplicationRoleBean implements IApplicationRoleBean {
    defaultGroups?: string[];
    defined?: boolean;
    groups?: string[];
    hasUnlimitedSeats?: boolean;
    key?: string;
    name?: string;
    numberOfSeats?: number;
    platform?: boolean;
    remainingSeats?: number;
    selectedByDefault?: boolean;
    userCount?: number;
    userCountDescription?: string;

    [key: string]: any;

    constructor(data?: IApplicationRoleBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["defaultGroups"])) {
                this.defaultGroups = [] as any;
                for (let item of _data["defaultGroups"])
                    this.defaultGroups!.push(item);
            }
            this.defined = _data["defined"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            this.hasUnlimitedSeats = _data["hasUnlimitedSeats"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.numberOfSeats = _data["numberOfSeats"];
            this.platform = _data["platform"];
            this.remainingSeats = _data["remainingSeats"];
            this.selectedByDefault = _data["selectedByDefault"];
            this.userCount = _data["userCount"];
            this.userCountDescription = _data["userCountDescription"];
        }
    }

    static fromJS(data: any): ApplicationRoleBean {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRoleBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.defaultGroups)) {
            data["defaultGroups"] = [];
            for (let item of this.defaultGroups)
                data["defaultGroups"].push(item);
        }
        data["defined"] = this.defined;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        data["hasUnlimitedSeats"] = this.hasUnlimitedSeats;
        data["key"] = this.key;
        data["name"] = this.name;
        data["numberOfSeats"] = this.numberOfSeats;
        data["platform"] = this.platform;
        data["remainingSeats"] = this.remainingSeats;
        data["selectedByDefault"] = this.selectedByDefault;
        data["userCount"] = this.userCount;
        data["userCountDescription"] = this.userCountDescription;
        return data;
    }
}

export interface IApplicationRoleBean {
    defaultGroups?: string[];
    defined?: boolean;
    groups?: string[];
    hasUnlimitedSeats?: boolean;
    key?: string;
    name?: string;
    numberOfSeats?: number;
    platform?: boolean;
    remainingSeats?: number;
    selectedByDefault?: boolean;
    userCount?: number;
    userCountDescription?: string;

    [key: string]: any;
}

export class AssociateProjectsBean implements IAssociateProjectsBean {
    idsOrKeys?: string[];

    [key: string]: any;

    constructor(data?: IAssociateProjectsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["idsOrKeys"])) {
                this.idsOrKeys = [] as any;
                for (let item of _data["idsOrKeys"])
                    this.idsOrKeys!.push(item);
            }
        }
    }

    static fromJS(data: any): AssociateProjectsBean {
        data = typeof data === 'object' ? data : {};
        let result = new AssociateProjectsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.idsOrKeys)) {
            data["idsOrKeys"] = [];
            for (let item of this.idsOrKeys)
                data["idsOrKeys"].push(item);
        }
        return data;
    }
}

export interface IAssociateProjectsBean {
    idsOrKeys?: string[];

    [key: string]: any;
}

export class AttachmentArchiveEntry implements IAttachmentArchiveEntry {
    abbreviatedName?: string;
    entryIndex?: number;
    mediaType?: string;
    name?: string;
    size?: number;

    [key: string]: any;

    constructor(data?: IAttachmentArchiveEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.abbreviatedName = _data["abbreviatedName"];
            this.entryIndex = _data["entryIndex"];
            this.mediaType = _data["mediaType"];
            this.name = _data["name"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): AttachmentArchiveEntry {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentArchiveEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["abbreviatedName"] = this.abbreviatedName;
        data["entryIndex"] = this.entryIndex;
        data["mediaType"] = this.mediaType;
        data["name"] = this.name;
        data["size"] = this.size;
        return data;
    }
}

export interface IAttachmentArchiveEntry {
    abbreviatedName?: string;
    entryIndex?: number;
    mediaType?: string;
    name?: string;
    size?: number;

    [key: string]: any;
}

export class AttachmentArchiveImpl implements IAttachmentArchiveImpl {
    entries?: AttachmentArchiveEntry[];
    /** Total number of entries available (can be larger that what was asked for) */
    totalEntryCount?: number;

    [key: string]: any;

    constructor(data?: IAttachmentArchiveImpl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["entries"])) {
                this.entries = [] as any;
                for (let item of _data["entries"])
                    this.entries!.push(AttachmentArchiveEntry.fromJS(item));
            }
            this.totalEntryCount = _data["totalEntryCount"];
        }
    }

    static fromJS(data: any): AttachmentArchiveImpl {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentArchiveImpl();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        data["totalEntryCount"] = this.totalEntryCount;
        return data;
    }
}

export interface IAttachmentArchiveImpl {
    entries?: AttachmentArchiveEntry[];
    /** Total number of entries available (can be larger that what was asked for) */
    totalEntryCount?: number;

    [key: string]: any;
}

export class AttachmentBean implements IAttachmentBean {

    [key: string]: any;

    constructor(data?: IAttachmentBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): AttachmentBean {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IAttachmentBean {

    [key: string]: any;
}

export class AttachmentJsonBean implements IAttachmentJsonBean {
    author?: UserJsonBean;
    content?: string;
    created?: Date;
    filename?: string;
    id?: string;
    mimeType?: string;
    self?: string;
    size?: number;
    thumbnail?: string;

    [key: string]: any;

    constructor(data?: IAttachmentJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.author = _data["author"] ? UserJsonBean.fromJS(_data["author"]) : <any>undefined;
            this.content = _data["content"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.filename = _data["filename"];
            this.id = _data["id"];
            this.mimeType = _data["mimeType"];
            this.self = _data["self"];
            this.size = _data["size"];
            this.thumbnail = _data["thumbnail"];
        }
    }

    static fromJS(data: any): AttachmentJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["content"] = this.content;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["filename"] = this.filename;
        data["id"] = this.id;
        data["mimeType"] = this.mimeType;
        data["self"] = this.self;
        data["size"] = this.size;
        data["thumbnail"] = this.thumbnail;
        return data;
    }
}

export interface IAttachmentJsonBean {
    author?: UserJsonBean;
    content?: string;
    created?: Date;
    filename?: string;
    id?: string;
    mimeType?: string;
    self?: string;
    size?: number;
    thumbnail?: string;

    [key: string]: any;
}

export class AttachmentMetaBean implements IAttachmentMetaBean {
    enabled?: boolean;
    /** Upload limit in bytes */
    uploadLimit?: number;

    [key: string]: any;

    constructor(data?: IAttachmentMetaBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.enabled = _data["enabled"];
            this.uploadLimit = _data["uploadLimit"];
        }
    }

    static fromJS(data: any): AttachmentMetaBean {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentMetaBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["enabled"] = this.enabled;
        data["uploadLimit"] = this.uploadLimit;
        return data;
    }
}

export interface IAttachmentMetaBean {
    enabled?: boolean;
    /** Upload limit in bytes */
    uploadLimit?: number;

    [key: string]: any;
}

export class AuthParams implements IAuthParams {
    password?: string;
    username?: string;

    [key: string]: any;

    constructor(data?: IAuthParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.password = _data["password"];
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): AuthParams {
        data = typeof data === 'object' ? data : {};
        let result = new AuthParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["password"] = this.password;
        data["username"] = this.username;
        return data;
    }
}

export interface IAuthParams {
    password?: string;
    username?: string;

    [key: string]: any;
}

export class AuthSuccess implements IAuthSuccess {
    loginInfo?: LoginInfo;
    session?: SessionInfo;

    [key: string]: any;

    constructor(data?: IAuthSuccess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.loginInfo = _data["loginInfo"] ? LoginInfo.fromJS(_data["loginInfo"]) : <any>undefined;
            this.session = _data["session"] ? SessionInfo.fromJS(_data["session"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AuthSuccess {
        data = typeof data === 'object' ? data : {};
        let result = new AuthSuccess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["loginInfo"] = this.loginInfo ? this.loginInfo.toJSON() : <any>undefined;
        data["session"] = this.session ? this.session.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAuthSuccess {
    loginInfo?: LoginInfo;
    session?: SessionInfo;

    [key: string]: any;
}

export class AutoCompleteResponseBean implements IAutoCompleteResponseBean {
    jqlReservedWords?: string[];
    visibleFieldNames?: string[];
    visibleFunctionNames?: string[];

    [key: string]: any;

    constructor(data?: IAutoCompleteResponseBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["jqlReservedWords"])) {
                this.jqlReservedWords = [] as any;
                for (let item of _data["jqlReservedWords"])
                    this.jqlReservedWords!.push(item);
            }
            if (Array.isArray(_data["visibleFieldNames"])) {
                this.visibleFieldNames = [] as any;
                for (let item of _data["visibleFieldNames"])
                    this.visibleFieldNames!.push(item);
            }
            if (Array.isArray(_data["visibleFunctionNames"])) {
                this.visibleFunctionNames = [] as any;
                for (let item of _data["visibleFunctionNames"])
                    this.visibleFunctionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): AutoCompleteResponseBean {
        data = typeof data === 'object' ? data : {};
        let result = new AutoCompleteResponseBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.jqlReservedWords)) {
            data["jqlReservedWords"] = [];
            for (let item of this.jqlReservedWords)
                data["jqlReservedWords"].push(item);
        }
        if (Array.isArray(this.visibleFieldNames)) {
            data["visibleFieldNames"] = [];
            for (let item of this.visibleFieldNames)
                data["visibleFieldNames"].push(item);
        }
        if (Array.isArray(this.visibleFunctionNames)) {
            data["visibleFunctionNames"] = [];
            for (let item of this.visibleFunctionNames)
                data["visibleFunctionNames"].push(item);
        }
        return data;
    }
}

export interface IAutoCompleteResponseBean {
    jqlReservedWords?: string[];
    visibleFieldNames?: string[];
    visibleFunctionNames?: string[];

    [key: string]: any;
}

export class AutoCompleteResultWrapper implements IAutoCompleteResultWrapper {

    [key: string]: any;

    constructor(data?: IAutoCompleteResultWrapper) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): AutoCompleteResultWrapper {
        data = typeof data === 'object' ? data : {};
        let result = new AutoCompleteResultWrapper();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IAutoCompleteResultWrapper {

    [key: string]: any;
}

export class AvailableIssueTypesRequestBean implements IAvailableIssueTypesRequestBean {
    ignoredIssueTypeIds?: string[];

    [key: string]: any;

    constructor(data?: IAvailableIssueTypesRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["ignoredIssueTypeIds"])) {
                this.ignoredIssueTypeIds = [] as any;
                for (let item of _data["ignoredIssueTypeIds"])
                    this.ignoredIssueTypeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): AvailableIssueTypesRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableIssueTypesRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.ignoredIssueTypeIds)) {
            data["ignoredIssueTypeIds"] = [];
            for (let item of this.ignoredIssueTypeIds)
                data["ignoredIssueTypeIds"].push(item);
        }
        return data;
    }
}

export interface IAvailableIssueTypesRequestBean {
    ignoredIssueTypeIds?: string[];

    [key: string]: any;
}

export class AvailableProjectsPaginatedBean implements IAvailableProjectsPaginatedBean {
    results?: PageBeanProjectBean;

    [key: string]: any;

    constructor(data?: IAvailableProjectsPaginatedBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.results = _data["results"] ? PageBeanProjectBean.fromJS(_data["results"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AvailableProjectsPaginatedBean {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableProjectsPaginatedBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["results"] = this.results ? this.results.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAvailableProjectsPaginatedBean {
    results?: PageBeanProjectBean;

    [key: string]: any;
}

export class AvailableProjectsRequestBean implements IAvailableProjectsRequestBean {
    ignoredProjectIds?: string[];

    [key: string]: any;

    constructor(data?: IAvailableProjectsRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["ignoredProjectIds"])) {
                this.ignoredProjectIds = [] as any;
                for (let item of _data["ignoredProjectIds"])
                    this.ignoredProjectIds!.push(item);
            }
        }
    }

    static fromJS(data: any): AvailableProjectsRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableProjectsRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.ignoredProjectIds)) {
            data["ignoredProjectIds"] = [];
            for (let item of this.ignoredProjectIds)
                data["ignoredProjectIds"].push(item);
        }
        return data;
    }
}

export interface IAvailableProjectsRequestBean {
    ignoredProjectIds?: string[];

    [key: string]: any;
}

export class AvatarBean implements IAvatarBean {
    id?: string;
    owner?: string;
    selected?: boolean;

    [key: string]: any;

    constructor(data?: IAvatarBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.owner = _data["owner"];
            this.selected = _data["selected"];
        }
    }

    static fromJS(data: any): AvatarBean {
        data = typeof data === 'object' ? data : {};
        let result = new AvatarBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["owner"] = this.owner;
        data["selected"] = this.selected;
        return data;
    }
}

export interface IAvatarBean {
    id?: string;
    owner?: string;
    selected?: boolean;

    [key: string]: any;
}

export class AvatarCroppingBean implements IAvatarCroppingBean {
    cropperOffsetX?: number;
    cropperOffsetY?: number;
    cropperWidth?: number;
    needsCropping?: boolean;
    url?: string;

    [key: string]: any;

    constructor(data?: IAvatarCroppingBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.cropperOffsetX = _data["cropperOffsetX"];
            this.cropperOffsetY = _data["cropperOffsetY"];
            this.cropperWidth = _data["cropperWidth"];
            this.needsCropping = _data["needsCropping"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): AvatarCroppingBean {
        data = typeof data === 'object' ? data : {};
        let result = new AvatarCroppingBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["cropperOffsetX"] = this.cropperOffsetX;
        data["cropperOffsetY"] = this.cropperOffsetY;
        data["cropperWidth"] = this.cropperWidth;
        data["needsCropping"] = this.needsCropping;
        data["url"] = this.url;
        return data;
    }
}

export interface IAvatarCroppingBean {
    cropperOffsetX?: number;
    cropperOffsetY?: number;
    cropperWidth?: number;
    needsCropping?: boolean;
    url?: string;

    [key: string]: any;
}

export class BulkDeleteResponseBean implements IBulkDeleteResponseBean {
    deletedCustomFields?: string[];
    message?: string;
    notDeletedCustomFields?: { [key: string]: string; };

    [key: string]: any;

    constructor(data?: IBulkDeleteResponseBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["deletedCustomFields"])) {
                this.deletedCustomFields = [] as any;
                for (let item of _data["deletedCustomFields"])
                    this.deletedCustomFields!.push(item);
            }
            this.message = _data["message"];
            if (_data["notDeletedCustomFields"]) {
                this.notDeletedCustomFields = {} as any;
                for (let key in _data["notDeletedCustomFields"]) {
                    if (_data["notDeletedCustomFields"].hasOwnProperty(key))
                        (<any>this.notDeletedCustomFields)![key] = _data["notDeletedCustomFields"][key];
                }
            }
        }
    }

    static fromJS(data: any): BulkDeleteResponseBean {
        data = typeof data === 'object' ? data : {};
        let result = new BulkDeleteResponseBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.deletedCustomFields)) {
            data["deletedCustomFields"] = [];
            for (let item of this.deletedCustomFields)
                data["deletedCustomFields"].push(item);
        }
        data["message"] = this.message;
        if (this.notDeletedCustomFields) {
            data["notDeletedCustomFields"] = {};
            for (let key in this.notDeletedCustomFields) {
                if (this.notDeletedCustomFields.hasOwnProperty(key))
                    (<any>data["notDeletedCustomFields"])[key] = (<any>this.notDeletedCustomFields)[key];
            }
        }
        return data;
    }
}

export interface IBulkDeleteResponseBean {
    deletedCustomFields?: string[];
    message?: string;
    notDeletedCustomFields?: { [key: string]: string; };

    [key: string]: any;
}

export class BulkOperationErrorResult implements IBulkOperationErrorResult {
    elementErrors?: ErrorCollection;
    failedElementNumber?: number;
    status?: number;

    [key: string]: any;

    constructor(data?: IBulkOperationErrorResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.elementErrors = _data["elementErrors"] ? ErrorCollection.fromJS(_data["elementErrors"]) : <any>undefined;
            this.failedElementNumber = _data["failedElementNumber"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): BulkOperationErrorResult {
        data = typeof data === 'object' ? data : {};
        let result = new BulkOperationErrorResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["elementErrors"] = this.elementErrors ? this.elementErrors.toJSON() : <any>undefined;
        data["failedElementNumber"] = this.failedElementNumber;
        data["status"] = this.status;
        return data;
    }
}

export interface IBulkOperationErrorResult {
    elementErrors?: ErrorCollection;
    failedElementNumber?: number;
    status?: number;

    [key: string]: any;
}

export class ClusterLockStatusBean implements IClusterLockStatusBean {
    holdingLockSec?: string;
    lockName?: string;
    lockedByNode?: string;
    updateTime?: string;

    [key: string]: any;

    constructor(data?: IClusterLockStatusBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.holdingLockSec = _data["holdingLockSec"];
            this.lockName = _data["lockName"];
            this.lockedByNode = _data["lockedByNode"];
            this.updateTime = _data["updateTime"];
        }
    }

    static fromJS(data: any): ClusterLockStatusBean {
        data = typeof data === 'object' ? data : {};
        let result = new ClusterLockStatusBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["holdingLockSec"] = this.holdingLockSec;
        data["lockName"] = this.lockName;
        data["lockedByNode"] = this.lockedByNode;
        data["updateTime"] = this.updateTime;
        return data;
    }
}

export interface IClusterLockStatusBean {
    holdingLockSec?: string;
    lockName?: string;
    lockedByNode?: string;
    updateTime?: string;

    [key: string]: any;
}

export class ClusterLockStatusesBean implements IClusterLockStatusesBean {
    clusterLocks?: ClusterLockStatusBean[];

    [key: string]: any;

    constructor(data?: IClusterLockStatusesBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["clusterLocks"])) {
                this.clusterLocks = [] as any;
                for (let item of _data["clusterLocks"])
                    this.clusterLocks!.push(ClusterLockStatusBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClusterLockStatusesBean {
        data = typeof data === 'object' ? data : {};
        let result = new ClusterLockStatusesBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.clusterLocks)) {
            data["clusterLocks"] = [];
            for (let item of this.clusterLocks)
                data["clusterLocks"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClusterLockStatusesBean {
    clusterLocks?: ClusterLockStatusBean[];

    [key: string]: any;
}

export class ClusterState implements IClusterState {
    build?: NodeBuildInfo;
    state?: ClusterStateState;

    [key: string]: any;

    constructor(data?: IClusterState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.build = _data["build"] ? NodeBuildInfo.fromJS(_data["build"]) : <any>undefined;
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): ClusterState {
        data = typeof data === 'object' ? data : {};
        let result = new ClusterState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["build"] = this.build ? this.build.toJSON() : <any>undefined;
        data["state"] = this.state;
        return data;
    }
}

export interface IClusterState {
    build?: NodeBuildInfo;
    state?: ClusterStateState;

    [key: string]: any;
}

export class ColumnLayout implements IColumnLayout {
    columnConfig?: ColumnLayoutColumnConfig;
    columnLayoutItems?: ColumnLayoutItem[];

    [key: string]: any;

    constructor(data?: IColumnLayout) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.columnConfig = _data["columnConfig"];
            if (Array.isArray(_data["columnLayoutItems"])) {
                this.columnLayoutItems = [] as any;
                for (let item of _data["columnLayoutItems"])
                    this.columnLayoutItems!.push(ColumnLayoutItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ColumnLayout {
        data = typeof data === 'object' ? data : {};
        let result = new ColumnLayout();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["columnConfig"] = this.columnConfig;
        if (Array.isArray(this.columnLayoutItems)) {
            data["columnLayoutItems"] = [];
            for (let item of this.columnLayoutItems)
                data["columnLayoutItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IColumnLayout {
    columnConfig?: ColumnLayoutColumnConfig;
    columnLayoutItems?: ColumnLayoutItem[];

    [key: string]: any;
}

export class ColumnLayoutItem implements IColumnLayoutItem {
    columnHeadingKey?: string;
    id?: string;
    navigableField?: NavigableField;
    position?: number;

    [key: string]: any;

    constructor(data?: IColumnLayoutItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.columnHeadingKey = _data["columnHeadingKey"];
            this.id = _data["id"];
            this.navigableField = _data["navigableField"] ? NavigableField.fromJS(_data["navigableField"]) : <any>undefined;
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): ColumnLayoutItem {
        data = typeof data === 'object' ? data : {};
        let result = new ColumnLayoutItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["columnHeadingKey"] = this.columnHeadingKey;
        data["id"] = this.id;
        data["navigableField"] = this.navigableField ? this.navigableField.toJSON() : <any>undefined;
        data["position"] = this.position;
        return data;
    }
}

export interface IColumnLayoutItem {
    columnHeadingKey?: string;
    id?: string;
    navigableField?: NavigableField;
    position?: number;

    [key: string]: any;
}

export class ColumnOptions implements IColumnOptions {

    [key: string]: any;

    constructor(data?: IColumnOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): ColumnOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ColumnOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IColumnOptions {

    [key: string]: any;
}

export class ColumnsBean implements IColumnsBean {
    columns?: string[];

    [key: string]: any;

    constructor(data?: IColumnsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(item);
            }
        }
    }

    static fromJS(data: any): ColumnsBean {
        data = typeof data === 'object' ? data : {};
        let result = new ColumnsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item);
        }
        return data;
    }
}

export interface IColumnsBean {
    columns?: string[];

    [key: string]: any;
}

export class CommentJsonBean implements ICommentJsonBean {
    author?: UserJsonBean;
    body?: string;
    created?: string;
    id?: string;
    properties?: EntityPropertyBean[];
    renderedBody?: string;
    self?: string;
    updateAuthor?: UserJsonBean;
    updated?: string;
    visibility?: VisibilityJsonBean;

    [key: string]: any;

    constructor(data?: ICommentJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.author = _data["author"] ? UserJsonBean.fromJS(_data["author"]) : <any>undefined;
            this.body = _data["body"];
            this.created = _data["created"];
            this.id = _data["id"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(EntityPropertyBean.fromJS(item));
            }
            this.renderedBody = _data["renderedBody"];
            this.self = _data["self"];
            this.updateAuthor = _data["updateAuthor"] ? UserJsonBean.fromJS(_data["updateAuthor"]) : <any>undefined;
            this.updated = _data["updated"];
            this.visibility = _data["visibility"] ? VisibilityJsonBean.fromJS(_data["visibility"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommentJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new CommentJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["created"] = this.created;
        data["id"] = this.id;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        data["renderedBody"] = this.renderedBody;
        data["self"] = this.self;
        data["updateAuthor"] = this.updateAuthor ? this.updateAuthor.toJSON() : <any>undefined;
        data["updated"] = this.updated;
        data["visibility"] = this.visibility ? this.visibility.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICommentJsonBean {
    author?: UserJsonBean;
    body?: string;
    created?: string;
    id?: string;
    properties?: EntityPropertyBean[];
    renderedBody?: string;
    self?: string;
    updateAuthor?: UserJsonBean;
    updated?: string;
    visibility?: VisibilityJsonBean;

    [key: string]: any;
}

export class CommentsWithPaginationJsonBean implements ICommentsWithPaginationJsonBean {
    comments?: CommentJsonBean[];
    maxResults?: number;
    startAt?: number;
    total?: number;

    [key: string]: any;

    constructor(data?: ICommentsWithPaginationJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(CommentJsonBean.fromJS(item));
            }
            this.maxResults = _data["maxResults"];
            this.startAt = _data["startAt"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): CommentsWithPaginationJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new CommentsWithPaginationJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        data["maxResults"] = this.maxResults;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        return data;
    }
}

export interface ICommentsWithPaginationJsonBean {
    comments?: CommentJsonBean[];
    maxResults?: number;
    startAt?: number;
    total?: number;

    [key: string]: any;
}

export class ComponentBean implements IComponentBean {
    archived?: boolean;
    assigneeType?: ComponentBeanAssigneeType;
    deleted?: boolean;
    description?: string;
    id?: string;
    lead?: UserBean;
    leadUserName?: string;
    name?: string;
    project?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IComponentBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.archived = _data["archived"];
            this.assigneeType = _data["assigneeType"];
            this.deleted = _data["deleted"];
            this.description = _data["description"];
            this.id = _data["id"];
            this.lead = _data["lead"] ? UserBean.fromJS(_data["lead"]) : <any>undefined;
            this.leadUserName = _data["leadUserName"];
            this.name = _data["name"];
            this.project = _data["project"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): ComponentBean {
        data = typeof data === 'object' ? data : {};
        let result = new ComponentBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["archived"] = this.archived;
        data["assigneeType"] = this.assigneeType;
        data["deleted"] = this.deleted;
        data["description"] = this.description;
        data["id"] = this.id;
        data["lead"] = this.lead ? this.lead.toJSON() : <any>undefined;
        data["leadUserName"] = this.leadUserName;
        data["name"] = this.name;
        data["project"] = this.project;
        data["self"] = this.self;
        return data;
    }
}

export interface IComponentBean {
    archived?: boolean;
    assigneeType?: ComponentBeanAssigneeType;
    deleted?: boolean;
    description?: string;
    id?: string;
    lead?: UserBean;
    leadUserName?: string;
    name?: string;
    project?: string;
    self?: string;

    [key: string]: any;
}

export class ComponentIssueCountsBean implements IComponentIssueCountsBean {
    issueCount?: number;
    self?: string;

    [key: string]: any;

    constructor(data?: IComponentIssueCountsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.issueCount = _data["issueCount"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): ComponentIssueCountsBean {
        data = typeof data === 'object' ? data : {};
        let result = new ComponentIssueCountsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["issueCount"] = this.issueCount;
        data["self"] = this.self;
        return data;
    }
}

export interface IComponentIssueCountsBean {
    issueCount?: number;
    self?: string;

    [key: string]: any;
}

export class ConfigurationBean implements IConfigurationBean {
    attachmentsEnabled?: boolean;
    issueLinkingEnabled?: boolean;
    subTasksEnabled?: boolean;
    timeTrackingConfiguration?: TimeTrackingConfigurationBean;
    timeTrackingEnabled?: boolean;
    unassignedIssuesAllowed?: boolean;
    votingEnabled?: boolean;
    watchingEnabled?: boolean;

    [key: string]: any;

    constructor(data?: IConfigurationBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.attachmentsEnabled = _data["attachmentsEnabled"];
            this.issueLinkingEnabled = _data["issueLinkingEnabled"];
            this.subTasksEnabled = _data["subTasksEnabled"];
            this.timeTrackingConfiguration = _data["timeTrackingConfiguration"] ? TimeTrackingConfigurationBean.fromJS(_data["timeTrackingConfiguration"]) : <any>undefined;
            this.timeTrackingEnabled = _data["timeTrackingEnabled"];
            this.unassignedIssuesAllowed = _data["unassignedIssuesAllowed"];
            this.votingEnabled = _data["votingEnabled"];
            this.watchingEnabled = _data["watchingEnabled"];
        }
    }

    static fromJS(data: any): ConfigurationBean {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["attachmentsEnabled"] = this.attachmentsEnabled;
        data["issueLinkingEnabled"] = this.issueLinkingEnabled;
        data["subTasksEnabled"] = this.subTasksEnabled;
        data["timeTrackingConfiguration"] = this.timeTrackingConfiguration ? this.timeTrackingConfiguration.toJSON() : <any>undefined;
        data["timeTrackingEnabled"] = this.timeTrackingEnabled;
        data["unassignedIssuesAllowed"] = this.unassignedIssuesAllowed;
        data["votingEnabled"] = this.votingEnabled;
        data["watchingEnabled"] = this.watchingEnabled;
        return data;
    }
}

export interface IConfigurationBean {
    attachmentsEnabled?: boolean;
    issueLinkingEnabled?: boolean;
    subTasksEnabled?: boolean;
    timeTrackingConfiguration?: TimeTrackingConfigurationBean;
    timeTrackingEnabled?: boolean;
    unassignedIssuesAllowed?: boolean;
    votingEnabled?: boolean;
    watchingEnabled?: boolean;

    [key: string]: any;
}

export class ContentToRender implements IContentToRender {

    [key: string]: any;

    constructor(data?: IContentToRender) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): ContentToRender {
        data = typeof data === 'object' ? data : {};
        let result = new ContentToRender();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IContentToRender {

    [key: string]: any;
}

export class CreateMetaIssueTypeBean implements ICreateMetaIssueTypeBean {
    avatarId?: number;
    description?: string;
    fields?: { [key: string]: FieldMetaBean; };
    iconUrl?: string;
    id?: string;
    name?: string;
    self?: string;
    subtask?: boolean;

    [key: string]: any;

    constructor(data?: ICreateMetaIssueTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.avatarId = _data["avatarId"];
            this.description = _data["description"];
            if (_data["fields"]) {
                this.fields = {} as any;
                for (let key in _data["fields"]) {
                    if (_data["fields"].hasOwnProperty(key))
                        (<any>this.fields)![key] = _data["fields"][key] ? FieldMetaBean.fromJS(_data["fields"][key]) : new FieldMetaBean();
                }
            }
            this.iconUrl = _data["iconUrl"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.self = _data["self"];
            this.subtask = _data["subtask"];
        }
    }

    static fromJS(data: any): CreateMetaIssueTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMetaIssueTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["avatarId"] = this.avatarId;
        data["description"] = this.description;
        if (this.fields) {
            data["fields"] = {};
            for (let key in this.fields) {
                if (this.fields.hasOwnProperty(key))
                    (<any>data["fields"])[key] = this.fields[key] ? this.fields[key].toJSON() : <any>undefined;
            }
        }
        data["iconUrl"] = this.iconUrl;
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        data["subtask"] = this.subtask;
        return data;
    }
}

export interface ICreateMetaIssueTypeBean {
    avatarId?: number;
    description?: string;
    fields?: { [key: string]: FieldMetaBean; };
    iconUrl?: string;
    id?: string;
    name?: string;
    self?: string;
    subtask?: boolean;

    [key: string]: any;
}

export class CreateUpdateRoleRequestBean implements ICreateUpdateRoleRequestBean {
    description?: string;
    name?: string;

    [key: string]: any;

    constructor(data?: ICreateUpdateRoleRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateUpdateRoleRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateRoleRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateUpdateRoleRequestBean {
    description?: string;
    name?: string;

    [key: string]: any;
}

export class CurrentUser implements ICurrentUser {

    [key: string]: any;

    constructor(data?: ICurrentUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): CurrentUser {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ICurrentUser {

    [key: string]: any;
}

export class CustomFieldBean implements ICustomFieldBean {
    description?: string;
    id?: string;
    isAllProjects?: boolean;
    isLocked?: boolean;
    isManaged?: boolean;
    isTrusted?: boolean;
    issueTypeIds?: string[];
    issuesWithValue?: number;
    lastValueUpdate?: Date;
    name?: string;
    numericId?: number;
    projectIds?: number[];
    projectsCount?: number;
    screensCount?: number;
    searcherKey?: string;
    self?: string;
    type?: string;

    [key: string]: any;

    constructor(data?: ICustomFieldBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.id = _data["id"];
            this.isAllProjects = _data["isAllProjects"];
            this.isLocked = _data["isLocked"];
            this.isManaged = _data["isManaged"];
            this.isTrusted = _data["isTrusted"];
            if (Array.isArray(_data["issueTypeIds"])) {
                this.issueTypeIds = [] as any;
                for (let item of _data["issueTypeIds"])
                    this.issueTypeIds!.push(item);
            }
            this.issuesWithValue = _data["issuesWithValue"];
            this.lastValueUpdate = _data["lastValueUpdate"] ? new Date(_data["lastValueUpdate"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.numericId = _data["numericId"];
            if (Array.isArray(_data["projectIds"])) {
                this.projectIds = [] as any;
                for (let item of _data["projectIds"])
                    this.projectIds!.push(item);
            }
            this.projectsCount = _data["projectsCount"];
            this.screensCount = _data["screensCount"];
            this.searcherKey = _data["searcherKey"];
            this.self = _data["self"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldBean {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["id"] = this.id;
        data["isAllProjects"] = this.isAllProjects;
        data["isLocked"] = this.isLocked;
        data["isManaged"] = this.isManaged;
        data["isTrusted"] = this.isTrusted;
        if (Array.isArray(this.issueTypeIds)) {
            data["issueTypeIds"] = [];
            for (let item of this.issueTypeIds)
                data["issueTypeIds"].push(item);
        }
        data["issuesWithValue"] = this.issuesWithValue;
        data["lastValueUpdate"] = this.lastValueUpdate ? this.lastValueUpdate.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["numericId"] = this.numericId;
        if (Array.isArray(this.projectIds)) {
            data["projectIds"] = [];
            for (let item of this.projectIds)
                data["projectIds"].push(item);
        }
        data["projectsCount"] = this.projectsCount;
        data["screensCount"] = this.screensCount;
        data["searcherKey"] = this.searcherKey;
        data["self"] = this.self;
        data["type"] = this.type;
        return data;
    }
}

export interface ICustomFieldBean {
    description?: string;
    id?: string;
    isAllProjects?: boolean;
    isLocked?: boolean;
    isManaged?: boolean;
    isTrusted?: boolean;
    issueTypeIds?: string[];
    issuesWithValue?: number;
    lastValueUpdate?: Date;
    name?: string;
    numericId?: number;
    projectIds?: number[];
    projectsCount?: number;
    screensCount?: number;
    searcherKey?: string;
    self?: string;
    type?: string;

    [key: string]: any;
}

export class CustomFieldDefinitionJsonBean implements ICustomFieldDefinitionJsonBean {
    description?: string;
    id?: string;
    issueTypeIds?: string[];
    name?: string;
    projectIds?: number[];
    searcherKey?: string;
    self?: string;
    type?: string;

    [key: string]: any;

    constructor(data?: ICustomFieldDefinitionJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.id = _data["id"];
            if (Array.isArray(_data["issueTypeIds"])) {
                this.issueTypeIds = [] as any;
                for (let item of _data["issueTypeIds"])
                    this.issueTypeIds!.push(item);
            }
            this.name = _data["name"];
            if (Array.isArray(_data["projectIds"])) {
                this.projectIds = [] as any;
                for (let item of _data["projectIds"])
                    this.projectIds!.push(item);
            }
            this.searcherKey = _data["searcherKey"];
            this.self = _data["self"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldDefinitionJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldDefinitionJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["id"] = this.id;
        if (Array.isArray(this.issueTypeIds)) {
            data["issueTypeIds"] = [];
            for (let item of this.issueTypeIds)
                data["issueTypeIds"].push(item);
        }
        data["name"] = this.name;
        if (Array.isArray(this.projectIds)) {
            data["projectIds"] = [];
            for (let item of this.projectIds)
                data["projectIds"].push(item);
        }
        data["searcherKey"] = this.searcherKey;
        data["self"] = this.self;
        data["type"] = this.type;
        return data;
    }
}

export interface ICustomFieldDefinitionJsonBean {
    description?: string;
    id?: string;
    issueTypeIds?: string[];
    name?: string;
    projectIds?: number[];
    searcherKey?: string;
    self?: string;
    type?: string;

    [key: string]: any;
}

export class CustomFieldOptionBean implements ICustomFieldOptionBean {
    childrenIds?: number[];
    disabled?: boolean;
    id?: number;
    self?: string;
    value?: string;

    [key: string]: any;

    constructor(data?: ICustomFieldOptionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["childrenIds"])) {
                this.childrenIds = [] as any;
                for (let item of _data["childrenIds"])
                    this.childrenIds!.push(item);
            }
            this.disabled = _data["disabled"];
            this.id = _data["id"];
            this.self = _data["self"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CustomFieldOptionBean {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldOptionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.childrenIds)) {
            data["childrenIds"] = [];
            for (let item of this.childrenIds)
                data["childrenIds"].push(item);
        }
        data["disabled"] = this.disabled;
        data["id"] = this.id;
        data["self"] = this.self;
        data["value"] = this.value;
        return data;
    }
}

export interface ICustomFieldOptionBean {
    childrenIds?: number[];
    disabled?: boolean;
    id?: number;
    self?: string;
    value?: string;

    [key: string]: any;
}

export class CustomFieldOptionsBean implements ICustomFieldOptionsBean {
    options?: CustomFieldOptionBean[];
    total?: number;

    [key: string]: any;

    constructor(data?: ICustomFieldOptionsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(CustomFieldOptionBean.fromJS(item));
            }
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): CustomFieldOptionsBean {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldOptionsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data;
    }
}

export interface ICustomFieldOptionsBean {
    options?: CustomFieldOptionBean[];
    total?: number;

    [key: string]: any;
}

export class CustomFieldReplacement implements ICustomFieldReplacement {
    customFieldId?: number;
    moveTo?: number;

    [key: string]: any;

    constructor(data?: ICustomFieldReplacement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.customFieldId = _data["customFieldId"];
            this.moveTo = _data["moveTo"];
        }
    }

    static fromJS(data: any): CustomFieldReplacement {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldReplacement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["customFieldId"] = this.customFieldId;
        data["moveTo"] = this.moveTo;
        return data;
    }
}

export interface ICustomFieldReplacement {
    customFieldId?: number;
    moveTo?: number;

    [key: string]: any;
}

export class DarkFeaturePropertyBean implements IDarkFeaturePropertyBean {
    enabled?: boolean;

    [key: string]: any;

    constructor(data?: IDarkFeaturePropertyBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.enabled = _data["enabled"];
        }
    }

    static fromJS(data: any): DarkFeaturePropertyBean {
        data = typeof data === 'object' ? data : {};
        let result = new DarkFeaturePropertyBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["enabled"] = this.enabled;
        return data;
    }
}

export interface IDarkFeaturePropertyBean {
    enabled?: boolean;

    [key: string]: any;
}

export class DarkFeaturesBean implements IDarkFeaturesBean {
    siteFeatures?: { [key: string]: DarkFeaturePropertyBean; };
    systemFeatures?: { [key: string]: DarkFeaturePropertyBean; };

    [key: string]: any;

    constructor(data?: IDarkFeaturesBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["siteFeatures"]) {
                this.siteFeatures = {} as any;
                for (let key in _data["siteFeatures"]) {
                    if (_data["siteFeatures"].hasOwnProperty(key))
                        (<any>this.siteFeatures)![key] = _data["siteFeatures"][key] ? DarkFeaturePropertyBean.fromJS(_data["siteFeatures"][key]) : new DarkFeaturePropertyBean();
                }
            }
            if (_data["systemFeatures"]) {
                this.systemFeatures = {} as any;
                for (let key in _data["systemFeatures"]) {
                    if (_data["systemFeatures"].hasOwnProperty(key))
                        (<any>this.systemFeatures)![key] = _data["systemFeatures"][key] ? DarkFeaturePropertyBean.fromJS(_data["systemFeatures"][key]) : new DarkFeaturePropertyBean();
                }
            }
        }
    }

    static fromJS(data: any): DarkFeaturesBean {
        data = typeof data === 'object' ? data : {};
        let result = new DarkFeaturesBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.siteFeatures) {
            data["siteFeatures"] = {};
            for (let key in this.siteFeatures) {
                if (this.siteFeatures.hasOwnProperty(key))
                    (<any>data["siteFeatures"])[key] = this.siteFeatures[key] ? this.siteFeatures[key].toJSON() : <any>undefined;
            }
        }
        if (this.systemFeatures) {
            data["systemFeatures"] = {};
            for (let key in this.systemFeatures) {
                if (this.systemFeatures.hasOwnProperty(key))
                    (<any>data["systemFeatures"])[key] = this.systemFeatures[key] ? this.systemFeatures[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IDarkFeaturesBean {
    siteFeatures?: { [key: string]: DarkFeaturePropertyBean; };
    systemFeatures?: { [key: string]: DarkFeaturePropertyBean; };

    [key: string]: any;
}

export class DashboardBean implements IDashboardBean {
    id?: string;
    name?: string;
    self?: string;
    view?: string;

    [key: string]: any;

    constructor(data?: IDashboardBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.self = _data["self"];
            this.view = _data["view"];
        }
    }

    static fromJS(data: any): DashboardBean {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        data["view"] = this.view;
        return data;
    }
}

export interface IDashboardBean {
    id?: string;
    name?: string;
    self?: string;
    view?: string;

    [key: string]: any;
}

export class DashboardsBean implements IDashboardsBean {
    dashboards?: DashboardBean[];
    maxResults?: number;
    next?: string;
    prev?: string;
    startAt?: number;
    total?: number;

    [key: string]: any;

    constructor(data?: IDashboardsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["dashboards"])) {
                this.dashboards = [] as any;
                for (let item of _data["dashboards"])
                    this.dashboards!.push(DashboardBean.fromJS(item));
            }
            this.maxResults = _data["maxResults"];
            this.next = _data["next"];
            this.prev = _data["prev"];
            this.startAt = _data["startAt"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): DashboardsBean {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.dashboards)) {
            data["dashboards"] = [];
            for (let item of this.dashboards)
                data["dashboards"].push(item.toJSON());
        }
        data["maxResults"] = this.maxResults;
        data["next"] = this.next;
        data["prev"] = this.prev;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        return data;
    }
}

export interface IDashboardsBean {
    dashboards?: DashboardBean[];
    maxResults?: number;
    next?: string;
    prev?: string;
    startAt?: number;
    total?: number;

    [key: string]: any;
}

export class DefaultBean implements IDefaultBean {
    updateDraftIfNeeded?: boolean;
    workflow?: string;

    [key: string]: any;

    constructor(data?: IDefaultBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.updateDraftIfNeeded = _data["updateDraftIfNeeded"];
            this.workflow = _data["workflow"];
        }
    }

    static fromJS(data: any): DefaultBean {
        data = typeof data === 'object' ? data : {};
        let result = new DefaultBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["updateDraftIfNeeded"] = this.updateDraftIfNeeded;
        data["workflow"] = this.workflow;
        return data;
    }
}

export interface IDefaultBean {
    updateDraftIfNeeded?: boolean;
    workflow?: string;

    [key: string]: any;
}

export class DefaultShareScopeBean implements IDefaultShareScopeBean {
    scope?: DefaultShareScopeBeanScope;

    [key: string]: any;

    constructor(data?: IDefaultShareScopeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.scope = _data["scope"];
        }
    }

    static fromJS(data: any): DefaultShareScopeBean {
        data = typeof data === 'object' ? data : {};
        let result = new DefaultShareScopeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["scope"] = this.scope;
        return data;
    }
}

export interface IDefaultShareScopeBean {
    scope?: DefaultShareScopeBeanScope;

    [key: string]: any;
}

export class DeleteAndReplaceVersionBean implements IDeleteAndReplaceVersionBean {
    customFieldReplacementList?: CustomFieldReplacement[];
    moveAffectedIssuesTo?: number;
    moveFixIssuesTo?: number;

    [key: string]: any;

    constructor(data?: IDeleteAndReplaceVersionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["customFieldReplacementList"])) {
                this.customFieldReplacementList = [] as any;
                for (let item of _data["customFieldReplacementList"])
                    this.customFieldReplacementList!.push(CustomFieldReplacement.fromJS(item));
            }
            this.moveAffectedIssuesTo = _data["moveAffectedIssuesTo"];
            this.moveFixIssuesTo = _data["moveFixIssuesTo"];
        }
    }

    static fromJS(data: any): DeleteAndReplaceVersionBean {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteAndReplaceVersionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.customFieldReplacementList)) {
            data["customFieldReplacementList"] = [];
            for (let item of this.customFieldReplacementList)
                data["customFieldReplacementList"].push(item.toJSON());
        }
        data["moveAffectedIssuesTo"] = this.moveAffectedIssuesTo;
        data["moveFixIssuesTo"] = this.moveFixIssuesTo;
        return data;
    }
}

export interface IDeleteAndReplaceVersionBean {
    customFieldReplacementList?: CustomFieldReplacement[];
    moveAffectedIssuesTo?: number;
    moveFixIssuesTo?: number;

    [key: string]: any;
}

export class EditorMarkupParameters implements IEditorMarkupParameters {
    fieldId!: string;
    fieldName?: string;
    issueKey?: string;
    value?: string;

    [key: string]: any;

    constructor(data?: IEditorMarkupParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.fieldId = _data["fieldId"];
            this.fieldName = _data["fieldName"];
            this.issueKey = _data["issueKey"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): EditorMarkupParameters {
        data = typeof data === 'object' ? data : {};
        let result = new EditorMarkupParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["fieldId"] = this.fieldId;
        data["fieldName"] = this.fieldName;
        data["issueKey"] = this.issueKey;
        data["value"] = this.value;
        return data;
    }
}

export interface IEditorMarkupParameters {
    fieldId: string;
    fieldName?: string;
    issueKey?: string;
    value?: string;

    [key: string]: any;
}

export class ErrorCollection implements IErrorCollection {
    errorMessages?: string[];
    errors?: { [key: string]: string; };

    [key: string]: any;

    constructor(data?: IErrorCollection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages!.push(item);
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key];
                }
            }
        }
    }

    static fromJS(data: any): ErrorCollection {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorCollection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        return data;
    }
}

export interface IErrorCollection {
    errorMessages?: string[];
    errors?: { [key: string]: string; };

    [key: string]: any;
}

export class FieldBean implements IFieldBean {
    clauseNames?: string[];
    custom?: boolean;
    id?: string;
    name?: string;
    navigable?: boolean;
    orderable?: boolean;
    schema?: JsonTypeBean;
    searchable?: boolean;

    [key: string]: any;

    constructor(data?: IFieldBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["clauseNames"])) {
                this.clauseNames = [] as any;
                for (let item of _data["clauseNames"])
                    this.clauseNames!.push(item);
            }
            this.custom = _data["custom"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.navigable = _data["navigable"];
            this.orderable = _data["orderable"];
            this.schema = _data["schema"] ? JsonTypeBean.fromJS(_data["schema"]) : <any>undefined;
            this.searchable = _data["searchable"];
        }
    }

    static fromJS(data: any): FieldBean {
        data = typeof data === 'object' ? data : {};
        let result = new FieldBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.clauseNames)) {
            data["clauseNames"] = [];
            for (let item of this.clauseNames)
                data["clauseNames"].push(item);
        }
        data["custom"] = this.custom;
        data["id"] = this.id;
        data["name"] = this.name;
        data["navigable"] = this.navigable;
        data["orderable"] = this.orderable;
        data["schema"] = this.schema ? this.schema.toJSON() : <any>undefined;
        data["searchable"] = this.searchable;
        return data;
    }
}

export interface IFieldBean {
    clauseNames?: string[];
    custom?: boolean;
    id?: string;
    name?: string;
    navigable?: boolean;
    orderable?: boolean;
    schema?: JsonTypeBean;
    searchable?: boolean;

    [key: string]: any;
}

export class FieldComparatorSource implements IFieldComparatorSource {

    [key: string]: any;

    constructor(data?: IFieldComparatorSource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): FieldComparatorSource {
        data = typeof data === 'object' ? data : {};
        let result = new FieldComparatorSource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IFieldComparatorSource {

    [key: string]: any;
}

export class FieldConfigSchemeBean implements IFieldConfigSchemeBean {
    allIssueTypes?: boolean;
    allProjects?: boolean;
    defaultValue?: any;
    description?: string;
    field?: FieldBean;
    fieldConfigIds?: number[];
    id?: number;
    issueTypes?: IssueTypeJsonBean[];
    name?: string;
    projects?: ProjectBean[];
    self?: string;

    [key: string]: any;

    constructor(data?: IFieldConfigSchemeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.allIssueTypes = _data["allIssueTypes"];
            this.allProjects = _data["allProjects"];
            this.defaultValue = _data["defaultValue"];
            this.description = _data["description"];
            this.field = _data["field"] ? FieldBean.fromJS(_data["field"]) : <any>undefined;
            if (Array.isArray(_data["fieldConfigIds"])) {
                this.fieldConfigIds = [] as any;
                for (let item of _data["fieldConfigIds"])
                    this.fieldConfigIds!.push(item);
            }
            this.id = _data["id"];
            if (Array.isArray(_data["issueTypes"])) {
                this.issueTypes = [] as any;
                for (let item of _data["issueTypes"])
                    this.issueTypes!.push(IssueTypeJsonBean.fromJS(item));
            }
            this.name = _data["name"];
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects!.push(ProjectBean.fromJS(item));
            }
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): FieldConfigSchemeBean {
        data = typeof data === 'object' ? data : {};
        let result = new FieldConfigSchemeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["allIssueTypes"] = this.allIssueTypes;
        data["allProjects"] = this.allProjects;
        data["defaultValue"] = this.defaultValue;
        data["description"] = this.description;
        data["field"] = this.field ? this.field.toJSON() : <any>undefined;
        if (Array.isArray(this.fieldConfigIds)) {
            data["fieldConfigIds"] = [];
            for (let item of this.fieldConfigIds)
                data["fieldConfigIds"].push(item);
        }
        data["id"] = this.id;
        if (Array.isArray(this.issueTypes)) {
            data["issueTypes"] = [];
            for (let item of this.issueTypes)
                data["issueTypes"].push(item.toJSON());
        }
        data["name"] = this.name;
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item.toJSON());
        }
        data["self"] = this.self;
        return data;
    }
}

export interface IFieldConfigSchemeBean {
    allIssueTypes?: boolean;
    allProjects?: boolean;
    defaultValue?: any;
    description?: string;
    field?: FieldBean;
    fieldConfigIds?: number[];
    id?: number;
    issueTypes?: IssueTypeJsonBean[];
    name?: string;
    projects?: ProjectBean[];
    self?: string;

    [key: string]: any;
}

export class FieldOperation implements IFieldOperation {
    operation?: string;
    value?: any;

    [key: string]: any;

    constructor(data?: IFieldOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.operation = _data["operation"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): FieldOperation {
        data = typeof data === 'object' ? data : {};
        let result = new FieldOperation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["operation"] = this.operation;
        data["value"] = this.value;
        return data;
    }
}

export interface IFieldOperation {
    operation?: string;
    value?: any;

    [key: string]: any;
}

export class FieldValueLoader implements IFieldValueLoader {
    comparator?: any;

    [key: string]: any;

    constructor(data?: IFieldValueLoader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.comparator = _data["comparator"];
        }
    }

    static fromJS(data: any): FieldValueLoader {
        data = typeof data === 'object' ? data : {};
        let result = new FieldValueLoader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["comparator"] = this.comparator;
        return data;
    }
}

export interface IFieldValueLoader {
    comparator?: any;

    [key: string]: any;
}

export class Fields implements IFields {
    issuetype?: IssueTypeJsonBean;
    priority?: PriorityJsonBean;
    status?: StatusJsonBean;
    summary?: string;

    [key: string]: any;

    constructor(data?: IFields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.issuetype = _data["issuetype"] ? IssueTypeJsonBean.fromJS(_data["issuetype"]) : <any>undefined;
            this.priority = _data["priority"] ? PriorityJsonBean.fromJS(_data["priority"]) : <any>undefined;
            this.status = _data["status"] ? StatusJsonBean.fromJS(_data["status"]) : <any>undefined;
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): Fields {
        data = typeof data === 'object' ? data : {};
        let result = new Fields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["issuetype"] = this.issuetype ? this.issuetype.toJSON() : <any>undefined;
        data["priority"] = this.priority ? this.priority.toJSON() : <any>undefined;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IFields {
    issuetype?: IssueTypeJsonBean;
    priority?: PriorityJsonBean;
    status?: StatusJsonBean;
    summary?: string;

    [key: string]: any;
}

export class FilePart implements IFilePart {
    contentType?: string;
    formField?: boolean;
    inputStream?: any;
    name?: string;
    size?: number;
    value?: string;

    [key: string]: any;

    constructor(data?: IFilePart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contentType = _data["contentType"];
            this.formField = _data["formField"];
            this.inputStream = _data["inputStream"];
            this.name = _data["name"];
            this.size = _data["size"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): FilePart {
        data = typeof data === 'object' ? data : {};
        let result = new FilePart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contentType"] = this.contentType;
        data["formField"] = this.formField;
        data["inputStream"] = this.inputStream;
        data["name"] = this.name;
        data["size"] = this.size;
        data["value"] = this.value;
        return data;
    }
}

export interface IFilePart {
    contentType?: string;
    formField?: boolean;
    inputStream?: any;
    name?: string;
    size?: number;
    value?: string;

    [key: string]: any;
}

export class FilterBean implements IFilterBean {
    description?: string;
    editable?: boolean;
    favourite?: boolean;
    id?: string;
    jql?: string;
    name?: string;
    owner?: UserBean;
    searchUrl?: string;
    self?: string;
    sharePermissions?: FilterPermissionBean[];
    sharedUsers?: UserBeanListWrapper;
    viewUrl?: string;

    [key: string]: any;

    constructor(data?: IFilterBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.editable = _data["editable"];
            this.favourite = _data["favourite"];
            this.id = _data["id"];
            this.jql = _data["jql"];
            this.name = _data["name"];
            this.owner = _data["owner"] ? UserBean.fromJS(_data["owner"]) : <any>undefined;
            this.searchUrl = _data["searchUrl"];
            this.self = _data["self"];
            if (Array.isArray(_data["sharePermissions"])) {
                this.sharePermissions = [] as any;
                for (let item of _data["sharePermissions"])
                    this.sharePermissions!.push(FilterPermissionBean.fromJS(item));
            }
            this.sharedUsers = _data["sharedUsers"] ? UserBeanListWrapper.fromJS(_data["sharedUsers"]) : <any>undefined;
            this.viewUrl = _data["viewUrl"];
        }
    }

    static fromJS(data: any): FilterBean {
        data = typeof data === 'object' ? data : {};
        let result = new FilterBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["editable"] = this.editable;
        data["favourite"] = this.favourite;
        data["id"] = this.id;
        data["jql"] = this.jql;
        data["name"] = this.name;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["searchUrl"] = this.searchUrl;
        data["self"] = this.self;
        if (Array.isArray(this.sharePermissions)) {
            data["sharePermissions"] = [];
            for (let item of this.sharePermissions)
                data["sharePermissions"].push(item.toJSON());
        }
        data["sharedUsers"] = this.sharedUsers ? this.sharedUsers.toJSON() : <any>undefined;
        data["viewUrl"] = this.viewUrl;
        return data;
    }
}

export interface IFilterBean {
    description?: string;
    editable?: boolean;
    favourite?: boolean;
    id?: string;
    jql?: string;
    name?: string;
    owner?: UserBean;
    searchUrl?: string;
    self?: string;
    sharePermissions?: FilterPermissionBean[];
    sharedUsers?: UserBeanListWrapper;
    viewUrl?: string;

    [key: string]: any;
}

export class FilterPermissionBean implements IFilterPermissionBean {
    edit?: boolean;
    group?: GroupJsonBean;
    id?: number;
    project?: ProjectBean;
    role?: ProjectRoleBean;
    type?: string;
    user?: UserBean;
    view?: boolean;

    [key: string]: any;

    constructor(data?: IFilterPermissionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.edit = _data["edit"];
            this.group = _data["group"] ? GroupJsonBean.fromJS(_data["group"]) : <any>undefined;
            this.id = _data["id"];
            this.project = _data["project"] ? ProjectBean.fromJS(_data["project"]) : <any>undefined;
            this.role = _data["role"] ? ProjectRoleBean.fromJS(_data["role"]) : <any>undefined;
            this.type = _data["type"];
            this.user = _data["user"] ? UserBean.fromJS(_data["user"]) : <any>undefined;
            this.view = _data["view"];
        }
    }

    static fromJS(data: any): FilterPermissionBean {
        data = typeof data === 'object' ? data : {};
        let result = new FilterPermissionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["edit"] = this.edit;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["view"] = this.view;
        return data;
    }
}

export interface IFilterPermissionBean {
    edit?: boolean;
    group?: GroupJsonBean;
    id?: number;
    project?: ProjectBean;
    role?: ProjectRoleBean;
    type?: string;
    user?: UserBean;
    view?: boolean;

    [key: string]: any;
}

export class GetReactionsRequestBean implements IGetReactionsRequestBean {
    commentIds?: number[];

    [key: string]: any;

    constructor(data?: IGetReactionsRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["commentIds"])) {
                this.commentIds = [] as any;
                for (let item of _data["commentIds"])
                    this.commentIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GetReactionsRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new GetReactionsRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.commentIds)) {
            data["commentIds"] = [];
            for (let item of this.commentIds)
                data["commentIds"].push(item);
        }
        return data;
    }
}

export interface IGetReactionsRequestBean {
    commentIds?: number[];

    [key: string]: any;
}

export class GrantToPermissionInputBean implements IGrantToPermissionInputBean {
    securityType?: string;
    value?: OptionString;

    [key: string]: any;

    constructor(data?: IGrantToPermissionInputBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.securityType = _data["securityType"];
            this.value = _data["value"] ? OptionString.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GrantToPermissionInputBean {
        data = typeof data === 'object' ? data : {};
        let result = new GrantToPermissionInputBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["securityType"] = this.securityType;
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGrantToPermissionInputBean {
    securityType?: string;
    value?: OptionString;

    [key: string]: any;
}

export class GroupBean implements IGroupBean {
    name?: string;
    self?: string;
    users?: PagedListWrapperUserJsonBeanApplicationUser;

    [key: string]: any;

    constructor(data?: IGroupBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.self = _data["self"];
            this.users = _data["users"] ? PagedListWrapperUserJsonBeanApplicationUser.fromJS(_data["users"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GroupBean {
        data = typeof data === 'object' ? data : {};
        let result = new GroupBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["self"] = this.self;
        data["users"] = this.users ? this.users.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGroupBean {
    name?: string;
    self?: string;
    users?: PagedListWrapperUserJsonBeanApplicationUser;

    [key: string]: any;
}

export class GroupJsonBean implements IGroupJsonBean {
    name?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IGroupJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): GroupJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new GroupJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

export interface IGroupJsonBean {
    name?: string;
    self?: string;

    [key: string]: any;
}

export class GroupLabelBean implements IGroupLabelBean {
    text?: string;
    title?: string;
    type?: GroupLabelBeanType;

    [key: string]: any;

    constructor(data?: IGroupLabelBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.text = _data["text"];
            this.title = _data["title"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): GroupLabelBean {
        data = typeof data === 'object' ? data : {};
        let result = new GroupLabelBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["text"] = this.text;
        data["title"] = this.title;
        data["type"] = this.type;
        return data;
    }
}

export interface IGroupLabelBean {
    text?: string;
    title?: string;
    type?: GroupLabelBeanType;

    [key: string]: any;
}

export class GroupSuggestionBean implements IGroupSuggestionBean {
    html?: string;
    labels?: GroupLabelBean[];
    name?: string;

    [key: string]: any;

    constructor(data?: IGroupSuggestionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.html = _data["html"];
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(GroupLabelBean.fromJS(item));
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GroupSuggestionBean {
        data = typeof data === 'object' ? data : {};
        let result = new GroupSuggestionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["html"] = this.html;
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        data["name"] = this.name;
        return data;
    }
}

export interface IGroupSuggestionBean {
    html?: string;
    labels?: GroupLabelBean[];
    name?: string;

    [key: string]: any;
}

export class GroupSuggestionsBean implements IGroupSuggestionsBean {
    groups?: GroupSuggestionBean[];
    header?: string;
    total?: number;

    [key: string]: any;

    constructor(data?: IGroupSuggestionsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(GroupSuggestionBean.fromJS(item));
            }
            this.header = _data["header"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): GroupSuggestionsBean {
        data = typeof data === 'object' ? data : {};
        let result = new GroupSuggestionsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        data["header"] = this.header;
        data["total"] = this.total;
        return data;
    }
}

export interface IGroupSuggestionsBean {
    groups?: GroupSuggestionBean[];
    header?: string;
    total?: number;

    [key: string]: any;
}

export class HumanReadableArchive implements IHumanReadableArchive {
    entries?: any;
    id?: number;
    mediaType?: string;
    name?: string;
    totalEntryCount?: number;

    [key: string]: any;

    constructor(data?: IHumanReadableArchive) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entries = _data["entries"];
            this.id = _data["id"];
            this.mediaType = _data["mediaType"];
            this.name = _data["name"];
            this.totalEntryCount = _data["totalEntryCount"];
        }
    }

    static fromJS(data: any): HumanReadableArchive {
        data = typeof data === 'object' ? data : {};
        let result = new HumanReadableArchive();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entries"] = this.entries;
        data["id"] = this.id;
        data["mediaType"] = this.mediaType;
        data["name"] = this.name;
        data["totalEntryCount"] = this.totalEntryCount;
        return data;
    }
}

export interface IHumanReadableArchive {
    entries?: any;
    id?: number;
    mediaType?: string;
    name?: string;
    totalEntryCount?: number;

    [key: string]: any;
}

export class Icon implements IIcon {
    link?: string;
    title?: string;
    url16x16?: string;

    [key: string]: any;

    constructor(data?: IIcon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.link = _data["link"];
            this.title = _data["title"];
            this.url16x16 = _data["url16x16"];
        }
    }

    static fromJS(data: any): Icon {
        data = typeof data === 'object' ? data : {};
        let result = new Icon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["link"] = this.link;
        data["title"] = this.title;
        data["url16x16"] = this.url16x16;
        return data;
    }
}

export interface IIcon {
    link?: string;
    title?: string;
    url16x16?: string;

    [key: string]: any;
}

export class IdBean implements IIdBean {
    id?: number;

    [key: string]: any;

    constructor(data?: IIdBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IdBean {
        data = typeof data === 'object' ? data : {};
        let result = new IdBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IIdBean {
    id?: number;

    [key: string]: any;
}

export class IndexReplicationQueueEntryBean implements IIndexReplicationQueueEntryBean {
    id?: number;
    replicationTime?: Date;

    [key: string]: any;

    constructor(data?: IIndexReplicationQueueEntryBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.replicationTime = _data["replicationTime"] ? new Date(_data["replicationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): IndexReplicationQueueEntryBean {
        data = typeof data === 'object' ? data : {};
        let result = new IndexReplicationQueueEntryBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["replicationTime"] = this.replicationTime ? this.replicationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IIndexReplicationQueueEntryBean {
    id?: number;
    replicationTime?: Date;

    [key: string]: any;
}

export class IndexReplicationQueueSummaryBean implements IIndexReplicationQueueSummaryBean {
    lastConsumedOperation?: IndexReplicationQueueEntryBean;
    lastOperationInQueue?: IndexReplicationQueueEntryBean;
    queueSize?: number;

    [key: string]: any;

    constructor(data?: IIndexReplicationQueueSummaryBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.lastConsumedOperation = _data["lastConsumedOperation"] ? IndexReplicationQueueEntryBean.fromJS(_data["lastConsumedOperation"]) : <any>undefined;
            this.lastOperationInQueue = _data["lastOperationInQueue"] ? IndexReplicationQueueEntryBean.fromJS(_data["lastOperationInQueue"]) : <any>undefined;
            this.queueSize = _data["queueSize"];
        }
    }

    static fromJS(data: any): IndexReplicationQueueSummaryBean {
        data = typeof data === 'object' ? data : {};
        let result = new IndexReplicationQueueSummaryBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["lastConsumedOperation"] = this.lastConsumedOperation ? this.lastConsumedOperation.toJSON() : <any>undefined;
        data["lastOperationInQueue"] = this.lastOperationInQueue ? this.lastOperationInQueue.toJSON() : <any>undefined;
        data["queueSize"] = this.queueSize;
        return data;
    }
}

export interface IIndexReplicationQueueSummaryBean {
    lastConsumedOperation?: IndexReplicationQueueEntryBean;
    lastOperationInQueue?: IndexReplicationQueueEntryBean;
    queueSize?: number;

    [key: string]: any;
}

export class IndexSnapshotBean implements IIndexSnapshotBean {
    absolutePath?: string;
    timestamp?: number;

    [key: string]: any;

    constructor(data?: IIndexSnapshotBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.absolutePath = _data["absolutePath"];
            this.timestamp = _data["timestamp"];
        }
    }

    static fromJS(data: any): IndexSnapshotBean {
        data = typeof data === 'object' ? data : {};
        let result = new IndexSnapshotBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["absolutePath"] = this.absolutePath;
        data["timestamp"] = this.timestamp;
        return data;
    }
}

export interface IIndexSnapshotBean {
    absolutePath?: string;
    timestamp?: number;

    [key: string]: any;
}

export class IndexSnapshotPromiseBean implements IIndexSnapshotPromiseBean {
    futureAbsolutePath?: string;

    [key: string]: any;

    constructor(data?: IIndexSnapshotPromiseBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.futureAbsolutePath = _data["futureAbsolutePath"];
        }
    }

    static fromJS(data: any): IndexSnapshotPromiseBean {
        data = typeof data === 'object' ? data : {};
        let result = new IndexSnapshotPromiseBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["futureAbsolutePath"] = this.futureAbsolutePath;
        return data;
    }
}

export interface IIndexSnapshotPromiseBean {
    futureAbsolutePath?: string;

    [key: string]: any;
}

export class IndexSnapshotStatusBean implements IIndexSnapshotStatusBean {
    running?: boolean;

    [key: string]: any;

    constructor(data?: IIndexSnapshotStatusBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.running = _data["running"];
        }
    }

    static fromJS(data: any): IndexSnapshotStatusBean {
        data = typeof data === 'object' ? data : {};
        let result = new IndexSnapshotStatusBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["running"] = this.running;
        return data;
    }
}

export interface IIndexSnapshotStatusBean {
    running?: boolean;

    [key: string]: any;
}

export class IndexSummaryBean implements IIndexSummaryBean {
    issueIndex?: IssueIndexSummaryBean;
    nodeId?: string;
    replicationQueues?: { [key: string]: IndexReplicationQueueSummaryBean; };
    reportTime?: Date;

    [key: string]: any;

    constructor(data?: IIndexSummaryBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.issueIndex = _data["issueIndex"] ? IssueIndexSummaryBean.fromJS(_data["issueIndex"]) : <any>undefined;
            this.nodeId = _data["nodeId"];
            if (_data["replicationQueues"]) {
                this.replicationQueues = {} as any;
                for (let key in _data["replicationQueues"]) {
                    if (_data["replicationQueues"].hasOwnProperty(key))
                        (<any>this.replicationQueues)![key] = _data["replicationQueues"][key] ? IndexReplicationQueueSummaryBean.fromJS(_data["replicationQueues"][key]) : new IndexReplicationQueueSummaryBean();
                }
            }
            this.reportTime = _data["reportTime"] ? new Date(_data["reportTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): IndexSummaryBean {
        data = typeof data === 'object' ? data : {};
        let result = new IndexSummaryBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["issueIndex"] = this.issueIndex ? this.issueIndex.toJSON() : <any>undefined;
        data["nodeId"] = this.nodeId;
        if (this.replicationQueues) {
            data["replicationQueues"] = {};
            for (let key in this.replicationQueues) {
                if (this.replicationQueues.hasOwnProperty(key))
                    (<any>data["replicationQueues"])[key] = this.replicationQueues[key] ? this.replicationQueues[key].toJSON() : <any>undefined;
            }
        }
        data["reportTime"] = this.reportTime ? this.reportTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IIndexSummaryBean {
    issueIndex?: IssueIndexSummaryBean;
    nodeId?: string;
    replicationQueues?: { [key: string]: IndexReplicationQueueSummaryBean; };
    reportTime?: Date;

    [key: string]: any;
}

export class IpdMonitoringRestEntity implements IIpdMonitoringRestEntity {
    enabled?: boolean;

    [key: string]: any;

    constructor(data?: IIpdMonitoringRestEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.enabled = _data["enabled"];
        }
    }

    static fromJS(data: any): IpdMonitoringRestEntity {
        data = typeof data === 'object' ? data : {};
        let result = new IpdMonitoringRestEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["enabled"] = this.enabled;
        return data;
    }
}

export interface IIpdMonitoringRestEntity {
    enabled?: boolean;

    [key: string]: any;
}

export class IssueCreateResponse implements IIssueCreateResponse {
    id?: string;
    key?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IIssueCreateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.key = _data["key"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): IssueCreateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new IssueCreateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["key"] = this.key;
        data["self"] = this.self;
        return data;
    }
}

export interface IIssueCreateResponse {
    id?: string;
    key?: string;
    self?: string;

    [key: string]: any;
}

export class IssueIndexSummaryBean implements IIssueIndexSummaryBean {
    countInArchive?: number;
    countInDatabase?: number;
    countInIndex?: number;
    indexReadable?: boolean;
    lastUpdatedInDatabase?: Date;
    lastUpdatedInIndex?: Date;

    [key: string]: any;

    constructor(data?: IIssueIndexSummaryBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.countInArchive = _data["countInArchive"];
            this.countInDatabase = _data["countInDatabase"];
            this.countInIndex = _data["countInIndex"];
            this.indexReadable = _data["indexReadable"];
            this.lastUpdatedInDatabase = _data["lastUpdatedInDatabase"] ? new Date(_data["lastUpdatedInDatabase"].toString()) : <any>undefined;
            this.lastUpdatedInIndex = _data["lastUpdatedInIndex"] ? new Date(_data["lastUpdatedInIndex"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): IssueIndexSummaryBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueIndexSummaryBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["countInArchive"] = this.countInArchive;
        data["countInDatabase"] = this.countInDatabase;
        data["countInIndex"] = this.countInIndex;
        data["indexReadable"] = this.indexReadable;
        data["lastUpdatedInDatabase"] = this.lastUpdatedInDatabase ? this.lastUpdatedInDatabase.toISOString() : <any>undefined;
        data["lastUpdatedInIndex"] = this.lastUpdatedInIndex ? this.lastUpdatedInIndex.toISOString() : <any>undefined;
        return data;
    }
}

export interface IIssueIndexSummaryBean {
    countInArchive?: number;
    countInDatabase?: number;
    countInIndex?: number;
    indexReadable?: boolean;
    lastUpdatedInDatabase?: Date;
    lastUpdatedInIndex?: Date;

    [key: string]: any;
}

export class IssueInvolvementBean implements IIssueInvolvementBean {
    id?: string;
    label?: string;

    [key: string]: any;

    constructor(data?: IIssueInvolvementBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): IssueInvolvementBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueInvolvementBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["label"] = this.label;
        return data;
    }
}

export interface IIssueInvolvementBean {
    id?: string;
    label?: string;

    [key: string]: any;
}

export class IssueLinkTypeJsonBean implements IIssueLinkTypeJsonBean {
    id?: string;
    inward?: string;
    name?: string;
    outward?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IIssueLinkTypeJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.inward = _data["inward"];
            this.name = _data["name"];
            this.outward = _data["outward"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): IssueLinkTypeJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueLinkTypeJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["inward"] = this.inward;
        data["name"] = this.name;
        data["outward"] = this.outward;
        data["self"] = this.self;
        return data;
    }
}

export interface IIssueLinkTypeJsonBean {
    id?: string;
    inward?: string;
    name?: string;
    outward?: string;
    self?: string;

    [key: string]: any;
}

export class IssueLinkTypeOrderUpdateRequest implements IIssueLinkTypeOrderUpdateRequest {
    newPosition?: number;

    [key: string]: any;

    constructor(data?: IIssueLinkTypeOrderUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.newPosition = _data["newPosition"];
        }
    }

    static fromJS(data: any): IssueLinkTypeOrderUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new IssueLinkTypeOrderUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["newPosition"] = this.newPosition;
        return data;
    }
}

export interface IIssueLinkTypeOrderUpdateRequest {
    newPosition?: number;

    [key: string]: any;
}

export class IssueLinkTypeResetOrderRequest implements IIssueLinkTypeResetOrderRequest {
    direction?: string;

    [key: string]: any;

    constructor(data?: IIssueLinkTypeResetOrderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.direction = _data["direction"];
        }
    }

    static fromJS(data: any): IssueLinkTypeResetOrderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new IssueLinkTypeResetOrderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["direction"] = this.direction;
        return data;
    }
}

export interface IIssueLinkTypeResetOrderRequest {
    direction?: string;

    [key: string]: any;
}

export class IssueLinkTypesBean implements IIssueLinkTypesBean {

    [key: string]: any;

    constructor(data?: IIssueLinkTypesBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): IssueLinkTypesBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueLinkTypesBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IIssueLinkTypesBean {

    [key: string]: any;
}

export class IssuePickerIssue implements IIssuePickerIssue {
    img?: string;
    key?: string;
    keyHtml?: string;
    summary?: string;
    summaryText?: string;

    [key: string]: any;

    constructor(data?: IIssuePickerIssue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.img = _data["img"];
            this.key = _data["key"];
            this.keyHtml = _data["keyHtml"];
            this.summary = _data["summary"];
            this.summaryText = _data["summaryText"];
        }
    }

    static fromJS(data: any): IssuePickerIssue {
        data = typeof data === 'object' ? data : {};
        let result = new IssuePickerIssue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["img"] = this.img;
        data["key"] = this.key;
        data["keyHtml"] = this.keyHtml;
        data["summary"] = this.summary;
        data["summaryText"] = this.summaryText;
        return data;
    }
}

export interface IIssuePickerIssue {
    img?: string;
    key?: string;
    keyHtml?: string;
    summary?: string;
    summaryText?: string;

    [key: string]: any;
}

export class IssuePickerResult implements IIssuePickerResult {
    sections?: IssueSection[];

    [key: string]: any;

    constructor(data?: IIssuePickerResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(IssueSection.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IssuePickerResult {
        data = typeof data === 'object' ? data : {};
        let result = new IssuePickerResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIssuePickerResult {
    sections?: IssueSection[];

    [key: string]: any;
}

export class IssueRefJsonBean implements IIssueRefJsonBean {
    fields?: Fields;
    id?: string;
    key?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IIssueRefJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.fields = _data["fields"] ? Fields.fromJS(_data["fields"]) : <any>undefined;
            this.id = _data["id"];
            this.key = _data["key"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): IssueRefJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueRefJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["fields"] = this.fields ? this.fields.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["key"] = this.key;
        data["self"] = this.self;
        return data;
    }
}

export interface IIssueRefJsonBean {
    fields?: Fields;
    id?: string;
    key?: string;
    self?: string;

    [key: string]: any;
}

export class IssueSection implements IIssueSection {
    id?: string;
    issues?: IssuePickerIssue[];
    label?: string;
    msg?: string;
    sub?: string;

    [key: string]: any;

    constructor(data?: IIssueSection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            if (Array.isArray(_data["issues"])) {
                this.issues = [] as any;
                for (let item of _data["issues"])
                    this.issues!.push(IssuePickerIssue.fromJS(item));
            }
            this.label = _data["label"];
            this.msg = _data["msg"];
            this.sub = _data["sub"];
        }
    }

    static fromJS(data: any): IssueSection {
        data = typeof data === 'object' ? data : {};
        let result = new IssueSection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item.toJSON());
        }
        data["label"] = this.label;
        data["msg"] = this.msg;
        data["sub"] = this.sub;
        return data;
    }
}

export interface IIssueSection {
    id?: string;
    issues?: IssuePickerIssue[];
    label?: string;
    msg?: string;
    sub?: string;

    [key: string]: any;
}

export class IssueSubTaskMovePositionBean implements IIssueSubTaskMovePositionBean {
    current?: number;
    original?: number;

    [key: string]: any;

    constructor(data?: IIssueSubTaskMovePositionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.current = _data["current"];
            this.original = _data["original"];
        }
    }

    static fromJS(data: any): IssueSubTaskMovePositionBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueSubTaskMovePositionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["current"] = this.current;
        data["original"] = this.original;
        return data;
    }
}

export interface IIssueSubTaskMovePositionBean {
    current?: number;
    original?: number;

    [key: string]: any;
}

export class IssueTypeCreateBean implements IIssueTypeCreateBean {
    description?: string;
    name?: string;
    type?: IssueTypeCreateBeanType;

    [key: string]: any;

    constructor(data?: IIssueTypeCreateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): IssueTypeCreateBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeCreateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

export interface IIssueTypeCreateBean {
    description?: string;
    name?: string;
    type?: IssueTypeCreateBeanType;

    [key: string]: any;
}

export class IssueTypeJsonBean implements IIssueTypeJsonBean {
    avatarId?: number;
    description?: string;
    iconUrl?: string;
    id?: string;
    name?: string;
    self?: string;
    subtask?: boolean;

    [key: string]: any;

    constructor(data?: IIssueTypeJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.avatarId = _data["avatarId"];
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.self = _data["self"];
            this.subtask = _data["subtask"];
        }
    }

    static fromJS(data: any): IssueTypeJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["avatarId"] = this.avatarId;
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        data["subtask"] = this.subtask;
        return data;
    }
}

export interface IIssueTypeJsonBean {
    avatarId?: number;
    description?: string;
    iconUrl?: string;
    id?: string;
    name?: string;
    self?: string;
    subtask?: boolean;

    [key: string]: any;
}

export class IssueTypeMappingBean implements IIssueTypeMappingBean {
    issueType?: string;
    updateDraftIfNeeded?: boolean;
    workflow?: string;

    [key: string]: any;

    constructor(data?: IIssueTypeMappingBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.issueType = _data["issueType"];
            this.updateDraftIfNeeded = _data["updateDraftIfNeeded"];
            this.workflow = _data["workflow"];
        }
    }

    static fromJS(data: any): IssueTypeMappingBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeMappingBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["issueType"] = this.issueType;
        data["updateDraftIfNeeded"] = this.updateDraftIfNeeded;
        data["workflow"] = this.workflow;
        return data;
    }
}

export interface IIssueTypeMappingBean {
    issueType?: string;
    updateDraftIfNeeded?: boolean;
    workflow?: string;

    [key: string]: any;
}

export class IssueTypeSchemeBean implements IIssueTypeSchemeBean {
    defaultIssueType?: IssueTypeJsonBean;
    description?: string;
    expand?: string;
    id?: string;
    issueTypes?: IssueTypeJsonBean[];
    name?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IIssueTypeSchemeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.defaultIssueType = _data["defaultIssueType"] ? IssueTypeJsonBean.fromJS(_data["defaultIssueType"]) : <any>undefined;
            this.description = _data["description"];
            this.expand = _data["expand"];
            this.id = _data["id"];
            if (Array.isArray(_data["issueTypes"])) {
                this.issueTypes = [] as any;
                for (let item of _data["issueTypes"])
                    this.issueTypes!.push(IssueTypeJsonBean.fromJS(item));
            }
            this.name = _data["name"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): IssueTypeSchemeBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeSchemeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["defaultIssueType"] = this.defaultIssueType ? this.defaultIssueType.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["expand"] = this.expand;
        data["id"] = this.id;
        if (Array.isArray(this.issueTypes)) {
            data["issueTypes"] = [];
            for (let item of this.issueTypes)
                data["issueTypes"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

export interface IIssueTypeSchemeBean {
    defaultIssueType?: IssueTypeJsonBean;
    description?: string;
    expand?: string;
    id?: string;
    issueTypes?: IssueTypeJsonBean[];
    name?: string;
    self?: string;

    [key: string]: any;
}

export class IssueTypeSchemeCreateUpdateBean implements IIssueTypeSchemeCreateUpdateBean {
    defaultIssueTypeId?: string;
    description?: string;
    issueTypeIDs?: string[];
    issueTypeIds?: string[];
    name?: string;

    [key: string]: any;

    constructor(data?: IIssueTypeSchemeCreateUpdateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.defaultIssueTypeId = _data["defaultIssueTypeId"];
            this.description = _data["description"];
            if (Array.isArray(_data["issueTypeIDs"])) {
                this.issueTypeIDs = [] as any;
                for (let item of _data["issueTypeIDs"])
                    this.issueTypeIDs!.push(item);
            }
            if (Array.isArray(_data["issueTypeIds"])) {
                this.issueTypeIds = [] as any;
                for (let item of _data["issueTypeIds"])
                    this.issueTypeIds!.push(item);
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IssueTypeSchemeCreateUpdateBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeSchemeCreateUpdateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["defaultIssueTypeId"] = this.defaultIssueTypeId;
        data["description"] = this.description;
        if (Array.isArray(this.issueTypeIDs)) {
            data["issueTypeIDs"] = [];
            for (let item of this.issueTypeIDs)
                data["issueTypeIDs"].push(item);
        }
        if (Array.isArray(this.issueTypeIds)) {
            data["issueTypeIds"] = [];
            for (let item of this.issueTypeIds)
                data["issueTypeIds"].push(item);
        }
        data["name"] = this.name;
        return data;
    }
}

export interface IIssueTypeSchemeCreateUpdateBean {
    defaultIssueTypeId?: string;
    description?: string;
    issueTypeIDs?: string[];
    issueTypeIds?: string[];
    name?: string;

    [key: string]: any;
}

export class IssueTypeSchemeListBean implements IIssueTypeSchemeListBean {
    schemes?: IssueTypeSchemeBean[];

    [key: string]: any;

    constructor(data?: IIssueTypeSchemeListBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["schemes"])) {
                this.schemes = [] as any;
                for (let item of _data["schemes"])
                    this.schemes!.push(IssueTypeSchemeBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IssueTypeSchemeListBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeSchemeListBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.schemes)) {
            data["schemes"] = [];
            for (let item of this.schemes)
                data["schemes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIssueTypeSchemeListBean {
    schemes?: IssueTypeSchemeBean[];

    [key: string]: any;
}

export class IssueTypeUpdateBean implements IIssueTypeUpdateBean {
    avatarId?: number;
    description?: string;
    name?: string;

    [key: string]: any;

    constructor(data?: IIssueTypeUpdateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.avatarId = _data["avatarId"];
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IssueTypeUpdateBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeUpdateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["avatarId"] = this.avatarId;
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

export interface IIssueTypeUpdateBean {
    avatarId?: number;
    description?: string;
    name?: string;

    [key: string]: any;
}

export class IssueTypeWithStatusJsonBean implements IIssueTypeWithStatusJsonBean {
    id?: string;
    name?: string;
    self?: string;
    statuses?: StatusJsonBean[];
    subtask?: boolean;

    [key: string]: any;

    constructor(data?: IIssueTypeWithStatusJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.self = _data["self"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(StatusJsonBean.fromJS(item));
            }
            this.subtask = _data["subtask"];
        }
    }

    static fromJS(data: any): IssueTypeWithStatusJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeWithStatusJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        data["subtask"] = this.subtask;
        return data;
    }
}

export interface IIssueTypeWithStatusJsonBean {
    id?: string;
    name?: string;
    self?: string;
    statuses?: StatusJsonBean[];
    subtask?: boolean;

    [key: string]: any;
}

export class IssueUpdateBean implements IIssueUpdateBean {
    fields?: { [key: string]: any; };
    historyMetadata?: HistoryMetadata;
    properties?: EntityPropertyBean[];
    transition?: TransitionBean;
    update?: { [key: string]: FieldOperation[]; };

    [key: string]: any;

    constructor(data?: IIssueUpdateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["fields"]) {
                this.fields = {} as any;
                for (let key in _data["fields"]) {
                    if (_data["fields"].hasOwnProperty(key))
                        (<any>this.fields)![key] = _data["fields"][key];
                }
            }
            this.historyMetadata = _data["historyMetadata"] ? HistoryMetadata.fromJS(_data["historyMetadata"]) : <any>undefined;
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(EntityPropertyBean.fromJS(item));
            }
            this.transition = _data["transition"] ? TransitionBean.fromJS(_data["transition"]) : <any>undefined;
            if (_data["update"]) {
                this.update = {} as any;
                for (let key in _data["update"]) {
                    if (_data["update"].hasOwnProperty(key))
                        (<any>this.update)![key] = _data["update"][key] ? _data["update"][key].map((i: any) => FieldOperation.fromJS(i)) : [];
                }
            }
        }
    }

    static fromJS(data: any): IssueUpdateBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueUpdateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.fields) {
            data["fields"] = {};
            for (let key in this.fields) {
                if (this.fields.hasOwnProperty(key))
                    (<any>data["fields"])[key] = (<any>this.fields)[key];
            }
        }
        data["historyMetadata"] = this.historyMetadata ? this.historyMetadata.toJSON() : <any>undefined;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        data["transition"] = this.transition ? this.transition.toJSON() : <any>undefined;
        if (this.update) {
            data["update"] = {};
            for (let key in this.update) {
                if (this.update.hasOwnProperty(key))
                    (<any>data["update"])[key] = (<any>this.update)[key];
            }
        }
        return data;
    }
}

export interface IIssueUpdateBean {
    fields?: { [key: string]: any; };
    historyMetadata?: HistoryMetadata;
    properties?: EntityPropertyBean[];
    transition?: TransitionBean;
    update?: { [key: string]: FieldOperation[]; };

    [key: string]: any;
}

export class IssuesCreateResponse implements IIssuesCreateResponse {
    errors?: BulkOperationErrorResult[];
    issues?: IssueCreateResponse[];

    [key: string]: any;

    constructor(data?: IIssuesCreateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(BulkOperationErrorResult.fromJS(item));
            }
            if (Array.isArray(_data["issues"])) {
                this.issues = [] as any;
                for (let item of _data["issues"])
                    this.issues!.push(IssueCreateResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IssuesCreateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new IssuesCreateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIssuesCreateResponse {
    errors?: BulkOperationErrorResult[];
    issues?: IssueCreateResponse[];

    [key: string]: any;
}

export class IssuesUpdateBean implements IIssuesUpdateBean {
    issueUpdates?: IssueUpdateBean[];

    [key: string]: any;

    constructor(data?: IIssuesUpdateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["issueUpdates"])) {
                this.issueUpdates = [] as any;
                for (let item of _data["issueUpdates"])
                    this.issueUpdates!.push(IssueUpdateBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IssuesUpdateBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssuesUpdateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.issueUpdates)) {
            data["issueUpdates"] = [];
            for (let item of this.issueUpdates)
                data["issueUpdates"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIssuesUpdateBean {
    issueUpdates?: IssueUpdateBean[];

    [key: string]: any;
}

export class LicenseValidationResults implements ILicenseValidationResults {
    errors?: { [key: string]: string; };
    licenseString?: string;

    [key: string]: any;

    constructor(data?: ILicenseValidationResults) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key];
                }
            }
            this.licenseString = _data["licenseString"];
        }
    }

    static fromJS(data: any): LicenseValidationResults {
        data = typeof data === 'object' ? data : {};
        let result = new LicenseValidationResults();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        data["licenseString"] = this.licenseString;
        return data;
    }
}

export interface ILicenseValidationResults {
    errors?: { [key: string]: string; };
    licenseString?: string;

    [key: string]: any;
}

export class LinkIssueRequestJsonBean implements ILinkIssueRequestJsonBean {
    comment?: CommentJsonBean;
    inwardIssue?: IssueRefJsonBean;
    outwardIssue?: IssueRefJsonBean;
    type?: IssueLinkTypeJsonBean;

    [key: string]: any;

    constructor(data?: ILinkIssueRequestJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.comment = _data["comment"] ? CommentJsonBean.fromJS(_data["comment"]) : <any>undefined;
            this.inwardIssue = _data["inwardIssue"] ? IssueRefJsonBean.fromJS(_data["inwardIssue"]) : <any>undefined;
            this.outwardIssue = _data["outwardIssue"] ? IssueRefJsonBean.fromJS(_data["outwardIssue"]) : <any>undefined;
            this.type = _data["type"] ? IssueLinkTypeJsonBean.fromJS(_data["type"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LinkIssueRequestJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new LinkIssueRequestJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["comment"] = this.comment ? this.comment.toJSON() : <any>undefined;
        data["inwardIssue"] = this.inwardIssue ? this.inwardIssue.toJSON() : <any>undefined;
        data["outwardIssue"] = this.outwardIssue ? this.outwardIssue.toJSON() : <any>undefined;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILinkIssueRequestJsonBean {
    comment?: CommentJsonBean;
    inwardIssue?: IssueRefJsonBean;
    outwardIssue?: IssueRefJsonBean;
    type?: IssueLinkTypeJsonBean;

    [key: string]: any;
}

export class ListWrapperCallbackApplicationRoleBean implements IListWrapperCallbackApplicationRoleBean {

    [key: string]: any;

    constructor(data?: IListWrapperCallbackApplicationRoleBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): ListWrapperCallbackApplicationRoleBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListWrapperCallbackApplicationRoleBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IListWrapperCallbackApplicationRoleBean {

    [key: string]: any;
}

export class ListWrapperCallbackGroupJsonBean implements IListWrapperCallbackGroupJsonBean {

    [key: string]: any;

    constructor(data?: IListWrapperCallbackGroupJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): ListWrapperCallbackGroupJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListWrapperCallbackGroupJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IListWrapperCallbackGroupJsonBean {

    [key: string]: any;
}

export class ListWrapperCallbackUserBean implements IListWrapperCallbackUserBean {

    [key: string]: any;

    constructor(data?: IListWrapperCallbackUserBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): ListWrapperCallbackUserBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListWrapperCallbackUserBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IListWrapperCallbackUserBean {

    [key: string]: any;
}

export class ListWrapperCallbackUserJsonBean implements IListWrapperCallbackUserJsonBean {

    [key: string]: any;

    constructor(data?: IListWrapperCallbackUserJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): ListWrapperCallbackUserJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new ListWrapperCallbackUserJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IListWrapperCallbackUserJsonBean {

    [key: string]: any;
}

export class LoginInfo implements ILoginInfo {
    failedLoginCount?: number;
    lastFailedLoginTime?: Date;
    loginCount?: number;
    previousLoginTime?: Date;

    [key: string]: any;

    constructor(data?: ILoginInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.failedLoginCount = _data["failedLoginCount"];
            this.lastFailedLoginTime = _data["lastFailedLoginTime"] ? new Date(_data["lastFailedLoginTime"].toString()) : <any>undefined;
            this.loginCount = _data["loginCount"];
            this.previousLoginTime = _data["previousLoginTime"] ? new Date(_data["previousLoginTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LoginInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LoginInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["failedLoginCount"] = this.failedLoginCount;
        data["lastFailedLoginTime"] = this.lastFailedLoginTime ? this.lastFailedLoginTime.toISOString() : <any>undefined;
        data["loginCount"] = this.loginCount;
        data["previousLoginTime"] = this.previousLoginTime ? this.previousLoginTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface ILoginInfo {
    failedLoginCount?: number;
    lastFailedLoginTime?: Date;
    loginCount?: number;
    previousLoginTime?: Date;

    [key: string]: any;
}

export class LuceneFieldSorter implements ILuceneFieldSorter {
    comparator?: any;
    documentConstant?: string;

    [key: string]: any;

    constructor(data?: ILuceneFieldSorter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.comparator = _data["comparator"];
            this.documentConstant = _data["documentConstant"];
        }
    }

    static fromJS(data: any): LuceneFieldSorter {
        data = typeof data === 'object' ? data : {};
        let result = new LuceneFieldSorter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["comparator"] = this.comparator;
        data["documentConstant"] = this.documentConstant;
        return data;
    }
}

export interface ILuceneFieldSorter {
    comparator?: any;
    documentConstant?: string;

    [key: string]: any;
}

export class MoveFieldBean implements IMoveFieldBean {
    after?: string;
    position?: MoveFieldBeanPosition;

    [key: string]: any;

    constructor(data?: IMoveFieldBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.after = _data["after"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): MoveFieldBean {
        data = typeof data === 'object' ? data : {};
        let result = new MoveFieldBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["after"] = this.after;
        data["position"] = this.position;
        return data;
    }
}

export interface IMoveFieldBean {
    after?: string;
    position?: MoveFieldBeanPosition;

    [key: string]: any;
}

export class NavigableField implements INavigableField {
    columnCssClass?: string;
    columnHeadingKey?: string;
    defaultSortOrder?: string;
    hiddenFieldId?: string;
    id?: string;
    name?: string;
    nameKey?: string;
    sortComparatorSource?: FieldComparatorSource;
    sorter?: LuceneFieldSorter;
    valueLoader?: FieldValueLoader;

    [key: string]: any;

    constructor(data?: INavigableField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.columnCssClass = _data["columnCssClass"];
            this.columnHeadingKey = _data["columnHeadingKey"];
            this.defaultSortOrder = _data["defaultSortOrder"];
            this.hiddenFieldId = _data["hiddenFieldId"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.nameKey = _data["nameKey"];
            this.sortComparatorSource = _data["sortComparatorSource"] ? FieldComparatorSource.fromJS(_data["sortComparatorSource"]) : <any>undefined;
            this.sorter = _data["sorter"] ? LuceneFieldSorter.fromJS(_data["sorter"]) : <any>undefined;
            this.valueLoader = _data["valueLoader"] ? FieldValueLoader.fromJS(_data["valueLoader"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NavigableField {
        data = typeof data === 'object' ? data : {};
        let result = new NavigableField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["columnCssClass"] = this.columnCssClass;
        data["columnHeadingKey"] = this.columnHeadingKey;
        data["defaultSortOrder"] = this.defaultSortOrder;
        data["hiddenFieldId"] = this.hiddenFieldId;
        data["id"] = this.id;
        data["name"] = this.name;
        data["nameKey"] = this.nameKey;
        data["sortComparatorSource"] = this.sortComparatorSource ? this.sortComparatorSource.toJSON() : <any>undefined;
        data["sorter"] = this.sorter ? this.sorter.toJSON() : <any>undefined;
        data["valueLoader"] = this.valueLoader ? this.valueLoader.toJSON() : <any>undefined;
        return data;
    }
}

export interface INavigableField {
    columnCssClass?: string;
    columnHeadingKey?: string;
    defaultSortOrder?: string;
    hiddenFieldId?: string;
    id?: string;
    name?: string;
    nameKey?: string;
    sortComparatorSource?: FieldComparatorSource;
    sorter?: LuceneFieldSorter;
    valueLoader?: FieldValueLoader;

    [key: string]: any;
}

export class NodeBean implements INodeBean {
    alive?: boolean;
    cacheListenerPort?: number;
    ip?: string;
    lastStateChangeTimestamp?: number;
    nodeBuildNumber?: number;
    nodeId?: string;
    nodeVersion?: string;
    state?: NodeBeanState;

    [key: string]: any;

    constructor(data?: INodeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.alive = _data["alive"];
            this.cacheListenerPort = _data["cacheListenerPort"];
            this.ip = _data["ip"];
            this.lastStateChangeTimestamp = _data["lastStateChangeTimestamp"];
            this.nodeBuildNumber = _data["nodeBuildNumber"];
            this.nodeId = _data["nodeId"];
            this.nodeVersion = _data["nodeVersion"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): NodeBean {
        data = typeof data === 'object' ? data : {};
        let result = new NodeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["alive"] = this.alive;
        data["cacheListenerPort"] = this.cacheListenerPort;
        data["ip"] = this.ip;
        data["lastStateChangeTimestamp"] = this.lastStateChangeTimestamp;
        data["nodeBuildNumber"] = this.nodeBuildNumber;
        data["nodeId"] = this.nodeId;
        data["nodeVersion"] = this.nodeVersion;
        data["state"] = this.state;
        return data;
    }
}

export interface INodeBean {
    alive?: boolean;
    cacheListenerPort?: number;
    ip?: string;
    lastStateChangeTimestamp?: number;
    nodeBuildNumber?: number;
    nodeId?: string;
    nodeVersion?: string;
    state?: NodeBeanState;

    [key: string]: any;
}

export class NodeBuildInfo implements INodeBuildInfo {
    buildNumber?: number;
    version?: string;

    [key: string]: any;

    constructor(data?: INodeBuildInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.buildNumber = _data["buildNumber"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): NodeBuildInfo {
        data = typeof data === 'object' ? data : {};
        let result = new NodeBuildInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["buildNumber"] = this.buildNumber;
        data["version"] = this.version;
        return data;
    }
}

export interface INodeBuildInfo {
    buildNumber?: number;
    version?: string;

    [key: string]: any;
}

export class NotificationJsonBean implements INotificationJsonBean {
    htmlBody?: string;
    restrict?: RestrictJsonBean;
    subject?: string;
    textBody?: string;
    to?: ToJsonBean;

    [key: string]: any;

    constructor(data?: INotificationJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.htmlBody = _data["htmlBody"];
            this.restrict = _data["restrict"] ? RestrictJsonBean.fromJS(_data["restrict"]) : <any>undefined;
            this.subject = _data["subject"];
            this.textBody = _data["textBody"];
            this.to = _data["to"] ? ToJsonBean.fromJS(_data["to"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["htmlBody"] = this.htmlBody;
        data["restrict"] = this.restrict ? this.restrict.toJSON() : <any>undefined;
        data["subject"] = this.subject;
        data["textBody"] = this.textBody;
        data["to"] = this.to ? this.to.toJSON() : <any>undefined;
        return data;
    }
}

export interface INotificationJsonBean {
    htmlBody?: string;
    restrict?: RestrictJsonBean;
    subject?: string;
    textBody?: string;
    to?: ToJsonBean;

    [key: string]: any;
}

export class NotificationSchemeBean implements INotificationSchemeBean {
    description?: string;
    expand?: string;
    id?: number;
    name?: string;
    notificationSchemeEvents?: any;
    self?: string;

    [key: string]: any;

    constructor(data?: INotificationSchemeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.expand = _data["expand"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.notificationSchemeEvents = _data["notificationSchemeEvents"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): NotificationSchemeBean {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSchemeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["expand"] = this.expand;
        data["id"] = this.id;
        data["name"] = this.name;
        data["notificationSchemeEvents"] = this.notificationSchemeEvents;
        data["self"] = this.self;
        return data;
    }
}

export interface INotificationSchemeBean {
    description?: string;
    expand?: string;
    id?: number;
    name?: string;
    notificationSchemeEvents?: any;
    self?: string;

    [key: string]: any;
}

export class OptionString implements IOptionString {
    defined?: boolean;
    empty?: boolean;
    orNull?: string;

    [key: string]: any;

    constructor(data?: IOptionString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.defined = _data["defined"];
            this.empty = _data["empty"];
            this.orNull = _data["orNull"];
        }
    }

    static fromJS(data: any): OptionString {
        data = typeof data === 'object' ? data : {};
        let result = new OptionString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["defined"] = this.defined;
        data["empty"] = this.empty;
        data["orNull"] = this.orNull;
        return data;
    }
}

export interface IOptionString {
    defined?: boolean;
    empty?: boolean;
    orNull?: string;

    [key: string]: any;
}

export class OrderByPreferences implements IOrderByPreferences {
    orderByOption?: string;
    projectId?: number;

    [key: string]: any;

    constructor(data?: IOrderByPreferences) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.orderByOption = _data["orderByOption"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): OrderByPreferences {
        data = typeof data === 'object' ? data : {};
        let result = new OrderByPreferences();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["orderByOption"] = this.orderByOption;
        data["projectId"] = this.projectId;
        return data;
    }
}

export interface IOrderByPreferences {
    orderByOption?: string;
    projectId?: number;

    [key: string]: any;
}

export class OriginalOrder implements IOriginalOrder {
    entries?: number[];

    [key: string]: any;

    constructor(data?: IOriginalOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["entries"])) {
                this.entries = [] as any;
                for (let item of _data["entries"])
                    this.entries!.push(item);
            }
        }
    }

    static fromJS(data: any): OriginalOrder {
        data = typeof data === 'object' ? data : {};
        let result = new OriginalOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item);
        }
        return data;
    }
}

export interface IOriginalOrder {
    entries?: number[];

    [key: string]: any;
}

export class PageBean implements IPageBean {
    isLast?: boolean;
    maxResults?: number;
    nextPage?: string;
    self?: string;
    startAt?: number;
    total?: number;
    values?: any[];

    [key: string]: any;

    constructor(data?: IPageBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.isLast = _data["isLast"];
            this.maxResults = _data["maxResults"];
            this.nextPage = _data["nextPage"];
            this.self = _data["self"];
            this.startAt = _data["startAt"];
            this.total = _data["total"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): PageBean {
        data = typeof data === 'object' ? data : {};
        let result = new PageBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data;
    }
}

export interface IPageBean {
    isLast?: boolean;
    maxResults?: number;
    nextPage?: string;
    self?: string;
    startAt?: number;
    total?: number;
    values?: any[];

    [key: string]: any;
}

export class PageBeanProjectBean implements IPageBeanProjectBean {
    isLast?: boolean;
    maxResults?: number;
    nextPage?: string;
    self?: string;
    startAt?: number;
    total?: number;
    values?: ProjectBean[];

    [key: string]: any;

    constructor(data?: IPageBeanProjectBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.isLast = _data["isLast"];
            this.maxResults = _data["maxResults"];
            this.nextPage = _data["nextPage"];
            this.self = _data["self"];
            this.startAt = _data["startAt"];
            this.total = _data["total"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(ProjectBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanProjectBean {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanProjectBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPageBeanProjectBean {
    isLast?: boolean;
    maxResults?: number;
    nextPage?: string;
    self?: string;
    startAt?: number;
    total?: number;
    values?: ProjectBean[];

    [key: string]: any;
}

export class PagedListWrapperUserJsonBeanApplicationUser implements IPagedListWrapperUserJsonBeanApplicationUser {
    backingListSize?: number;
    callback?: ListWrapperCallbackUserJsonBean;
    items?: UserJsonBean[];
    maxResults?: number;
    pagingCallback?: ListWrapperCallbackUserJsonBean;
    size?: number;

    [key: string]: any;

    constructor(data?: IPagedListWrapperUserJsonBeanApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.backingListSize = _data["backingListSize"];
            this.callback = _data["callback"] ? ListWrapperCallbackUserJsonBean.fromJS(_data["callback"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserJsonBean.fromJS(item));
            }
            this.maxResults = _data["maxResults"];
            this.pagingCallback = _data["pagingCallback"] ? ListWrapperCallbackUserJsonBean.fromJS(_data["pagingCallback"]) : <any>undefined;
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): PagedListWrapperUserJsonBeanApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListWrapperUserJsonBeanApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["backingListSize"] = this.backingListSize;
        data["callback"] = this.callback ? this.callback.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["maxResults"] = this.maxResults;
        data["pagingCallback"] = this.pagingCallback ? this.pagingCallback.toJSON() : <any>undefined;
        data["size"] = this.size;
        return data;
    }
}

export interface IPagedListWrapperUserJsonBeanApplicationUser {
    backingListSize?: number;
    callback?: ListWrapperCallbackUserJsonBean;
    items?: UserJsonBean[];
    maxResults?: number;
    pagingCallback?: ListWrapperCallbackUserJsonBean;
    size?: number;

    [key: string]: any;
}

export class PasswordBean implements IPasswordBean {
    currentPassword?: string;
    password?: string;

    [key: string]: any;

    constructor(data?: IPasswordBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.currentPassword = _data["currentPassword"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): PasswordBean {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["currentPassword"] = this.currentPassword;
        data["password"] = this.password;
        return data;
    }
}

export interface IPasswordBean {
    currentPassword?: string;
    password?: string;

    [key: string]: any;
}

export class PasswordPolicyCreateUserBean implements IPasswordPolicyCreateUserBean {
    displayName?: string;
    emailAddress?: string;
    password?: string;
    username?: string;

    [key: string]: any;

    constructor(data?: IPasswordPolicyCreateUserBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.displayName = _data["displayName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): PasswordPolicyCreateUserBean {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordPolicyCreateUserBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["displayName"] = this.displayName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["username"] = this.username;
        return data;
    }
}

export interface IPasswordPolicyCreateUserBean {
    displayName?: string;
    emailAddress?: string;
    password?: string;
    username?: string;

    [key: string]: any;
}

export class PasswordPolicyUpdateUserBean implements IPasswordPolicyUpdateUserBean {
    newPassword?: string;
    oldPassword?: string;
    username?: string;

    [key: string]: any;

    constructor(data?: IPasswordPolicyUpdateUserBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.newPassword = _data["newPassword"];
            this.oldPassword = _data["oldPassword"];
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): PasswordPolicyUpdateUserBean {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordPolicyUpdateUserBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["newPassword"] = this.newPassword;
        data["oldPassword"] = this.oldPassword;
        data["username"] = this.username;
        return data;
    }
}

export interface IPasswordPolicyUpdateUserBean {
    newPassword?: string;
    oldPassword?: string;
    username?: string;

    [key: string]: any;
}

export class PermissionGrantBean implements IPermissionGrantBean {
    holder?: PermissionHolderBean;
    id?: number;
    permission?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IPermissionGrantBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.holder = _data["holder"] ? PermissionHolderBean.fromJS(_data["holder"]) : <any>undefined;
            this.id = _data["id"];
            this.permission = _data["permission"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): PermissionGrantBean {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGrantBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["holder"] = this.holder ? this.holder.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["permission"] = this.permission;
        data["self"] = this.self;
        return data;
    }
}

export interface IPermissionGrantBean {
    holder?: PermissionHolderBean;
    id?: number;
    permission?: string;
    self?: string;

    [key: string]: any;
}

export class PermissionGrantsBean implements IPermissionGrantsBean {
    expand?: string;
    permissions?: PermissionGrantBean[];

    [key: string]: any;

    constructor(data?: IPermissionGrantsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.expand = _data["expand"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionGrantBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionGrantsBean {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGrantsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["expand"] = this.expand;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionGrantsBean {
    expand?: string;
    permissions?: PermissionGrantBean[];

    [key: string]: any;
}

export class PermissionHolderBean implements IPermissionHolderBean {
    field?: FieldBean;
    group?: GroupJsonBean;
    parameter?: string;
    projectRole?: ProjectRoleBean;
    type?: string;
    user?: UserJsonBean;

    [key: string]: any;

    constructor(data?: IPermissionHolderBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.field = _data["field"] ? FieldBean.fromJS(_data["field"]) : <any>undefined;
            this.group = _data["group"] ? GroupJsonBean.fromJS(_data["group"]) : <any>undefined;
            this.parameter = _data["parameter"];
            this.projectRole = _data["projectRole"] ? ProjectRoleBean.fromJS(_data["projectRole"]) : <any>undefined;
            this.type = _data["type"];
            this.user = _data["user"] ? UserJsonBean.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PermissionHolderBean {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionHolderBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["field"] = this.field ? this.field.toJSON() : <any>undefined;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["parameter"] = this.parameter;
        data["projectRole"] = this.projectRole ? this.projectRole.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPermissionHolderBean {
    field?: FieldBean;
    group?: GroupJsonBean;
    parameter?: string;
    projectRole?: ProjectRoleBean;
    type?: string;
    user?: UserJsonBean;

    [key: string]: any;
}

/** A map of permission keys to permission objects. */
export class PermissionJsonBean implements IPermissionJsonBean {
    description?: string;
    id?: string;
    key?: string;
    name?: string;
    type?: PermissionJsonBeanType;

    [key: string]: any;

    constructor(data?: IPermissionJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.id = _data["id"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): PermissionJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["id"] = this.id;
        data["key"] = this.key;
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

/** A map of permission keys to permission objects. */
export interface IPermissionJsonBean {
    description?: string;
    id?: string;
    key?: string;
    name?: string;
    type?: PermissionJsonBeanType;

    [key: string]: any;
}

export class PermissionSchemeAttributeBean implements IPermissionSchemeAttributeBean {
    key?: string;
    value?: string;

    [key: string]: any;

    constructor(data?: IPermissionSchemeAttributeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PermissionSchemeAttributeBean {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSchemeAttributeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IPermissionSchemeAttributeBean {
    key?: string;
    value?: string;

    [key: string]: any;
}

export class PermissionSchemeBean implements IPermissionSchemeBean {
    description?: string;
    expand?: string;
    id?: number;
    name?: string;
    permissions?: PermissionGrantBean[];
    self?: string;

    [key: string]: any;

    constructor(data?: IPermissionSchemeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.expand = _data["expand"];
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionGrantBean.fromJS(item));
            }
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): PermissionSchemeBean {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSchemeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["expand"] = this.expand;
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        data["self"] = this.self;
        return data;
    }
}

export interface IPermissionSchemeBean {
    description?: string;
    expand?: string;
    id?: number;
    name?: string;
    permissions?: PermissionGrantBean[];
    self?: string;

    [key: string]: any;
}

export class PermissionSchemesBean implements IPermissionSchemesBean {
    permissionSchemes?: PermissionSchemeBean[];

    [key: string]: any;

    constructor(data?: IPermissionSchemesBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["permissionSchemes"])) {
                this.permissionSchemes = [] as any;
                for (let item of _data["permissionSchemes"])
                    this.permissionSchemes!.push(PermissionSchemeBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionSchemesBean {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSchemesBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.permissionSchemes)) {
            data["permissionSchemes"] = [];
            for (let item of this.permissionSchemes)
                data["permissionSchemes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionSchemesBean {
    permissionSchemes?: PermissionSchemeBean[];

    [key: string]: any;
}

export class PermissionsInputBean implements IPermissionsInputBean {
    grants?: GrantToPermissionInputBean[];
    permissionKeys?: string[];

    [key: string]: any;

    constructor(data?: IPermissionsInputBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["grants"])) {
                this.grants = [] as any;
                for (let item of _data["grants"])
                    this.grants!.push(GrantToPermissionInputBean.fromJS(item));
            }
            if (Array.isArray(_data["permissionKeys"])) {
                this.permissionKeys = [] as any;
                for (let item of _data["permissionKeys"])
                    this.permissionKeys!.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionsInputBean {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionsInputBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.grants)) {
            data["grants"] = [];
            for (let item of this.grants)
                data["grants"].push(item.toJSON());
        }
        if (Array.isArray(this.permissionKeys)) {
            data["permissionKeys"] = [];
            for (let item of this.permissionKeys)
                data["permissionKeys"].push(item);
        }
        return data;
    }
}

export interface IPermissionsInputBean {
    grants?: GrantToPermissionInputBean[];
    permissionKeys?: string[];

    [key: string]: any;
}

export class PermissionsJsonBean implements IPermissionsJsonBean {
    /** A map of permission keys to permission objects. */
    permissions?: { [key: string]: PermissionJsonBean; };

    [key: string]: any;

    constructor(data?: IPermissionsJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["permissions"]) {
                this.permissions = {} as any;
                for (let key in _data["permissions"]) {
                    if (_data["permissions"].hasOwnProperty(key))
                        (<any>this.permissions)![key] = _data["permissions"][key] ? PermissionJsonBean.fromJS(_data["permissions"][key]) : new PermissionJsonBean();
                }
            }
        }
    }

    static fromJS(data: any): PermissionsJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionsJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.permissions) {
            data["permissions"] = {};
            for (let key in this.permissions) {
                if (this.permissions.hasOwnProperty(key))
                    (<any>data["permissions"])[key] = this.permissions[key] ? this.permissions[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IPermissionsJsonBean {
    /** A map of permission keys to permission objects. */
    permissions?: { [key: string]: PermissionJsonBean; };

    [key: string]: any;
}

export class PinnedCommentJsonBean implements IPinnedCommentJsonBean {
    comment?: CommentJsonBean;
    pinnedBy?: string;
    pinnedDate?: string;

    [key: string]: any;

    constructor(data?: IPinnedCommentJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.comment = _data["comment"] ? CommentJsonBean.fromJS(_data["comment"]) : <any>undefined;
            this.pinnedBy = _data["pinnedBy"];
            this.pinnedDate = _data["pinnedDate"];
        }
    }

    static fromJS(data: any): PinnedCommentJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new PinnedCommentJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["comment"] = this.comment ? this.comment.toJSON() : <any>undefined;
        data["pinnedBy"] = this.pinnedBy;
        data["pinnedDate"] = this.pinnedDate;
        return data;
    }
}

export interface IPinnedCommentJsonBean {
    comment?: CommentJsonBean;
    pinnedBy?: string;
    pinnedDate?: string;

    [key: string]: any;
}

export class PriorityJsonBean implements IPriorityJsonBean {
    description?: string;
    iconUrl?: string;
    id?: string;
    name?: string;
    self?: string;
    statusColor?: string;

    [key: string]: any;

    constructor(data?: IPriorityJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.self = _data["self"];
            this.statusColor = _data["statusColor"];
        }
    }

    static fromJS(data: any): PriorityJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new PriorityJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        data["statusColor"] = this.statusColor;
        return data;
    }
}

export interface IPriorityJsonBean {
    description?: string;
    iconUrl?: string;
    id?: string;
    name?: string;
    self?: string;
    statusColor?: string;

    [key: string]: any;
}

export class PrioritySchemeBean implements IPrioritySchemeBean {
    defaultOptionId?: string;
    defaultScheme?: boolean;
    description?: string;
    id?: number;
    name?: string;
    optionIds?: string[];
    projectKeys?: string[];
    self?: string;

    [key: string]: any;

    constructor(data?: IPrioritySchemeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.defaultOptionId = _data["defaultOptionId"];
            this.defaultScheme = _data["defaultScheme"];
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["optionIds"])) {
                this.optionIds = [] as any;
                for (let item of _data["optionIds"])
                    this.optionIds!.push(item);
            }
            if (Array.isArray(_data["projectKeys"])) {
                this.projectKeys = [] as any;
                for (let item of _data["projectKeys"])
                    this.projectKeys!.push(item);
            }
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): PrioritySchemeBean {
        data = typeof data === 'object' ? data : {};
        let result = new PrioritySchemeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["defaultOptionId"] = this.defaultOptionId;
        data["defaultScheme"] = this.defaultScheme;
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.optionIds)) {
            data["optionIds"] = [];
            for (let item of this.optionIds)
                data["optionIds"].push(item);
        }
        if (Array.isArray(this.projectKeys)) {
            data["projectKeys"] = [];
            for (let item of this.projectKeys)
                data["projectKeys"].push(item);
        }
        data["self"] = this.self;
        return data;
    }
}

export interface IPrioritySchemeBean {
    defaultOptionId?: string;
    defaultScheme?: boolean;
    description?: string;
    id?: number;
    name?: string;
    optionIds?: string[];
    projectKeys?: string[];
    self?: string;

    [key: string]: any;
}

export class PrioritySchemeListBean implements IPrioritySchemeListBean {
    maxResults?: number;
    schemes?: PrioritySchemeBean[];
    startAt?: number;
    total?: number;

    [key: string]: any;

    constructor(data?: IPrioritySchemeListBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.maxResults = _data["maxResults"];
            if (Array.isArray(_data["schemes"])) {
                this.schemes = [] as any;
                for (let item of _data["schemes"])
                    this.schemes!.push(PrioritySchemeBean.fromJS(item));
            }
            this.startAt = _data["startAt"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): PrioritySchemeListBean {
        data = typeof data === 'object' ? data : {};
        let result = new PrioritySchemeListBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["maxResults"] = this.maxResults;
        if (Array.isArray(this.schemes)) {
            data["schemes"] = [];
            for (let item of this.schemes)
                data["schemes"].push(item.toJSON());
        }
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        return data;
    }
}

export interface IPrioritySchemeListBean {
    maxResults?: number;
    schemes?: PrioritySchemeBean[];
    startAt?: number;
    total?: number;

    [key: string]: any;
}

export class PrioritySchemeUpdateBean implements IPrioritySchemeUpdateBean {
    defaultOptionId?: string;
    description?: string;
    id?: number;
    name?: string;
    optionIds?: string[];

    [key: string]: any;

    constructor(data?: IPrioritySchemeUpdateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.defaultOptionId = _data["defaultOptionId"];
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["optionIds"])) {
                this.optionIds = [] as any;
                for (let item of _data["optionIds"])
                    this.optionIds!.push(item);
            }
        }
    }

    static fromJS(data: any): PrioritySchemeUpdateBean {
        data = typeof data === 'object' ? data : {};
        let result = new PrioritySchemeUpdateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["defaultOptionId"] = this.defaultOptionId;
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.optionIds)) {
            data["optionIds"] = [];
            for (let item of this.optionIds)
                data["optionIds"].push(item);
        }
        return data;
    }
}

export interface IPrioritySchemeUpdateBean {
    defaultOptionId?: string;
    description?: string;
    id?: number;
    name?: string;
    optionIds?: string[];

    [key: string]: any;
}

export class ProjectBean implements IProjectBean {
    archived?: boolean;
    avatarUrls?: { [key: string]: string; };
    description?: string;
    id?: string;
    key?: string;
    name?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IProjectBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.archived = _data["archived"];
            if (_data["avatarUrls"]) {
                this.avatarUrls = {} as any;
                for (let key in _data["avatarUrls"]) {
                    if (_data["avatarUrls"].hasOwnProperty(key))
                        (<any>this.avatarUrls)![key] = _data["avatarUrls"][key];
                }
            }
            this.description = _data["description"];
            this.id = _data["id"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): ProjectBean {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["archived"] = this.archived;
        if (this.avatarUrls) {
            data["avatarUrls"] = {};
            for (let key in this.avatarUrls) {
                if (this.avatarUrls.hasOwnProperty(key))
                    (<any>data["avatarUrls"])[key] = (<any>this.avatarUrls)[key];
            }
        }
        data["description"] = this.description;
        data["id"] = this.id;
        data["key"] = this.key;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

export interface IProjectBean {
    archived?: boolean;
    avatarUrls?: { [key: string]: string; };
    description?: string;
    id?: string;
    key?: string;
    name?: string;
    self?: string;

    [key: string]: any;
}

export class ProjectCategoryBean implements IProjectCategoryBean {
    description?: string;
    id?: string;
    name?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IProjectCategoryBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): ProjectCategoryBean {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectCategoryBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

export interface IProjectCategoryBean {
    description?: string;
    id?: string;
    name?: string;
    self?: string;

    [key: string]: any;
}

export class ProjectDeleteInstructionsBean implements IProjectDeleteInstructionsBean {
    grantsToDelete?: number[];

    [key: string]: any;

    constructor(data?: IProjectDeleteInstructionsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["grantsToDelete"])) {
                this.grantsToDelete = [] as any;
                for (let item of _data["grantsToDelete"])
                    this.grantsToDelete!.push(item);
            }
        }
    }

    static fromJS(data: any): ProjectDeleteInstructionsBean {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDeleteInstructionsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.grantsToDelete)) {
            data["grantsToDelete"] = [];
            for (let item of this.grantsToDelete)
                data["grantsToDelete"].push(item);
        }
        return data;
    }
}

export interface IProjectDeleteInstructionsBean {
    grantsToDelete?: number[];

    [key: string]: any;
}

export class ProjectIdentity implements IProjectIdentity {
    id?: number;
    key?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IProjectIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.key = _data["key"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): ProjectIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["key"] = this.key;
        data["self"] = this.self;
        return data;
    }
}

export interface IProjectIdentity {
    id?: number;
    key?: string;
    self?: string;

    [key: string]: any;
}

export class ProjectPickerItem implements IProjectPickerItem {
    avatar?: string;
    html?: string;
    id?: string;
    key?: string;
    name?: string;

    [key: string]: any;

    constructor(data?: IProjectPickerItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.avatar = _data["avatar"];
            this.html = _data["html"];
            this.id = _data["id"];
            this.key = _data["key"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProjectPickerItem {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectPickerItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["avatar"] = this.avatar;
        data["html"] = this.html;
        data["id"] = this.id;
        data["key"] = this.key;
        data["name"] = this.name;
        return data;
    }
}

export interface IProjectPickerItem {
    avatar?: string;
    html?: string;
    id?: string;
    key?: string;
    name?: string;

    [key: string]: any;
}

export class ProjectPickerResultWrapper implements IProjectPickerResultWrapper {
    header?: string;
    projects?: ProjectPickerItem[];
    total?: number;

    [key: string]: any;

    constructor(data?: IProjectPickerResultWrapper) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.header = _data["header"];
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects!.push(ProjectPickerItem.fromJS(item));
            }
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): ProjectPickerResultWrapper {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectPickerResultWrapper();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["header"] = this.header;
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data;
    }
}

export interface IProjectPickerResultWrapper {
    header?: string;
    projects?: ProjectPickerItem[];
    total?: number;

    [key: string]: any;
}

export class ProjectRoleActorsBean implements IProjectRoleActorsBean {
    actors?: RoleActorBean[];

    [key: string]: any;

    constructor(data?: IProjectRoleActorsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["actors"])) {
                this.actors = [] as any;
                for (let item of _data["actors"])
                    this.actors!.push(RoleActorBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectRoleActorsBean {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectRoleActorsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.actors)) {
            data["actors"] = [];
            for (let item of this.actors)
                data["actors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProjectRoleActorsBean {
    actors?: RoleActorBean[];

    [key: string]: any;
}

export class ProjectRoleActorsUpdateBean implements IProjectRoleActorsUpdateBean {
    categorisedActors?: { [key: string]: string[]; };
    id?: number;

    [key: string]: any;

    constructor(data?: IProjectRoleActorsUpdateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["categorisedActors"]) {
                this.categorisedActors = {} as any;
                for (let key in _data["categorisedActors"]) {
                    if (_data["categorisedActors"].hasOwnProperty(key))
                        (<any>this.categorisedActors)![key] = _data["categorisedActors"][key] !== undefined ? _data["categorisedActors"][key] : [];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProjectRoleActorsUpdateBean {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectRoleActorsUpdateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.categorisedActors) {
            data["categorisedActors"] = {};
            for (let key in this.categorisedActors) {
                if (this.categorisedActors.hasOwnProperty(key))
                    (<any>data["categorisedActors"])[key] = (<any>this.categorisedActors)[key];
            }
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IProjectRoleActorsUpdateBean {
    categorisedActors?: { [key: string]: string[]; };
    id?: number;

    [key: string]: any;
}

export class ProjectRoleBean implements IProjectRoleBean {
    actors?: RoleActorBean[];
    description?: string;
    id?: number;
    name?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IProjectRoleBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["actors"])) {
                this.actors = [] as any;
                for (let item of _data["actors"])
                    this.actors!.push(RoleActorBean.fromJS(item));
            }
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): ProjectRoleBean {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectRoleBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.actors)) {
            data["actors"] = [];
            for (let item of this.actors)
                data["actors"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

export interface IProjectRoleBean {
    actors?: RoleActorBean[];
    description?: string;
    id?: number;
    name?: string;
    self?: string;

    [key: string]: any;
}

export class ProjectTypeBean implements IProjectTypeBean {
    color?: string;
    descriptionI18nKey?: string;
    formattedKey?: string;
    icon?: string;
    key?: string;

    [key: string]: any;

    constructor(data?: IProjectTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.color = _data["color"];
            this.descriptionI18nKey = _data["descriptionI18nKey"];
            this.formattedKey = _data["formattedKey"];
            this.icon = _data["icon"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): ProjectTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["color"] = this.color;
        data["descriptionI18nKey"] = this.descriptionI18nKey;
        data["formattedKey"] = this.formattedKey;
        data["icon"] = this.icon;
        data["key"] = this.key;
        return data;
    }
}

export interface IProjectTypeBean {
    color?: string;
    descriptionI18nKey?: string;
    formattedKey?: string;
    icon?: string;
    key?: string;

    [key: string]: any;
}

export class ProjectUpdateBean implements IProjectUpdateBean {
    assigneeType?: ProjectUpdateBeanAssigneeType;
    avatarId?: number;
    categoryId?: number;
    description?: string;
    issueSecurityScheme?: number;
    key?: string;
    lead?: string;
    name?: string;
    notificationScheme?: number;
    permissionScheme?: number;
    projectTemplateKey?: string;
    projectTypeKey?: string;
    url?: string;

    [key: string]: any;

    constructor(data?: IProjectUpdateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.assigneeType = _data["assigneeType"];
            this.avatarId = _data["avatarId"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            this.issueSecurityScheme = _data["issueSecurityScheme"];
            this.key = _data["key"];
            this.lead = _data["lead"];
            this.name = _data["name"];
            this.notificationScheme = _data["notificationScheme"];
            this.permissionScheme = _data["permissionScheme"];
            this.projectTemplateKey = _data["projectTemplateKey"];
            this.projectTypeKey = _data["projectTypeKey"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): ProjectUpdateBean {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectUpdateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["assigneeType"] = this.assigneeType;
        data["avatarId"] = this.avatarId;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        data["issueSecurityScheme"] = this.issueSecurityScheme;
        data["key"] = this.key;
        data["lead"] = this.lead;
        data["name"] = this.name;
        data["notificationScheme"] = this.notificationScheme;
        data["permissionScheme"] = this.permissionScheme;
        data["projectTemplateKey"] = this.projectTemplateKey;
        data["projectTypeKey"] = this.projectTypeKey;
        data["url"] = this.url;
        return data;
    }
}

export interface IProjectUpdateBean {
    assigneeType?: ProjectUpdateBeanAssigneeType;
    avatarId?: number;
    categoryId?: number;
    description?: string;
    issueSecurityScheme?: number;
    key?: string;
    lead?: string;
    name?: string;
    notificationScheme?: number;
    permissionScheme?: number;
    projectTemplateKey?: string;
    projectTypeKey?: string;
    url?: string;

    [key: string]: any;
}

export class Property implements IProperty {
    example?: string;
    key?: string;
    value?: string;

    [key: string]: any;

    constructor(data?: IProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.example = _data["example"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Property {
        data = typeof data === 'object' ? data : {};
        let result = new Property();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["example"] = this.example;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IProperty {
    example?: string;
    key?: string;
    value?: string;

    [key: string]: any;
}

export class PropertyBean implements IPropertyBean {
    id?: string;
    key?: string;
    value?: string;

    [key: string]: any;

    constructor(data?: IPropertyBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PropertyBean {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IPropertyBean {
    id?: string;
    key?: string;
    value?: string;

    [key: string]: any;
}

export class ReindexBean implements IReindexBean {
    currentProgress?: number;
    currentSubTask?: string;
    finishTime?: Date;
    progressUrl?: string;
    startTime?: Date;
    submittedTime?: Date;
    success?: boolean;
    type?: ReindexBeanType;

    [key: string]: any;

    constructor(data?: IReindexBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.currentProgress = _data["currentProgress"];
            this.currentSubTask = _data["currentSubTask"];
            this.finishTime = _data["finishTime"] ? new Date(_data["finishTime"].toString()) : <any>undefined;
            this.progressUrl = _data["progressUrl"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.submittedTime = _data["submittedTime"] ? new Date(_data["submittedTime"].toString()) : <any>undefined;
            this.success = _data["success"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ReindexBean {
        data = typeof data === 'object' ? data : {};
        let result = new ReindexBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["currentProgress"] = this.currentProgress;
        data["currentSubTask"] = this.currentSubTask;
        data["finishTime"] = this.finishTime ? this.finishTime.toISOString() : <any>undefined;
        data["progressUrl"] = this.progressUrl;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["submittedTime"] = this.submittedTime ? this.submittedTime.toISOString() : <any>undefined;
        data["success"] = this.success;
        data["type"] = this.type;
        return data;
    }
}

export interface IReindexBean {
    currentProgress?: number;
    currentSubTask?: string;
    finishTime?: Date;
    progressUrl?: string;
    startTime?: Date;
    submittedTime?: Date;
    success?: boolean;
    type?: ReindexBeanType;

    [key: string]: any;
}

export class ReindexRequestBean implements IReindexRequestBean {
    completionTime?: Date;
    id?: number;
    requestTime?: Date;
    startTime?: Date;
    status?: ReindexRequestBeanStatus;
    type?: ReindexRequestBeanType;

    [key: string]: any;

    constructor(data?: IReindexRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.completionTime = _data["completionTime"] ? new Date(_data["completionTime"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.requestTime = _data["requestTime"] ? new Date(_data["requestTime"].toString()) : <any>undefined;
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ReindexRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new ReindexRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["completionTime"] = this.completionTime ? this.completionTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["requestTime"] = this.requestTime ? this.requestTime.toISOString() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["type"] = this.type;
        return data;
    }
}

export interface IReindexRequestBean {
    completionTime?: Date;
    id?: number;
    requestTime?: Date;
    startTime?: Date;
    status?: ReindexRequestBeanStatus;
    type?: ReindexRequestBeanType;

    [key: string]: any;
}

export class RemoteEntityLinkJsonBean implements IRemoteEntityLinkJsonBean {
    link?: string;
    name?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IRemoteEntityLinkJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.link = _data["link"];
            this.name = _data["name"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): RemoteEntityLinkJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteEntityLinkJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["link"] = this.link;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

export interface IRemoteEntityLinkJsonBean {
    link?: string;
    name?: string;
    self?: string;

    [key: string]: any;
}

export class RemoteEntityLinksJsonBean implements IRemoteEntityLinksJsonBean {
    links?: RemoteEntityLinkJsonBean[];

    [key: string]: any;

    constructor(data?: IRemoteEntityLinksJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(RemoteEntityLinkJsonBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RemoteEntityLinksJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteEntityLinksJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRemoteEntityLinksJsonBean {
    links?: RemoteEntityLinkJsonBean[];

    [key: string]: any;
}

export class RemoteIssueLinkBean implements IRemoteIssueLinkBean {

    [key: string]: any;

    constructor(data?: IRemoteIssueLinkBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): RemoteIssueLinkBean {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteIssueLinkBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IRemoteIssueLinkBean {

    [key: string]: any;
}

export class RemoteIssueLinkCreateOrUpdateRequest implements IRemoteIssueLinkCreateOrUpdateRequest {
    application?: Application;
    globalId?: string;
    object?: RemoteObject;
    relationship?: string;

    [key: string]: any;

    constructor(data?: IRemoteIssueLinkCreateOrUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.application = _data["application"] ? Application.fromJS(_data["application"]) : <any>undefined;
            this.globalId = _data["globalId"];
            this.object = _data["object"] ? RemoteObject.fromJS(_data["object"]) : <any>undefined;
            this.relationship = _data["relationship"];
        }
    }

    static fromJS(data: any): RemoteIssueLinkCreateOrUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteIssueLinkCreateOrUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["globalId"] = this.globalId;
        data["object"] = this.object ? this.object.toJSON() : <any>undefined;
        data["relationship"] = this.relationship;
        return data;
    }
}

export interface IRemoteIssueLinkCreateOrUpdateRequest {
    application?: Application;
    globalId?: string;
    object?: RemoteObject;
    relationship?: string;

    [key: string]: any;
}

export class RemoteObject implements IRemoteObject {
    icon?: Icon;
    status?: Status;
    summary?: string;
    title?: string;
    url?: string;

    [key: string]: any;

    constructor(data?: IRemoteObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.icon = _data["icon"] ? Icon.fromJS(_data["icon"]) : <any>undefined;
            this.status = _data["status"] ? Status.fromJS(_data["status"]) : <any>undefined;
            this.summary = _data["summary"];
            this.title = _data["title"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): RemoteObject {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["icon"] = this.icon ? this.icon.toJSON() : <any>undefined;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["summary"] = this.summary;
        data["title"] = this.title;
        data["url"] = this.url;
        return data;
    }
}

export interface IRemoteObject {
    icon?: Icon;
    status?: Status;
    summary?: string;
    title?: string;
    url?: string;

    [key: string]: any;
}

export class ResolutionBean implements IResolutionBean {

    [key: string]: any;

    constructor(data?: IResolutionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): ResolutionBean {
        data = typeof data === 'object' ? data : {};
        let result = new ResolutionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IResolutionBean {

    [key: string]: any;
}

export class ResolutionJsonBean implements IResolutionJsonBean {
    description?: string;
    iconUrl?: string;
    id?: string;
    name?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IResolutionJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): ResolutionJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new ResolutionJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

export interface IResolutionJsonBean {
    description?: string;
    iconUrl?: string;
    id?: string;
    name?: string;
    self?: string;

    [key: string]: any;
}

export class RestrictJsonBean implements IRestrictJsonBean {
    groups?: GroupJsonBean[];
    permissions?: PermissionJsonBean[];

    [key: string]: any;

    constructor(data?: IRestrictJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(GroupJsonBean.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionJsonBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RestrictJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new RestrictJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRestrictJsonBean {
    groups?: GroupJsonBean[];
    permissions?: PermissionJsonBean[];

    [key: string]: any;
}

export class RoleActorBean implements IRoleActorBean {
    avatarUrl?: string;
    name?: string;

    [key: string]: any;

    constructor(data?: IRoleActorBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.avatarUrl = _data["avatarUrl"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RoleActorBean {
        data = typeof data === 'object' ? data : {};
        let result = new RoleActorBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["avatarUrl"] = this.avatarUrl;
        data["name"] = this.name;
        return data;
    }
}

export interface IRoleActorBean {
    avatarUrl?: string;
    name?: string;

    [key: string]: any;
}

export class ScreenableFieldBean implements IScreenableFieldBean {
    id?: string;
    name?: string;
    showWhenEmpty?: boolean;
    type?: string;

    [key: string]: any;

    constructor(data?: IScreenableFieldBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.showWhenEmpty = _data["showWhenEmpty"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ScreenableFieldBean {
        data = typeof data === 'object' ? data : {};
        let result = new ScreenableFieldBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["showWhenEmpty"] = this.showWhenEmpty;
        data["type"] = this.type;
        return data;
    }
}

export interface IScreenableFieldBean {
    id?: string;
    name?: string;
    showWhenEmpty?: boolean;
    type?: string;

    [key: string]: any;
}

export class ScreenableTabBean implements IScreenableTabBean {
    id?: number;
    name?: string;

    [key: string]: any;

    constructor(data?: IScreenableTabBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ScreenableTabBean {
        data = typeof data === 'object' ? data : {};
        let result = new ScreenableTabBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IScreenableTabBean {
    id?: number;
    name?: string;

    [key: string]: any;
}

export class SearchRequestBean implements ISearchRequestBean {
    expand?: string[];
    fields?: string[];
    jql?: string;
    maxResults?: number;
    startAt?: number;
    validateQuery?: boolean;

    [key: string]: any;

    constructor(data?: ISearchRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["expand"])) {
                this.expand = [] as any;
                for (let item of _data["expand"])
                    this.expand!.push(item);
            }
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(item);
            }
            this.jql = _data["jql"];
            this.maxResults = _data["maxResults"];
            this.startAt = _data["startAt"];
            this.validateQuery = _data["validateQuery"];
        }
    }

    static fromJS(data: any): SearchRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new SearchRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.expand)) {
            data["expand"] = [];
            for (let item of this.expand)
                data["expand"].push(item);
        }
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item);
        }
        data["jql"] = this.jql;
        data["maxResults"] = this.maxResults;
        data["startAt"] = this.startAt;
        data["validateQuery"] = this.validateQuery;
        return data;
    }
}

export interface ISearchRequestBean {
    expand?: string[];
    fields?: string[];
    jql?: string;
    maxResults?: number;
    startAt?: number;
    validateQuery?: boolean;

    [key: string]: any;
}

export class SecurityLevelJsonBean implements ISecurityLevelJsonBean {
    description?: string;
    id?: string;
    name?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: ISecurityLevelJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): SecurityLevelJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityLevelJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

export interface ISecurityLevelJsonBean {
    description?: string;
    id?: string;
    name?: string;
    self?: string;

    [key: string]: any;
}

export class SecurityListLevelJsonBean implements ISecurityListLevelJsonBean {
    levels?: SecurityLevelJsonBean[];

    [key: string]: any;

    constructor(data?: ISecurityListLevelJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["levels"])) {
                this.levels = [] as any;
                for (let item of _data["levels"])
                    this.levels!.push(SecurityLevelJsonBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SecurityListLevelJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityListLevelJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.levels)) {
            data["levels"] = [];
            for (let item of this.levels)
                data["levels"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISecurityListLevelJsonBean {
    levels?: SecurityLevelJsonBean[];

    [key: string]: any;
}

export class SecuritySchemeJsonBean implements ISecuritySchemeJsonBean {
    defaultSecurityLevelId?: number;
    description?: string;
    id?: number;
    levels?: SecurityLevelJsonBean[];
    name?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: ISecuritySchemeJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.defaultSecurityLevelId = _data["defaultSecurityLevelId"];
            this.description = _data["description"];
            this.id = _data["id"];
            if (Array.isArray(_data["levels"])) {
                this.levels = [] as any;
                for (let item of _data["levels"])
                    this.levels!.push(SecurityLevelJsonBean.fromJS(item));
            }
            this.name = _data["name"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): SecuritySchemeJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySchemeJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["defaultSecurityLevelId"] = this.defaultSecurityLevelId;
        data["description"] = this.description;
        data["id"] = this.id;
        if (Array.isArray(this.levels)) {
            data["levels"] = [];
            for (let item of this.levels)
                data["levels"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

export interface ISecuritySchemeJsonBean {
    defaultSecurityLevelId?: number;
    description?: string;
    id?: number;
    levels?: SecurityLevelJsonBean[];
    name?: string;
    self?: string;

    [key: string]: any;
}

export class SecuritySchemesJsonBean implements ISecuritySchemesJsonBean {
    issueSecuritySchemes?: SecuritySchemeJsonBean[];

    [key: string]: any;

    constructor(data?: ISecuritySchemesJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["issueSecuritySchemes"])) {
                this.issueSecuritySchemes = [] as any;
                for (let item of _data["issueSecuritySchemes"])
                    this.issueSecuritySchemes!.push(SecuritySchemeJsonBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SecuritySchemesJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySchemesJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.issueSecuritySchemes)) {
            data["issueSecuritySchemes"] = [];
            for (let item of this.issueSecuritySchemes)
                data["issueSecuritySchemes"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISecuritySchemesJsonBean {
    issueSecuritySchemes?: SecuritySchemeJsonBean[];

    [key: string]: any;
}

export class ServerInfoBean implements IServerInfoBean {

    [key: string]: any;

    constructor(data?: IServerInfoBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): ServerInfoBean {
        data = typeof data === 'object' ? data : {};
        let result = new ServerInfoBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IServerInfoBean {

    [key: string]: any;
}

export class SessionInfo implements ISessionInfo {
    name?: string;
    value?: string;

    [key: string]: any;

    constructor(data?: ISessionInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SessionInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SessionInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface ISessionInfo {
    name?: string;
    value?: string;

    [key: string]: any;
}

export class SharePermissionInputBean implements ISharePermissionInputBean {
    edit?: boolean;
    groupname?: string;
    projectId?: string;
    projectRoleId?: string;
    type?: string;
    userKey?: string;
    view?: boolean;

    [key: string]: any;

    constructor(data?: ISharePermissionInputBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.edit = _data["edit"];
            this.groupname = _data["groupname"];
            this.projectId = _data["projectId"];
            this.projectRoleId = _data["projectRoleId"];
            this.type = _data["type"];
            this.userKey = _data["userKey"];
            this.view = _data["view"];
        }
    }

    static fromJS(data: any): SharePermissionInputBean {
        data = typeof data === 'object' ? data : {};
        let result = new SharePermissionInputBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["edit"] = this.edit;
        data["groupname"] = this.groupname;
        data["projectId"] = this.projectId;
        data["projectRoleId"] = this.projectRoleId;
        data["type"] = this.type;
        data["userKey"] = this.userKey;
        data["view"] = this.view;
        return data;
    }
}

export interface ISharePermissionInputBean {
    edit?: boolean;
    groupname?: string;
    projectId?: string;
    projectRoleId?: string;
    type?: string;
    userKey?: string;
    view?: boolean;

    [key: string]: any;
}

export class SimpleListWrapperApplicationRoleBean implements ISimpleListWrapperApplicationRoleBean {
    callback?: ListWrapperCallbackApplicationRoleBean;
    maxResults?: number;
    pagingCallback?: ListWrapperCallbackApplicationRoleBean;
    size?: number;

    [key: string]: any;

    constructor(data?: ISimpleListWrapperApplicationRoleBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.callback = _data["callback"] ? ListWrapperCallbackApplicationRoleBean.fromJS(_data["callback"]) : <any>undefined;
            this.maxResults = _data["maxResults"];
            this.pagingCallback = _data["pagingCallback"] ? ListWrapperCallbackApplicationRoleBean.fromJS(_data["pagingCallback"]) : <any>undefined;
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): SimpleListWrapperApplicationRoleBean {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleListWrapperApplicationRoleBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["callback"] = this.callback ? this.callback.toJSON() : <any>undefined;
        data["maxResults"] = this.maxResults;
        data["pagingCallback"] = this.pagingCallback ? this.pagingCallback.toJSON() : <any>undefined;
        data["size"] = this.size;
        return data;
    }
}

export interface ISimpleListWrapperApplicationRoleBean {
    callback?: ListWrapperCallbackApplicationRoleBean;
    maxResults?: number;
    pagingCallback?: ListWrapperCallbackApplicationRoleBean;
    size?: number;

    [key: string]: any;
}

export class SimpleListWrapperGroupJsonBean implements ISimpleListWrapperGroupJsonBean {
    callback?: ListWrapperCallbackGroupJsonBean;
    maxResults?: number;
    pagingCallback?: ListWrapperCallbackGroupJsonBean;
    size?: number;

    [key: string]: any;

    constructor(data?: ISimpleListWrapperGroupJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.callback = _data["callback"] ? ListWrapperCallbackGroupJsonBean.fromJS(_data["callback"]) : <any>undefined;
            this.maxResults = _data["maxResults"];
            this.pagingCallback = _data["pagingCallback"] ? ListWrapperCallbackGroupJsonBean.fromJS(_data["pagingCallback"]) : <any>undefined;
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): SimpleListWrapperGroupJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleListWrapperGroupJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["callback"] = this.callback ? this.callback.toJSON() : <any>undefined;
        data["maxResults"] = this.maxResults;
        data["pagingCallback"] = this.pagingCallback ? this.pagingCallback.toJSON() : <any>undefined;
        data["size"] = this.size;
        return data;
    }
}

export interface ISimpleListWrapperGroupJsonBean {
    callback?: ListWrapperCallbackGroupJsonBean;
    maxResults?: number;
    pagingCallback?: ListWrapperCallbackGroupJsonBean;
    size?: number;

    [key: string]: any;
}

export class Status implements IStatus {
    icon?: Icon;
    resolved?: boolean;

    [key: string]: any;

    constructor(data?: IStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.icon = _data["icon"] ? Icon.fromJS(_data["icon"]) : <any>undefined;
            this.resolved = _data["resolved"];
        }
    }

    static fromJS(data: any): Status {
        data = typeof data === 'object' ? data : {};
        let result = new Status();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["icon"] = this.icon ? this.icon.toJSON() : <any>undefined;
        data["resolved"] = this.resolved;
        return data;
    }
}

export interface IStatus {
    icon?: Icon;
    resolved?: boolean;

    [key: string]: any;
}

export class TerminologyRequestBean implements ITerminologyRequestBean {
    newName?: string;
    newNamePlural?: string;
    originalName?: string;

    [key: string]: any;

    constructor(data?: ITerminologyRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.newName = _data["newName"];
            this.newNamePlural = _data["newNamePlural"];
            this.originalName = _data["originalName"];
        }
    }

    static fromJS(data: any): TerminologyRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new TerminologyRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["newName"] = this.newName;
        data["newNamePlural"] = this.newNamePlural;
        data["originalName"] = this.originalName;
        return data;
    }
}

export interface ITerminologyRequestBean {
    newName?: string;
    newNamePlural?: string;
    originalName?: string;

    [key: string]: any;
}

export class TerminologyResponseBean implements ITerminologyResponseBean {
    isDefault?: boolean;
    newName?: string;
    newNamePlural?: string;
    originalName?: string;
    originalNamePlural?: string;

    [key: string]: any;

    constructor(data?: ITerminologyResponseBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.isDefault = _data["isDefault"];
            this.newName = _data["newName"];
            this.newNamePlural = _data["newNamePlural"];
            this.originalName = _data["originalName"];
            this.originalNamePlural = _data["originalNamePlural"];
        }
    }

    static fromJS(data: any): TerminologyResponseBean {
        data = typeof data === 'object' ? data : {};
        let result = new TerminologyResponseBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["isDefault"] = this.isDefault;
        data["newName"] = this.newName;
        data["newNamePlural"] = this.newNamePlural;
        data["originalName"] = this.originalName;
        data["originalNamePlural"] = this.originalNamePlural;
        return data;
    }
}

export interface ITerminologyResponseBean {
    isDefault?: boolean;
    newName?: string;
    newNamePlural?: string;
    originalName?: string;
    originalNamePlural?: string;

    [key: string]: any;
}

export class TimeTrackingConfigurationBean implements ITimeTrackingConfigurationBean {
    defaultUnit?: TimeTrackingConfigurationBeanDefaultUnit;
    timeFormat?: TimeTrackingConfigurationBeanTimeFormat;
    workingDaysPerWeek?: number;
    workingHoursPerDay?: number;

    [key: string]: any;

    constructor(data?: ITimeTrackingConfigurationBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.defaultUnit = _data["defaultUnit"];
            this.timeFormat = _data["timeFormat"];
            this.workingDaysPerWeek = _data["workingDaysPerWeek"];
            this.workingHoursPerDay = _data["workingHoursPerDay"];
        }
    }

    static fromJS(data: any): TimeTrackingConfigurationBean {
        data = typeof data === 'object' ? data : {};
        let result = new TimeTrackingConfigurationBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["defaultUnit"] = this.defaultUnit;
        data["timeFormat"] = this.timeFormat;
        data["workingDaysPerWeek"] = this.workingDaysPerWeek;
        data["workingHoursPerDay"] = this.workingHoursPerDay;
        return data;
    }
}

export interface ITimeTrackingConfigurationBean {
    defaultUnit?: TimeTrackingConfigurationBeanDefaultUnit;
    timeFormat?: TimeTrackingConfigurationBeanTimeFormat;
    workingDaysPerWeek?: number;
    workingHoursPerDay?: number;

    [key: string]: any;
}

export class ToJsonBean implements IToJsonBean {
    assignee?: boolean;
    groups?: GroupJsonBean[];
    reporter?: boolean;
    users?: UserJsonBean[];
    voters?: boolean;
    watchers?: boolean;

    [key: string]: any;

    constructor(data?: IToJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.assignee = _data["assignee"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(GroupJsonBean.fromJS(item));
            }
            this.reporter = _data["reporter"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserJsonBean.fromJS(item));
            }
            this.voters = _data["voters"];
            this.watchers = _data["watchers"];
        }
    }

    static fromJS(data: any): ToJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new ToJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["assignee"] = this.assignee;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        data["reporter"] = this.reporter;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        data["voters"] = this.voters;
        data["watchers"] = this.watchers;
        return data;
    }
}

export interface IToJsonBean {
    assignee?: boolean;
    groups?: GroupJsonBean[];
    reporter?: boolean;
    users?: UserJsonBean[];
    voters?: boolean;
    watchers?: boolean;

    [key: string]: any;
}

export class TransitionsMetaBean implements ITransitionsMetaBean {
    transitions?: TransitionBean[];

    [key: string]: any;

    constructor(data?: ITransitionsMetaBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["transitions"])) {
                this.transitions = [] as any;
                for (let item of _data["transitions"])
                    this.transitions!.push(TransitionBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransitionsMetaBean {
        data = typeof data === 'object' ? data : {};
        let result = new TransitionsMetaBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.transitions)) {
            data["transitions"] = [];
            for (let item of this.transitions)
                data["transitions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITransitionsMetaBean {
    transitions?: TransitionBean[];

    [key: string]: any;
}

export class UpdateUserToGroupBean implements IUpdateUserToGroupBean {
    name?: string;

    [key: string]: any;

    constructor(data?: IUpdateUserToGroupBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateUserToGroupBean {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserToGroupBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateUserToGroupBean {
    name?: string;

    [key: string]: any;
}

export class UpgradeResultBean implements IUpgradeResultBean {
    duration?: number;
    message?: string;
    outcome?: string;
    startTime?: Date;

    [key: string]: any;

    constructor(data?: IUpgradeResultBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.duration = _data["duration"];
            this.message = _data["message"];
            this.outcome = _data["outcome"];
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpgradeResultBean {
        data = typeof data === 'object' ? data : {};
        let result = new UpgradeResultBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["duration"] = this.duration;
        data["message"] = this.message;
        data["outcome"] = this.outcome;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUpgradeResultBean {
    duration?: number;
    message?: string;
    outcome?: string;
    startTime?: Date;

    [key: string]: any;
}

export class UserAnonymizationRequestBean implements IUserAnonymizationRequestBean {
    newOwnerKey?: string;
    userKey?: string;

    [key: string]: any;

    constructor(data?: IUserAnonymizationRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.newOwnerKey = _data["newOwnerKey"];
            this.userKey = _data["userKey"];
        }
    }

    static fromJS(data: any): UserAnonymizationRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new UserAnonymizationRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["newOwnerKey"] = this.newOwnerKey;
        data["userKey"] = this.userKey;
        return data;
    }
}

export interface IUserAnonymizationRequestBean {
    newOwnerKey?: string;
    userKey?: string;

    [key: string]: any;
}

export class UserAnonymizationRerunRequestBean implements IUserAnonymizationRerunRequestBean {
    newOwnerKey?: string;
    oldUserKey?: string;
    oldUserName?: string;
    userKey?: string;

    [key: string]: any;

    constructor(data?: IUserAnonymizationRerunRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.newOwnerKey = _data["newOwnerKey"];
            this.oldUserKey = _data["oldUserKey"];
            this.oldUserName = _data["oldUserName"];
            this.userKey = _data["userKey"];
        }
    }

    static fromJS(data: any): UserAnonymizationRerunRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new UserAnonymizationRerunRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["newOwnerKey"] = this.newOwnerKey;
        data["oldUserKey"] = this.oldUserKey;
        data["oldUserName"] = this.oldUserName;
        data["userKey"] = this.userKey;
        return data;
    }
}

export interface IUserAnonymizationRerunRequestBean {
    newOwnerKey?: string;
    oldUserKey?: string;
    oldUserName?: string;
    userKey?: string;

    [key: string]: any;
}

export class UserAnonymizationValidationBean implements IUserAnonymizationValidationBean {
    affectedEntities?: { [key: string]: AffectedEntityBean[]; };
    businessLogicValidationFailed?: boolean;
    deleted?: boolean;
    displayName?: string;
    email?: string;
    errors?: { [key: string]: ErrorCollection; };
    expand?: string;
    operations?: string[];
    success?: boolean;
    userKey?: string;
    userName?: string;
    warnings?: { [key: string]: ErrorCollection; };

    [key: string]: any;

    constructor(data?: IUserAnonymizationValidationBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["affectedEntities"]) {
                this.affectedEntities = {} as any;
                for (let key in _data["affectedEntities"]) {
                    if (_data["affectedEntities"].hasOwnProperty(key))
                        (<any>this.affectedEntities)![key] = _data["affectedEntities"][key] ? _data["affectedEntities"][key].map((i: any) => AffectedEntityBean.fromJS(i)) : [];
                }
            }
            this.businessLogicValidationFailed = _data["businessLogicValidationFailed"];
            this.deleted = _data["deleted"];
            this.displayName = _data["displayName"];
            this.email = _data["email"];
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] ? ErrorCollection.fromJS(_data["errors"][key]) : new ErrorCollection();
                }
            }
            this.expand = _data["expand"];
            if (Array.isArray(_data["operations"])) {
                this.operations = [] as any;
                for (let item of _data["operations"])
                    this.operations!.push(item);
            }
            this.success = _data["success"];
            this.userKey = _data["userKey"];
            this.userName = _data["userName"];
            if (_data["warnings"]) {
                this.warnings = {} as any;
                for (let key in _data["warnings"]) {
                    if (_data["warnings"].hasOwnProperty(key))
                        (<any>this.warnings)![key] = _data["warnings"][key] ? ErrorCollection.fromJS(_data["warnings"][key]) : new ErrorCollection();
                }
            }
        }
    }

    static fromJS(data: any): UserAnonymizationValidationBean {
        data = typeof data === 'object' ? data : {};
        let result = new UserAnonymizationValidationBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.affectedEntities) {
            data["affectedEntities"] = {};
            for (let key in this.affectedEntities) {
                if (this.affectedEntities.hasOwnProperty(key))
                    (<any>data["affectedEntities"])[key] = (<any>this.affectedEntities)[key];
            }
        }
        data["businessLogicValidationFailed"] = this.businessLogicValidationFailed;
        data["deleted"] = this.deleted;
        data["displayName"] = this.displayName;
        data["email"] = this.email;
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = this.errors[key] ? this.errors[key].toJSON() : <any>undefined;
            }
        }
        data["expand"] = this.expand;
        if (Array.isArray(this.operations)) {
            data["operations"] = [];
            for (let item of this.operations)
                data["operations"].push(item);
        }
        data["success"] = this.success;
        data["userKey"] = this.userKey;
        data["userName"] = this.userName;
        if (this.warnings) {
            data["warnings"] = {};
            for (let key in this.warnings) {
                if (this.warnings.hasOwnProperty(key))
                    (<any>data["warnings"])[key] = this.warnings[key] ? this.warnings[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IUserAnonymizationValidationBean {
    affectedEntities?: { [key: string]: AffectedEntityBean[]; };
    businessLogicValidationFailed?: boolean;
    deleted?: boolean;
    displayName?: string;
    email?: string;
    errors?: { [key: string]: ErrorCollection; };
    expand?: string;
    operations?: string[];
    success?: boolean;
    userKey?: string;
    userName?: string;
    warnings?: { [key: string]: ErrorCollection; };

    [key: string]: any;
}

export class UserBean implements IUserBean {
    active?: boolean;
    applicationRoles?: SimpleListWrapperApplicationRoleBean;
    avatarUrls?: { [key: string]: string; };
    deleted?: boolean;
    displayName?: string;
    emailAddress?: string;
    expand?: string;
    groups?: SimpleListWrapperGroupJsonBean;
    key?: string;
    lastLoginTime?: string;
    locale?: string;
    name?: string;
    self?: string;
    timeZone?: string;

    [key: string]: any;

    constructor(data?: IUserBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.active = _data["active"];
            this.applicationRoles = _data["applicationRoles"] ? SimpleListWrapperApplicationRoleBean.fromJS(_data["applicationRoles"]) : <any>undefined;
            if (_data["avatarUrls"]) {
                this.avatarUrls = {} as any;
                for (let key in _data["avatarUrls"]) {
                    if (_data["avatarUrls"].hasOwnProperty(key))
                        (<any>this.avatarUrls)![key] = _data["avatarUrls"][key];
                }
            }
            this.deleted = _data["deleted"];
            this.displayName = _data["displayName"];
            this.emailAddress = _data["emailAddress"];
            this.expand = _data["expand"];
            this.groups = _data["groups"] ? SimpleListWrapperGroupJsonBean.fromJS(_data["groups"]) : <any>undefined;
            this.key = _data["key"];
            this.lastLoginTime = _data["lastLoginTime"];
            this.locale = _data["locale"];
            this.name = _data["name"];
            this.self = _data["self"];
            this.timeZone = _data["timeZone"];
        }
    }

    static fromJS(data: any): UserBean {
        data = typeof data === 'object' ? data : {};
        let result = new UserBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["active"] = this.active;
        data["applicationRoles"] = this.applicationRoles ? this.applicationRoles.toJSON() : <any>undefined;
        if (this.avatarUrls) {
            data["avatarUrls"] = {};
            for (let key in this.avatarUrls) {
                if (this.avatarUrls.hasOwnProperty(key))
                    (<any>data["avatarUrls"])[key] = (<any>this.avatarUrls)[key];
            }
        }
        data["deleted"] = this.deleted;
        data["displayName"] = this.displayName;
        data["emailAddress"] = this.emailAddress;
        data["expand"] = this.expand;
        data["groups"] = this.groups ? this.groups.toJSON() : <any>undefined;
        data["key"] = this.key;
        data["lastLoginTime"] = this.lastLoginTime;
        data["locale"] = this.locale;
        data["name"] = this.name;
        data["self"] = this.self;
        data["timeZone"] = this.timeZone;
        return data;
    }
}

export interface IUserBean {
    active?: boolean;
    applicationRoles?: SimpleListWrapperApplicationRoleBean;
    avatarUrls?: { [key: string]: string; };
    deleted?: boolean;
    displayName?: string;
    emailAddress?: string;
    expand?: string;
    groups?: SimpleListWrapperGroupJsonBean;
    key?: string;
    lastLoginTime?: string;
    locale?: string;
    name?: string;
    self?: string;
    timeZone?: string;

    [key: string]: any;
}

export class UserBeanListWrapper implements IUserBeanListWrapper {
    backingListSize?: number;
    callback?: ListWrapperCallbackUserBean;
    items?: UserBean[];
    maxResults?: number;
    pagingCallback?: ListWrapperCallbackUserBean;
    size?: number;

    [key: string]: any;

    constructor(data?: IUserBeanListWrapper) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.backingListSize = _data["backingListSize"];
            this.callback = _data["callback"] ? ListWrapperCallbackUserBean.fromJS(_data["callback"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserBean.fromJS(item));
            }
            this.maxResults = _data["maxResults"];
            this.pagingCallback = _data["pagingCallback"] ? ListWrapperCallbackUserBean.fromJS(_data["pagingCallback"]) : <any>undefined;
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): UserBeanListWrapper {
        data = typeof data === 'object' ? data : {};
        let result = new UserBeanListWrapper();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["backingListSize"] = this.backingListSize;
        data["callback"] = this.callback ? this.callback.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["maxResults"] = this.maxResults;
        data["pagingCallback"] = this.pagingCallback ? this.pagingCallback.toJSON() : <any>undefined;
        data["size"] = this.size;
        return data;
    }
}

export interface IUserBeanListWrapper {
    backingListSize?: number;
    callback?: ListWrapperCallbackUserBean;
    items?: UserBean[];
    maxResults?: number;
    pagingCallback?: ListWrapperCallbackUserBean;
    size?: number;

    [key: string]: any;
}

export class UserIssueRelevanceBean implements IUserIssueRelevanceBean {
    avatarUrls?: { [key: string]: string; };
    displayName?: string;
    emailAddress?: string;
    highestIssueInvolvementRank?: number;
    issueInvolvements?: IssueInvolvementBean[];
    key?: string;
    latestCommentCreationTime?: number;
    name?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IUserIssueRelevanceBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["avatarUrls"]) {
                this.avatarUrls = {} as any;
                for (let key in _data["avatarUrls"]) {
                    if (_data["avatarUrls"].hasOwnProperty(key))
                        (<any>this.avatarUrls)![key] = _data["avatarUrls"][key];
                }
            }
            this.displayName = _data["displayName"];
            this.emailAddress = _data["emailAddress"];
            this.highestIssueInvolvementRank = _data["highestIssueInvolvementRank"];
            if (Array.isArray(_data["issueInvolvements"])) {
                this.issueInvolvements = [] as any;
                for (let item of _data["issueInvolvements"])
                    this.issueInvolvements!.push(IssueInvolvementBean.fromJS(item));
            }
            this.key = _data["key"];
            this.latestCommentCreationTime = _data["latestCommentCreationTime"];
            this.name = _data["name"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): UserIssueRelevanceBean {
        data = typeof data === 'object' ? data : {};
        let result = new UserIssueRelevanceBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.avatarUrls) {
            data["avatarUrls"] = {};
            for (let key in this.avatarUrls) {
                if (this.avatarUrls.hasOwnProperty(key))
                    (<any>data["avatarUrls"])[key] = (<any>this.avatarUrls)[key];
            }
        }
        data["displayName"] = this.displayName;
        data["emailAddress"] = this.emailAddress;
        data["highestIssueInvolvementRank"] = this.highestIssueInvolvementRank;
        if (Array.isArray(this.issueInvolvements)) {
            data["issueInvolvements"] = [];
            for (let item of this.issueInvolvements)
                data["issueInvolvements"].push(item.toJSON());
        }
        data["key"] = this.key;
        data["latestCommentCreationTime"] = this.latestCommentCreationTime;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

export interface IUserIssueRelevanceBean {
    avatarUrls?: { [key: string]: string; };
    displayName?: string;
    emailAddress?: string;
    highestIssueInvolvementRank?: number;
    issueInvolvements?: IssueInvolvementBean[];
    key?: string;
    latestCommentCreationTime?: number;
    name?: string;
    self?: string;

    [key: string]: any;
}

export class UserPickerResultsBean implements IUserPickerResultsBean {

    [key: string]: any;

    constructor(data?: IUserPickerResultsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): UserPickerResultsBean {
        data = typeof data === 'object' ? data : {};
        let result = new UserPickerResultsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IUserPickerResultsBean {

    [key: string]: any;
}

export class UserWriteBean implements IUserWriteBean {
    active?: boolean;
    applicationKeys?: string[];
    displayName?: string;
    emailAddress?: string;
    key?: string;
    name?: string;
    notification?: string;
    password?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IUserWriteBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.active = _data["active"];
            if (Array.isArray(_data["applicationKeys"])) {
                this.applicationKeys = [] as any;
                for (let item of _data["applicationKeys"])
                    this.applicationKeys!.push(item);
            }
            this.displayName = _data["displayName"];
            this.emailAddress = _data["emailAddress"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.notification = _data["notification"];
            this.password = _data["password"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): UserWriteBean {
        data = typeof data === 'object' ? data : {};
        let result = new UserWriteBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["active"] = this.active;
        if (Array.isArray(this.applicationKeys)) {
            data["applicationKeys"] = [];
            for (let item of this.applicationKeys)
                data["applicationKeys"].push(item);
        }
        data["displayName"] = this.displayName;
        data["emailAddress"] = this.emailAddress;
        data["key"] = this.key;
        data["name"] = this.name;
        data["notification"] = this.notification;
        data["password"] = this.password;
        data["self"] = this.self;
        return data;
    }
}

export interface IUserWriteBean {
    active?: boolean;
    applicationKeys?: string[];
    displayName?: string;
    emailAddress?: string;
    key?: string;
    name?: string;
    notification?: string;
    password?: string;
    self?: string;

    [key: string]: any;
}

export class UsersAndGroupsBean implements IUsersAndGroupsBean {
    groups?: GroupSuggestionsBean;
    users?: UserPickerResultsBean;

    [key: string]: any;

    constructor(data?: IUsersAndGroupsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.groups = _data["groups"] ? GroupSuggestionsBean.fromJS(_data["groups"]) : <any>undefined;
            this.users = _data["users"] ? UserPickerResultsBean.fromJS(_data["users"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UsersAndGroupsBean {
        data = typeof data === 'object' ? data : {};
        let result = new UsersAndGroupsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["groups"] = this.groups ? this.groups.toJSON() : <any>undefined;
        data["users"] = this.users ? this.users.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUsersAndGroupsBean {
    groups?: GroupSuggestionsBean;
    users?: UserPickerResultsBean;

    [key: string]: any;
}

export class ValidationError implements IValidationError {
    error?: string;
    field?: string;
    params?: string[];

    [key: string]: any;

    constructor(data?: IValidationError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.error = _data["error"];
            this.field = _data["field"];
            if (Array.isArray(_data["params"])) {
                this.params = [] as any;
                for (let item of _data["params"])
                    this.params!.push(item);
            }
        }
    }

    static fromJS(data: any): ValidationError {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["error"] = this.error;
        data["field"] = this.field;
        if (Array.isArray(this.params)) {
            data["params"] = [];
            for (let item of this.params)
                data["params"].push(item);
        }
        return data;
    }
}

export interface IValidationError {
    error?: string;
    field?: string;
    params?: string[];

    [key: string]: any;
}

export class VersionIssueCountsBean implements IVersionIssueCountsBean {
    customFieldNames?: VersionUsageInCustomFields[];
    issueCountWithCustomFieldsShowingVersion?: number;
    issuesAffectedCount?: number;
    issuesFixedCount?: number;
    self?: string;

    [key: string]: any;

    constructor(data?: IVersionIssueCountsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["customFieldNames"])) {
                this.customFieldNames = [] as any;
                for (let item of _data["customFieldNames"])
                    this.customFieldNames!.push(VersionUsageInCustomFields.fromJS(item));
            }
            this.issueCountWithCustomFieldsShowingVersion = _data["issueCountWithCustomFieldsShowingVersion"];
            this.issuesAffectedCount = _data["issuesAffectedCount"];
            this.issuesFixedCount = _data["issuesFixedCount"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): VersionIssueCountsBean {
        data = typeof data === 'object' ? data : {};
        let result = new VersionIssueCountsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.customFieldNames)) {
            data["customFieldNames"] = [];
            for (let item of this.customFieldNames)
                data["customFieldNames"].push(item.toJSON());
        }
        data["issueCountWithCustomFieldsShowingVersion"] = this.issueCountWithCustomFieldsShowingVersion;
        data["issuesAffectedCount"] = this.issuesAffectedCount;
        data["issuesFixedCount"] = this.issuesFixedCount;
        data["self"] = this.self;
        return data;
    }
}

export interface IVersionIssueCountsBean {
    customFieldNames?: VersionUsageInCustomFields[];
    issueCountWithCustomFieldsShowingVersion?: number;
    issuesAffectedCount?: number;
    issuesFixedCount?: number;
    self?: string;

    [key: string]: any;
}

export class VersionMoveBean implements IVersionMoveBean {
    after?: string;
    position?: VersionMoveBeanPosition;

    [key: string]: any;

    constructor(data?: IVersionMoveBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.after = _data["after"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): VersionMoveBean {
        data = typeof data === 'object' ? data : {};
        let result = new VersionMoveBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["after"] = this.after;
        data["position"] = this.position;
        return data;
    }
}

export interface IVersionMoveBean {
    after?: string;
    position?: VersionMoveBeanPosition;

    [key: string]: any;
}

export class VersionUnresolvedIssueCountsBean implements IVersionUnresolvedIssueCountsBean {
    issuesUnresolvedCount?: number;
    self?: string;

    [key: string]: any;

    constructor(data?: IVersionUnresolvedIssueCountsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.issuesUnresolvedCount = _data["issuesUnresolvedCount"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): VersionUnresolvedIssueCountsBean {
        data = typeof data === 'object' ? data : {};
        let result = new VersionUnresolvedIssueCountsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["issuesUnresolvedCount"] = this.issuesUnresolvedCount;
        data["self"] = this.self;
        return data;
    }
}

export interface IVersionUnresolvedIssueCountsBean {
    issuesUnresolvedCount?: number;
    self?: string;

    [key: string]: any;
}

export class VersionUsageInCustomFields implements IVersionUsageInCustomFields {
    customFieldId?: number;
    fieldName?: string;
    issueCountWithVersionInCustomField?: number;

    [key: string]: any;

    constructor(data?: IVersionUsageInCustomFields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.customFieldId = _data["customFieldId"];
            this.fieldName = _data["fieldName"];
            this.issueCountWithVersionInCustomField = _data["issueCountWithVersionInCustomField"];
        }
    }

    static fromJS(data: any): VersionUsageInCustomFields {
        data = typeof data === 'object' ? data : {};
        let result = new VersionUsageInCustomFields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["customFieldId"] = this.customFieldId;
        data["fieldName"] = this.fieldName;
        data["issueCountWithVersionInCustomField"] = this.issueCountWithVersionInCustomField;
        return data;
    }
}

export interface IVersionUsageInCustomFields {
    customFieldId?: number;
    fieldName?: string;
    issueCountWithVersionInCustomField?: number;

    [key: string]: any;
}

export class VisibilityJsonBean implements IVisibilityJsonBean {
    type?: VisibilityJsonBeanType;
    value?: string;

    [key: string]: any;

    constructor(data?: IVisibilityJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): VisibilityJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new VisibilityJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

export interface IVisibilityJsonBean {
    type?: VisibilityJsonBeanType;
    value?: string;

    [key: string]: any;
}

export class VoteBean implements IVoteBean {

    [key: string]: any;

    constructor(data?: IVoteBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): VoteBean {
        data = typeof data === 'object' ? data : {};
        let result = new VoteBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IVoteBean {

    [key: string]: any;
}

export class VoteWatchResult implements IVoteWatchResult {

    [key: string]: any;

    constructor(data?: IVoteWatchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): VoteWatchResult {
        data = typeof data === 'object' ? data : {};
        let result = new VoteWatchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IVoteWatchResult {

    [key: string]: any;
}

export class WatchersBean implements IWatchersBean {

    [key: string]: any;

    constructor(data?: IWatchersBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): WatchersBean {
        data = typeof data === 'object' ? data : {};
        let result = new WatchersBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IWatchersBean {

    [key: string]: any;
}

export class WorkflowMappingBean implements IWorkflowMappingBean {
    defaultMapping?: boolean;
    issueTypes?: string[];
    updateDraftIfNeeded?: boolean;
    workflow?: string;

    [key: string]: any;

    constructor(data?: IWorkflowMappingBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.defaultMapping = _data["defaultMapping"];
            if (Array.isArray(_data["issueTypes"])) {
                this.issueTypes = [] as any;
                for (let item of _data["issueTypes"])
                    this.issueTypes!.push(item);
            }
            this.updateDraftIfNeeded = _data["updateDraftIfNeeded"];
            this.workflow = _data["workflow"];
        }
    }

    static fromJS(data: any): WorkflowMappingBean {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowMappingBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["defaultMapping"] = this.defaultMapping;
        if (Array.isArray(this.issueTypes)) {
            data["issueTypes"] = [];
            for (let item of this.issueTypes)
                data["issueTypes"].push(item);
        }
        data["updateDraftIfNeeded"] = this.updateDraftIfNeeded;
        data["workflow"] = this.workflow;
        return data;
    }
}

export interface IWorkflowMappingBean {
    defaultMapping?: boolean;
    issueTypes?: string[];
    updateDraftIfNeeded?: boolean;
    workflow?: string;

    [key: string]: any;
}

export class WorkflowSchemeBean implements IWorkflowSchemeBean {
    defaultWorkflow?: string;
    description?: string;
    draft?: boolean;
    id?: number;
    issueTypeMappings?: { [key: string]: string; };
    issueTypes?: { [key: string]: IssueTypeJsonBean; };
    lastModified?: string;
    lastModifiedUser?: UserBean;
    name?: string;
    originalDefaultWorkflow?: string;
    originalIssueTypeMappings?: { [key: string]: string; };
    self?: string;
    updateDraftIfNeeded?: boolean;

    [key: string]: any;

    constructor(data?: IWorkflowSchemeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.defaultWorkflow = _data["defaultWorkflow"];
            this.description = _data["description"];
            this.draft = _data["draft"];
            this.id = _data["id"];
            if (_data["issueTypeMappings"]) {
                this.issueTypeMappings = {} as any;
                for (let key in _data["issueTypeMappings"]) {
                    if (_data["issueTypeMappings"].hasOwnProperty(key))
                        (<any>this.issueTypeMappings)![key] = _data["issueTypeMappings"][key];
                }
            }
            if (_data["issueTypes"]) {
                this.issueTypes = {} as any;
                for (let key in _data["issueTypes"]) {
                    if (_data["issueTypes"].hasOwnProperty(key))
                        (<any>this.issueTypes)![key] = _data["issueTypes"][key] ? IssueTypeJsonBean.fromJS(_data["issueTypes"][key]) : new IssueTypeJsonBean();
                }
            }
            this.lastModified = _data["lastModified"];
            this.lastModifiedUser = _data["lastModifiedUser"] ? UserBean.fromJS(_data["lastModifiedUser"]) : <any>undefined;
            this.name = _data["name"];
            this.originalDefaultWorkflow = _data["originalDefaultWorkflow"];
            if (_data["originalIssueTypeMappings"]) {
                this.originalIssueTypeMappings = {} as any;
                for (let key in _data["originalIssueTypeMappings"]) {
                    if (_data["originalIssueTypeMappings"].hasOwnProperty(key))
                        (<any>this.originalIssueTypeMappings)![key] = _data["originalIssueTypeMappings"][key];
                }
            }
            this.self = _data["self"];
            this.updateDraftIfNeeded = _data["updateDraftIfNeeded"];
        }
    }

    static fromJS(data: any): WorkflowSchemeBean {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSchemeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["defaultWorkflow"] = this.defaultWorkflow;
        data["description"] = this.description;
        data["draft"] = this.draft;
        data["id"] = this.id;
        if (this.issueTypeMappings) {
            data["issueTypeMappings"] = {};
            for (let key in this.issueTypeMappings) {
                if (this.issueTypeMappings.hasOwnProperty(key))
                    (<any>data["issueTypeMappings"])[key] = (<any>this.issueTypeMappings)[key];
            }
        }
        if (this.issueTypes) {
            data["issueTypes"] = {};
            for (let key in this.issueTypes) {
                if (this.issueTypes.hasOwnProperty(key))
                    (<any>data["issueTypes"])[key] = this.issueTypes[key] ? this.issueTypes[key].toJSON() : <any>undefined;
            }
        }
        data["lastModified"] = this.lastModified;
        data["lastModifiedUser"] = this.lastModifiedUser ? this.lastModifiedUser.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["originalDefaultWorkflow"] = this.originalDefaultWorkflow;
        if (this.originalIssueTypeMappings) {
            data["originalIssueTypeMappings"] = {};
            for (let key in this.originalIssueTypeMappings) {
                if (this.originalIssueTypeMappings.hasOwnProperty(key))
                    (<any>data["originalIssueTypeMappings"])[key] = (<any>this.originalIssueTypeMappings)[key];
            }
        }
        data["self"] = this.self;
        data["updateDraftIfNeeded"] = this.updateDraftIfNeeded;
        return data;
    }
}

export interface IWorkflowSchemeBean {
    defaultWorkflow?: string;
    description?: string;
    draft?: boolean;
    id?: number;
    issueTypeMappings?: { [key: string]: string; };
    issueTypes?: { [key: string]: IssueTypeJsonBean; };
    lastModified?: string;
    lastModifiedUser?: UserBean;
    name?: string;
    originalDefaultWorkflow?: string;
    originalIssueTypeMappings?: { [key: string]: string; };
    self?: string;
    updateDraftIfNeeded?: boolean;

    [key: string]: any;
}

export class WorkflowTransitionResource implements IWorkflowTransitionResource {

    [key: string]: any;

    constructor(data?: IWorkflowTransitionResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): WorkflowTransitionResource {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTransitionResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IWorkflowTransitionResource {

    [key: string]: any;
}

export class WorklogChangeBean implements IWorklogChangeBean {
    updatedTime?: number;
    worklogId?: number;

    [key: string]: any;

    constructor(data?: IWorklogChangeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.updatedTime = _data["updatedTime"];
            this.worklogId = _data["worklogId"];
        }
    }

    static fromJS(data: any): WorklogChangeBean {
        data = typeof data === 'object' ? data : {};
        let result = new WorklogChangeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["updatedTime"] = this.updatedTime;
        data["worklogId"] = this.worklogId;
        return data;
    }
}

export interface IWorklogChangeBean {
    updatedTime?: number;
    worklogId?: number;

    [key: string]: any;
}

export class WorklogChangedSinceBean implements IWorklogChangedSinceBean {
    isLastPage?: boolean;
    lastPage?: boolean;
    nextPage?: string;
    self?: string;
    since?: number;
    until?: number;
    values?: WorklogChangeBean[];

    [key: string]: any;

    constructor(data?: IWorklogChangedSinceBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.isLastPage = _data["isLastPage"];
            this.lastPage = _data["lastPage"];
            this.nextPage = _data["nextPage"];
            this.self = _data["self"];
            this.since = _data["since"];
            this.until = _data["until"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(WorklogChangeBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorklogChangedSinceBean {
        data = typeof data === 'object' ? data : {};
        let result = new WorklogChangedSinceBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["isLastPage"] = this.isLastPage;
        data["lastPage"] = this.lastPage;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["since"] = this.since;
        data["until"] = this.until;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorklogChangedSinceBean {
    isLastPage?: boolean;
    lastPage?: boolean;
    nextPage?: string;
    self?: string;
    since?: number;
    until?: number;
    values?: WorklogChangeBean[];

    [key: string]: any;
}

export class WorklogIdsRequestBean implements IWorklogIdsRequestBean {
    /** List of worklog ids */
    ids?: number[];

    [key: string]: any;

    constructor(data?: IWorklogIdsRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): WorklogIdsRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new WorklogIdsRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }
}

export interface IWorklogIdsRequestBean {
    /** List of worklog ids */
    ids?: number[];

    [key: string]: any;
}

export class WorklogWithPaginationBean implements IWorklogWithPaginationBean {
    maxResults?: number;
    startAt?: number;
    total?: number;
    worklogs?: Worklog[];

    [key: string]: any;

    constructor(data?: IWorklogWithPaginationBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.maxResults = _data["maxResults"];
            this.startAt = _data["startAt"];
            this.total = _data["total"];
            if (Array.isArray(_data["worklogs"])) {
                this.worklogs = [] as any;
                for (let item of _data["worklogs"])
                    this.worklogs!.push(Worklog.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorklogWithPaginationBean {
        data = typeof data === 'object' ? data : {};
        let result = new WorklogWithPaginationBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["maxResults"] = this.maxResults;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.worklogs)) {
            data["worklogs"] = [];
            for (let item of this.worklogs)
                data["worklogs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorklogWithPaginationBean {
    maxResults?: number;
    startAt?: number;
    total?: number;
    worklogs?: Worklog[];

    [key: string]: any;
}

export class IssueLinks implements IIssueLinks {
    id?: string;
    inwardIssue?: IssueRefJsonBean;
    outwardIssue?: IssueRefJsonBean;
    self?: string;
    type?: IssueLinkTypeJsonBean;

    [key: string]: any;

    constructor(data?: IIssueLinks) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.inwardIssue = _data["inwardIssue"] ? IssueRefJsonBean.fromJS(_data["inwardIssue"]) : <any>undefined;
            this.outwardIssue = _data["outwardIssue"] ? IssueRefJsonBean.fromJS(_data["outwardIssue"]) : <any>undefined;
            this.self = _data["self"];
            this.type = _data["type"] ? IssueLinkTypeJsonBean.fromJS(_data["type"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IssueLinks {
        data = typeof data === 'object' ? data : {};
        let result = new IssueLinks();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["inwardIssue"] = this.inwardIssue ? this.inwardIssue.toJSON() : <any>undefined;
        data["outwardIssue"] = this.outwardIssue ? this.outwardIssue.toJSON() : <any>undefined;
        data["self"] = this.self;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIssueLinks {
    id?: string;
    inwardIssue?: IssueRefJsonBean;
    outwardIssue?: IssueRefJsonBean;
    self?: string;
    type?: IssueLinkTypeJsonBean;

    [key: string]: any;
}

export class Worklog implements IWorklog {
    author?: UserJsonBean;
    comment?: string;
    created?: string;
    id?: string;
    issueId?: string;
    self?: string;
    started?: string;
    timeSpent?: string;
    timeSpentSeconds?: number;
    updateAuthor?: UserJsonBean;
    updated?: string;
    visibility?: VisibilityJsonBean;

    [key: string]: any;

    constructor(data?: IWorklog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.author = _data["author"] ? UserJsonBean.fromJS(_data["author"]) : <any>undefined;
            this.comment = _data["comment"];
            this.created = _data["created"];
            this.id = _data["id"];
            this.issueId = _data["issueId"];
            this.self = _data["self"];
            this.started = _data["started"];
            this.timeSpent = _data["timeSpent"];
            this.timeSpentSeconds = _data["timeSpentSeconds"];
            this.updateAuthor = _data["updateAuthor"] ? UserJsonBean.fromJS(_data["updateAuthor"]) : <any>undefined;
            this.updated = _data["updated"];
            this.visibility = _data["visibility"] ? VisibilityJsonBean.fromJS(_data["visibility"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Worklog {
        data = typeof data === 'object' ? data : {};
        let result = new Worklog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["comment"] = this.comment;
        data["created"] = this.created;
        data["id"] = this.id;
        data["issueId"] = this.issueId;
        data["self"] = this.self;
        data["started"] = this.started;
        data["timeSpent"] = this.timeSpent;
        data["timeSpentSeconds"] = this.timeSpentSeconds;
        data["updateAuthor"] = this.updateAuthor ? this.updateAuthor.toJSON() : <any>undefined;
        data["updated"] = this.updated;
        data["visibility"] = this.visibility ? this.visibility.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWorklog {
    author?: UserJsonBean;
    comment?: string;
    created?: string;
    id?: string;
    issueId?: string;
    self?: string;
    started?: string;
    timeSpent?: string;
    timeSpentSeconds?: number;
    updateAuthor?: UserJsonBean;
    updated?: string;
    visibility?: VisibilityJsonBean;

    [key: string]: any;
}

export class Body implements IBody {
    columns?: string[];

    [key: string]: any;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(item);
            }
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item);
        }
        return data;
    }
}

export interface IBody {
    columns?: string[];

    [key: string]: any;
}

export class Body2 implements IBody2 {
    columns?: string[];

    [key: string]: any;

    constructor(data?: IBody2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(item);
            }
        }
    }

    static fromJS(data: any): Body2 {
        data = typeof data === 'object' ? data : {};
        let result = new Body2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item);
        }
        return data;
    }
}

export interface IBody2 {
    columns?: string[];

    [key: string]: any;
}

export class Body3 implements IBody3 {
    username?: string;
    columns?: string[];

    [key: string]: any;

    constructor(data?: IBody3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.username = _data["username"];
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(item);
            }
        }
    }

    static fromJS(data: any): Body3 {
        data = typeof data === 'object' ? data : {};
        let result = new Body3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["username"] = this.username;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item);
        }
        return data;
    }
}

export interface IBody3 {
    username?: string;
    columns?: string[];

    [key: string]: any;
}

export enum ColorBeanKey {
    Color_1 = "color_1",
    Color_2 = "color_2",
    Color_3 = "color_3",
    Color_4 = "color_4",
    Color_5 = "color_5",
    Color_6 = "color_6",
    Color_7 = "color_7",
    Color_8 = "color_8",
    Color_9 = "color_9",
    Color_10 = "color_10",
    Color_11 = "color_11",
    Color_12 = "color_12",
    Color_13 = "color_13",
    Color_14 = "color_14",
}

export class Locale implements ILocale {
    country?: string;
    displayCountry?: string;
    displayLanguage?: string;
    displayName?: string;
    displayScript?: string;
    displayVariant?: string;
    extensionKeys?: string[];
    iso3Country?: string;
    iso3Language?: string;
    language?: string;
    script?: string;
    unicodeLocaleAttributes?: string[];
    unicodeLocaleKeys?: string[];
    variant?: string;

    [key: string]: any;

    constructor(data?: ILocale) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.country = _data["country"];
            this.displayCountry = _data["displayCountry"];
            this.displayLanguage = _data["displayLanguage"];
            this.displayName = _data["displayName"];
            this.displayScript = _data["displayScript"];
            this.displayVariant = _data["displayVariant"];
            if (Array.isArray(_data["extensionKeys"])) {
                this.extensionKeys = [] as any;
                for (let item of _data["extensionKeys"])
                    this.extensionKeys!.push(item);
            }
            this.iso3Country = _data["iso3Country"];
            this.iso3Language = _data["iso3Language"];
            this.language = _data["language"];
            this.script = _data["script"];
            if (Array.isArray(_data["unicodeLocaleAttributes"])) {
                this.unicodeLocaleAttributes = [] as any;
                for (let item of _data["unicodeLocaleAttributes"])
                    this.unicodeLocaleAttributes!.push(item);
            }
            if (Array.isArray(_data["unicodeLocaleKeys"])) {
                this.unicodeLocaleKeys = [] as any;
                for (let item of _data["unicodeLocaleKeys"])
                    this.unicodeLocaleKeys!.push(item);
            }
            this.variant = _data["variant"];
        }
    }

    static fromJS(data: any): Locale {
        data = typeof data === 'object' ? data : {};
        let result = new Locale();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["country"] = this.country;
        data["displayCountry"] = this.displayCountry;
        data["displayLanguage"] = this.displayLanguage;
        data["displayName"] = this.displayName;
        data["displayScript"] = this.displayScript;
        data["displayVariant"] = this.displayVariant;
        if (Array.isArray(this.extensionKeys)) {
            data["extensionKeys"] = [];
            for (let item of this.extensionKeys)
                data["extensionKeys"].push(item);
        }
        data["iso3Country"] = this.iso3Country;
        data["iso3Language"] = this.iso3Language;
        data["language"] = this.language;
        data["script"] = this.script;
        if (Array.isArray(this.unicodeLocaleAttributes)) {
            data["unicodeLocaleAttributes"] = [];
            for (let item of this.unicodeLocaleAttributes)
                data["unicodeLocaleAttributes"].push(item);
        }
        if (Array.isArray(this.unicodeLocaleKeys)) {
            data["unicodeLocaleKeys"] = [];
            for (let item of this.unicodeLocaleKeys)
                data["unicodeLocaleKeys"].push(item);
        }
        data["variant"] = this.variant;
        return data;
    }
}

export interface ILocale {
    country?: string;
    displayCountry?: string;
    displayLanguage?: string;
    displayName?: string;
    displayScript?: string;
    displayVariant?: string;
    extensionKeys?: string[];
    iso3Country?: string;
    iso3Language?: string;
    language?: string;
    script?: string;
    unicodeLocaleAttributes?: string[];
    unicodeLocaleKeys?: string[];
    variant?: string;

    [key: string]: any;
}

export enum ProjectInputBeanAssigneeType {
    PROJECT_LEAD = "PROJECT_LEAD",
    UNASSIGNED = "UNASSIGNED",
}

export class Statistics implements IStatistics {
    empty?: boolean;

    [key: string]: any;

    constructor(data?: IStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.empty = _data["empty"];
        }
    }

    static fromJS(data: any): Statistics {
        data = typeof data === 'object' ? data : {};
        let result = new Statistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["empty"] = this.empty;
        return data;
    }
}

export interface IStatistics {
    empty?: boolean;

    [key: string]: any;
}

export enum AffectedEntityBeanType {
    ANONYMIZE = "ANONYMIZE",
    TRANSFER_OWNERSHIP = "TRANSFER_OWNERSHIP",
    REMOVE = "REMOVE",
    MANUAL = "MANUAL",
}

export enum ClusterStateState {
    STABLE = "STABLE",
    READY_TO_UPGRADE = "READY_TO_UPGRADE",
    MIXED = "MIXED",
    READY_TO_RUN_UPGRADE_TASKS = "READY_TO_RUN_UPGRADE_TASKS",
    RUNNING_UPGRADE_TASKS = "RUNNING_UPGRADE_TASKS",
    UPGRADE_TASKS_FAILED = "UPGRADE_TASKS_FAILED",
}

export enum ColumnLayoutColumnConfig {
    SYSTEM = "SYSTEM",
    EXPLICIT = "EXPLICIT",
    FILTER = "FILTER",
    USER = "USER",
    NONE = "NONE",
}

export enum ComponentBeanAssigneeType {
    PROJECT_DEFAULT = "PROJECT_DEFAULT",
    COMPONENT_LEAD = "COMPONENT_LEAD",
    PROJECT_LEAD = "PROJECT_LEAD",
    UNASSIGNED = "UNASSIGNED",
}

export enum DefaultShareScopeBeanScope {
    GLOBAL = "GLOBAL",
    AUTHENTICATED = "AUTHENTICATED",
    PRIVATE = "PRIVATE",
}

export enum GroupLabelBeanType {
    ADMIN = "ADMIN",
    SINGLE = "SINGLE",
    MULTIPLE = "MULTIPLE",
}

export enum IssueTypeCreateBeanType {
    Subtask = "subtask",
    Standard = "standard",
}

export enum MoveFieldBeanPosition {
    Earlier = "Earlier",
    Later = "Later",
    First = "First",
    Last = "Last",
}

export enum NodeBeanState {
    ACTIVE = "ACTIVE",
    PASSIVE = "PASSIVE",
    ACTIVATING = "ACTIVATING",
    PASSIVATING = "PASSIVATING",
    OFFLINE = "OFFLINE",
}

export enum PermissionJsonBeanType {
    GLOBAL = "GLOBAL",
    PROJECT = "PROJECT",
}

export enum ProjectUpdateBeanAssigneeType {
    PROJECT_LEAD = "PROJECT_LEAD",
    UNASSIGNED = "UNASSIGNED",
}

export enum ReindexBeanType {
    FOREGROUND = "FOREGROUND",
    BACKGROUND = "BACKGROUND",
    BACKGROUND_PREFFERED = "BACKGROUND_PREFFERED",
    BACKGROUND_PREFERRED = "BACKGROUND_PREFERRED",
}

export enum ReindexRequestBeanStatus {
    PENDING = "PENDING",
    ACTIVE = "ACTIVE",
    RUNNING = "RUNNING",
    FAILED = "FAILED",
    COMPLETE = "COMPLETE",
}

export enum ReindexRequestBeanType {
    IMMEDIATE = "IMMEDIATE",
    DELAYED = "DELAYED",
}

export enum TimeTrackingConfigurationBeanDefaultUnit {
    Minute = "minute",
    Hour = "hour",
    Day = "day",
    Week = "week",
}

export enum TimeTrackingConfigurationBeanTimeFormat {
    Pretty = "pretty",
    Days = "days",
    Hours = "hours",
}

export enum VersionMoveBeanPosition {
    Earlier = "Earlier",
    Later = "Later",
    First = "First",
    Last = "Last",
}

export enum VisibilityJsonBeanType {
    Group = "group",
    Role = "role",
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}