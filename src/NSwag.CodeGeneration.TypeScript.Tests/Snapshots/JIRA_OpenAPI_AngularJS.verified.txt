
/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import * as ng from 'angular';

export class Client {
    private baseUrl: string | undefined = undefined;
    private http: ng.IHttpService;
    private q: ng.IQService;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor($http: ng.IHttpService, $q: ng.IQService, baseUrl?: string) {
        this.http = $http;
        this.q = $q;
        this.baseUrl = baseUrl ?? "https://your-domain.atlassian.net";
    }

    /**
     * Get announcement banner configuration
     * @return Returned if the request is successful.
     */
    getBanner(): ng.IPromise<AnnouncementBannerConfiguration> {
        let url_ = this.baseUrl + "/rest/api/3/announcementBanner";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetBanner(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetBanner(_response);
            throw _response;
        });
    }

    protected processGetBanner(response: any): ng.IPromise<AnnouncementBannerConfiguration> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AnnouncementBannerConfiguration.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<AnnouncementBannerConfiguration>(null as any);
    }

    /**
     * Update announcement banner configuration
     * @return Returned if the request is successful.
     */
    setBanner(body: AnnouncementBannerConfigurationUpdate): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/announcementBanner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetBanner(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetBanner(_response);
            throw _response;
        });
    }

    protected processSetBanner(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if an invalid parameter is passed.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Bulk get custom field configurations
     * @param id (optional) The list of configuration IDs. To include multiple configurations, separate IDs with an ampersand: `id=10000&id=10001`. Can't be provided with `fieldContextId`, `issueId`, `projectKeyOrId`, or `issueTypeId`.
     * @param fieldContextId (optional) The list of field context IDs. To include multiple field contexts, separate IDs with an ampersand: `fieldContextId=10000&fieldContextId=10001`. Can't be provided with `id`, `issueId`, `projectKeyOrId`, or `issueTypeId`.
     * @param issueId (optional) The ID of the issue to filter results by. If the issue doesn't exist, an empty list is returned. Can't be provided with `projectKeyOrId`, or `issueTypeId`.
     * @param projectKeyOrId (optional) The ID or key of the project to filter results by. Must be provided with `issueTypeId`. Can't be provided with `issueId`.
     * @param issueTypeId (optional) The ID of the issue type to filter results by. Must be provided with `projectKeyOrId`. Can't be provided with `issueId`.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getCustomFieldsConfigurations(body: ConfigurationsListParameters, id?: number[] | undefined, fieldContextId?: number[] | undefined, issueId?: number | undefined, projectKeyOrId?: string | undefined, issueTypeId?: string | undefined, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanBulkContextualConfiguration> {
        let url_ = this.baseUrl + "/rest/api/3/app/field/context/configuration/list?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (fieldContextId === null)
            throw new Error("The parameter 'fieldContextId' cannot be null.");
        else if (fieldContextId !== undefined)
            fieldContextId && fieldContextId.forEach(item => { url_ += "fieldContextId=" + encodeURIComponent("" + item) + "&"; });
        if (issueId === null)
            throw new Error("The parameter 'issueId' cannot be null.");
        else if (issueId !== undefined)
            url_ += "issueId=" + encodeURIComponent("" + issueId) + "&";
        if (projectKeyOrId === null)
            throw new Error("The parameter 'projectKeyOrId' cannot be null.");
        else if (projectKeyOrId !== undefined)
            url_ += "projectKeyOrId=" + encodeURIComponent("" + projectKeyOrId) + "&";
        if (issueTypeId === null)
            throw new Error("The parameter 'issueTypeId' cannot be null.");
        else if (issueTypeId !== undefined)
            url_ += "issueTypeId=" + encodeURIComponent("" + issueTypeId) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetCustomFieldsConfigurations(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetCustomFieldsConfigurations(_response);
            throw _response;
        });
    }

    protected processGetCustomFieldsConfigurations(response: any): ng.IPromise<PageBeanBulkContextualConfiguration> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanBulkContextualConfiguration.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user is not a Jira admin or the request is not authenticated as from the app that provided the field.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the custom field is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanBulkContextualConfiguration>(null as any);
    }

    /**
     * Update custom fields
     * @param generateChangelog (optional) Whether to generate a changelog for this update.
     * @return Returned if the request is successful.
     */
    updateMultipleCustomFieldValues(body: MultipleCustomFieldValuesUpdateDetails, generateChangelog?: boolean | undefined): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/app/field/value?";
        if (generateChangelog === null)
            throw new Error("The parameter 'generateChangelog' cannot be null.");
        else if (generateChangelog !== undefined)
            url_ += "generateChangelog=" + encodeURIComponent("" + generateChangelog) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateMultipleCustomFieldValues(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateMultipleCustomFieldValues(_response);
            throw _response;
        });
    }

    protected processUpdateMultipleCustomFieldValues(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not authenticated as the app that provided all the fields.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if any field is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get custom field configurations
     * @param fieldIdOrKey The ID or key of the custom field, for example `customfield_10000`.
     * @param id (optional) The list of configuration IDs. To include multiple configurations, separate IDs with an ampersand: `id=10000&id=10001`. Can't be provided with `fieldContextId`, `issueId`, `projectKeyOrId`, or `issueTypeId`.
     * @param fieldContextId (optional) The list of field context IDs. To include multiple field contexts, separate IDs with an ampersand: `fieldContextId=10000&fieldContextId=10001`. Can't be provided with `id`, `issueId`, `projectKeyOrId`, or `issueTypeId`.
     * @param issueId (optional) The ID of the issue to filter results by. If the issue doesn't exist, an empty list is returned. Can't be provided with `projectKeyOrId`, or `issueTypeId`.
     * @param projectKeyOrId (optional) The ID or key of the project to filter results by. Must be provided with `issueTypeId`. Can't be provided with `issueId`.
     * @param issueTypeId (optional) The ID of the issue type to filter results by. Must be provided with `projectKeyOrId`. Can't be provided with `issueId`.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getCustomFieldConfiguration(fieldIdOrKey: string, id?: number[] | undefined, fieldContextId?: number[] | undefined, issueId?: number | undefined, projectKeyOrId?: string | undefined, issueTypeId?: string | undefined, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanContextualConfiguration> {
        let url_ = this.baseUrl + "/rest/api/3/app/field/{fieldIdOrKey}/context/configuration?";
        if (fieldIdOrKey === undefined || fieldIdOrKey === null)
            throw new Error("The parameter 'fieldIdOrKey' must be defined.");
        url_ = url_.replace("{fieldIdOrKey}", encodeURIComponent("" + fieldIdOrKey));
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (fieldContextId === null)
            throw new Error("The parameter 'fieldContextId' cannot be null.");
        else if (fieldContextId !== undefined)
            fieldContextId && fieldContextId.forEach(item => { url_ += "fieldContextId=" + encodeURIComponent("" + item) + "&"; });
        if (issueId === null)
            throw new Error("The parameter 'issueId' cannot be null.");
        else if (issueId !== undefined)
            url_ += "issueId=" + encodeURIComponent("" + issueId) + "&";
        if (projectKeyOrId === null)
            throw new Error("The parameter 'projectKeyOrId' cannot be null.");
        else if (projectKeyOrId !== undefined)
            url_ += "projectKeyOrId=" + encodeURIComponent("" + projectKeyOrId) + "&";
        if (issueTypeId === null)
            throw new Error("The parameter 'issueTypeId' cannot be null.");
        else if (issueTypeId !== undefined)
            url_ += "issueTypeId=" + encodeURIComponent("" + issueTypeId) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetCustomFieldConfiguration(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetCustomFieldConfiguration(_response);
            throw _response;
        });
    }

    protected processGetCustomFieldConfiguration(response: any): ng.IPromise<PageBeanContextualConfiguration> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanContextualConfiguration.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user is not a Jira admin or the request is not authenticated as from the app that provided the field.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the custom field is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanContextualConfiguration>(null as any);
    }

    /**
     * Update custom field configurations
     * @param fieldIdOrKey The ID or key of the custom field, for example `customfield_10000`.
     * @return Returned if the request is successful.
     */
    updateCustomFieldConfiguration(fieldIdOrKey: string, body: CustomFieldConfigurations): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/app/field/{fieldIdOrKey}/context/configuration";
        if (fieldIdOrKey === undefined || fieldIdOrKey === null)
            throw new Error("The parameter 'fieldIdOrKey' must be defined.");
        url_ = url_.replace("{fieldIdOrKey}", encodeURIComponent("" + fieldIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateCustomFieldConfiguration(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateCustomFieldConfiguration(_response);
            throw _response;
        });
    }

    protected processUpdateCustomFieldConfiguration(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user is not a Jira admin or the request is not authenticated as from the app that provided the field.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the custom field is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Update custom field value
     * @param fieldIdOrKey The ID or key of the custom field. For example, `customfield_10010`.
     * @param generateChangelog (optional) Whether to generate a changelog for this update.
     * @return Returned if the request is successful.
     */
    updateCustomFieldValue(fieldIdOrKey: string, body: CustomFieldValueUpdateDetails, generateChangelog?: boolean | undefined): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/app/field/{fieldIdOrKey}/value?";
        if (fieldIdOrKey === undefined || fieldIdOrKey === null)
            throw new Error("The parameter 'fieldIdOrKey' must be defined.");
        url_ = url_.replace("{fieldIdOrKey}", encodeURIComponent("" + fieldIdOrKey));
        if (generateChangelog === null)
            throw new Error("The parameter 'generateChangelog' cannot be null.");
        else if (generateChangelog !== undefined)
            url_ += "generateChangelog=" + encodeURIComponent("" + generateChangelog) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateCustomFieldValue(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateCustomFieldValue(_response);
            throw _response;
        });
    }

    protected processUpdateCustomFieldValue(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not authenticated as the app that provided the field.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get application property
     * @param key (optional) The key of the application property.
     * @param permissionLevel (optional) The permission level of all items being returned in the list.
     * @param keyFilter (optional) When a `key` isn't provided, this filters the list of results by the application property `key` using a regular expression. For example, using `jira.lf.*` will return all application properties with keys that start with *jira.lf.*.
     * @return Returned if the request is successful.
     */
    getApplicationProperty(key?: string | undefined, permissionLevel?: string | undefined, keyFilter?: string | undefined): ng.IPromise<ApplicationProperty[]> {
        let url_ = this.baseUrl + "/rest/api/3/application-properties?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (permissionLevel === null)
            throw new Error("The parameter 'permissionLevel' cannot be null.");
        else if (permissionLevel !== undefined)
            url_ += "permissionLevel=" + encodeURIComponent("" + permissionLevel) + "&";
        if (keyFilter === null)
            throw new Error("The parameter 'keyFilter' cannot be null.");
        else if (keyFilter !== undefined)
            url_ += "keyFilter=" + encodeURIComponent("" + keyFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetApplicationProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetApplicationProperty(_response);
            throw _response;
        });
    }

    protected processGetApplicationProperty(response: any): ng.IPromise<ApplicationProperty[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApplicationProperty.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the application property is not found or the user does not have permission to view it.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ApplicationProperty[]>(null as any);
    }

    /**
     * Get advanced settings
     * @return Returned if the request is successful.
     */
    getAdvancedSettings(): ng.IPromise<ApplicationProperty[]> {
        let url_ = this.baseUrl + "/rest/api/3/application-properties/advanced-settings";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAdvancedSettings(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAdvancedSettings(_response);
            throw _response;
        });
    }

    protected processGetAdvancedSettings(response: any): ng.IPromise<ApplicationProperty[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApplicationProperty.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user is not an administrator.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ApplicationProperty[]>(null as any);
    }

    /**
     * Set application property
     * @param id The key of the application property to update.
     * @return Returned if the request is successful.
     */
    setApplicationProperty(id: string, body: SimpleApplicationPropertyBean): ng.IPromise<ApplicationProperty> {
        let url_ = this.baseUrl + "/rest/api/3/application-properties/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetApplicationProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetApplicationProperty(_response);
            throw _response;
        });
    }

    protected processSetApplicationProperty(response: any): ng.IPromise<ApplicationProperty> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationProperty.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the data type of the `value` does not match the application property\'s data type. For example, a string is provided instead of an integer.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have permission to edit the property.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the property is not found or the user does not have permission to view it.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ApplicationProperty>(null as any);
    }

    /**
     * Get all application roles
     * @return Returned if the request is successful.
     */
    getAllApplicationRoles(): ng.IPromise<ApplicationRole[]> {
        let url_ = this.baseUrl + "/rest/api/3/applicationrole";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllApplicationRoles(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllApplicationRoles(_response);
            throw _response;
        });
    }

    protected processGetAllApplicationRoles(response: any): ng.IPromise<ApplicationRole[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApplicationRole.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user is not an administrator.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ApplicationRole[]>(null as any);
    }

    /**
     * Get application role
     * @param key The key of the application role. Use the [Get all application roles](#api-rest-api-3-applicationrole-get) operation to get the key for each application role.
     * @return Returned if the request is successful.
     */
    getApplicationRole(key: string): ng.IPromise<ApplicationRole> {
        let url_ = this.baseUrl + "/rest/api/3/applicationrole/{key}";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined.");
        url_ = url_.replace("{key}", encodeURIComponent("" + key));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetApplicationRole(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetApplicationRole(_response);
            throw _response;
        });
    }

    protected processGetApplicationRole(response: any): ng.IPromise<ApplicationRole> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRole.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user is not an administrator.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the role is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ApplicationRole>(null as any);
    }

    /**
     * Get attachment content
     * @param id The ID of the attachment.
     * @param redirect (optional) Whether a redirect is provided for the attachment download. Clients that do not automatically follow redirects can set this to `false` to avoid making multiple requests to download the attachment.
     * @return Returned if the request is successful when `redirect` is set to `false`.
     */
    getAttachmentContent(id: string, redirect?: boolean | undefined): ng.IPromise<any[]> {
        let url_ = this.baseUrl + "/rest/api/3/attachment/content/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (redirect === null)
            throw new Error("The parameter 'redirect' cannot be null.");
        else if (redirect !== undefined)
            url_ += "redirect=" + encodeURIComponent("" + redirect) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAttachmentContent(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAttachmentContent(_response);
            throw _response;
        });
    }

    protected processGetAttachmentContent(response: any): ng.IPromise<any[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 206) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is successful when a `Range` header is provided and `redirect` is set to `false`.", status, _responseText, _headers);

        } else if (status === 303) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is successful. See the `Location` header for the download URL.", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the range supplied in the `Range` header is malformed.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "The user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the attachment is not found.\n *  attachments are disabled in the Jira settings.", status, _responseText, _headers);

        } else if (status === 416) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the server is unable to satisfy the range of bytes provided.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any[]>(null as any);
    }

    /**
     * Get Jira attachment settings
     * @return Returned if the request is successful.
     */
    getAttachmentMeta(): ng.IPromise<AttachmentSettings> {
        let url_ = this.baseUrl + "/rest/api/3/attachment/meta";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAttachmentMeta(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAttachmentMeta(_response);
            throw _response;
        });
    }

    protected processGetAttachmentMeta(response: any): ng.IPromise<AttachmentSettings> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentSettings.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<AttachmentSettings>(null as any);
    }

    /**
     * Get attachment thumbnail
     * @param id The ID of the attachment.
     * @param redirect (optional) Whether a redirect is provided for the attachment download. Clients that do not automatically follow redirects can set this to `false` to avoid making multiple requests to download the attachment.
     * @param fallbackToDefault (optional) Whether a default thumbnail is returned when the requested thumbnail is not found.
     * @param width (optional) The maximum width to scale the thumbnail to.
     * @param height (optional) The maximum height to scale the thumbnail to.
     * @return Returned if the request is successful when `redirect` is set to `false`.
     */
    getAttachmentThumbnail(id: string, redirect?: boolean | undefined, fallbackToDefault?: boolean | undefined, width?: number | undefined, height?: number | undefined): ng.IPromise<any[]> {
        let url_ = this.baseUrl + "/rest/api/3/attachment/thumbnail/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (redirect === null)
            throw new Error("The parameter 'redirect' cannot be null.");
        else if (redirect !== undefined)
            url_ += "redirect=" + encodeURIComponent("" + redirect) + "&";
        if (fallbackToDefault === null)
            throw new Error("The parameter 'fallbackToDefault' cannot be null.");
        else if (fallbackToDefault !== undefined)
            url_ += "fallbackToDefault=" + encodeURIComponent("" + fallbackToDefault) + "&";
        if (width === null)
            throw new Error("The parameter 'width' cannot be null.");
        else if (width !== undefined)
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "height=" + encodeURIComponent("" + height) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAttachmentThumbnail(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAttachmentThumbnail(_response);
            throw _response;
        });
    }

    protected processGetAttachmentThumbnail(response: any): ng.IPromise<any[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 303) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is successful. See the `Location` header for the download URL.", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "The user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the attachment is not found.\n *  attachments are disabled in the Jira settings.\n *  `fallbackToDefault` is `false` and the request thumbnail cannot be downloaded.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any[]>(null as any);
    }

    /**
     * Delete attachment
     * @param id The ID of the attachment.
     * @return Returned if the request is successful.
     */
    removeAttachment(id: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/attachment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveAttachment(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveAttachment(_response);
            throw _response;
        });
    }

    protected processRemoveAttachment(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the attachment is not found.\n *  attachments are disabled in the Jira settings.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get attachment metadata
     * @param id The ID of the attachment.
     * @return Returned if the request is successful.
     */
    getAttachment(id: string): ng.IPromise<AttachmentMetadata> {
        let url_ = this.baseUrl + "/rest/api/3/attachment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAttachment(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAttachment(_response);
            throw _response;
        });
    }

    protected processGetAttachment(response: any): ng.IPromise<AttachmentMetadata> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentMetadata.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the attachment is not found.\n *  attachments are disabled in the Jira settings.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<AttachmentMetadata>(null as any);
    }

    /**
     * Get all metadata for an expanded attachment
     * @param id The ID of the attachment.
     * @return Returned if the request is successful. If an empty list is returned in the response, the attachment is empty, corrupt, or not an archive.
     */
    expandAttachmentForHumans(id: string): ng.IPromise<AttachmentArchiveMetadataReadable> {
        let url_ = this.baseUrl + "/rest/api/3/attachment/{id}/expand/human";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processExpandAttachmentForHumans(_response);
        }, (_response) => {
            if (_response.status)
                return this.processExpandAttachmentForHumans(_response);
            throw _response;
        });
    }

    protected processExpandAttachmentForHumans(response: any): ng.IPromise<AttachmentArchiveMetadataReadable> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentArchiveMetadataReadable.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "The user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the attachment is not found.\n *  attachments are disabled in the Jira settings.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the attachment is an archive, but not a supported archive format.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<AttachmentArchiveMetadataReadable>(null as any);
    }

    /**
     * Get contents metadata for an expanded attachment
     * @param id The ID of the attachment.
     * @return Returned if the request is successful. If an empty list is returned in the response, the attachment is empty, corrupt, or not an archive.
     */
    expandAttachmentForMachines(id: string): ng.IPromise<AttachmentArchiveImpl> {
        let url_ = this.baseUrl + "/rest/api/3/attachment/{id}/expand/raw";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processExpandAttachmentForMachines(_response);
        }, (_response) => {
            if (_response.status)
                return this.processExpandAttachmentForMachines(_response);
            throw _response;
        });
    }

    protected processExpandAttachmentForMachines(response: any): ng.IPromise<AttachmentArchiveImpl> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachmentArchiveImpl.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "The user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the attachment is not found.\n *  attachments are disabled in the Jira settings.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the attachment is an archive, but not a supported archive format.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<AttachmentArchiveImpl>(null as any);
    }

    /**
     * Get audit records
     * @param offset (optional) The number of records to skip before returning the first result.
     * @param limit (optional) The maximum number of results to return.
     * @param filter (optional) The strings to match with audit field content, space separated.
     * @param from (optional) The date and time on or after which returned audit records must have been created. If `to` is provided `from` must be before `to` or no audit records are returned.
     * @param to (optional) The date and time on or before which returned audit results must have been created. If `from` is provided `to` must be after `from` or no audit records are returned.
     * @return Returned if the request is successful.
     */
    getAuditRecords(offset?: number | undefined, limit?: number | undefined, filter?: string | undefined, from?: string | undefined, to?: string | undefined): ng.IPromise<AuditRecords> {
        let url_ = this.baseUrl + "/rest/api/3/auditing/record?";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to === null)
            throw new Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAuditRecords(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAuditRecords(_response);
            throw _response;
        });
    }

    protected processGetAuditRecords(response: any): ng.IPromise<AuditRecords> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuditRecords.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if:\n\n *  the user does not have the required permissions.\n *  all Jira products are on free plans. Audit logs are available when at least one Jira product is on a paid plan.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<AuditRecords>(null as any);
    }

    /**
     * Get system avatars by type
     * @param type The avatar type.
     * @return Returned if the request is successful.
     */
    getAllSystemAvatars(type: Type): ng.IPromise<SystemAvatars> {
        let url_ = this.baseUrl + "/rest/api/3/avatar/{type}/system";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllSystemAvatars(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllSystemAvatars(_response);
            throw _response;
        });
    }

    protected processGetAllSystemAvatars(response: any): ng.IPromise<SystemAvatars> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemAvatars.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if an error occurs while retrieving the list of avatars.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SystemAvatars>(null as any);
    }

    /**
     * Bulk delete issues
     * @param body The request body containing the issues to be deleted.
     * @return Returned if the request is successful.
     */
    submitBulkDelete(body: IssueBulkDeletePayload): ng.IPromise<SubmittedBulkOperation> {
        let url_ = this.baseUrl + "/rest/api/3/bulk/issues/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSubmitBulkDelete(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSubmitBulkDelete(_response);
            throw _response;
        });
    }

    protected processSubmitBulkDelete(response: any): ng.IPromise<SubmittedBulkOperation> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SubmittedBulkOperation.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BulkOperationErrorResponse.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = BulkOperationErrorResponse.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = BulkOperationErrorResponse.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SubmittedBulkOperation>(null as any);
    }

    /**
     * Get bulk editable fields
     * @param issueIdsOrKeys The IDs or keys of the issues to get editable fields from.
     * @param searchText (optional) (Optional)The text to search for in the editable fields.
     * @param endingBefore (optional) (Optional)The end cursor for use in pagination.
     * @param startingAfter (optional) (Optional)The start cursor for use in pagination.
     * @return Returned if the request is successful.
     */
    getBulkEditableFields(issueIdsOrKeys: string, searchText?: string | undefined, endingBefore?: string | undefined, startingAfter?: string | undefined): ng.IPromise<BulkEditGetFields> {
        let url_ = this.baseUrl + "/rest/api/3/bulk/issues/fields?";
        if (issueIdsOrKeys === undefined || issueIdsOrKeys === null)
            throw new Error("The parameter 'issueIdsOrKeys' must be defined and cannot be null.");
        else
            url_ += "issueIdsOrKeys=" + encodeURIComponent("" + issueIdsOrKeys) + "&";
        if (searchText === null)
            throw new Error("The parameter 'searchText' cannot be null.");
        else if (searchText !== undefined)
            url_ += "searchText=" + encodeURIComponent("" + searchText) + "&";
        if (endingBefore === null)
            throw new Error("The parameter 'endingBefore' cannot be null.");
        else if (endingBefore !== undefined)
            url_ += "endingBefore=" + encodeURIComponent("" + endingBefore) + "&";
        if (startingAfter === null)
            throw new Error("The parameter 'startingAfter' cannot be null.");
        else if (startingAfter !== undefined)
            url_ += "startingAfter=" + encodeURIComponent("" + startingAfter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetBulkEditableFields(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetBulkEditableFields(_response);
            throw _response;
        });
    }

    protected processGetBulkEditableFields(response: any): ng.IPromise<BulkEditGetFields> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkEditGetFields.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BulkOperationErrorResponse.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = BulkOperationErrorResponse.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = BulkOperationErrorResponse.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = BulkOperationErrorResponse.fromJS(resultData404);
            return throwException(this.q, "Returned if no editable fields are found for the provided issue IDs.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<BulkEditGetFields>(null as any);
    }

    /**
     * Bulk edit issues
     * @param body The request body containing the issues to be edited and the new field values.
     * @return Returned if the request is successful.
     */
    submitBulkEdit(body: IssueBulkEditPayload): ng.IPromise<SubmittedBulkOperation> {
        let url_ = this.baseUrl + "/rest/api/3/bulk/issues/fields";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSubmitBulkEdit(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSubmitBulkEdit(_response);
            throw _response;
        });
    }

    protected processSubmitBulkEdit(response: any): ng.IPromise<SubmittedBulkOperation> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SubmittedBulkOperation.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BulkOperationErrorResponse.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = BulkOperationErrorResponse.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SubmittedBulkOperation>(null as any);
    }

    /**
     * Bulk move issues
     * @return Returned if the request is successful.
     */
    submitBulkMove(body: IssueBulkMovePayload): ng.IPromise<SubmittedBulkOperation> {
        let url_ = this.baseUrl + "/rest/api/3/bulk/issues/move";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSubmitBulkMove(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSubmitBulkMove(_response);
            throw _response;
        });
    }

    protected processSubmitBulkMove(response: any): ng.IPromise<SubmittedBulkOperation> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SubmittedBulkOperation.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BulkOperationErrorResponse.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = BulkOperationErrorResponse.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SubmittedBulkOperation>(null as any);
    }

    /**
     * Get available transitions
     * @param issueIdsOrKeys Comma (,) separated Ids or keys of the issues to get transitions available for them.
     * @param endingBefore (optional) (Optional)The end cursor for use in pagination.
     * @param startingAfter (optional) (Optional)The start cursor for use in pagination.
     * @return Returned if the request is successful.
     */
    getAvailableTransitions(issueIdsOrKeys: string, endingBefore?: string | undefined, startingAfter?: string | undefined): ng.IPromise<BulkTransitionGetAvailableTransitions> {
        let url_ = this.baseUrl + "/rest/api/3/bulk/issues/transition?";
        if (issueIdsOrKeys === undefined || issueIdsOrKeys === null)
            throw new Error("The parameter 'issueIdsOrKeys' must be defined and cannot be null.");
        else
            url_ += "issueIdsOrKeys=" + encodeURIComponent("" + issueIdsOrKeys) + "&";
        if (endingBefore === null)
            throw new Error("The parameter 'endingBefore' cannot be null.");
        else if (endingBefore !== undefined)
            url_ += "endingBefore=" + encodeURIComponent("" + endingBefore) + "&";
        if (startingAfter === null)
            throw new Error("The parameter 'startingAfter' cannot be null.");
        else if (startingAfter !== undefined)
            url_ += "startingAfter=" + encodeURIComponent("" + startingAfter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAvailableTransitions(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAvailableTransitions(_response);
            throw _response;
        });
    }

    protected processGetAvailableTransitions(response: any): ng.IPromise<BulkTransitionGetAvailableTransitions> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkTransitionGetAvailableTransitions.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BulkOperationErrorResponse.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is not valid. For example, if a provided issue ID or key is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = BulkOperationErrorResponse.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = BulkOperationErrorResponse.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<BulkTransitionGetAvailableTransitions>(null as any);
    }

    /**
     * Bulk transition issue statuses
     * @param body The request body containing the issues to be transitioned.
     * @return Returned if the request is successful.
     */
    submitBulkTransition(body: IssueBulkTransitionPayload): ng.IPromise<SubmittedBulkOperation> {
        let url_ = this.baseUrl + "/rest/api/3/bulk/issues/transition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSubmitBulkTransition(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSubmitBulkTransition(_response);
            throw _response;
        });
    }

    protected processSubmitBulkTransition(response: any): ng.IPromise<SubmittedBulkOperation> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SubmittedBulkOperation.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BulkOperationErrorResponse.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = BulkOperationErrorResponse.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = BulkOperationErrorResponse.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SubmittedBulkOperation>(null as any);
    }

    /**
     * Bulk unwatch issues
     * @param body The request body containing the issues to be unwatched.
     * @return Returned if the request is successful.
     */
    submitBulkUnwatch(body: IssueBulkWatchOrUnwatchPayload): ng.IPromise<SubmittedBulkOperation> {
        let url_ = this.baseUrl + "/rest/api/3/bulk/issues/unwatch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSubmitBulkUnwatch(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSubmitBulkUnwatch(_response);
            throw _response;
        });
    }

    protected processSubmitBulkUnwatch(response: any): ng.IPromise<SubmittedBulkOperation> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SubmittedBulkOperation.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BulkOperationErrorResponse.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = BulkOperationErrorResponse.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = BulkOperationErrorResponse.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SubmittedBulkOperation>(null as any);
    }

    /**
     * Bulk watch issues
     * @param body The request body containing the issues to be watched.
     * @return Returned if the request is successful.
     */
    submitBulkWatch(body: IssueBulkWatchOrUnwatchPayload): ng.IPromise<SubmittedBulkOperation> {
        let url_ = this.baseUrl + "/rest/api/3/bulk/issues/watch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSubmitBulkWatch(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSubmitBulkWatch(_response);
            throw _response;
        });
    }

    protected processSubmitBulkWatch(response: any): ng.IPromise<SubmittedBulkOperation> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SubmittedBulkOperation.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BulkOperationErrorResponse.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = BulkOperationErrorResponse.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = BulkOperationErrorResponse.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SubmittedBulkOperation>(null as any);
    }

    /**
     * Get bulk issue operation progress
     * @param taskId The ID of the task.
     * @return Returned if the request is successful.
     */
    getBulkOperationProgress(taskId: string): ng.IPromise<BulkOperationProgress> {
        let url_ = this.baseUrl + "/rest/api/3/bulk/queue/{taskId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetBulkOperationProgress(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetBulkOperationProgress(_response);
            throw _response;
        });
    }

    protected processGetBulkOperationProgress(response: any): ng.IPromise<BulkOperationProgress> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkOperationProgress.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = BulkOperationErrorResponse.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = BulkOperationErrorResponse.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<BulkOperationProgress>(null as any);
    }

    /**
     * Bulk fetch changelogs
     * @param body A JSON object containing the bulk fetch changelog request filters such as issue IDs and field IDs.
     * @return Returned if the request is successful.
     */
    getBulkChangelogs(body: BulkChangelogRequestBean): ng.IPromise<BulkChangelogResponseBean> {
        let url_ = this.baseUrl + "/rest/api/3/changelog/bulkfetch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetBulkChangelogs(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetBulkChangelogs(_response);
            throw _response;
        });
    }

    protected processGetBulkChangelogs(response: any): ng.IPromise<BulkChangelogResponseBean> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkChangelogResponseBean.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if there are input validation problems such as no issue IDs/keys were present, or more than 1000 issue IDs/keys were requested.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<BulkChangelogResponseBean>(null as any);
    }

    /**
     * Get all classification levels
     * @param status (optional) Optional set of statuses to filter by.
     * @param orderBy (optional) Ordering of the results by a given field. If not provided, values will not be sorted.
     * @return Returned if the request is successful.
     */
    getAllUserDataClassificationLevels(status?: Status2[] | undefined, orderBy?: OrderBy | undefined): ng.IPromise<DataClassificationLevelsBean> {
        let url_ = this.baseUrl + "/rest/api/3/classification-levels?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            status && status.forEach(item => { url_ += "status=" + encodeURIComponent("" + item) + "&"; });
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllUserDataClassificationLevels(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllUserDataClassificationLevels(_response);
            throw _response;
        });
    }

    protected processGetAllUserDataClassificationLevels(response: any): ng.IPromise<DataClassificationLevelsBean> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataClassificationLevelsBean.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<DataClassificationLevelsBean>(null as any);
    }

    /**
     * Get comments by IDs
     * @param body The list of comment IDs.
     * @param expand (optional) Use [expand](#expansion) to include additional information about comments in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `renderedBody` Returns the comment body rendered in HTML.
     *  `properties` Returns the comment's properties.
     * @return Returned if the request is successful.
     */
    getCommentsByIds(body: IssueCommentListRequestBean, expand?: string | undefined): ng.IPromise<PageBeanComment> {
        let url_ = this.baseUrl + "/rest/api/3/comment/list?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetCommentsByIds(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetCommentsByIds(_response);
            throw _response;
        });
    }

    protected processGetCommentsByIds(response: any): ng.IPromise<PageBeanComment> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanComment.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request contains more than 1000 IDs or is empty.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanComment>(null as any);
    }

    /**
     * Get comment property keys
     * @param commentId The ID of the comment.
     * @return Returned if the request is successful.
     */
    getCommentPropertyKeys(commentId: string): ng.IPromise<PropertyKeys> {
        let url_ = this.baseUrl + "/rest/api/3/comment/{commentId}/properties";
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetCommentPropertyKeys(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetCommentPropertyKeys(_response);
            throw _response;
        });
    }

    protected processGetCommentPropertyKeys(response: any): ng.IPromise<PropertyKeys> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyKeys.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the comment ID is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the comment is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PropertyKeys>(null as any);
    }

    /**
     * Delete comment property
     * @param commentId The ID of the comment.
     * @param propertyKey The key of the property.
     * @return Returned if the request is successful.
     */
    deleteCommentProperty(commentId: string, propertyKey: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/comment/{commentId}/properties/{propertyKey}";
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteCommentProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteCommentProperty(_response);
            throw _response;
        });
    }

    protected processDeleteCommentProperty(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the comment or the property is not found or the user has the necessary project permissions but isn\'t a member of the role or group visibility of the comment is restricted to.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get comment property
     * @param commentId The ID of the comment.
     * @param propertyKey The key of the property.
     * @return Returned if the request is successful.
     */
    getCommentProperty(commentId: string, propertyKey: string): ng.IPromise<EntityProperty> {
        let url_ = this.baseUrl + "/rest/api/3/comment/{commentId}/properties/{propertyKey}";
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetCommentProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetCommentProperty(_response);
            throw _response;
        });
    }

    protected processGetCommentProperty(response: any): ng.IPromise<EntityProperty> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityProperty.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the comment or the property is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<EntityProperty>(null as any);
    }

    /**
     * Set comment property
     * @param commentId The ID of the comment.
     * @param propertyKey The key of the property. The maximum length is 255 characters.
     * @param body The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes.
     * @return Returned if the comment property is updated.
     */
    setCommentProperty(commentId: string, propertyKey: string, body: any): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/comment/{commentId}/properties/{propertyKey}";
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetCommentProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetCommentProperty(_response);
            throw _response;
        });
    }

    protected processSetCommentProperty(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the comment is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Find components for projects
     * @param projectIdsOrKeys (optional) The project IDs and/or project keys (case sensitive).
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param orderBy (optional) [Order](#ordering) the results by a field:

     *  `description` Sorts by the component description.
     *  `name` Sorts by component name.
     * @param query (optional) Filter the results using a literal string. Components with a matching `name` or `description` are returned (case insensitive).
     * @return Returned if the request is successful.
     */
    findComponentsForProjects(projectIdsOrKeys?: string[] | undefined, startAt?: number | undefined, maxResults?: number | undefined, orderBy?: OrderBy2 | undefined, query?: string | undefined): ng.IPromise<PageBean2ComponentJsonBean> {
        let url_ = this.baseUrl + "/rest/api/3/component?";
        if (projectIdsOrKeys === null)
            throw new Error("The parameter 'projectIdsOrKeys' cannot be null.");
        else if (projectIdsOrKeys !== undefined)
            projectIdsOrKeys && projectIdsOrKeys.forEach(item => { url_ += "projectIdsOrKeys=" + encodeURIComponent("" + item) + "&"; });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processFindComponentsForProjects(_response);
        }, (_response) => {
            if (_response.status)
                return this.processFindComponentsForProjects(_response);
            throw _response;
        });
    }

    protected processFindComponentsForProjects(response: any): ng.IPromise<PageBean2ComponentJsonBean> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBean2ComponentJsonBean.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBean2ComponentJsonBean>(null as any);
    }

    /**
     * Create component
     * @return Returned if the request is successful.
     */
    createComponent(body: ProjectComponent): ng.IPromise<ProjectComponent> {
        let url_ = this.baseUrl + "/rest/api/3/component";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateComponent(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateComponent(_response);
            throw _response;
        });
    }

    protected processCreateComponent(response: any): ng.IPromise<ProjectComponent> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProjectComponent.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the user is not found.\n *  `name` is not provided.\n *  `name` is over 255 characters in length.\n *  `projectId` is not provided.\n *  `assigneeType` is an invalid value.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to manage the project containing the component or does not have permission to administer Jira.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user does not have permission to browse the project containing the component.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectComponent>(null as any);
    }

    /**
     * Delete component
     * @param id The ID of the component.
     * @param moveIssuesTo (optional) The ID of the component to replace the deleted component. If this value is null no replacement is made.
     * @return Returned if the request is successful.
     */
    deleteComponent(id: string, moveIssuesTo?: string | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/component/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (moveIssuesTo === null)
            throw new Error("The parameter 'moveIssuesTo' cannot be null.");
        else if (moveIssuesTo !== undefined)
            url_ += "moveIssuesTo=" + encodeURIComponent("" + moveIssuesTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteComponent(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteComponent(_response);
            throw _response;
        });
    }

    protected processDeleteComponent(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to manage the project containing the component or does not have permission to administer Jira.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the component is not found.\n *  the replacement component is not found.\n *  the user does not have permission to browse the project containing the component.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get component
     * @param id The ID of the component.
     * @return Returned if the request is successful.
     */
    getComponent(id: string): ng.IPromise<ProjectComponent> {
        let url_ = this.baseUrl + "/rest/api/3/component/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetComponent(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetComponent(_response);
            throw _response;
        });
    }

    protected processGetComponent(response: any): ng.IPromise<ProjectComponent> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectComponent.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the component is not found or the user does not have permission to browse the project containing the component.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectComponent>(null as any);
    }

    /**
     * Update component
     * @param id The ID of the component.
     * @return Returned if the request is successful.
     */
    updateComponent(id: string, body: ProjectComponent): ng.IPromise<ProjectComponent> {
        let url_ = this.baseUrl + "/rest/api/3/component/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateComponent(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateComponent(_response);
            throw _response;
        });
    }

    protected processUpdateComponent(response: any): ng.IPromise<ProjectComponent> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectComponent.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the user is not found.\n *  `assigneeType` is an invalid value.\n *  `name` is over 255 characters in length.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to manage the project containing the component or does not have permission to administer Jira.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the component is not found or the user does not have permission to browse the project containing the component.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectComponent>(null as any);
    }

    /**
     * Get component issues count
     * @param id The ID of the component.
     * @return Returned if the request is successful.
     */
    getComponentRelatedIssues(id: string): ng.IPromise<ComponentIssuesCount> {
        let url_ = this.baseUrl + "/rest/api/3/component/{id}/relatedIssueCounts";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetComponentRelatedIssues(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetComponentRelatedIssues(_response);
            throw _response;
        });
    }

    protected processGetComponentRelatedIssues(response: any): ng.IPromise<ComponentIssuesCount> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ComponentIssuesCount.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the component is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ComponentIssuesCount>(null as any);
    }

    /**
     * Get global settings
     * @return Returned if the request is successful.
     */
    getConfiguration(): ng.IPromise<Configuration> {
        let url_ = this.baseUrl + "/rest/api/3/configuration";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetConfiguration(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetConfiguration(_response);
            throw _response;
        });
    }

    protected processGetConfiguration(response: any): ng.IPromise<Configuration> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Configuration.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Configuration>(null as any);
    }

    /**
     * Get selected time tracking provider
     * @return Returned if the request is successful and time tracking is enabled.
     */
    getSelectedTimeTrackingImplementation(): ng.IPromise<TimeTrackingProvider> {
        let url_ = this.baseUrl + "/rest/api/3/configuration/timetracking";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetSelectedTimeTrackingImplementation(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetSelectedTimeTrackingImplementation(_response);
            throw _response;
        });
    }

    protected processGetSelectedTimeTrackingImplementation(response: any): ng.IPromise<TimeTrackingProvider> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TimeTrackingProvider.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return throwException(this.q, "Returned if the request is successful but time tracking is disabled.", status, _responseText, _headers, result204);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<TimeTrackingProvider>(null as any);
    }

    /**
     * Select time tracking provider
     * @return Returned if the request is successful.
     */
    selectTimeTrackingImplementation(body: TimeTrackingProvider): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/configuration/timetracking";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSelectTimeTrackingImplementation(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSelectTimeTrackingImplementation(_response);
            throw _response;
        });
    }

    protected processSelectTimeTrackingImplementation(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the time tracking provider is not found.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get all time tracking providers
     * @return Returned if the request is successful.
     */
    getAvailableTimeTrackingImplementations(): ng.IPromise<TimeTrackingProvider[]> {
        let url_ = this.baseUrl + "/rest/api/3/configuration/timetracking/list";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAvailableTimeTrackingImplementations(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAvailableTimeTrackingImplementations(_response);
            throw _response;
        });
    }

    protected processGetAvailableTimeTrackingImplementations(response: any): ng.IPromise<TimeTrackingProvider[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TimeTrackingProvider.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<TimeTrackingProvider[]>(null as any);
    }

    /**
     * Get time tracking settings
     * @return Returned if the request is successful.
     */
    getSharedTimeTrackingConfiguration(): ng.IPromise<TimeTrackingConfiguration> {
        let url_ = this.baseUrl + "/rest/api/3/configuration/timetracking/options";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetSharedTimeTrackingConfiguration(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetSharedTimeTrackingConfiguration(_response);
            throw _response;
        });
    }

    protected processGetSharedTimeTrackingConfiguration(response: any): ng.IPromise<TimeTrackingConfiguration> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TimeTrackingConfiguration.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<TimeTrackingConfiguration>(null as any);
    }

    /**
     * Set time tracking settings
     * @return Returned if the request is successful.
     */
    setSharedTimeTrackingConfiguration(body: TimeTrackingConfiguration): ng.IPromise<TimeTrackingConfiguration> {
        let url_ = this.baseUrl + "/rest/api/3/configuration/timetracking/options";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetSharedTimeTrackingConfiguration(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetSharedTimeTrackingConfiguration(_response);
            throw _response;
        });
    }

    protected processSetSharedTimeTrackingConfiguration(response: any): ng.IPromise<TimeTrackingConfiguration> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TimeTrackingConfiguration.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request object is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<TimeTrackingConfiguration>(null as any);
    }

    /**
     * Get custom field option
     * @param id The ID of the custom field option.
     * @return Returned if the request is successful.
     */
    getCustomFieldOption(id: string): ng.IPromise<CustomFieldOption> {
        let url_ = this.baseUrl + "/rest/api/3/customFieldOption/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetCustomFieldOption(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetCustomFieldOption(_response);
            throw _response;
        });
    }

    protected processGetCustomFieldOption(response: any): ng.IPromise<CustomFieldOption> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomFieldOption.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the custom field option is not found.\n *  the user does not have permission to view the custom field.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<CustomFieldOption>(null as any);
    }

    /**
     * Get all dashboards
     * @param filter (optional) The filter applied to the list of dashboards. Valid values are:

     *  `favourite` Returns dashboards the user has marked as favorite.
     *  `my` Returns dashboards owned by the user.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getAllDashboards(filter?: Filter2 | undefined, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageOfDashboards> {
        let url_ = this.baseUrl + "/rest/api/3/dashboard?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllDashboards(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllDashboards(_response);
            throw _response;
        });
    }

    protected processGetAllDashboards(response: any): ng.IPromise<PageOfDashboards> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfDashboards.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageOfDashboards>(null as any);
    }

    /**
     * Create dashboard
     * @param body Dashboard details.
     * @param extendAdminPermissions (optional) Whether admin level permissions are used. It should only be true if the user has *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg)
     * @return Returned if the request is successful.
     */
    createDashboard(body: DashboardDetails, extendAdminPermissions?: boolean | undefined): ng.IPromise<Dashboard> {
        let url_ = this.baseUrl + "/rest/api/3/dashboard?";
        if (extendAdminPermissions === null)
            throw new Error("The parameter 'extendAdminPermissions' cannot be null.");
        else if (extendAdminPermissions !== undefined)
            url_ += "extendAdminPermissions=" + encodeURIComponent("" + extendAdminPermissions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateDashboard(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateDashboard(_response);
            throw _response;
        });
    }

    protected processCreateDashboard(response: any): ng.IPromise<Dashboard> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Dashboard.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Dashboard>(null as any);
    }

    /**
     * Bulk edit dashboards
     * @param body The details of dashboards being updated in bulk.
     * @return Returned if the request is successful.
     */
    bulkEditDashboards(body: BulkEditShareableEntityRequest): ng.IPromise<BulkEditShareableEntityResponse> {
        let url_ = this.baseUrl + "/rest/api/3/dashboard/bulk/edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processBulkEditDashboards(_response);
        }, (_response) => {
            if (_response.status)
                return this.processBulkEditDashboards(_response);
            throw _response;
        });
    }

    protected processBulkEditDashboards(response: any): ng.IPromise<BulkEditShareableEntityResponse> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkEditShareableEntityResponse.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<BulkEditShareableEntityResponse>(null as any);
    }

    /**
     * Get available gadgets
     * @return Returned if the request is successful.
     */
    getAllAvailableDashboardGadgets(): ng.IPromise<AvailableDashboardGadgetsResponse> {
        let url_ = this.baseUrl + "/rest/api/3/dashboard/gadgets";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllAvailableDashboardGadgets(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllAvailableDashboardGadgets(_response);
            throw _response;
        });
    }

    protected processGetAllAvailableDashboardGadgets(response: any): ng.IPromise<AvailableDashboardGadgetsResponse> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AvailableDashboardGadgetsResponse.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "400 response", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<AvailableDashboardGadgetsResponse>(null as any);
    }

    /**
     * Search for dashboards
     * @param dashboardName (optional) String used to perform a case-insensitive partial match with `name`.
     * @param accountId (optional) User account ID used to return dashboards with the matching `owner.accountId`. This parameter cannot be used with the `owner` parameter.
     * @param owner (optional) This parameter is deprecated because of privacy changes. Use `accountId` instead. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. User name used to return dashboards with the matching `owner.name`. This parameter cannot be used with the `accountId` parameter.
     * @param groupname (optional) As a group's name can change, use of `groupId` is recommended. Group name used to return dashboards that are shared with a group that matches `sharePermissions.group.name`. This parameter cannot be used with the `groupId` parameter.
     * @param groupId (optional) Group ID used to return dashboards that are shared with a group that matches `sharePermissions.group.groupId`. This parameter cannot be used with the `groupname` parameter.
     * @param projectId (optional) Project ID used to returns dashboards that are shared with a project that matches `sharePermissions.project.id`.
     * @param orderBy (optional) [Order](#ordering) the results by a field:

     *  `description` Sorts by dashboard description. Note that this sort works independently of whether the expand to display the description field is in use.
     *  `favourite_count` Sorts by dashboard popularity.
     *  `id` Sorts by dashboard ID.
     *  `is_favourite` Sorts by whether the dashboard is marked as a favorite.
     *  `name` Sorts by dashboard name.
     *  `owner` Sorts by dashboard owner name.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param status (optional) The status to filter by. It may be active, archived or deleted.
     * @param expand (optional) Use [expand](#expansion) to include additional information about dashboard in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `description` Returns the description of the dashboard.
     *  `owner` Returns the owner of the dashboard.
     *  `viewUrl` Returns the URL that is used to view the dashboard.
     *  `favourite` Returns `isFavourite`, an indicator of whether the user has set the dashboard as a favorite.
     *  `favouritedCount` Returns `popularity`, a count of how many users have set this dashboard as a favorite.
     *  `sharePermissions` Returns details of the share permissions defined for the dashboard.
     *  `editPermissions` Returns details of the edit permissions defined for the dashboard.
     *  `isWritable` Returns whether the current user has permission to edit the dashboard.
     * @return Returned if the request is successful.
     */
    getDashboardsPaginated(dashboardName?: string | undefined, accountId?: string | undefined, owner?: string | undefined, groupname?: string | undefined, groupId?: string | undefined, projectId?: number | undefined, orderBy?: OrderBy3 | undefined, startAt?: number | undefined, maxResults?: number | undefined, status?: Status3 | undefined, expand?: string | undefined): ng.IPromise<PageBeanDashboard> {
        let url_ = this.baseUrl + "/rest/api/3/dashboard/search?";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "dashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (owner === null)
            throw new Error("The parameter 'owner' cannot be null.");
        else if (owner !== undefined)
            url_ += "owner=" + encodeURIComponent("" + owner) + "&";
        if (groupname === null)
            throw new Error("The parameter 'groupname' cannot be null.");
        else if (groupname !== undefined)
            url_ += "groupname=" + encodeURIComponent("" + groupname) + "&";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetDashboardsPaginated(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetDashboardsPaginated(_response);
            throw _response;
        });
    }

    protected processGetDashboardsPaginated(response: any): ng.IPromise<PageBeanDashboard> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanDashboard.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if:\n\n *  `orderBy` is invalid.\n *  `expand` includes an invalid value.\n *  `accountId` and `owner` are provided.\n *  `groupname` and `groupId` are provided.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "401 response", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanDashboard>(null as any);
    }

    /**
     * Get gadgets
     * @param dashboardId The ID of the dashboard.
     * @param moduleKey (optional) The list of gadgets module keys. To include multiple module keys, separate module keys with ampersand: `moduleKey=key:one&moduleKey=key:two`.
     * @param uri (optional) The list of gadgets URIs. To include multiple URIs, separate URIs with ampersand: `uri=/rest/example/uri/1&uri=/rest/example/uri/2`.
     * @param gadgetId (optional) The list of gadgets IDs. To include multiple IDs, separate IDs with ampersand: `gadgetId=10000&gadgetId=10001`.
     * @return Returned if the request is successful.
     */
    getAllGadgets(dashboardId: number, moduleKey?: string[] | undefined, uri?: string[] | undefined, gadgetId?: number[] | undefined): ng.IPromise<DashboardGadgetResponse> {
        let url_ = this.baseUrl + "/rest/api/3/dashboard/{dashboardId}/gadget?";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        if (moduleKey === null)
            throw new Error("The parameter 'moduleKey' cannot be null.");
        else if (moduleKey !== undefined)
            moduleKey && moduleKey.forEach(item => { url_ += "moduleKey=" + encodeURIComponent("" + item) + "&"; });
        if (uri === null)
            throw new Error("The parameter 'uri' cannot be null.");
        else if (uri !== undefined)
            uri && uri.forEach(item => { url_ += "uri=" + encodeURIComponent("" + item) + "&"; });
        if (gadgetId === null)
            throw new Error("The parameter 'gadgetId' cannot be null.");
        else if (gadgetId !== undefined)
            gadgetId && gadgetId.forEach(item => { url_ += "gadgetId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllGadgets(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllGadgets(_response);
            throw _response;
        });
    }

    protected processGetAllGadgets(response: any): ng.IPromise<DashboardGadgetResponse> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardGadgetResponse.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the dashboard is not found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<DashboardGadgetResponse>(null as any);
    }

    /**
     * Add gadget to dashboard
     * @param dashboardId The ID of the dashboard.
     * @return Returned if the request is successful.
     */
    addGadget(dashboardId: number, body: DashboardGadgetSettings): ng.IPromise<DashboardGadget> {
        let url_ = this.baseUrl + "/rest/api/3/dashboard/{dashboardId}/gadget";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddGadget(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddGadget(_response);
            throw _response;
        });
    }

    protected processAddGadget(response: any): ng.IPromise<DashboardGadget> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardGadget.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the dashboard is not found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<DashboardGadget>(null as any);
    }

    /**
     * Remove gadget from dashboard
     * @param dashboardId The ID of the dashboard.
     * @param gadgetId The ID of the gadget.
     * @return Returned if the request is successful.
     */
    removeGadget(dashboardId: number, gadgetId: number): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/dashboard/{dashboardId}/gadget/{gadgetId}";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        if (gadgetId === undefined || gadgetId === null)
            throw new Error("The parameter 'gadgetId' must be defined.");
        url_ = url_.replace("{gadgetId}", encodeURIComponent("" + gadgetId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveGadget(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveGadget(_response);
            throw _response;
        });
    }

    protected processRemoveGadget(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the gadget or the dashboard is not found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Update gadget on dashboard
     * @param dashboardId The ID of the dashboard.
     * @param gadgetId The ID of the gadget.
     * @return Returned if the request is successful.
     */
    updateGadget(dashboardId: number, gadgetId: number, body: DashboardGadgetUpdateRequest): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/dashboard/{dashboardId}/gadget/{gadgetId}";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        if (gadgetId === undefined || gadgetId === null)
            throw new Error("The parameter 'gadgetId' must be defined.");
        url_ = url_.replace("{gadgetId}", encodeURIComponent("" + gadgetId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateGadget(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateGadget(_response);
            throw _response;
        });
    }

    protected processUpdateGadget(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the gadget or the dashboard is not found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get dashboard item property keys
     * @param dashboardId The ID of the dashboard.
     * @param itemId The ID of the dashboard item.
     * @return Returned if the request is successful.
     */
    getDashboardItemPropertyKeys(dashboardId: string, itemId: string): ng.IPromise<PropertyKeys> {
        let url_ = this.baseUrl + "/rest/api/3/dashboard/{dashboardId}/items/{itemId}/properties";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetDashboardItemPropertyKeys(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetDashboardItemPropertyKeys(_response);
            throw _response;
        });
    }

    protected processGetDashboardItemPropertyKeys(response: any): ng.IPromise<PropertyKeys> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyKeys.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the dashboard or dashboard item is not found, or the dashboard is not owned by or shared with the user.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PropertyKeys>(null as any);
    }

    /**
     * Delete dashboard item property
     * @param dashboardId The ID of the dashboard.
     * @param itemId The ID of the dashboard item.
     * @param propertyKey The key of the dashboard item property.
     * @return Returned if the dashboard item property is deleted.
     */
    deleteDashboardItemProperty(dashboardId: string, itemId: string, propertyKey: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteDashboardItemProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteDashboardItemProperty(_response);
            throw _response;
        });
    }

    protected processDeleteDashboardItemProperty(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the dashboard or dashboard item ID is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user is not the owner of the dashboard.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the dashboard item is not found or the dashboard is not shared with the user.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get dashboard item property
     * @param dashboardId The ID of the dashboard.
     * @param itemId The ID of the dashboard item.
     * @param propertyKey The key of the dashboard item property.
     * @return Returned if the request is successful.
     */
    getDashboardItemProperty(dashboardId: string, itemId: string, propertyKey: string): ng.IPromise<EntityProperty> {
        let url_ = this.baseUrl + "/rest/api/3/dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetDashboardItemProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetDashboardItemProperty(_response);
            throw _response;
        });
    }

    protected processGetDashboardItemProperty(response: any): ng.IPromise<EntityProperty> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityProperty.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the dashboard, the dashboard item, or dashboard item property is not found, or the dashboard is not owned by or shared with the user.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<EntityProperty>(null as any);
    }

    /**
     * Set dashboard item property
     * @param dashboardId The ID of the dashboard.
     * @param itemId The ID of the dashboard item.
     * @param propertyKey The key of the dashboard item property. The maximum length is 255 characters. For dashboard items with a spec URI and no complete module key, if the provided propertyKey is equal to "config", the request body's JSON must be an object with all keys and values as strings.
     * @param body The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes.
     * @return Returned if the dashboard item property is updated.
     */
    setDashboardItemProperty(dashboardId: string, itemId: string, propertyKey: string, body: any): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/dashboard/{dashboardId}/items/{itemId}/properties/{propertyKey}";
        if (dashboardId === undefined || dashboardId === null)
            throw new Error("The parameter 'dashboardId' must be defined.");
        url_ = url_.replace("{dashboardId}", encodeURIComponent("" + dashboardId));
        if (itemId === undefined || itemId === null)
            throw new Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetDashboardItemProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetDashboardItemProperty(_response);
            throw _response;
        });
    }

    protected processSetDashboardItemProperty(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if:\n\n *  Request is invalid\n *  Or if all of these conditions are met in the request:\n    \n     *  The dashboard item has a spec URI and no complete module key\n     *  The value of propertyKey is equal to \"config\"\n     *  The request body contains a JSON object whose keys and values are not strings.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user is not the owner of the dashboard.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the dashboard item is not found or the dashboard is not shared with the user.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Delete dashboard
     * @param id The ID of the dashboard.
     * @return Returned if the dashboard is deleted.
     */
    deleteDashboard(id: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/dashboard/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteDashboard(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteDashboard(_response);
            throw _response;
        });
    }

    protected processDeleteDashboard(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "400 response", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get dashboard
     * @param id The ID of the dashboard.
     * @return Returned if the request is successful.
     */
    getDashboard(id: string): ng.IPromise<Dashboard> {
        let url_ = this.baseUrl + "/rest/api/3/dashboard/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetDashboard(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetDashboard(_response);
            throw _response;
        });
    }

    protected processGetDashboard(response: any): ng.IPromise<Dashboard> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Dashboard.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "400 response", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the dashboard is not found or the dashboard is not owned by or shared with the user.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Dashboard>(null as any);
    }

    /**
     * Update dashboard
     * @param id The ID of the dashboard to update.
     * @param body Replacement dashboard details.
     * @param extendAdminPermissions (optional) Whether admin level permissions are used. It should only be true if the user has *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg)
     * @return Returned if the request is successful.
     */
    updateDashboard(id: string, body: DashboardDetails, extendAdminPermissions?: boolean | undefined): ng.IPromise<Dashboard> {
        let url_ = this.baseUrl + "/rest/api/3/dashboard/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (extendAdminPermissions === null)
            throw new Error("The parameter 'extendAdminPermissions' cannot be null.");
        else if (extendAdminPermissions !== undefined)
            url_ += "extendAdminPermissions=" + encodeURIComponent("" + extendAdminPermissions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateDashboard(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateDashboard(_response);
            throw _response;
        });
    }

    protected processUpdateDashboard(response: any): ng.IPromise<Dashboard> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Dashboard.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the dashboard is not found or the dashboard is not owned by the user.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Dashboard>(null as any);
    }

    /**
     * Copy dashboard
     * @param body Dashboard details.
     * @param extendAdminPermissions (optional) Whether admin level permissions are used. It should only be true if the user has *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg)
     * @return Returned if the request is successful.
     */
    copyDashboard(id: string, body: DashboardDetails, extendAdminPermissions?: boolean | undefined): ng.IPromise<Dashboard> {
        let url_ = this.baseUrl + "/rest/api/3/dashboard/{id}/copy?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (extendAdminPermissions === null)
            throw new Error("The parameter 'extendAdminPermissions' cannot be null.");
        else if (extendAdminPermissions !== undefined)
            url_ += "extendAdminPermissions=" + encodeURIComponent("" + extendAdminPermissions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCopyDashboard(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCopyDashboard(_response);
            throw _response;
        });
    }

    protected processCopyDashboard(response: any): ng.IPromise<Dashboard> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Dashboard.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the dashboard is not found or the dashboard is not owned by or shared with the user.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Dashboard>(null as any);
    }

    /**
     * Get data policy for the workspace
     * @return Returned if the request is successful
     */
    getPolicy(): ng.IPromise<WorkspaceDataPolicy> {
        let url_ = this.baseUrl + "/rest/api/3/data-policy";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetPolicy(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetPolicy(_response);
            throw _response;
        });
    }

    protected processGetPolicy(response: any): ng.IPromise<WorkspaceDataPolicy> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkspaceDataPolicy.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the client is not authorized to make the request.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkspaceDataPolicy>(null as any);
    }

    /**
     * Get data policy for projects
     * @param ids (optional) A list of project identifiers. This parameter accepts a comma-separated list.
     * @return Returned if the request is successful.
     */
    getPolicies(ids?: string | undefined): ng.IPromise<ProjectDataPolicies> {
        let url_ = this.baseUrl + "/rest/api/3/data-policy/project?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            url_ += "ids=" + encodeURIComponent("" + ids) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetPolicies(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetPolicies(_response);
            throw _response;
        });
    }

    protected processGetPolicies(response: any): ng.IPromise<ProjectDataPolicies> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectDataPolicies.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is not valid or includes invalid or not-permitted project identifiers.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the client is not authorized to make the request.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectDataPolicies>(null as any);
    }

    /**
     * Get events
     * @return Returned if the request is successful.
     */
    getEvents(): ng.IPromise<IssueEvent[]> {
        let url_ = this.baseUrl + "/rest/api/3/events";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetEvents(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetEvents(_response);
            throw _response;
        });
    }

    protected processGetEvents(response: any): ng.IPromise<IssueEvent[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IssueEvent.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to complete this request.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueEvent[]>(null as any);
    }

    /**
     * Analyse Jira expression
     * @param body The Jira expressions to analyse.
     * @param check (optional) The check to perform:

     *  `syntax` Each expression's syntax is checked to ensure the expression can be parsed. Also, syntactic limits are validated. For example, the expression's length.
     *  `type` EXPERIMENTAL. Each expression is type checked and the final type of the expression inferred. Any type errors that would result in the expression failure at runtime are reported. For example, accessing properties that don't exist or passing the wrong number of arguments to functions. Also performs the syntax check.
     *  `complexity` EXPERIMENTAL. Determines the formulae for how many [expensive operations](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#expensive-operations) each expression may execute.
     * @return Returned if the request is successful.
     */
    analyseExpression(body: JiraExpressionForAnalysis, check?: Check | undefined): ng.IPromise<JiraExpressionsAnalysis> {
        let url_ = this.baseUrl + "/rest/api/3/expression/analyse?";
        if (check === null)
            throw new Error("The parameter 'check' cannot be null.");
        else if (check !== undefined)
            url_ += "check=" + encodeURIComponent("" + check) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAnalyseExpression(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAnalyseExpression(_response);
            throw _response;
        });
    }

    protected processAnalyseExpression(response: any): ng.IPromise<JiraExpressionsAnalysis> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JiraExpressionsAnalysis.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "400 response", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "404 response", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<JiraExpressionsAnalysis>(null as any);
    }

    /**
     * Evaluate Jira expression
     * @param body The Jira expression and the evaluation context.
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts `meta.complexity` that returns information about the expression complexity. For example, the number of expensive operations used by the expression and how close the expression is to reaching the [complexity limit](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#restrictions). Useful when designing and debugging your expressions.
     * @return Returned if the evaluation results in a value. The result is a JSON primitive value, list, or object.
     * @deprecated
     */
    evaluateJiraExpression(body: JiraExpressionEvalRequestBean, expand?: string | undefined): ng.IPromise<JiraExpressionResult> {
        let url_ = this.baseUrl + "/rest/api/3/expression/eval?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processEvaluateJiraExpression(_response);
        }, (_response) => {
            if (_response.status)
                return this.processEvaluateJiraExpression(_response);
            throw _response;
        });
    }

    protected processEvaluateJiraExpression(response: any): ng.IPromise<JiraExpressionResult> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JiraExpressionResult.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if:\n\n *  the request is invalid, that is:\n    \n     *  invalid data is provided, such as a request including issue ID and key.\n     *  the expression is invalid and can not be parsed.\n *  evaluation fails at runtime. This may happen for various reasons. For example, accessing a property on a null object (such as the expression `issue.id` where `issue` is `null`). In this case an error message is provided.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if any object provided in the request context is not found or the user does not have permission to view it.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<JiraExpressionResult>(null as any);
    }

    /**
     * Evaluate Jira expression using enhanced search API
     * @param body The Jira expression and the evaluation context.
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts `meta.complexity` that returns information about the expression complexity. For example, the number of expensive operations used by the expression and how close the expression is to reaching the [complexity limit](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#restrictions). Useful when designing and debugging your expressions.
     * @return Returned if the evaluation results in a value. The result is a JSON primitive value, list, or object.
     */
    evaluateJSISJiraExpression(body: JiraExpressionEvaluateRequestBean, expand?: string | undefined): ng.IPromise<JExpEvaluateJiraExpressionResultBean> {
        let url_ = this.baseUrl + "/rest/api/3/expression/evaluate?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processEvaluateJSISJiraExpression(_response);
        }, (_response) => {
            if (_response.status)
                return this.processEvaluateJSISJiraExpression(_response);
            throw _response;
        });
    }

    protected processEvaluateJSISJiraExpression(response: any): ng.IPromise<JExpEvaluateJiraExpressionResultBean> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JExpEvaluateJiraExpressionResultBean.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if:\n\n *  the request is invalid, that is:\n    \n     *  invalid data is provided, such as a request including issue ID and key.\n     *  the expression is invalid and can not be parsed.\n *  evaluation fails at runtime. This may happen for various reasons. For example, accessing a property on a null object (such as the expression `issue.id` where `issue` is `null`). In this case an error message is provided.\n *  If jql is unbounded or empty.\n *  If nextPageToken is invalid", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if any object provided in the request context is not found or the user does not have permission to view it.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<JExpEvaluateJiraExpressionResultBean>(null as any);
    }

    /**
     * Get fields
     * @return Returned if the request is successful.
     */
    getFields(): ng.IPromise<FieldDetails[]> {
        let url_ = this.baseUrl + "/rest/api/3/field";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetFields(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetFields(_response);
            throw _response;
        });
    }

    protected processGetFields(response: any): ng.IPromise<FieldDetails[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FieldDetails.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<FieldDetails[]>(null as any);
    }

    /**
     * Create custom field
     * @param body Definition of the custom field to be created
     * @return Returned if the custom field is created.
     */
    createCustomField(body: CustomFieldDefinitionJsonBean): ng.IPromise<FieldDetails> {
        let url_ = this.baseUrl + "/rest/api/3/field";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateCustomField(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateCustomField(_response);
            throw _response;
        });
    }

    protected processCreateCustomField(response: any): ng.IPromise<FieldDetails> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = FieldDetails.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the user does not have permission to create custom fields.\n *  any of the request object properties have invalid or missing values.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<FieldDetails>(null as any);
    }

    /**
     * Remove associations
     * @param body Payload containing the fields to uassociate and the projects and issue types to unassociate them to.
     * @return Returned if the field association validation passes.
     */
    removeAssociations(body: FieldAssociationsRequest): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/field/association";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveAssociations(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveAssociations(_response);
            throw _response;
        });
    }

    protected processRemoveAssociations(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field, project, or issue type is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Create associations
     * @param body Payload containing the fields to associate and the projects to associate them to.
     * @return Returned if the field association validation passes.
     */
    createAssociations(body: FieldAssociationsRequest): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/field/association";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateAssociations(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateAssociations(_response);
            throw _response;
        });
    }

    protected processCreateAssociations(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field, project, or issue type is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get fields paginated
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param type (optional) The type of fields to search.
     * @param id (optional) The IDs of the custom fields to return or, where `query` is specified, filter.
     * @param query (optional) String used to perform a case-insensitive partial match with field names or descriptions.
     * @param orderBy (optional) [Order](#ordering) the results by:

     *  `contextsCount` sorts by the number of contexts related to a field
     *  `lastUsed` sorts by the date when the value of the field last changed
     *  `name` sorts by the field name
     *  `screensCount` sorts by the number of screens related to a field
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `key` returns the key for each field
     *  `stableId` returns the stableId for each field
     *  `lastUsed` returns the date when the value of the field last changed
     *  `screensCount` returns the number of screens related to a field
     *  `contextsCount` returns the number of contexts related to a field
     *  `isLocked` returns information about whether the field is locked
     *  `searcherKey` returns the searcher key for each custom field
     * @param projectIds (optional) 
     * @return Returned if the request is successful.
     */
    getFieldsPaginated(startAt?: number | undefined, maxResults?: number | undefined, type?: Type2[] | undefined, id?: string[] | undefined, query?: string | undefined, orderBy?: OrderBy4 | undefined, expand?: string | undefined, projectIds?: number[] | undefined): ng.IPromise<PageBeanField> {
        let url_ = this.baseUrl + "/rest/api/3/field/search?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            type && type.forEach(item => { url_ += "type=" + encodeURIComponent("" + item) + "&"; });
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (projectIds === null)
            throw new Error("The parameter 'projectIds' cannot be null.");
        else if (projectIds !== undefined)
            projectIds && projectIds.forEach(item => { url_ += "projectIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetFieldsPaginated(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetFieldsPaginated(_response);
            throw _response;
        });
    }

    protected processGetFieldsPaginated(response: any): ng.IPromise<PageBeanField> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanField.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanField>(null as any);
    }

    /**
     * Get fields in trash paginated
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param id (optional) 
     * @param query (optional) String used to perform a case-insensitive partial match with field names or descriptions.
     * @param expand (optional) 
     * @param orderBy (optional) [Order](#ordering) the results by a field:

     *  `name` sorts by the field name
     *  `trashDate` sorts by the date the field was moved to the trash
     *  `plannedDeletionDate` sorts by the planned deletion date
     * @return Returned if the request is successful.
     */
    getTrashedFieldsPaginated(startAt?: number | undefined, maxResults?: number | undefined, id?: string[] | undefined, query?: string | undefined, expand?: Expand | undefined, orderBy?: string | undefined): ng.IPromise<PageBeanField> {
        let url_ = this.baseUrl + "/rest/api/3/field/search/trashed?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetTrashedFieldsPaginated(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetTrashedFieldsPaginated(_response);
            throw _response;
        });
    }

    protected processGetTrashedFieldsPaginated(response: any): ng.IPromise<PageBeanField> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanField.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanField>(null as any);
    }

    /**
     * Update custom field
     * @param fieldId The ID of the custom field.
     * @param body The custom field update details.
     * @return Returned if the request is successful.
     */
    updateCustomField(fieldId: string, body: UpdateCustomFieldDetails): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateCustomField(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateCustomField(_response);
            throw _response;
        });
    }

    protected processUpdateCustomField(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the custom field is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get custom field contexts
     * @param fieldId The ID of the custom field.
     * @param isAnyIssueType (optional) Whether to return contexts that apply to all issue types.
     * @param isGlobalContext (optional) Whether to return contexts that apply to all projects.
     * @param contextId (optional) The list of context IDs. To include multiple contexts, separate IDs with ampersand: `contextId=10000&contextId=10001`.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getContextsForField(fieldId: string, isAnyIssueType?: boolean | undefined, isGlobalContext?: boolean | undefined, contextId?: number[] | undefined, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanCustomFieldContext> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context?";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (isAnyIssueType === null)
            throw new Error("The parameter 'isAnyIssueType' cannot be null.");
        else if (isAnyIssueType !== undefined)
            url_ += "isAnyIssueType=" + encodeURIComponent("" + isAnyIssueType) + "&";
        if (isGlobalContext === null)
            throw new Error("The parameter 'isGlobalContext' cannot be null.");
        else if (isGlobalContext !== undefined)
            url_ += "isGlobalContext=" + encodeURIComponent("" + isGlobalContext) + "&";
        if (contextId === null)
            throw new Error("The parameter 'contextId' cannot be null.");
        else if (contextId !== undefined)
            contextId && contextId.forEach(item => { url_ += "contextId=" + encodeURIComponent("" + item) + "&"; });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetContextsForField(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetContextsForField(_response);
            throw _response;
        });
    }

    protected processGetContextsForField(response: any): ng.IPromise<PageBeanCustomFieldContext> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanCustomFieldContext.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the custom field was not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanCustomFieldContext>(null as any);
    }

    /**
     * Create custom field context
     * @param fieldId The ID of the custom field.
     * @return Returned if the custom field context is created.
     */
    createCustomFieldContext(fieldId: string, body: CreateCustomFieldContext): ng.IPromise<CreateCustomFieldContext> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateCustomFieldContext(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateCustomFieldContext(_response);
            throw _response;
        });
    }

    protected processCreateCustomFieldContext(response: any): ng.IPromise<CreateCustomFieldContext> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreateCustomFieldContext.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field, project, or issue type is not found.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type is a sub-task, but sub-tasks are disabled in Jira settings.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<CreateCustomFieldContext>(null as any);
    }

    /**
     * Get custom field contexts default values
     * @param fieldId The ID of the custom field, for example `customfield\_10000`.
     * @param contextId (optional) The IDs of the contexts.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getDefaultValues(fieldId: string, contextId?: number[] | undefined, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanCustomFieldContextDefaultValue> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context/defaultValue?";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (contextId === null)
            throw new Error("The parameter 'contextId' cannot be null.");
        else if (contextId !== undefined)
            contextId && contextId.forEach(item => { url_ += "contextId=" + encodeURIComponent("" + item) + "&"; });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetDefaultValues(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetDefaultValues(_response);
            throw _response;
        });
    }

    protected processGetDefaultValues(response: any): ng.IPromise<PageBeanCustomFieldContextDefaultValue> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanCustomFieldContextDefaultValue.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the custom field is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanCustomFieldContextDefaultValue>(null as any);
    }

    /**
     * Set custom field contexts default values
     * @param fieldId The ID of the custom field.
     * @return Returned if operation is successful.
     */
    setDefaultValues(fieldId: string, body: CustomFieldContextDefaultValueUpdate): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context/defaultValue";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetDefaultValues(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetDefaultValues(_response);
            throw _response;
        });
    }

    protected processSetDefaultValues(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the custom field, a context, an option, or a cascading option is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get issue types for custom field context
     * @param fieldId The ID of the custom field.
     * @param contextId (optional) The ID of the context. To include multiple contexts, provide an ampersand-separated list. For example, `contextId=10001&contextId=10002`.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if operation is successful.
     */
    getIssueTypeMappingsForContexts(fieldId: string, contextId?: number[] | undefined, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanIssueTypeToContextMapping> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context/issuetypemapping?";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (contextId === null)
            throw new Error("The parameter 'contextId' cannot be null.");
        else if (contextId !== undefined)
            contextId && contextId.forEach(item => { url_ += "contextId=" + encodeURIComponent("" + item) + "&"; });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueTypeMappingsForContexts(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueTypeMappingsForContexts(_response);
            throw _response;
        });
    }

    protected processGetIssueTypeMappingsForContexts(response: any): ng.IPromise<PageBeanIssueTypeToContextMapping> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanIssueTypeToContextMapping.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanIssueTypeToContextMapping>(null as any);
    }

    /**
     * Get custom field contexts for projects and issue types
     * @param fieldId The ID of the custom field.
     * @param body The list of project and issue type mappings.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getCustomFieldContextsForProjectsAndIssueTypes(fieldId: string, body: ProjectIssueTypeMappings, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanContextForProjectAndIssueType> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context/mapping?";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetCustomFieldContextsForProjectsAndIssueTypes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetCustomFieldContextsForProjectsAndIssueTypes(_response);
            throw _response;
        });
    }

    protected processGetCustomFieldContextsForProjectsAndIssueTypes(response: any): ng.IPromise<PageBeanContextForProjectAndIssueType> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanContextForProjectAndIssueType.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the custom field, project, or issue type is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanContextForProjectAndIssueType>(null as any);
    }

    /**
     * Get project mappings for custom field context
     * @param fieldId The ID of the custom field, for example `customfield\_10000`.
     * @param contextId (optional) The list of context IDs. To include multiple context, separate IDs with ampersand: `contextId=10000&contextId=10001`.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getProjectContextMapping(fieldId: string, contextId?: number[] | undefined, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanCustomFieldContextProjectMapping> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context/projectmapping?";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (contextId === null)
            throw new Error("The parameter 'contextId' cannot be null.");
        else if (contextId !== undefined)
            contextId && contextId.forEach(item => { url_ += "contextId=" + encodeURIComponent("" + item) + "&"; });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectContextMapping(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectContextMapping(_response);
            throw _response;
        });
    }

    protected processGetProjectContextMapping(response: any): ng.IPromise<PageBeanCustomFieldContextProjectMapping> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanCustomFieldContextProjectMapping.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the custom field is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanCustomFieldContextProjectMapping>(null as any);
    }

    /**
     * Delete custom field context
     * @param fieldId The ID of the custom field.
     * @param contextId The ID of the context.
     * @return Returned if the context is deleted.
     */
    deleteCustomFieldContext(fieldId: string, contextId: number): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context/{contextId}";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (contextId === undefined || contextId === null)
            throw new Error("The parameter 'contextId' must be defined.");
        url_ = url_.replace("{contextId}", encodeURIComponent("" + contextId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteCustomFieldContext(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteCustomFieldContext(_response);
            throw _response;
        });
    }

    protected processDeleteCustomFieldContext(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the custom field or the context is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Update custom field context
     * @param fieldId The ID of the custom field.
     * @param contextId The ID of the context.
     * @return Returned if the context is updated.
     */
    updateCustomFieldContext(fieldId: string, contextId: number, body: CustomFieldContextUpdateDetails): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context/{contextId}";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (contextId === undefined || contextId === null)
            throw new Error("The parameter 'contextId' must be defined.");
        url_ = url_.replace("{contextId}", encodeURIComponent("" + contextId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateCustomFieldContext(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateCustomFieldContext(_response);
            throw _response;
        });
    }

    protected processUpdateCustomFieldContext(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the custom field or the context is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Add issue types to context
     * @param fieldId The ID of the custom field.
     * @param contextId The ID of the context.
     * @return Returned if operation is successful.
     */
    addIssueTypesToContext(fieldId: string, contextId: number, body: IssueTypeIds): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context/{contextId}/issuetype";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (contextId === undefined || contextId === null)
            throw new Error("The parameter 'contextId' must be defined.");
        url_ = url_.replace("{contextId}", encodeURIComponent("" + contextId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddIssueTypesToContext(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddIssueTypesToContext(_response);
            throw _response;
        });
    }

    protected processAddIssueTypesToContext(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the custom field, context, or one or more issue types are not found.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type is a sub-task, but sub-tasks are disabled in Jira settings.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Remove issue types from context
     * @param fieldId The ID of the custom field.
     * @param contextId The ID of the context.
     * @return Returned if operation is successful.
     */
    removeIssueTypesFromContext(fieldId: string, contextId: number, body: IssueTypeIds): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context/{contextId}/issuetype/remove";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (contextId === undefined || contextId === null)
            throw new Error("The parameter 'contextId' must be defined.");
        url_ = url_.replace("{contextId}", encodeURIComponent("" + contextId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveIssueTypesFromContext(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveIssueTypesFromContext(_response);
            throw _response;
        });
    }

    protected processRemoveIssueTypesFromContext(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the custom field, context, or one or more issue types are not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get custom field options (context)
     * @param fieldId The ID of the custom field.
     * @param contextId The ID of the context.
     * @param optionId (optional) The ID of the option.
     * @param onlyOptions (optional) Whether only options are returned.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getOptionsForContext(fieldId: string, contextId: number, optionId?: number | undefined, onlyOptions?: boolean | undefined, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanCustomFieldContextOption> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context/{contextId}/option?";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (contextId === undefined || contextId === null)
            throw new Error("The parameter 'contextId' must be defined.");
        url_ = url_.replace("{contextId}", encodeURIComponent("" + contextId));
        if (optionId === null)
            throw new Error("The parameter 'optionId' cannot be null.");
        else if (optionId !== undefined)
            url_ += "optionId=" + encodeURIComponent("" + optionId) + "&";
        if (onlyOptions === null)
            throw new Error("The parameter 'onlyOptions' cannot be null.");
        else if (onlyOptions !== undefined)
            url_ += "onlyOptions=" + encodeURIComponent("" + onlyOptions) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetOptionsForContext(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetOptionsForContext(_response);
            throw _response;
        });
    }

    protected processGetOptionsForContext(response: any): ng.IPromise<PageBeanCustomFieldContextOption> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanCustomFieldContextOption.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the custom field is not found or the context doesn\'t match the custom field.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanCustomFieldContextOption>(null as any);
    }

    /**
     * Create custom field options (context)
     * @param fieldId The ID of the custom field.
     * @param contextId The ID of the context.
     * @return Returned if the request is successful.
     */
    createCustomFieldOption(fieldId: string, contextId: number, body: BulkCustomFieldOptionCreateRequest): ng.IPromise<CustomFieldCreatedContextOptionsList> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context/{contextId}/option";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (contextId === undefined || contextId === null)
            throw new Error("The parameter 'contextId' must be defined.");
        url_ = url_.replace("{contextId}", encodeURIComponent("" + contextId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateCustomFieldOption(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateCustomFieldOption(_response);
            throw _response;
        });
    }

    protected processCreateCustomFieldOption(response: any): ng.IPromise<CustomFieldCreatedContextOptionsList> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomFieldCreatedContextOptionsList.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the custom field is not found or the context doesn\'t match the custom field.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<CustomFieldCreatedContextOptionsList>(null as any);
    }

    /**
     * Update custom field options (context)
     * @param fieldId The ID of the custom field.
     * @param contextId The ID of the context.
     * @return Returned if the request is successful.
     */
    updateCustomFieldOption(fieldId: string, contextId: number, body: BulkCustomFieldOptionUpdateRequest): ng.IPromise<CustomFieldUpdatedContextOptionsList> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context/{contextId}/option";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (contextId === undefined || contextId === null)
            throw new Error("The parameter 'contextId' must be defined.");
        url_ = url_.replace("{contextId}", encodeURIComponent("" + contextId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateCustomFieldOption(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateCustomFieldOption(_response);
            throw _response;
        });
    }

    protected processUpdateCustomFieldOption(response: any): ng.IPromise<CustomFieldUpdatedContextOptionsList> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomFieldUpdatedContextOptionsList.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field, context, or one or more options is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<CustomFieldUpdatedContextOptionsList>(null as any);
    }

    /**
     * Reorder custom field options (context)
     * @param fieldId The ID of the custom field.
     * @param contextId The ID of the context.
     * @return Returned if options are reordered.
     */
    reorderCustomFieldOptions(fieldId: string, contextId: number, body: OrderOfCustomFieldOptions): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context/{contextId}/option/move";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (contextId === undefined || contextId === null)
            throw new Error("The parameter 'contextId' must be defined.");
        url_ = url_.replace("{contextId}", encodeURIComponent("" + contextId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processReorderCustomFieldOptions(_response);
        }, (_response) => {
            if (_response.status)
                return this.processReorderCustomFieldOptions(_response);
            throw _response;
        });
    }

    protected processReorderCustomFieldOptions(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field, the context, or one or more of the options is not found..", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Delete custom field options (context)
     * @param fieldId The ID of the custom field.
     * @param contextId The ID of the context from which an option should be deleted.
     * @param optionId The ID of the option to delete.
     * @return Returned if the option is deleted.
     */
    deleteCustomFieldOption(fieldId: string, contextId: number, optionId: number): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context/{contextId}/option/{optionId}";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (contextId === undefined || contextId === null)
            throw new Error("The parameter 'contextId' must be defined.");
        url_ = url_.replace("{contextId}", encodeURIComponent("" + contextId));
        if (optionId === undefined || optionId === null)
            throw new Error("The parameter 'optionId' must be defined.");
        url_ = url_.replace("{optionId}", encodeURIComponent("" + optionId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteCustomFieldOption(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteCustomFieldOption(_response);
            throw _response;
        });
    }

    protected processDeleteCustomFieldOption(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field, the context, or the option is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Replace custom field options
     * @param fieldId The ID of the custom field.
     * @param optionId The ID of the option to be deselected.
     * @param contextId The ID of the context.
     * @param replaceWith (optional) The ID of the option that will replace the currently selected option.
     * @param jql (optional) A JQL query that specifies the issues to be updated. For example, *project=10000*.
     */
    replaceCustomFieldOption(fieldId: string, optionId: number, contextId: number, replaceWith?: number | undefined, jql?: string | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context/{contextId}/option/{optionId}/issue?";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (optionId === undefined || optionId === null)
            throw new Error("The parameter 'optionId' must be defined.");
        url_ = url_.replace("{optionId}", encodeURIComponent("" + optionId));
        if (contextId === undefined || contextId === null)
            throw new Error("The parameter 'contextId' must be defined.");
        url_ = url_.replace("{contextId}", encodeURIComponent("" + contextId));
        if (replaceWith === null)
            throw new Error("The parameter 'replaceWith' cannot be null.");
        else if (replaceWith !== undefined)
            url_ += "replaceWith=" + encodeURIComponent("" + replaceWith) + "&";
        if (jql === null)
            throw new Error("The parameter 'jql' cannot be null.");
        else if (jql !== undefined)
            url_ += "jql=" + encodeURIComponent("" + jql) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processReplaceCustomFieldOption(_response);
        }, (_response) => {
            if (_response.status)
                return this.processReplaceCustomFieldOption(_response);
            throw _response;
        });
    }

    protected processReplaceCustomFieldOption(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 303) {
            const _responseText = response.data;
            let result303: any = null;
            let resultData303 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result303 = TaskProgressBeanRemoveOptionFromIssuesResult.fromJS(resultData303);
            return throwException(this.q, "Returned if the long-running task to deselect the option is started.", status, _responseText, _headers, result303);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field is not found or does not support options, or the options to be replaced are not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Assign custom field context to projects
     * @param fieldId The ID of the custom field.
     * @param contextId The ID of the context.
     * @return Returned if operation is successful.
     */
    assignProjectsToCustomFieldContext(fieldId: string, contextId: number, body: ProjectIds): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context/{contextId}/project";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (contextId === undefined || contextId === null)
            throw new Error("The parameter 'contextId' must be defined.");
        url_ = url_.replace("{contextId}", encodeURIComponent("" + contextId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAssignProjectsToCustomFieldContext(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAssignProjectsToCustomFieldContext(_response);
            throw _response;
        });
    }

    protected processAssignProjectsToCustomFieldContext(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the custom field, context, or project is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Remove custom field context from projects
     * @param fieldId The ID of the custom field.
     * @param contextId The ID of the context.
     * @return Returned if the custom field context is removed from the projects.
     */
    removeCustomFieldContextFromProjects(fieldId: string, contextId: number, body: ProjectIds): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/context/{contextId}/project/remove";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (contextId === undefined || contextId === null)
            throw new Error("The parameter 'contextId' must be defined.");
        url_ = url_.replace("{contextId}", encodeURIComponent("" + contextId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveCustomFieldContextFromProjects(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveCustomFieldContextFromProjects(_response);
            throw _response;
        });
    }

    protected processRemoveCustomFieldContextFromProjects(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the custom field, context, or one or more projects are not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get contexts for a field
     * @param fieldId The ID of the field to return contexts for.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     * @deprecated
     */
    getContextsForFieldDeprecated(fieldId: string, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanContext> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/contexts?";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetContextsForFieldDeprecated(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetContextsForFieldDeprecated(_response);
            throw _response;
        });
    }

    protected processGetContextsForFieldDeprecated(response: any): ng.IPromise<PageBeanContext> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanContext.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanContext>(null as any);
    }

    /**
     * Get screens for a field
     * @param fieldId The ID of the field to return screens for.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param expand (optional) Use [expand](#expansion) to include additional information about screens in the response. This parameter accepts `tab` which returns details about the screen tabs the field is used in.
     * @return Returned if the request is successful.
     */
    getScreensForField(fieldId: string, startAt?: number | undefined, maxResults?: number | undefined, expand?: string | undefined): ng.IPromise<PageBeanScreenWithTab> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldId}/screens?";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetScreensForField(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetScreensForField(_response);
            throw _response;
        });
    }

    protected processGetScreensForField(response: any): ng.IPromise<PageBeanScreenWithTab> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanScreenWithTab.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanScreenWithTab>(null as any);
    }

    /**
     * Get all issue field options
     * @param fieldKey The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:

     *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
     *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getAllIssueFieldOptions(fieldKey: string, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanIssueFieldOption> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldKey}/option?";
        if (fieldKey === undefined || fieldKey === null)
            throw new Error("The parameter 'fieldKey' must be defined.");
        url_ = url_.replace("{fieldKey}", encodeURIComponent("" + fieldKey));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllIssueFieldOptions(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllIssueFieldOptions(_response);
            throw _response;
        });
    }

    protected processGetAllIssueFieldOptions(response: any): ng.IPromise<PageBeanIssueFieldOption> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanIssueFieldOption.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field is not found or does not support options.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not authenticated as a Jira administrator or the app that provided the field.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanIssueFieldOption>(null as any);
    }

    /**
     * Create issue field option
     * @param fieldKey The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:

     *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
     *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
     * @return Returned if the request is successful.
     */
    createIssueFieldOption(fieldKey: string, body: IssueFieldOptionCreateBean): ng.IPromise<IssueFieldOption> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldKey}/option";
        if (fieldKey === undefined || fieldKey === null)
            throw new Error("The parameter 'fieldKey' must be defined.");
        url_ = url_.replace("{fieldKey}", encodeURIComponent("" + fieldKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateIssueFieldOption(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateIssueFieldOption(_response);
            throw _response;
        });
    }

    protected processCreateIssueFieldOption(response: any): ng.IPromise<IssueFieldOption> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueFieldOption.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the option is invalid.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not authenticated as a Jira administrator or the app that provided the field.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field is not found or does not support options.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueFieldOption>(null as any);
    }

    /**
     * Get selectable issue field options
     * @param fieldKey The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:

     *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
     *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param projectId (optional) Filters the results to options that are only available in the specified project.
     * @return Returned if the request is successful.
     */
    getSelectableIssueFieldOptions(fieldKey: string, startAt?: number | undefined, maxResults?: number | undefined, projectId?: number | undefined): ng.IPromise<PageBeanIssueFieldOption> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldKey}/option/suggestions/edit?";
        if (fieldKey === undefined || fieldKey === null)
            throw new Error("The parameter 'fieldKey' must be defined.");
        url_ = url_.replace("{fieldKey}", encodeURIComponent("" + fieldKey));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetSelectableIssueFieldOptions(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetSelectableIssueFieldOptions(_response);
            throw _response;
        });
    }

    protected processGetSelectableIssueFieldOptions(response: any): ng.IPromise<PageBeanIssueFieldOption> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanIssueFieldOption.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field is not found or does not support options.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanIssueFieldOption>(null as any);
    }

    /**
     * Get visible issue field options
     * @param fieldKey The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:

     *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
     *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param projectId (optional) Filters the results to options that are only available in the specified project.
     * @return Returned if the request is successful.
     */
    getVisibleIssueFieldOptions(fieldKey: string, startAt?: number | undefined, maxResults?: number | undefined, projectId?: number | undefined): ng.IPromise<PageBeanIssueFieldOption> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldKey}/option/suggestions/search?";
        if (fieldKey === undefined || fieldKey === null)
            throw new Error("The parameter 'fieldKey' must be defined.");
        url_ = url_.replace("{fieldKey}", encodeURIComponent("" + fieldKey));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetVisibleIssueFieldOptions(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetVisibleIssueFieldOptions(_response);
            throw _response;
        });
    }

    protected processGetVisibleIssueFieldOptions(response: any): ng.IPromise<PageBeanIssueFieldOption> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanIssueFieldOption.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field is not found or does not support options.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanIssueFieldOption>(null as any);
    }

    /**
     * Delete issue field option
     * @param fieldKey The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:

     *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
     *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
     * @param optionId The ID of the option to be deleted.
     * @return Returned if the field option is deleted.
     */
    deleteIssueFieldOption(fieldKey: string, optionId: number): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldKey}/option/{optionId}";
        if (fieldKey === undefined || fieldKey === null)
            throw new Error("The parameter 'fieldKey' must be defined.");
        url_ = url_.replace("{fieldKey}", encodeURIComponent("" + fieldKey));
        if (optionId === undefined || optionId === null)
            throw new Error("The parameter 'optionId' must be defined.");
        url_ = url_.replace("{optionId}", encodeURIComponent("" + optionId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteIssueFieldOption(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteIssueFieldOption(_response);
            throw _response;
        });
    }

    protected processDeleteIssueFieldOption(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not authenticated as a Jira administrator or the app that provided the field.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field or option is not found.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the option is selected for the field in any issue.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get issue field option
     * @param fieldKey The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:

     *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
     *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
     * @param optionId The ID of the option to be returned.
     * @return Returned if the requested option is returned.
     */
    getIssueFieldOption(fieldKey: string, optionId: number): ng.IPromise<IssueFieldOption> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldKey}/option/{optionId}";
        if (fieldKey === undefined || fieldKey === null)
            throw new Error("The parameter 'fieldKey' must be defined.");
        url_ = url_.replace("{fieldKey}", encodeURIComponent("" + fieldKey));
        if (optionId === undefined || optionId === null)
            throw new Error("The parameter 'optionId' must be defined.");
        url_ = url_.replace("{optionId}", encodeURIComponent("" + optionId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueFieldOption(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueFieldOption(_response);
            throw _response;
        });
    }

    protected processGetIssueFieldOption(response: any): ng.IPromise<IssueFieldOption> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueFieldOption.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field is not found or does not support options.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not authenticated as a Jira administrator or the app that provided the field.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the option is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueFieldOption>(null as any);
    }

    /**
     * Update issue field option
     * @param fieldKey The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:

     *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
     *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
     * @param optionId The ID of the option to be updated.
     * @return Returned if the option is updated or created.
     */
    updateIssueFieldOption(fieldKey: string, optionId: number, body: IssueFieldOption): ng.IPromise<IssueFieldOption> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldKey}/option/{optionId}";
        if (fieldKey === undefined || fieldKey === null)
            throw new Error("The parameter 'fieldKey' must be defined.");
        url_ = url_.replace("{fieldKey}", encodeURIComponent("" + fieldKey));
        if (optionId === undefined || optionId === null)
            throw new Error("The parameter 'optionId' must be defined.");
        url_ = url_.replace("{optionId}", encodeURIComponent("" + optionId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateIssueFieldOption(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateIssueFieldOption(_response);
            throw _response;
        });
    }

    protected processUpdateIssueFieldOption(response: any): ng.IPromise<IssueFieldOption> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueFieldOption.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the option is invalid, or the *ID* in the request object does not match the *optionId* parameter.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not authenticated as a Jira administrator or the app that provided the field.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if field is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueFieldOption>(null as any);
    }

    /**
     * Replace issue field option
     * @param fieldKey The field key is specified in the following format: **$(app-key)\_\_$(field-key)**. For example, *example-add-on\_\_example-issue-field*. To determine the `fieldKey` value, do one of the following:

     *  open the app's plugin descriptor, then **app-key** is the key at the top and **field-key** is the key in the `jiraIssueFields` module. **app-key** can also be found in the app listing in the Atlassian Universal Plugin Manager.
     *  run [Get fields](#api-rest-api-3-field-get) and in the field details the value is returned in `key`. For example, `"key": "teams-add-on__team-issue-field"`
     * @param optionId The ID of the option to be deselected.
     * @param replaceWith (optional) The ID of the option that will replace the currently selected option.
     * @param jql (optional) A JQL query that specifies the issues to be updated. For example, *project=10000*.
     * @param overrideScreenSecurity (optional) Whether screen security is overridden to enable hidden fields to be edited. Available to Connect and Forge app users with admin permission.
     * @param overrideEditableFlag (optional) Whether screen security is overridden to enable uneditable fields to be edited. Available to Connect and Forge app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     */
    replaceIssueFieldOption(fieldKey: string, optionId: number, replaceWith?: number | undefined, jql?: string | undefined, overrideScreenSecurity?: boolean | undefined, overrideEditableFlag?: boolean | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/field/{fieldKey}/option/{optionId}/issue?";
        if (fieldKey === undefined || fieldKey === null)
            throw new Error("The parameter 'fieldKey' must be defined.");
        url_ = url_.replace("{fieldKey}", encodeURIComponent("" + fieldKey));
        if (optionId === undefined || optionId === null)
            throw new Error("The parameter 'optionId' must be defined.");
        url_ = url_.replace("{optionId}", encodeURIComponent("" + optionId));
        if (replaceWith === null)
            throw new Error("The parameter 'replaceWith' cannot be null.");
        else if (replaceWith !== undefined)
            url_ += "replaceWith=" + encodeURIComponent("" + replaceWith) + "&";
        if (jql === null)
            throw new Error("The parameter 'jql' cannot be null.");
        else if (jql !== undefined)
            url_ += "jql=" + encodeURIComponent("" + jql) + "&";
        if (overrideScreenSecurity === null)
            throw new Error("The parameter 'overrideScreenSecurity' cannot be null.");
        else if (overrideScreenSecurity !== undefined)
            url_ += "overrideScreenSecurity=" + encodeURIComponent("" + overrideScreenSecurity) + "&";
        if (overrideEditableFlag === null)
            throw new Error("The parameter 'overrideEditableFlag' cannot be null.");
        else if (overrideEditableFlag !== undefined)
            url_ += "overrideEditableFlag=" + encodeURIComponent("" + overrideEditableFlag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processReplaceIssueFieldOption(_response);
        }, (_response) => {
            if (_response.status)
                return this.processReplaceIssueFieldOption(_response);
            throw _response;
        });
    }

    protected processReplaceIssueFieldOption(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 303) {
            const _responseText = response.data;
            let result303: any = null;
            let resultData303 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result303 = TaskProgressBeanRemoveOptionFromIssuesResult.fromJS(resultData303);
            return throwException(this.q, "Returned if the long-running task to deselect the option is started.", status, _responseText, _headers, result303);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field is not found or does not support options, or the options to be replaced are not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Delete custom field
     * @param id The ID of a custom field.
     */
    deleteCustomField(id: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/field/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteCustomField(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteCustomField(_response);
            throw _response;
        });
    }

    protected processDeleteCustomField(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 303) {
            const _responseText = response.data;
            let result303: any = null;
            let resultData303 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result303 = TaskProgressBeanObject.fromJS(resultData303);
            return throwException(this.q, "Returned if the request is successful.", status, _responseText, _headers, result303);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if any of these are true:\n\n *  The custom field is locked.\n *  The custom field is used in a issue security scheme or a permission scheme.\n *  The custom field ID format is incorrect.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the custom field is not found.", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorCollection.fromJS(resultData409);
            return throwException(this.q, "Returned if a task to delete the custom field is running.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Restore custom field from trash
     * @param id The ID of a custom field.
     * @return Returned if the request is successful.
     */
    restoreCustomField(id: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/field/{id}/restore";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRestoreCustomField(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRestoreCustomField(_response);
            throw _response;
        });
    }

    protected processRestoreCustomField(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the custom field is not found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Move custom field to trash
     * @param id The ID of a custom field.
     * @return Returned if the request is successful.
     */
    trashCustomField(id: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/field/{id}/trash";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processTrashCustomField(_response);
        }, (_response) => {
            if (_response.status)
                return this.processTrashCustomField(_response);
            throw _response;
        });
    }

    protected processTrashCustomField(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the custom field is not found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get all field configurations
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param id (optional) The list of field configuration IDs. To include multiple IDs, provide an ampersand-separated list. For example, `id=10000&id=10001`.
     * @param isDefault (optional) If *true* returns default field configurations only.
     * @param query (optional) The query string used to match against field configuration names and descriptions.
     * @return Returned if the request is successful.
     */
    getAllFieldConfigurations(startAt?: number | undefined, maxResults?: number | undefined, id?: number[] | undefined, isDefault?: boolean | undefined, query?: string | undefined): ng.IPromise<PageBeanFieldConfigurationDetails> {
        let url_ = this.baseUrl + "/rest/api/3/fieldconfiguration?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (isDefault === null)
            throw new Error("The parameter 'isDefault' cannot be null.");
        else if (isDefault !== undefined)
            url_ += "isDefault=" + encodeURIComponent("" + isDefault) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllFieldConfigurations(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllFieldConfigurations(_response);
            throw _response;
        });
    }

    protected processGetAllFieldConfigurations(response: any): ng.IPromise<PageBeanFieldConfigurationDetails> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanFieldConfigurationDetails.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanFieldConfigurationDetails>(null as any);
    }

    /**
     * Create field configuration
     * @return Returned if the request is successful.
     */
    createFieldConfiguration(body: FieldConfigurationDetails): ng.IPromise<FieldConfiguration> {
        let url_ = this.baseUrl + "/rest/api/3/fieldconfiguration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateFieldConfiguration(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateFieldConfiguration(_response);
            throw _response;
        });
    }

    protected processCreateFieldConfiguration(response: any): ng.IPromise<FieldConfiguration> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FieldConfiguration.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<FieldConfiguration>(null as any);
    }

    /**
     * Delete field configuration
     * @param id The ID of the field configuration.
     * @return Returned if the request is successful.
     */
    deleteFieldConfiguration(id: number): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/fieldconfiguration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteFieldConfiguration(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteFieldConfiguration(_response);
            throw _response;
        });
    }

    protected processDeleteFieldConfiguration(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field configuration is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Update field configuration
     * @param id The ID of the field configuration.
     * @return Returned if the request is successful.
     */
    updateFieldConfiguration(id: number, body: FieldConfigurationDetails): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/fieldconfiguration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateFieldConfiguration(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateFieldConfiguration(_response);
            throw _response;
        });
    }

    protected processUpdateFieldConfiguration(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field configuration is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get field configuration items
     * @param id The ID of the field configuration.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getFieldConfigurationItems(id: number, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanFieldConfigurationItem> {
        let url_ = this.baseUrl + "/rest/api/3/fieldconfiguration/{id}/fields?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetFieldConfigurationItems(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetFieldConfigurationItems(_response);
            throw _response;
        });
    }

    protected processGetFieldConfigurationItems(response: any): ng.IPromise<PageBeanFieldConfigurationItem> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanFieldConfigurationItem.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field configuration is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanFieldConfigurationItem>(null as any);
    }

    /**
     * Update field configuration items
     * @param id The ID of the field configuration.
     * @return Returned if the request is successful.
     */
    updateFieldConfigurationItems(id: number, body: FieldConfigurationItemsDetails): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/fieldconfiguration/{id}/fields";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateFieldConfigurationItems(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateFieldConfigurationItems(_response);
            throw _response;
        });
    }

    protected processUpdateFieldConfigurationItems(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field configuration is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get all field configuration schemes
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param id (optional) The list of field configuration scheme IDs. To include multiple IDs, provide an ampersand-separated list. For example, `id=10000&id=10001`.
     * @return Returned if the request is successful.
     */
    getAllFieldConfigurationSchemes(startAt?: number | undefined, maxResults?: number | undefined, id?: number[] | undefined): ng.IPromise<PageBeanFieldConfigurationScheme> {
        let url_ = this.baseUrl + "/rest/api/3/fieldconfigurationscheme?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllFieldConfigurationSchemes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllFieldConfigurationSchemes(_response);
            throw _response;
        });
    }

    protected processGetAllFieldConfigurationSchemes(response: any): ng.IPromise<PageBeanFieldConfigurationScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanFieldConfigurationScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanFieldConfigurationScheme>(null as any);
    }

    /**
     * Create field configuration scheme
     * @param body The details of the field configuration scheme.
     * @return Returned if the request is successful.
     */
    createFieldConfigurationScheme(body: UpdateFieldConfigurationSchemeDetails): ng.IPromise<FieldConfigurationScheme> {
        let url_ = this.baseUrl + "/rest/api/3/fieldconfigurationscheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateFieldConfigurationScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateFieldConfigurationScheme(_response);
            throw _response;
        });
    }

    protected processCreateFieldConfigurationScheme(response: any): ng.IPromise<FieldConfigurationScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = FieldConfigurationScheme.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<FieldConfigurationScheme>(null as any);
    }

    /**
     * Get field configuration issue type items
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param fieldConfigurationSchemeId (optional) The list of field configuration scheme IDs. To include multiple field configuration schemes separate IDs with ampersand: `fieldConfigurationSchemeId=10000&fieldConfigurationSchemeId=10001`.
     * @return Returned if the request is successful.
     */
    getFieldConfigurationSchemeMappings(startAt?: number | undefined, maxResults?: number | undefined, fieldConfigurationSchemeId?: number[] | undefined): ng.IPromise<PageBeanFieldConfigurationIssueTypeItem> {
        let url_ = this.baseUrl + "/rest/api/3/fieldconfigurationscheme/mapping?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (fieldConfigurationSchemeId === null)
            throw new Error("The parameter 'fieldConfigurationSchemeId' cannot be null.");
        else if (fieldConfigurationSchemeId !== undefined)
            fieldConfigurationSchemeId && fieldConfigurationSchemeId.forEach(item => { url_ += "fieldConfigurationSchemeId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetFieldConfigurationSchemeMappings(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetFieldConfigurationSchemeMappings(_response);
            throw _response;
        });
    }

    protected processGetFieldConfigurationSchemeMappings(response: any): ng.IPromise<PageBeanFieldConfigurationIssueTypeItem> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanFieldConfigurationIssueTypeItem.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if no field configuration schemes are found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanFieldConfigurationIssueTypeItem>(null as any);
    }

    /**
     * Get field configuration schemes for projects
     * @param projectId The list of project IDs. To include multiple projects, separate IDs with ampersand: `projectId=10000&projectId=10001`.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getFieldConfigurationSchemeProjectMapping(projectId: number[], startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanFieldConfigurationSchemeProjects> {
        let url_ = this.baseUrl + "/rest/api/3/fieldconfigurationscheme/project?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            projectId && projectId.forEach(item => { url_ += "projectId=" + encodeURIComponent("" + item) + "&"; });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetFieldConfigurationSchemeProjectMapping(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetFieldConfigurationSchemeProjectMapping(_response);
            throw _response;
        });
    }

    protected processGetFieldConfigurationSchemeProjectMapping(response: any): ng.IPromise<PageBeanFieldConfigurationSchemeProjects> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanFieldConfigurationSchemeProjects.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanFieldConfigurationSchemeProjects>(null as any);
    }

    /**
     * Assign field configuration scheme to project
     * @return Returned if the request is successful.
     */
    assignFieldConfigurationSchemeToProject(body: FieldConfigurationSchemeProjectAssociation): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/fieldconfigurationscheme/project";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAssignFieldConfigurationSchemeToProject(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAssignFieldConfigurationSchemeToProject(_response);
            throw _response;
        });
    }

    protected processAssignFieldConfigurationSchemeToProject(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not a classic project.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Delete field configuration scheme
     * @param id The ID of the field configuration scheme.
     * @return Returned if the request is successful.
     */
    deleteFieldConfigurationScheme(id: number): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/fieldconfigurationscheme/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteFieldConfigurationScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteFieldConfigurationScheme(_response);
            throw _response;
        });
    }

    protected processDeleteFieldConfigurationScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field configuration scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Update field configuration scheme
     * @param id The ID of the field configuration scheme.
     * @param body The details of the field configuration scheme.
     * @return Returned if the request is successful.
     */
    updateFieldConfigurationScheme(id: number, body: UpdateFieldConfigurationSchemeDetails): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/fieldconfigurationscheme/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateFieldConfigurationScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateFieldConfigurationScheme(_response);
            throw _response;
        });
    }

    protected processUpdateFieldConfigurationScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field configuration scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Assign issue types to field configurations
     * @param id The ID of the field configuration scheme.
     * @return Returned if the request is successful.
     */
    setFieldConfigurationSchemeMapping(id: number, body: AssociateFieldConfigurationsWithIssueTypesRequest): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/fieldconfigurationscheme/{id}/mapping";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetFieldConfigurationSchemeMapping(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetFieldConfigurationSchemeMapping(_response);
            throw _response;
        });
    }

    protected processSetFieldConfigurationSchemeMapping(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field configuration scheme, the field configuration, or the issue type is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Remove issue types from field configuration scheme
     * @param id The ID of the field configuration scheme.
     * @param body The issue type IDs to remove.
     * @return Returned if the request is successful.
     */
    removeIssueTypesFromGlobalFieldConfigurationScheme(id: number, body: IssueTypeIdsToRemove): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/fieldconfigurationscheme/{id}/mapping/delete";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveIssueTypesFromGlobalFieldConfigurationScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveIssueTypesFromGlobalFieldConfigurationScheme(_response);
            throw _response;
        });
    }

    protected processRemoveIssueTypesFromGlobalFieldConfigurationScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the field configuration scheme or the issue types are not found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Create filter
     * @param body The filter to create.
     * @param expand (optional) Use [expand](#expansion) to include additional information about filter in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `sharedUsers` Returns the users that the filter is shared with. This includes users that can browse projects that the filter is shared with. If you don't specify `sharedUsers`, then the `sharedUsers` object is returned but it doesn't list any users. The list of users returned is limited to 1000, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 1000 users, use `?expand=sharedUsers[1001:2000]`.
     *  `subscriptions` Returns the users that are subscribed to the filter. If you don't specify `subscriptions`, the `subscriptions` object is returned but it doesn't list any subscriptions. The list of subscriptions returned is limited to 1000, to access additional subscriptions append `[start-index:end-index]` to the expand request. For example, to access the next 1000 subscriptions, use `?expand=subscriptions[1001:2000]`.
     * @param overrideSharePermissions (optional) EXPERIMENTAL: Whether share permissions are overridden to enable filters with any share permissions to be created. Available to users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * @return Returned if the request is successful.
     */
    createFilter(body: Filter, expand?: string | undefined, overrideSharePermissions?: boolean | undefined): ng.IPromise<Filter> {
        let url_ = this.baseUrl + "/rest/api/3/filter?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (overrideSharePermissions === null)
            throw new Error("The parameter 'overrideSharePermissions' cannot be null.");
        else if (overrideSharePermissions !== undefined)
            url_ += "overrideSharePermissions=" + encodeURIComponent("" + overrideSharePermissions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateFilter(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateFilter(_response);
            throw _response;
        });
    }

    protected processCreateFilter(response: any): ng.IPromise<Filter> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Filter.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request object is invalid. For example, the `name` is not unique or the project ID is not specified for a project role share permission.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Filter>(null as any);
    }

    /**
     * Get default share scope
     * @return Returned if the request is successful.
     */
    getDefaultShareScope(): ng.IPromise<DefaultShareScope> {
        let url_ = this.baseUrl + "/rest/api/3/filter/defaultShareScope";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetDefaultShareScope(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetDefaultShareScope(_response);
            throw _response;
        });
    }

    protected processGetDefaultShareScope(response: any): ng.IPromise<DefaultShareScope> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DefaultShareScope.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<DefaultShareScope>(null as any);
    }

    /**
     * Set default share scope
     * @return Returned if the request is successful.
     */
    setDefaultShareScope(body: DefaultShareScope): ng.IPromise<DefaultShareScope> {
        let url_ = this.baseUrl + "/rest/api/3/filter/defaultShareScope";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetDefaultShareScope(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetDefaultShareScope(_response);
            throw _response;
        });
    }

    protected processSetDefaultShareScope(response: any): ng.IPromise<DefaultShareScope> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DefaultShareScope.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if an invalid scope is set.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<DefaultShareScope>(null as any);
    }

    /**
     * Get favorite filters
     * @param expand (optional) Use [expand](#expansion) to include additional information about filter in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `sharedUsers` Returns the users that the filter is shared with. This includes users that can browse projects that the filter is shared with. If you don't specify `sharedUsers`, then the `sharedUsers` object is returned but it doesn't list any users. The list of users returned is limited to 1000, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 1000 users, use `?expand=sharedUsers[1001:2000]`.
     *  `subscriptions` Returns the users that are subscribed to the filter. If you don't specify `subscriptions`, the `subscriptions` object is returned but it doesn't list any subscriptions. The list of subscriptions returned is limited to 1000, to access additional subscriptions append `[start-index:end-index]` to the expand request. For example, to access the next 1000 subscriptions, use `?expand=subscriptions[1001:2000]`.
     * @return Returned if the request is successful.
     */
    getFavouriteFilters(expand?: string | undefined): ng.IPromise<Filter[]> {
        let url_ = this.baseUrl + "/rest/api/3/filter/favourite?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetFavouriteFilters(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetFavouriteFilters(_response);
            throw _response;
        });
    }

    protected processGetFavouriteFilters(response: any): ng.IPromise<Filter[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Filter.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Filter[]>(null as any);
    }

    /**
     * Get my filters
     * @param expand (optional) Use [expand](#expansion) to include additional information about filter in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `sharedUsers` Returns the users that the filter is shared with. This includes users that can browse projects that the filter is shared with. If you don't specify `sharedUsers`, then the `sharedUsers` object is returned but it doesn't list any users. The list of users returned is limited to 1000, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 1000 users, use `?expand=sharedUsers[1001:2000]`.
     *  `subscriptions` Returns the users that are subscribed to the filter. If you don't specify `subscriptions`, the `subscriptions` object is returned but it doesn't list any subscriptions. The list of subscriptions returned is limited to 1000, to access additional subscriptions append `[start-index:end-index]` to the expand request. For example, to access the next 1000 subscriptions, use `?expand=subscriptions[1001:2000]`.
     * @param includeFavourites (optional) Include the user's favorite filters in the response.
     * @return Returned if the request is successful.
     */
    getMyFilters(expand?: string | undefined, includeFavourites?: boolean | undefined): ng.IPromise<Filter[]> {
        let url_ = this.baseUrl + "/rest/api/3/filter/my?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (includeFavourites === null)
            throw new Error("The parameter 'includeFavourites' cannot be null.");
        else if (includeFavourites !== undefined)
            url_ += "includeFavourites=" + encodeURIComponent("" + includeFavourites) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetMyFilters(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetMyFilters(_response);
            throw _response;
        });
    }

    protected processGetMyFilters(response: any): ng.IPromise<Filter[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Filter.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Filter[]>(null as any);
    }

    /**
     * Search for filters
     * @param filterName (optional) String used to perform a case-insensitive partial match with `name`.
     * @param accountId (optional) User account ID used to return filters with the matching `owner.accountId`. This parameter cannot be used with `owner`.
     * @param owner (optional) This parameter is deprecated because of privacy changes. Use `accountId` instead. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. User name used to return filters with the matching `owner.name`. This parameter cannot be used with `accountId`.
     * @param groupname (optional) As a group's name can change, use of `groupId` is recommended to identify a group. Group name used to returns filters that are shared with a group that matches `sharePermissions.group.groupname`. This parameter cannot be used with the `groupId` parameter.
     * @param groupId (optional) Group ID used to returns filters that are shared with a group that matches `sharePermissions.group.groupId`. This parameter cannot be used with the `groupname` parameter.
     * @param projectId (optional) Project ID used to returns filters that are shared with a project that matches `sharePermissions.project.id`.
     * @param id (optional) The list of filter IDs. To include multiple IDs, provide an ampersand-separated list. For example, `id=10000&id=10001`. Do not exceed 200 filter IDs.
     * @param orderBy (optional) [Order](#ordering) the results by a field:

     *  `description` Sorts by filter description. Note that this sorting works independently of whether the expand to display the description field is in use.
     *  `favourite_count` Sorts by the count of how many users have this filter as a favorite.
     *  `is_favourite` Sorts by whether the filter is marked as a favorite.
     *  `id` Sorts by filter ID.
     *  `name` Sorts by filter name.
     *  `owner` Sorts by the ID of the filter owner.
     *  `is_shared` Sorts by whether the filter is shared.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param expand (optional) Use [expand](#expansion) to include additional information about filter in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `description` Returns the description of the filter.
     *  `favourite` Returns an indicator of whether the user has set the filter as a favorite.
     *  `favouritedCount` Returns a count of how many users have set this filter as a favorite.
     *  `jql` Returns the JQL query that the filter uses.
     *  `owner` Returns the owner of the filter.
     *  `searchUrl` Returns a URL to perform the filter's JQL query.
     *  `sharePermissions` Returns the share permissions defined for the filter.
     *  `editPermissions` Returns the edit permissions defined for the filter.
     *  `isWritable` Returns whether the current user has permission to edit the filter.
     *  `approximateLastUsed` \[Experimental\] Returns the approximate date and time when the filter was last evaluated.
     *  `subscriptions` Returns the users that are subscribed to the filter.
     *  `viewUrl` Returns a URL to view the filter.
     * @param overrideSharePermissions (optional) EXPERIMENTAL: Whether share permissions are overridden to enable filters with any share permissions to be returned. Available to users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * @param isSubstringMatch (optional) When `true` this will perform a case-insensitive substring match for the provided `filterName`. When `false` the filter name will be searched using [full text search syntax](https://support.atlassian.com/jira-software-cloud/docs/search-for-issues-using-the-text-field/).
     * @return Returned if the request is successful.
     */
    getFiltersPaginated(filterName?: string | undefined, accountId?: string | undefined, owner?: string | undefined, groupname?: string | undefined, groupId?: string | undefined, projectId?: number | undefined, id?: number[] | undefined, orderBy?: OrderBy5 | undefined, startAt?: number | undefined, maxResults?: number | undefined, expand?: string | undefined, overrideSharePermissions?: boolean | undefined, isSubstringMatch?: boolean | undefined): ng.IPromise<PageBeanFilterDetails> {
        let url_ = this.baseUrl + "/rest/api/3/filter/search?";
        if (filterName === null)
            throw new Error("The parameter 'filterName' cannot be null.");
        else if (filterName !== undefined)
            url_ += "filterName=" + encodeURIComponent("" + filterName) + "&";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (owner === null)
            throw new Error("The parameter 'owner' cannot be null.");
        else if (owner !== undefined)
            url_ += "owner=" + encodeURIComponent("" + owner) + "&";
        if (groupname === null)
            throw new Error("The parameter 'groupname' cannot be null.");
        else if (groupname !== undefined)
            url_ += "groupname=" + encodeURIComponent("" + groupname) + "&";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (overrideSharePermissions === null)
            throw new Error("The parameter 'overrideSharePermissions' cannot be null.");
        else if (overrideSharePermissions !== undefined)
            url_ += "overrideSharePermissions=" + encodeURIComponent("" + overrideSharePermissions) + "&";
        if (isSubstringMatch === null)
            throw new Error("The parameter 'isSubstringMatch' cannot be null.");
        else if (isSubstringMatch !== undefined)
            url_ += "isSubstringMatch=" + encodeURIComponent("" + isSubstringMatch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetFiltersPaginated(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetFiltersPaginated(_response);
            throw _response;
        });
    }

    protected processGetFiltersPaginated(response: any): ng.IPromise<PageBeanFilterDetails> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanFilterDetails.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if:\n\n *  `owner` and `accountId` are provided.\n *  `expand` includes an invalid value.\n *  `orderBy` is invalid.\n *  `id` identifies more than 200 filter IDs.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanFilterDetails>(null as any);
    }

    /**
     * Delete filter
     * @param id The ID of the filter to delete.
     * @return Returned if the request is successful.
     */
    deleteFilter(id: number): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/filter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteFilter(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteFilter(_response);
            throw _response;
        });
    }

    protected processDeleteFilter(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the filter is not found.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to delete the filter.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get filter
     * @param id The ID of the filter to return.
     * @param expand (optional) Use [expand](#expansion) to include additional information about filter in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `sharedUsers` Returns the users that the filter is shared with. This includes users that can browse projects that the filter is shared with. If you don't specify `sharedUsers`, then the `sharedUsers` object is returned but it doesn't list any users. The list of users returned is limited to 1000, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 1000 users, use `?expand=sharedUsers[1001:2000]`.
     *  `subscriptions` Returns the users that are subscribed to the filter. If you don't specify `subscriptions`, the `subscriptions` object is returned but it doesn't list any subscriptions. The list of subscriptions returned is limited to 1000, to access additional subscriptions append `[start-index:end-index]` to the expand request. For example, to access the next 1000 subscriptions, use `?expand=subscriptions[1001:2000]`.
     * @param overrideSharePermissions (optional) EXPERIMENTAL: Whether share permissions are overridden to enable filters with any share permissions to be returned. Available to users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * @return Returned if the request is successful.
     */
    getFilter(id: number, expand?: string | undefined, overrideSharePermissions?: boolean | undefined): ng.IPromise<Filter> {
        let url_ = this.baseUrl + "/rest/api/3/filter/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (overrideSharePermissions === null)
            throw new Error("The parameter 'overrideSharePermissions' cannot be null.");
        else if (overrideSharePermissions !== undefined)
            url_ += "overrideSharePermissions=" + encodeURIComponent("" + overrideSharePermissions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetFilter(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetFilter(_response);
            throw _response;
        });
    }

    protected processGetFilter(response: any): ng.IPromise<Filter> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Filter.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the filter is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Filter>(null as any);
    }

    /**
     * Update filter
     * @param id The ID of the filter to update.
     * @param body The filter to update.
     * @param expand (optional) Use [expand](#expansion) to include additional information about filter in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `sharedUsers` Returns the users that the filter is shared with. This includes users that can browse projects that the filter is shared with. If you don't specify `sharedUsers`, then the `sharedUsers` object is returned but it doesn't list any users. The list of users returned is limited to 1000, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 1000 users, use `?expand=sharedUsers[1001:2000]`.
     *  `subscriptions` Returns the users that are subscribed to the filter. If you don't specify `subscriptions`, the `subscriptions` object is returned but it doesn't list any subscriptions. The list of subscriptions returned is limited to 1000, to access additional subscriptions append `[start-index:end-index]` to the expand request. For example, to access the next 1000 subscriptions, use `?expand=subscriptions[1001:2000]`.
     * @param overrideSharePermissions (optional) EXPERIMENTAL: Whether share permissions are overridden to enable the addition of any share permissions to filters. Available to users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * @return Returned if the request is successful.
     */
    updateFilter(id: number, body: Filter, expand?: string | undefined, overrideSharePermissions?: boolean | undefined): ng.IPromise<Filter> {
        let url_ = this.baseUrl + "/rest/api/3/filter/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (overrideSharePermissions === null)
            throw new Error("The parameter 'overrideSharePermissions' cannot be null.");
        else if (overrideSharePermissions !== undefined)
            url_ += "overrideSharePermissions=" + encodeURIComponent("" + overrideSharePermissions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateFilter(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateFilter(_response);
            throw _response;
        });
    }

    protected processUpdateFilter(response: any): ng.IPromise<Filter> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Filter.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request object is invalid. For example, the `name` is not unique or the project ID is not specified for a project role share permission.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Filter>(null as any);
    }

    /**
     * Reset columns
     * @param id The ID of the filter.
     * @return Returned if the request is successful.
     */
    resetColumns(id: number): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/filter/{id}/columns";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processResetColumns(_response);
        }, (_response) => {
            if (_response.status)
                return this.processResetColumns(_response);
            throw _response;
        });
    }

    protected processResetColumns(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the filter is not found.\n *  the user does not have permission to view the filter.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get columns
     * @param id The ID of the filter.
     * @return Returned if the request is successful.
     */
    getColumns(id: number): ng.IPromise<ColumnItem[]> {
        let url_ = this.baseUrl + "/rest/api/3/filter/{id}/columns";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetColumns(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetColumns(_response);
            throw _response;
        });
    }

    protected processGetColumns(response: any): ng.IPromise<ColumnItem[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ColumnItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to view the filter.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if a column configuration is not set for the filter.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ColumnItem[]>(null as any);
    }

    /**
     * Set columns
     * @param id The ID of the filter.
     * @param body The IDs of the fields to set as columns. In the form data, specify each field as `columns=id`, where `id` is the *id* of a field (as seen in the response for [Get fields](#api-rest-api-<ver>-field-get)). For example, `columns=summary`.
     * @param columns (optional) 
     * @return Returned if the request is successful.
     */
    setColumns(id: number, body: ColumnRequestBody, columns?: string[] | undefined): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/filter/{id}/columns";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (columns === null || columns === undefined)
            throw new Error("The parameter 'columns' cannot be null.");
        else
            columns.forEach(item_ => content_.append("columns", item_.toString()));

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "*/*",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetColumns(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetColumns(_response);
            throw _response;
        });
    }

    protected processSetColumns(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  a non-navigable field is set as a column.\n *  the user does not have permission to view the filter.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the requesting user is not an owner of the filter.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Remove filter as favorite
     * @param id The ID of the filter.
     * @param expand (optional) Use [expand](#expansion) to include additional information about filter in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `sharedUsers` Returns the users that the filter is shared with. This includes users that can browse projects that the filter is shared with. If you don't specify `sharedUsers`, then the `sharedUsers` object is returned but it doesn't list any users. The list of users returned is limited to 1000, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 1000 users, use `?expand=sharedUsers[1001:2000]`.
     *  `subscriptions` Returns the users that are subscribed to the filter. If you don't specify `subscriptions`, the `subscriptions` object is returned but it doesn't list any subscriptions. The list of subscriptions returned is limited to 1000, to access additional subscriptions append `[start-index:end-index]` to the expand request. For example, to access the next 1000 subscriptions, use `?expand=subscriptions[1001:2000]`.
     * @return Returned if the request is successful.
     */
    deleteFavouriteForFilter(id: number, expand?: string | undefined): ng.IPromise<Filter> {
        let url_ = this.baseUrl + "/rest/api/3/filter/{id}/favourite?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteFavouriteForFilter(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteFavouriteForFilter(_response);
            throw _response;
        });
    }

    protected processDeleteFavouriteForFilter(response: any): ng.IPromise<Filter> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Filter.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the filter is not found.\n *  the user does not have permission to view the filter.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Filter>(null as any);
    }

    /**
     * Add filter as favorite
     * @param id The ID of the filter.
     * @param expand (optional) Use [expand](#expansion) to include additional information about filter in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `sharedUsers` Returns the users that the filter is shared with. This includes users that can browse projects that the filter is shared with. If you don't specify `sharedUsers`, then the `sharedUsers` object is returned but it doesn't list any users. The list of users returned is limited to 1000, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 1000 users, use `?expand=sharedUsers[1001:2000]`.
     *  `subscriptions` Returns the users that are subscribed to the filter. If you don't specify `subscriptions`, the `subscriptions` object is returned but it doesn't list any subscriptions. The list of subscriptions returned is limited to 1000, to access additional subscriptions append `[start-index:end-index]` to the expand request. For example, to access the next 1000 subscriptions, use `?expand=subscriptions[1001:2000]`.
     * @return Returned if the request is successful.
     */
    setFavouriteForFilter(id: number, expand?: string | undefined): ng.IPromise<Filter> {
        let url_ = this.baseUrl + "/rest/api/3/filter/{id}/favourite?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetFavouriteForFilter(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetFavouriteForFilter(_response);
            throw _response;
        });
    }

    protected processSetFavouriteForFilter(response: any): ng.IPromise<Filter> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Filter.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the filter is not found.\n *  the user does not have permission to favorite the filter.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Filter>(null as any);
    }

    /**
     * Change filter owner
     * @param id The ID of the filter to update.
     * @param body The account ID of the new owner of the filter.
     * @return Returned if the request is successful.
     */
    changeFilterOwner(id: number, body: ChangeFilterOwner): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/filter/{id}/owner";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processChangeFilterOwner(_response);
        }, (_response) => {
            if (_response.status)
                return this.processChangeFilterOwner(_response);
            throw _response;
        });
    }

    protected processChangeFilterOwner(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned when:\n\n *  The new owner of the filter owns a filter with the same name.\n *  An attempt is made to change owner of the default filter.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the requesting user is not an owner of the filter or does not have *Administer Jira* global permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the filter or the new owner of the filter is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get share permissions
     * @param id The ID of the filter.
     * @return Returned if the request is successful.
     */
    getSharePermissions(id: number): ng.IPromise<SharePermission[]> {
        let url_ = this.baseUrl + "/rest/api/3/filter/{id}/permission";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetSharePermissions(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetSharePermissions(_response);
            throw _response;
        });
    }

    protected processGetSharePermissions(response: any): ng.IPromise<SharePermission[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SharePermission.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the filter is not found.\n *  the user does not have permission to view the filter.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SharePermission[]>(null as any);
    }

    /**
     * Add share permission
     * @param id The ID of the filter.
     * @return Returned if the request is successful.
     */
    addSharePermission(id: number, body: SharePermissionInputBean): ng.IPromise<SharePermission[]> {
        let url_ = this.baseUrl + "/rest/api/3/filter/{id}/permission";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddSharePermission(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddSharePermission(_response);
            throw _response;
        });
    }

    protected processAddSharePermission(response: any): ng.IPromise<SharePermission[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201!.push(SharePermission.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the request object is invalid. For example, it contains an invalid type, the ID does not match the type, or the project or group is not found.\n *  the user does not own the filter.\n *  the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the filter is not found.\n *  the user does not have permission to view the filter.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SharePermission[]>(null as any);
    }

    /**
     * Delete share permission
     * @param id The ID of the filter.
     * @param permissionId The ID of the share permission.
     * @return Returned if the request is successful.
     */
    deleteSharePermission(id: number, permissionId: number): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/filter/{id}/permission/{permissionId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (permissionId === undefined || permissionId === null)
            throw new Error("The parameter 'permissionId' must be defined.");
        url_ = url_.replace("{permissionId}", encodeURIComponent("" + permissionId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteSharePermission(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteSharePermission(_response);
            throw _response;
        });
    }

    protected processDeleteSharePermission(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the filter is not found.\n *  the user does not own the filter.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get share permission
     * @param id The ID of the filter.
     * @param permissionId The ID of the share permission.
     * @return Returned if the request is successful.
     */
    getSharePermission(id: number, permissionId: number): ng.IPromise<SharePermission> {
        let url_ = this.baseUrl + "/rest/api/3/filter/{id}/permission/{permissionId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (permissionId === undefined || permissionId === null)
            throw new Error("The parameter 'permissionId' must be defined.");
        url_ = url_.replace("{permissionId}", encodeURIComponent("" + permissionId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetSharePermission(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetSharePermission(_response);
            throw _response;
        });
    }

    protected processGetSharePermission(response: any): ng.IPromise<SharePermission> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SharePermission.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the filter is not found.\n *  the permission is not found.\n *  the user does not have permission to view the filter.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SharePermission>(null as any);
    }

    /**
     * Remove group
     * @param groupname (optional) 
     * @param groupId (optional) The ID of the group. This parameter cannot be used with the `groupname` parameter.
     * @param swapGroup (optional) As a group's name can change, use of `swapGroupId` is recommended to identify a group.  
    The group to transfer restrictions to. Only comments and worklogs are transferred. If restrictions are not transferred, comments and worklogs are inaccessible after the deletion. This parameter cannot be used with the `swapGroupId` parameter.
     * @param swapGroupId (optional) The ID of the group to transfer restrictions to. Only comments and worklogs are transferred. If restrictions are not transferred, comments and worklogs are inaccessible after the deletion. This parameter cannot be used with the `swapGroup` parameter.
     * @return Returned if the request is successful.
     */
    removeGroup(groupname?: string | undefined, groupId?: string | undefined, swapGroup?: string | undefined, swapGroupId?: string | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/group?";
        if (groupname === null)
            throw new Error("The parameter 'groupname' cannot be null.");
        else if (groupname !== undefined)
            url_ += "groupname=" + encodeURIComponent("" + groupname) + "&";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (swapGroup === null)
            throw new Error("The parameter 'swapGroup' cannot be null.");
        else if (swapGroup !== undefined)
            url_ += "swapGroup=" + encodeURIComponent("" + swapGroup) + "&";
        if (swapGroupId === null)
            throw new Error("The parameter 'swapGroupId' cannot be null.");
        else if (swapGroupId !== undefined)
            url_ += "swapGroupId=" + encodeURIComponent("" + swapGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveGroup(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveGroup(_response);
            throw _response;
        });
    }

    protected processRemoveGroup(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the group name is not specified.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing from the request.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the group is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get group
     * @param groupname (optional) As a group's name can change, use of `groupId` is recommended to identify a group.  
    The name of the group. This parameter cannot be used with the `groupId` parameter.
     * @param groupId (optional) The ID of the group. This parameter cannot be used with the `groupName` parameter.
     * @param expand (optional) List of fields to expand.
     * @return Returned if the request is successful.
     * @deprecated
     */
    getGroup(groupname?: string | undefined, groupId?: string | undefined, expand?: string | undefined): ng.IPromise<Group> {
        let url_ = this.baseUrl + "/rest/api/3/group?";
        if (groupname === null)
            throw new Error("The parameter 'groupname' cannot be null.");
        else if (groupname !== undefined)
            url_ += "groupname=" + encodeURIComponent("" + groupname) + "&";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetGroup(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetGroup(_response);
            throw _response;
        });
    }

    protected processGetGroup(response: any): ng.IPromise<Group> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Group.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the group name is not specified.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the calling user does not have the Administer Jira global permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the group is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Group>(null as any);
    }

    /**
     * Create group
     * @param body The name of the group.
     * @return Returned if the request is successful.
     */
    createGroup(body: AddGroupBean): ng.IPromise<Group> {
        let url_ = this.baseUrl + "/rest/api/3/group";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateGroup(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateGroup(_response);
            throw _response;
        });
    }

    protected processCreateGroup(response: any): ng.IPromise<Group> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Group.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if group name is not specified or the group name is in use.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Group>(null as any);
    }

    /**
     * Bulk get groups
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param groupId (optional) The ID of a group. To specify multiple IDs, pass multiple `groupId` parameters. For example, `groupId=5b10a2844c20165700ede21g&groupId=5b10ac8d82e05b22cc7d4ef5`.
     * @param groupName (optional) The name of a group. To specify multiple names, pass multiple `groupName` parameters. For example, `groupName=administrators&groupName=jira-software-users`.
     * @param accessType (optional) The access level of a group. Valid values: 'site-admin', 'admin', 'user'.
     * @param applicationKey (optional) The application key of the product user groups to search for. Valid values: 'jira-servicedesk', 'jira-software', 'jira-product-discovery', 'jira-core'.
     * @return Returned if the request is successful.
     */
    bulkGetGroups(startAt?: number | undefined, maxResults?: number | undefined, groupId?: string[] | undefined, groupName?: string[] | undefined, accessType?: string | undefined, applicationKey?: string | undefined): ng.IPromise<PageBeanGroupDetails> {
        let url_ = this.baseUrl + "/rest/api/3/group/bulk?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            groupId && groupId.forEach(item => { url_ += "groupId=" + encodeURIComponent("" + item) + "&"; });
        if (groupName === null)
            throw new Error("The parameter 'groupName' cannot be null.");
        else if (groupName !== undefined)
            groupName && groupName.forEach(item => { url_ += "groupName=" + encodeURIComponent("" + item) + "&"; });
        if (accessType === null)
            throw new Error("The parameter 'accessType' cannot be null.");
        else if (accessType !== undefined)
            url_ += "accessType=" + encodeURIComponent("" + accessType) + "&";
        if (applicationKey === null)
            throw new Error("The parameter 'applicationKey' cannot be null.");
        else if (applicationKey !== undefined)
            url_ += "applicationKey=" + encodeURIComponent("" + applicationKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processBulkGetGroups(_response);
        }, (_response) => {
            if (_response.status)
                return this.processBulkGetGroups(_response);
            throw _response;
        });
    }

    protected processBulkGetGroups(response: any): ng.IPromise<PageBeanGroupDetails> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanGroupDetails.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the group with the given access level can\'t be retrieved.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanGroupDetails>(null as any);
    }

    /**
     * Get users from group
     * @param groupname (optional) As a group's name can change, use of `groupId` is recommended to identify a group.  
    The name of the group. This parameter cannot be used with the `groupId` parameter.
     * @param groupId (optional) The ID of the group. This parameter cannot be used with the `groupName` parameter.
     * @param includeInactiveUsers (optional) Include inactive users.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page (number should be between 1 and 50).
     * @return Returned if the request is successful.
     */
    getUsersFromGroup(groupname?: string | undefined, groupId?: string | undefined, includeInactiveUsers?: boolean | undefined, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanUserDetails> {
        let url_ = this.baseUrl + "/rest/api/3/group/member?";
        if (groupname === null)
            throw new Error("The parameter 'groupname' cannot be null.");
        else if (groupname !== undefined)
            url_ += "groupname=" + encodeURIComponent("" + groupname) + "&";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (includeInactiveUsers === null)
            throw new Error("The parameter 'includeInactiveUsers' cannot be null.");
        else if (includeInactiveUsers !== undefined)
            url_ += "includeInactiveUsers=" + encodeURIComponent("" + includeInactiveUsers) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetUsersFromGroup(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetUsersFromGroup(_response);
            throw _response;
        });
    }

    protected processGetUsersFromGroup(response: any): ng.IPromise<PageBeanUserDetails> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanUserDetails.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the group name is not specified.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the calling user does not have the Administer Jira global permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the group is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanUserDetails>(null as any);
    }

    /**
     * Remove user from group
     * @param accountId The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     * @param groupname (optional) As a group's name can change, use of `groupId` is recommended to identify a group.  
    The name of the group. This parameter cannot be used with the `groupId` parameter.
     * @param groupId (optional) The ID of the group. This parameter cannot be used with the `groupName` parameter.
     * @param username (optional) This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @return Returned if the request is successful.
     */
    removeUserFromGroup(accountId: string, groupname?: string | undefined, groupId?: string | undefined, username?: string | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/group/user?";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined and cannot be null.");
        else
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (groupname === null)
            throw new Error("The parameter 'groupname' cannot be null.");
        else if (groupname !== undefined)
            url_ += "groupname=" + encodeURIComponent("" + groupname) + "&";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveUserFromGroup(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveUserFromGroup(_response);
            throw _response;
        });
    }

    protected processRemoveUserFromGroup(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  `groupName` is missing.\n *  `accountId` is missing.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing from the request.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the group or user are not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Add user to group
     * @param body The user to add to the group.
     * @param groupname (optional) As a group's name can change, use of `groupId` is recommended to identify a group.  
    The name of the group. This parameter cannot be used with the `groupId` parameter.
     * @param groupId (optional) The ID of the group. This parameter cannot be used with the `groupName` parameter.
     * @return Returned if the request is successful.
     */
    addUserToGroup(body: UpdateUserToGroupBean, groupname?: string | undefined, groupId?: string | undefined): ng.IPromise<Group> {
        let url_ = this.baseUrl + "/rest/api/3/group/user?";
        if (groupname === null)
            throw new Error("The parameter 'groupname' cannot be null.");
        else if (groupname !== undefined)
            url_ += "groupname=" + encodeURIComponent("" + groupname) + "&";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddUserToGroup(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddUserToGroup(_response);
            throw _response;
        });
    }

    protected processAddUserToGroup(response: any): ng.IPromise<Group> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Group.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  `groupname` is not provided.\n *  `accountId` is missing.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing from the request.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the calling user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the group or user are not found.", status, _responseText, _headers);

        } else if (status === 429) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if rate limiting is being enforced.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Group>(null as any);
    }

    /**
     * Find groups
     * @param accountId (optional) This parameter is deprecated, setting it does not affect the results. To find groups containing a particular user, use [Get user groups](#api-rest-api-3-user-groups-get).
     * @param query (optional) The string to find in group names.
     * @param exclude (optional) As a group's name can change, use of `excludeGroupIds` is recommended to identify a group.  
    A group to exclude from the result. To exclude multiple groups, provide an ampersand-separated list. For example, `exclude=group1&exclude=group2`. This parameter cannot be used with the `excludeGroupIds` parameter.
     * @param excludeId (optional) A group ID to exclude from the result. To exclude multiple groups, provide an ampersand-separated list. For example, `excludeId=group1-id&excludeId=group2-id`. This parameter cannot be used with the `excludeGroups` parameter.
     * @param maxResults (optional) The maximum number of groups to return. The maximum number of groups that can be returned is limited by the system property `jira.ajax.autocomplete.limit`.
     * @param caseInsensitive (optional) Whether the search for groups should be case insensitive.
     * @param userName (optional) This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @return Returned if the request is successful.
     */
    findGroups(accountId?: string | undefined, query?: string | undefined, exclude?: string[] | undefined, excludeId?: string[] | undefined, maxResults?: number | undefined, caseInsensitive?: boolean | undefined, userName?: string | undefined): ng.IPromise<FoundGroups> {
        let url_ = this.baseUrl + "/rest/api/3/groups/picker?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (exclude === null)
            throw new Error("The parameter 'exclude' cannot be null.");
        else if (exclude !== undefined)
            exclude && exclude.forEach(item => { url_ += "exclude=" + encodeURIComponent("" + item) + "&"; });
        if (excludeId === null)
            throw new Error("The parameter 'excludeId' cannot be null.");
        else if (excludeId !== undefined)
            excludeId && excludeId.forEach(item => { url_ += "excludeId=" + encodeURIComponent("" + item) + "&"; });
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (caseInsensitive === null)
            throw new Error("The parameter 'caseInsensitive' cannot be null.");
        else if (caseInsensitive !== undefined)
            url_ += "caseInsensitive=" + encodeURIComponent("" + caseInsensitive) + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processFindGroups(_response);
        }, (_response) => {
            if (_response.status)
                return this.processFindGroups(_response);
            throw _response;
        });
    }

    protected processFindGroups(response: any): ng.IPromise<FoundGroups> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FoundGroups.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<FoundGroups>(null as any);
    }

    /**
     * Find users and groups
     * @param query The search string.
     * @param maxResults (optional) The maximum number of items to return in each list.
     * @param showAvatar (optional) Whether the user avatar should be returned. If an invalid value is provided, the default value is used.
     * @param fieldId (optional) The custom field ID of the field this request is for.
     * @param projectId (optional) The ID of a project that returned users and groups must have permission to view. To include multiple projects, provide an ampersand-separated list. For example, `projectId=10000&projectId=10001`. This parameter is only used when `fieldId` is present.
     * @param issueTypeId (optional) The ID of an issue type that returned users and groups must have permission to view. To include multiple issue types, provide an ampersand-separated list. For example, `issueTypeId=10000&issueTypeId=10001`. Special values, such as `-1` (all standard issue types) and `-2` (all subtask issue types), are supported. This parameter is only used when `fieldId` is present.
     * @param avatarSize (optional) The size of the avatar to return. If an invalid value is provided, the default value is used.
     * @param caseInsensitive (optional) Whether the search for groups should be case insensitive.
     * @param excludeConnectAddons (optional) Whether Connect app users and groups should be excluded from the search results. If an invalid value is provided, the default value is used.
     * @return Returned if the request is successful.
     */
    findUsersAndGroups(query: string, maxResults?: number | undefined, showAvatar?: boolean | undefined, fieldId?: string | undefined, projectId?: string[] | undefined, issueTypeId?: string[] | undefined, avatarSize?: AvatarSize | undefined, caseInsensitive?: boolean | undefined, excludeConnectAddons?: boolean | undefined): ng.IPromise<FoundUsersAndGroups> {
        let url_ = this.baseUrl + "/rest/api/3/groupuserpicker?";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined and cannot be null.");
        else
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (showAvatar === null)
            throw new Error("The parameter 'showAvatar' cannot be null.");
        else if (showAvatar !== undefined)
            url_ += "showAvatar=" + encodeURIComponent("" + showAvatar) + "&";
        if (fieldId === null)
            throw new Error("The parameter 'fieldId' cannot be null.");
        else if (fieldId !== undefined)
            url_ += "fieldId=" + encodeURIComponent("" + fieldId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            projectId && projectId.forEach(item => { url_ += "projectId=" + encodeURIComponent("" + item) + "&"; });
        if (issueTypeId === null)
            throw new Error("The parameter 'issueTypeId' cannot be null.");
        else if (issueTypeId !== undefined)
            issueTypeId && issueTypeId.forEach(item => { url_ += "issueTypeId=" + encodeURIComponent("" + item) + "&"; });
        if (avatarSize === null)
            throw new Error("The parameter 'avatarSize' cannot be null.");
        else if (avatarSize !== undefined)
            url_ += "avatarSize=" + encodeURIComponent("" + avatarSize) + "&";
        if (caseInsensitive === null)
            throw new Error("The parameter 'caseInsensitive' cannot be null.");
        else if (caseInsensitive !== undefined)
            url_ += "caseInsensitive=" + encodeURIComponent("" + caseInsensitive) + "&";
        if (excludeConnectAddons === null)
            throw new Error("The parameter 'excludeConnectAddons' cannot be null.");
        else if (excludeConnectAddons !== undefined)
            url_ += "excludeConnectAddons=" + encodeURIComponent("" + excludeConnectAddons) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processFindUsersAndGroups(_response);
        }, (_response) => {
            if (_response.status)
                return this.processFindUsersAndGroups(_response);
            throw _response;
        });
    }

    protected processFindUsersAndGroups(response: any): ng.IPromise<FoundUsersAndGroups> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FoundUsersAndGroups.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the query parameter is not provided.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 429) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the rate limit is exceeded. User search endpoints share a collective rate limit for the tenant, in addition to Jira\'s normal rate limiting you may receive a rate limit for user search. Please respect the Retry-After header.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<FoundUsersAndGroups>(null as any);
    }

    /**
     * Get license
     * @return Returned if the request is successful.
     */
    getLicense(): ng.IPromise<License> {
        let url_ = this.baseUrl + "/rest/api/3/instance/license";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetLicense(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetLicense(_response);
            throw _response;
        });
    }

    protected processGetLicense(response: any): ng.IPromise<License> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = License.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<License>(null as any);
    }

    /**
     * Create issue
     * @param updateHistory (optional) Whether the project in which the issue is created is added to the user's **Recently viewed** project list, as shown under **Projects** in Jira. When provided, the issue type and request type are added to the user's history for a project. These values are then used to provide defaults on the issue create screen.
     * @return Returned if the request is successful.
     */
    createIssue(body: IssueUpdateDetails, updateHistory?: boolean | undefined): ng.IPromise<CreatedIssue> {
        let url_ = this.baseUrl + "/rest/api/3/issue?";
        if (updateHistory === null)
            throw new Error("The parameter 'updateHistory' cannot be null.");
        else if (updateHistory !== undefined)
            url_ += "updateHistory=" + encodeURIComponent("" + updateHistory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateIssue(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateIssue(_response);
            throw _response;
        });
    }

    protected processCreateIssue(response: any): ng.IPromise<CreatedIssue> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreatedIssue.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request:\n\n *  is missing required fields.\n *  contains invalid field values.\n *  contains fields that cannot be set for the issue type.\n *  is by a user who does not have the necessary permission.\n *  is to create a subtype in a project different that of the parent issue.\n *  is for a subtask when the option to create subtasks is disabled.\n *  is invalid for any other reason.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 422) {
            const _responseText = response.data;
            let result422: any = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = ErrorCollection.fromJS(resultData422);
            return throwException(this.q, "Returned if a configuration problem prevents the creation of the issue.", status, _responseText, _headers, result422);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<CreatedIssue>(null as any);
    }

    /**
     * Archive issue(s) by JQL
     * @param body A JQL query specifying the issues to archive. Note that subtasks can only be archived through their parent issues.
     * @return Returns the URL to check the status of the submitted request.
     */
    archiveIssues(body: ArchiveIssueAsyncRequest): ng.IPromise<string> {
        let url_ = this.baseUrl + "/rest/api/3/issue/archive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processArchiveIssues(_response);
        }, (_response) => {
            if (_response.status)
                return this.processArchiveIssues(_response);
            throw _response;
        });
    }

    protected processArchiveIssues(response: any): ng.IPromise<string> {
        const status = response.status;

        let _headers: any = {};
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result202 = resultData202 !== undefined ? resultData202 : <any>null;
    
            return this.q.resolve(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if no issues were archived due to a bad request, for example an invalid JQL query.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if no issues were archived because the provided authentication credentials are either missing or invalid.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if no issues were archived because the user lacks the required Jira admin or site admin permissions.", status, _responseText, _headers);

        } else if (status === 412) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if a request to archive issue(s) is already running.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<string>(null as any);
    }

    /**
     * Archive issue(s) by issue ID/key
     * @param body Contains a list of issue keys or IDs to be archived.
     * @return Returned if there is at least one valid issue to archive in the request. The return message will include the count of archived issues and subtasks, as well as error details for issues which failed to get archived.
     */
    archiveIssues(body: IssueArchivalSyncRequest): ng.IPromise<IssueArchivalSyncResponse> {
        let url_ = this.baseUrl + "/rest/api/3/issue/archive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processArchiveIssues(_response);
        }, (_response) => {
            if (_response.status)
                return this.processArchiveIssues(_response);
            throw _response;
        });
    }

    protected processArchiveIssues(response: any): ng.IPromise<IssueArchivalSyncResponse> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueArchivalSyncResponse.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if none of the issues in the request can be archived. Possible reasons:\n\n *  the issues weren\'t found\n *  the issues are subtasks\n *  the issues belong to unlicensed projects\n *  the issues belong to archived projects", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if no issues were archived because the provided authentication credentials are either missing or invalid.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if no issues were archived because the user lacks the required Jira admin or site admin permissions.", status, _responseText, _headers);

        } else if (status === 412) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if one or more issues were successfully archived, but the operation was incomplete because the number of issue IDs or keys provided exceeds 1000.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueArchivalSyncResponse>(null as any);
    }

    /**
     * Bulk create issue
     * @return Returned if any of the issue or subtask creation requests were successful. A request may be unsuccessful when it:

     *  is missing required fields.
     *  contains invalid field values.
     *  contains fields that cannot be set for the issue type.
     *  is by a user who does not have the necessary permission.
     *  is to create a subtype in a project different that of the parent issue.
     *  is for a subtask when the option to create subtasks is disabled.
     *  is invalid for any other reason.
     */
    createIssues(body: IssuesUpdateBean): ng.IPromise<CreatedIssues> {
        let url_ = this.baseUrl + "/rest/api/3/issue/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateIssues(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateIssues(_response);
            throw _response;
        });
    }

    protected processCreateIssues(response: any): ng.IPromise<CreatedIssues> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreatedIssues.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = CreatedIssues.fromJS(resultData400);
            return throwException(this.q, "Returned if all requests are invalid. Requests may be unsuccessful when they:\n\n *  are missing required fields.\n *  contain invalid field values.\n *  contain fields that cannot be set for the issue type.\n *  are by a user who does not have the necessary permission.\n *  are to create a subtype in a project different that of the parent issue.\n *  is for a subtask when the option to create subtasks is disabled.\n *  are invalid for any other reason.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<CreatedIssues>(null as any);
    }

    /**
     * Bulk fetch issues
     * @param body A JSON object containing the information about which issues and fields to fetch.
     * @return Returned if the request is successful. A response may contain both successful issues and issue errors.
     */
    bulkFetchIssues(body: BulkFetchIssueRequestBean): ng.IPromise<BulkIssueResults> {
        let url_ = this.baseUrl + "/rest/api/3/issue/bulkfetch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processBulkFetchIssues(_response);
        }, (_response) => {
            if (_response.status)
                return this.processBulkFetchIssues(_response);
            throw _response;
        });
    }

    protected processBulkFetchIssues(response: any): ng.IPromise<BulkIssueResults> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkIssueResults.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if no issue IDs/keys were present, or more than 100 issue IDs/keys were requested.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<BulkIssueResults>(null as any);
    }

    /**
     * Get create issue metadata
     * @param projectIds (optional) List of project IDs. This parameter accepts a comma-separated list. Multiple project IDs can also be provided using an ampersand-separated list. For example, `projectIds=10000,10001&projectIds=10020,10021`. This parameter may be provided with `projectKeys`.
     * @param projectKeys (optional) List of project keys. This parameter accepts a comma-separated list. Multiple project keys can also be provided using an ampersand-separated list. For example, `projectKeys=proj1,proj2&projectKeys=proj3`. This parameter may be provided with `projectIds`.
     * @param issuetypeIds (optional) List of issue type IDs. This parameter accepts a comma-separated list. Multiple issue type IDs can also be provided using an ampersand-separated list. For example, `issuetypeIds=10000,10001&issuetypeIds=10020,10021`. This parameter may be provided with `issuetypeNames`.
     * @param issuetypeNames (optional) List of issue type names. This parameter accepts a comma-separated list. Multiple issue type names can also be provided using an ampersand-separated list. For example, `issuetypeNames=name1,name2&issuetypeNames=name3`. This parameter may be provided with `issuetypeIds`.
     * @param expand (optional) Use [expand](#expansion) to include additional information about issue metadata in the response. This parameter accepts `projects.issuetypes.fields`, which returns information about the fields in the issue creation screen for each issue type. Fields hidden from the screen are not returned. Use the information to populate the `fields` and `update` fields in [Create issue](#api-rest-api-3-issue-post) and [Create issues](#api-rest-api-3-issue-bulk-post).
     * @return Returned if the request is successful.
     * @deprecated
     */
    getCreateIssueMeta(projectIds?: string[] | undefined, projectKeys?: string[] | undefined, issuetypeIds?: string[] | undefined, issuetypeNames?: string[] | undefined, expand?: string | undefined): ng.IPromise<IssueCreateMetadata> {
        let url_ = this.baseUrl + "/rest/api/3/issue/createmeta?";
        if (projectIds === null)
            throw new Error("The parameter 'projectIds' cannot be null.");
        else if (projectIds !== undefined)
            projectIds && projectIds.forEach(item => { url_ += "projectIds=" + encodeURIComponent("" + item) + "&"; });
        if (projectKeys === null)
            throw new Error("The parameter 'projectKeys' cannot be null.");
        else if (projectKeys !== undefined)
            projectKeys && projectKeys.forEach(item => { url_ += "projectKeys=" + encodeURIComponent("" + item) + "&"; });
        if (issuetypeIds === null)
            throw new Error("The parameter 'issuetypeIds' cannot be null.");
        else if (issuetypeIds !== undefined)
            issuetypeIds && issuetypeIds.forEach(item => { url_ += "issuetypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (issuetypeNames === null)
            throw new Error("The parameter 'issuetypeNames' cannot be null.");
        else if (issuetypeNames !== undefined)
            issuetypeNames && issuetypeNames.forEach(item => { url_ += "issuetypeNames=" + encodeURIComponent("" + item) + "&"; });
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetCreateIssueMeta(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetCreateIssueMeta(_response);
            throw _response;
        });
    }

    protected processGetCreateIssueMeta(response: any): ng.IPromise<IssueCreateMetadata> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueCreateMetadata.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueCreateMetadata>(null as any);
    }

    /**
     * Get create metadata issue types for a project
     * @param projectIdOrKey The ID or key of the project.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getCreateIssueMetaIssueTypes(projectIdOrKey: string, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageOfCreateMetaIssueTypes> {
        let url_ = this.baseUrl + "/rest/api/3/issue/createmeta/{projectIdOrKey}/issuetypes?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetCreateIssueMetaIssueTypes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetCreateIssueMetaIssueTypes(_response);
            throw _response;
        });
    }

    protected processGetCreateIssueMetaIssueTypes(response: any): ng.IPromise<PageOfCreateMetaIssueTypes> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfCreateMetaIssueTypes.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageOfCreateMetaIssueTypes>(null as any);
    }

    /**
     * Get create field metadata for a project and issue type id
     * @param projectIdOrKey The ID or key of the project.
     * @param issueTypeId The issuetype ID.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getCreateIssueMetaIssueTypeId(projectIdOrKey: string, issueTypeId: string, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageOfCreateMetaIssueTypeWithField> {
        let url_ = this.baseUrl + "/rest/api/3/issue/createmeta/{projectIdOrKey}/issuetypes/{issueTypeId}?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (issueTypeId === undefined || issueTypeId === null)
            throw new Error("The parameter 'issueTypeId' must be defined.");
        url_ = url_.replace("{issueTypeId}", encodeURIComponent("" + issueTypeId));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetCreateIssueMetaIssueTypeId(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetCreateIssueMetaIssueTypeId(_response);
            throw _response;
        });
    }

    protected processGetCreateIssueMetaIssueTypeId(response: any): ng.IPromise<PageOfCreateMetaIssueTypeWithField> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfCreateMetaIssueTypeWithField.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageOfCreateMetaIssueTypeWithField>(null as any);
    }

    /**
     * Get issue limit report
     * @param isReturningKeys (optional) Return issue keys instead of issue ids in the response.

    Usage: Add `?isReturningKeys=true` to the end of the path to request issue keys.
     * @return Returned if the request is successful.
     */
    getIssueLimitReport(isReturningKeys?: boolean | undefined): ng.IPromise<IssueLimitReportResponseBean> {
        let url_ = this.baseUrl + "/rest/api/3/issue/limit/report?";
        if (isReturningKeys === null)
            throw new Error("The parameter 'isReturningKeys' cannot be null.");
        else if (isReturningKeys !== undefined)
            url_ += "isReturningKeys=" + encodeURIComponent("" + isReturningKeys) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueLimitReport(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueLimitReport(_response);
            throw _response;
        });
    }

    protected processGetIssueLimitReport(response: any): ng.IPromise<IssueLimitReportResponseBean> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueLimitReportResponseBean.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to complete this request.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueLimitReportResponseBean>(null as any);
    }

    /**
     * Get issue picker suggestions
     * @param query (optional) A string to match against text fields in the issue such as title, description, or comments.
     * @param currentJQL (optional) A JQL query defining a list of issues to search for the query term. Note that `username` and `userkey` cannot be used as search terms for this parameter, due to privacy reasons. Use `accountId` instead.
     * @param currentIssueKey (optional) The key of an issue to exclude from search results. For example, the issue the user is viewing when they perform this query.
     * @param currentProjectId (optional) The ID of a project that suggested issues must belong to.
     * @param showSubTasks (optional) Indicate whether to include subtasks in the suggestions list.
     * @param showSubTaskParent (optional) When `currentIssueKey` is a subtask, whether to include the parent issue in the suggestions if it matches the query.
     * @return Returned if the request is successful.
     */
    getIssuePickerResource(query?: string | undefined, currentJQL?: string | undefined, currentIssueKey?: string | undefined, currentProjectId?: string | undefined, showSubTasks?: boolean | undefined, showSubTaskParent?: boolean | undefined): ng.IPromise<IssuePickerSuggestions> {
        let url_ = this.baseUrl + "/rest/api/3/issue/picker?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (currentJQL === null)
            throw new Error("The parameter 'currentJQL' cannot be null.");
        else if (currentJQL !== undefined)
            url_ += "currentJQL=" + encodeURIComponent("" + currentJQL) + "&";
        if (currentIssueKey === null)
            throw new Error("The parameter 'currentIssueKey' cannot be null.");
        else if (currentIssueKey !== undefined)
            url_ += "currentIssueKey=" + encodeURIComponent("" + currentIssueKey) + "&";
        if (currentProjectId === null)
            throw new Error("The parameter 'currentProjectId' cannot be null.");
        else if (currentProjectId !== undefined)
            url_ += "currentProjectId=" + encodeURIComponent("" + currentProjectId) + "&";
        if (showSubTasks === null)
            throw new Error("The parameter 'showSubTasks' cannot be null.");
        else if (showSubTasks !== undefined)
            url_ += "showSubTasks=" + encodeURIComponent("" + showSubTasks) + "&";
        if (showSubTaskParent === null)
            throw new Error("The parameter 'showSubTaskParent' cannot be null.");
        else if (showSubTaskParent !== undefined)
            url_ += "showSubTaskParent=" + encodeURIComponent("" + showSubTaskParent) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssuePickerResource(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssuePickerResource(_response);
            throw _response;
        });
    }

    protected processGetIssuePickerResource(response: any): ng.IPromise<IssuePickerSuggestions> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssuePickerSuggestions.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssuePickerSuggestions>(null as any);
    }

    /**
     * Bulk set issues properties by list
     * @param body Issue properties to be set or updated with values.
     */
    bulkSetIssuesPropertiesList(body: IssueEntityProperties): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issue/properties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http(options_).then((_response) => {
            return this.processBulkSetIssuesPropertiesList(_response);
        }, (_response) => {
            if (_response.status)
                return this.processBulkSetIssuesPropertiesList(_response);
            throw _response;
        });
    }

    protected processBulkSetIssuesPropertiesList(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 303) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the operation is successful.", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Return if the request is invalid or the user does not have the necessary permission.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Bulk set issue properties by issue
     * @param body Details of the issue properties to be set or updated. Note that if an issue is not found, it is ignored.
     */
    bulkSetIssuePropertiesByIssue(body: MultiIssueEntityProperties): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issue/properties/multi";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http(options_).then((_response) => {
            return this.processBulkSetIssuePropertiesByIssue(_response);
        }, (_response) => {
            if (_response.status)
                return this.processBulkSetIssuePropertiesByIssue(_response);
            throw _response;
        });
    }

    protected processBulkSetIssuePropertiesByIssue(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 303) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the operation is successful.", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Return if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Return if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Bulk delete issue property
     * @param propertyKey The key of the property.
     */
    bulkDeleteIssueProperty(propertyKey: string, body: IssueFilterForBulkPropertyDelete): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issue/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http(options_).then((_response) => {
            return this.processBulkDeleteIssueProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processBulkDeleteIssueProperty(_response);
            throw _response;
        });
    }

    protected processBulkDeleteIssueProperty(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 303) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is successful.", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Bulk set issue property
     * @param propertyKey The key of the property. The maximum length is 255 characters.
     */
    bulkSetIssueProperty(propertyKey: string, body: BulkIssuePropertyUpdateRequest): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issue/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http(options_).then((_response) => {
            return this.processBulkSetIssueProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processBulkSetIssueProperty(_response);
            throw _response;
        });
    }

    protected processBulkSetIssueProperty(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 303) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is successful.", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Unarchive issue(s) by issue keys/ID
     * @param body Contains a list of issue keys or IDs to be unarchived.
     * @return Returned if there is at least one valid issue to unarchive in the request. It will return the count of unarchived issues, which also includes the count of the subtasks unarchived, and it will show the detailed errors for those issues which are not unarchived.
     */
    unarchiveIssues(body: IssueArchivalSyncRequest): ng.IPromise<IssueArchivalSyncResponse> {
        let url_ = this.baseUrl + "/rest/api/3/issue/unarchive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUnarchiveIssues(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUnarchiveIssues(_response);
            throw _response;
        });
    }

    protected processUnarchiveIssues(response: any): ng.IPromise<IssueArchivalSyncResponse> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueArchivalSyncResponse.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if none of the issues in the request are eligible to be unarchived. Possible reasons:\n\n *  the issues weren\'t found\n *  the issues are subtasks\n *  the issues belong to archived projects", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if no issues were unarchived because the provided authentication credentials are either missing or invalid.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if no issues were unarchived because the user lacks the required Jira admin or site admin permissions.", status, _responseText, _headers);

        } else if (status === 412) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if one or more issues were successfully unarchived, but the operation was incomplete because the number of issue IDs or keys provided exceeds 1000.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueArchivalSyncResponse>(null as any);
    }

    /**
     * Get is watching issue bulk
     * @param body A list of issue IDs.
     * @return Returned if the request is successful
     */
    getIsWatchingIssueBulk(body: IssueList): ng.IPromise<BulkIssueIsWatching> {
        let url_ = this.baseUrl + "/rest/api/3/issue/watching";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIsWatchingIssueBulk(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIsWatchingIssueBulk(_response);
            throw _response;
        });
    }

    protected processGetIsWatchingIssueBulk(response: any): ng.IPromise<BulkIssueIsWatching> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkIssueIsWatching.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<BulkIssueIsWatching>(null as any);
    }

    /**
     * Delete issue
     * @param issueIdOrKey The ID or key of the issue.
     * @param deleteSubtasks (optional) Whether the issue's subtasks are deleted when the issue is deleted.
     * @return Returned if the request is successful.
     */
    deleteIssue(issueIdOrKey: string, deleteSubtasks?: DeleteSubtasks | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (deleteSubtasks === null)
            throw new Error("The parameter 'deleteSubtasks' cannot be null.");
        else if (deleteSubtasks !== undefined)
            url_ += "deleteSubtasks=" + encodeURIComponent("" + deleteSubtasks) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteIssue(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteIssue(_response);
            throw _response;
        });
    }

    protected processDeleteIssue(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue has subtasks and `deleteSubtasks` is not set to *true*.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to delete the issue.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue is not found or the user does not have permission to view the issue.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get issue
     * @param issueIdOrKey The ID or key of the issue.
     * @param fields (optional) A list of fields to return for the issue. This parameter accepts a comma-separated list. Use it to retrieve a subset of fields. Allowed values:

     *  `*all` Returns all fields.
     *  `*navigable` Returns navigable fields.
     *  Any issue field, prefixed with a minus to exclude.

    Examples:

     *  `summary,comment` Returns only the summary and comments fields.
     *  `-description` Returns all (default) fields except description.
     *  `*navigable,-comment` Returns all navigable fields except comment.

    This parameter may be specified multiple times. For example, `fields=field1,field2& fields=field3`.

    Note: All fields are returned by default. This differs from [Search for issues using JQL (GET)](#api-rest-api-3-search-get) and [Search for issues using JQL (POST)](#api-rest-api-3-search-post) where the default is all navigable fields.
     * @param fieldsByKeys (optional) Whether fields in `fields` are referenced by keys rather than IDs. This parameter is useful where fields have been added by a connect app and a field's key may differ from its ID.
     * @param expand (optional) Use [expand](#expansion) to include additional information about the issues in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `renderedFields` Returns field values rendered in HTML format.
     *  `names` Returns the display name of each field.
     *  `schema` Returns the schema describing a field type.
     *  `transitions` Returns all possible transitions for the issue.
     *  `editmeta` Returns information about how each field can be edited.
     *  `changelog` Returns a list of recent updates to an issue, sorted by date, starting from the most recent.
     *  `versionedRepresentations` Returns a JSON array for each version of a field's value, with the highest number representing the most recent version. Note: When included in the request, the `fields` parameter is ignored.
     * @param properties (optional) A list of issue properties to return for the issue. This parameter accepts a comma-separated list. Allowed values:

     *  `*all` Returns all issue properties.
     *  Any issue property key, prefixed with a minus to exclude.

    Examples:

     *  `*all` Returns all properties.
     *  `*all,-prop1` Returns all properties except `prop1`.
     *  `prop1,prop2` Returns `prop1` and `prop2` properties.

    This parameter may be specified multiple times. For example, `properties=prop1,prop2& properties=prop3`.
     * @param updateHistory (optional) Whether the project in which the issue is created is added to the user's **Recently viewed** project list, as shown under **Projects** in Jira. This also populates the [JQL issues search](#api-rest-api-3-search-get) `lastViewed` field.
     * @param failFast (optional) Whether to fail the request quickly in case of an error while loading fields for an issue. For `failFast=true`, if one field fails, the entire operation fails. For `failFast=false`, the operation will continue even if a field fails. It will return a valid response, but without values for the failed field(s).
     * @return Returned if the request is successful.
     */
    getIssue(issueIdOrKey: string, fields?: string[] | undefined, fieldsByKeys?: boolean | undefined, expand?: string | undefined, properties?: string[] | undefined, updateHistory?: boolean | undefined, failFast?: boolean | undefined): ng.IPromise<IssueBean> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (fieldsByKeys === null)
            throw new Error("The parameter 'fieldsByKeys' cannot be null.");
        else if (fieldsByKeys !== undefined)
            url_ += "fieldsByKeys=" + encodeURIComponent("" + fieldsByKeys) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (properties === null)
            throw new Error("The parameter 'properties' cannot be null.");
        else if (properties !== undefined)
            properties && properties.forEach(item => { url_ += "properties=" + encodeURIComponent("" + item) + "&"; });
        if (updateHistory === null)
            throw new Error("The parameter 'updateHistory' cannot be null.");
        else if (updateHistory !== undefined)
            url_ += "updateHistory=" + encodeURIComponent("" + updateHistory) + "&";
        if (failFast === null)
            throw new Error("The parameter 'failFast' cannot be null.");
        else if (failFast !== undefined)
            url_ += "failFast=" + encodeURIComponent("" + failFast) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssue(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssue(_response);
            throw _response;
        });
    }

    protected processGetIssue(response: any): ng.IPromise<IssueBean> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueBean.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueBean>(null as any);
    }

    /**
     * Edit issue
     * @param issueIdOrKey The ID or key of the issue.
     * @param notifyUsers (optional) Whether a notification email about the issue update is sent to all watchers. To disable the notification, administer Jira or administer project permissions are required. If the user doesn't have the necessary permission the request is ignored.
     * @param overrideScreenSecurity (optional) Whether screen security is overridden to enable hidden fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * @param overrideEditableFlag (optional) Whether screen security is overridden to enable uneditable fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * @param returnIssue (optional) Whether the response should contain the issue with fields edited in this request. The returned issue will have the same format as in the [Get issue API](#api-rest-api-3-issue-issueidorkey-get).
     * @param expand (optional) The Get issue API expand parameter to use in the response if the `returnIssue` parameter is `true`.
     * @return Returned if the request is successful and the `returnIssue` parameter is `true`
     */
    editIssue(issueIdOrKey: string, body: IssueUpdateDetails, notifyUsers?: boolean | undefined, overrideScreenSecurity?: boolean | undefined, overrideEditableFlag?: boolean | undefined, returnIssue?: boolean | undefined, expand?: string | undefined): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (notifyUsers === null)
            throw new Error("The parameter 'notifyUsers' cannot be null.");
        else if (notifyUsers !== undefined)
            url_ += "notifyUsers=" + encodeURIComponent("" + notifyUsers) + "&";
        if (overrideScreenSecurity === null)
            throw new Error("The parameter 'overrideScreenSecurity' cannot be null.");
        else if (overrideScreenSecurity !== undefined)
            url_ += "overrideScreenSecurity=" + encodeURIComponent("" + overrideScreenSecurity) + "&";
        if (overrideEditableFlag === null)
            throw new Error("The parameter 'overrideEditableFlag' cannot be null.");
        else if (overrideEditableFlag !== undefined)
            url_ += "overrideEditableFlag=" + encodeURIComponent("" + overrideEditableFlag) + "&";
        if (returnIssue === null)
            throw new Error("The parameter 'returnIssue' cannot be null.");
        else if (returnIssue !== undefined)
            url_ += "returnIssue=" + encodeURIComponent("" + returnIssue) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processEditIssue(_response);
        }, (_response) => {
            if (_response.status)
                return this.processEditIssue(_response);
            throw _response;
        });
    }

    protected processEditIssue(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the request body is missing.\n *  the user does not have the necessary permission to edit one or more fields.\n *  the request includes one or more fields that are not found or are not associated with the issue\'s edit screen.\n *  the request includes an invalid transition.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user uses `overrideScreenSecurity` or `overrideEditableFlag` but doesn\'t have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue could not be updated due to a conflicting update.", status, _responseText, _headers);

        } else if (status === 422) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if a configuration problem prevents the issue being updated.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Assign issue
     * @param issueIdOrKey The ID or key of the issue to be assigned.
     * @param body The request object with the user that the issue is assigned to.
     * @return Returned if the request is successful.
     */
    assignIssue(issueIdOrKey: string, body: User): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/assignee";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAssignIssue(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAssignIssue(_response);
            throw _response;
        });
    }

    protected processAssignIssue(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the user is not found.\n *  `name`, `key`, or `accountId` is missing.\n *  more than one of `name`, `key`, and `accountId` are provided.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Add attachment
     * @param issueIdOrKey The ID or key of the issue that attachments are added to.
     * @return Returned if the request is successful.
     */
    addAttachment(issueIdOrKey: string, body: Blob): ng.IPromise<Attachment[]> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/attachments";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "multipart/form-data",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddAttachment(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddAttachment(_response);
            throw _response;
        });
    }

    protected processAddAttachment(response: any): ng.IPromise<Attachment[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Attachment.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if any of the following is true:\n\n *  the issue is not found.\n *  the user does not have permission to view the issue.", status, _responseText, _headers);

        } else if (status === 413) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if any of the following is true:\n\n *  the attachments exceed the maximum attachment size for issues.\n *  more than 60 files are requested to be uploaded.\n *  the per-issue limit for attachments has been breached.\n\nSee [Configuring file attachments](https://confluence.atlassian.com/x/wIXKM) for details.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Attachment[]>(null as any);
    }

    /**
     * Get changelogs
     * @param issueIdOrKey The ID or key of the issue.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getChangeLogs(issueIdOrKey: string, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanChangelog> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/changelog?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetChangeLogs(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetChangeLogs(_response);
            throw _response;
        });
    }

    protected processGetChangeLogs(response: any): ng.IPromise<PageBeanChangelog> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanChangelog.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanChangelog>(null as any);
    }

    /**
     * Get changelogs by IDs
     * @param issueIdOrKey The ID or key of the issue.
     * @return Returned if the request is successful.
     */
    getChangeLogsByIds(issueIdOrKey: string, body: IssueChangelogIds): ng.IPromise<PageOfChangelogs> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/changelog/list";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetChangeLogsByIds(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetChangeLogsByIds(_response);
            throw _response;
        });
    }

    protected processGetChangeLogsByIds(response: any): ng.IPromise<PageOfChangelogs> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfChangelogs.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue is not found or the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageOfChangelogs>(null as any);
    }

    /**
     * Get comments
     * @param issueIdOrKey The ID or key of the issue.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param orderBy (optional) [Order](#ordering) the results by a field. Accepts *created* to sort comments by their created date.
     * @param expand (optional) Use [expand](#expansion) to include additional information about comments in the response. This parameter accepts `renderedBody`, which returns the comment body rendered in HTML.
     * @return Returned if the request is successful.
     */
    getComments(issueIdOrKey: string, startAt?: number | undefined, maxResults?: number | undefined, orderBy?: OrderBy6 | undefined, expand?: string | undefined): ng.IPromise<PageOfComments> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/comment?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetComments(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetComments(_response);
            throw _response;
        });
    }

    protected processGetComments(response: any): ng.IPromise<PageOfComments> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfComments.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if `orderBy` is set to a value other than *created*.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageOfComments>(null as any);
    }

    /**
     * Add comment
     * @param issueIdOrKey The ID or key of the issue.
     * @param expand (optional) Use [expand](#expansion) to include additional information about comments in the response. This parameter accepts `renderedBody`, which returns the comment body rendered in HTML.
     * @return Returned if the request is successful.
     */
    addComment(issueIdOrKey: string, body: Comment, expand?: string | undefined): ng.IPromise<Comment> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/comment?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddComment(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddComment(_response);
            throw _response;
        });
    }

    protected processAddComment(response: any): ng.IPromise<Comment> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Comment.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status === 413) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the per-issue limit has been breached for one of the following fields:\n\n *  comments\n *  attachments", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Comment>(null as any);
    }

    /**
     * Delete comment
     * @param issueIdOrKey The ID or key of the issue.
     * @param id The ID of the comment.
     * @return Returned if the request is successful.
     */
    deleteComment(issueIdOrKey: string, id: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/comment/{id}";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteComment(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteComment(_response);
            throw _response;
        });
    }

    protected processDeleteComment(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to delete the comment.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue or comment is not found or the user does not have permission to view the issue or comment.", status, _responseText, _headers);

        } else if (status === 405) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if an anonymous call is made to the operation.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get comment
     * @param issueIdOrKey The ID or key of the issue.
     * @param id The ID of the comment.
     * @param expand (optional) Use [expand](#expansion) to include additional information about comments in the response. This parameter accepts `renderedBody`, which returns the comment body rendered in HTML.
     * @return Returned if the request is successful.
     */
    getComment(issueIdOrKey: string, id: string, expand?: string | undefined): ng.IPromise<Comment> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/comment/{id}?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetComment(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetComment(_response);
            throw _response;
        });
    }

    protected processGetComment(response: any): ng.IPromise<Comment> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Comment.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue or comment is not found or the user does not have permission to view the issue or comment.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Comment>(null as any);
    }

    /**
     * Update comment
     * @param issueIdOrKey The ID or key of the issue.
     * @param id The ID of the comment.
     * @param notifyUsers (optional) Whether users are notified when a comment is updated.
     * @param overrideEditableFlag (optional) Whether screen security is overridden to enable uneditable fields to be edited. Available to Connect app users with the *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * @param expand (optional) Use [expand](#expansion) to include additional information about comments in the response. This parameter accepts `renderedBody`, which returns the comment body rendered in HTML.
     * @return Returned if the request is successful.
     */
    updateComment(issueIdOrKey: string, id: string, body: Comment, notifyUsers?: boolean | undefined, overrideEditableFlag?: boolean | undefined, expand?: string | undefined): ng.IPromise<Comment> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/comment/{id}?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (notifyUsers === null)
            throw new Error("The parameter 'notifyUsers' cannot be null.");
        else if (notifyUsers !== undefined)
            url_ += "notifyUsers=" + encodeURIComponent("" + notifyUsers) + "&";
        if (overrideEditableFlag === null)
            throw new Error("The parameter 'overrideEditableFlag' cannot be null.");
        else if (overrideEditableFlag !== undefined)
            url_ += "overrideEditableFlag=" + encodeURIComponent("" + overrideEditableFlag) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateComment(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateComment(_response);
            throw _response;
        });
    }

    protected processUpdateComment(response: any): ng.IPromise<Comment> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Comment.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to edit the comment or the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue or comment is not found or the user does not have permission to view the issue or comment.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Comment>(null as any);
    }

    /**
     * Get edit issue metadata
     * @param issueIdOrKey The ID or key of the issue.
     * @param overrideScreenSecurity (optional) Whether hidden fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * @param overrideEditableFlag (optional) Whether non-editable fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     * @return Returned if the request is successful.
     */
    getEditIssueMeta(issueIdOrKey: string, overrideScreenSecurity?: boolean | undefined, overrideEditableFlag?: boolean | undefined): ng.IPromise<IssueUpdateMetadata> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/editmeta?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (overrideScreenSecurity === null)
            throw new Error("The parameter 'overrideScreenSecurity' cannot be null.");
        else if (overrideScreenSecurity !== undefined)
            url_ += "overrideScreenSecurity=" + encodeURIComponent("" + overrideScreenSecurity) + "&";
        if (overrideEditableFlag === null)
            throw new Error("The parameter 'overrideEditableFlag' cannot be null.");
        else if (overrideEditableFlag !== undefined)
            url_ += "overrideEditableFlag=" + encodeURIComponent("" + overrideEditableFlag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetEditIssueMeta(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetEditIssueMeta(_response);
            throw _response;
        });
    }

    protected processGetEditIssueMeta(response: any): ng.IPromise<IssueUpdateMetadata> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueUpdateMetadata.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user uses an override parameter but doesn\'t have permission to do so.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueUpdateMetadata>(null as any);
    }

    /**
     * Send notification for issue
     * @param issueIdOrKey ID or key of the issue that the notification is sent for.
     * @param body The request object for the notification and recipients.
     * @return Returned if the email is queued for sending.
     */
    notify(issueIdOrKey: string, body: Notification): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/notify";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processNotify(_response);
        }, (_response) => {
            if (_response.status)
                return this.processNotify(_response);
            throw _response;
        });
    }

    protected processNotify(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the recipient is the same as the calling user.\n *  the recipient is invalid. For example, the recipient is set to the assignee, but the issue is unassigned.\n *  the issueIdOrKey is of an invalid/null issue.\n *  the request is invalid. For example, required fields are missing or have invalid values.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  outgoing emails are disabled.\n *  no SMTP server is configured.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get issue property keys
     * @param issueIdOrKey The key or ID of the issue.
     * @return Returned if the request is successful.
     */
    getIssuePropertyKeys(issueIdOrKey: string): ng.IPromise<PropertyKeys> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/properties";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssuePropertyKeys(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssuePropertyKeys(_response);
            throw _response;
        });
    }

    protected processGetIssuePropertyKeys(response: any): ng.IPromise<PropertyKeys> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyKeys.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue is not found or the user does not have permissions to view the issue.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PropertyKeys>(null as any);
    }

    /**
     * Delete issue property
     * @param issueIdOrKey The key or ID of the issue.
     * @param propertyKey The key of the property.
     * @return Returned if the request is successful.
     */
    deleteIssueProperty(issueIdOrKey: string, propertyKey: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/properties/{propertyKey}";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteIssueProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteIssueProperty(_response);
            throw _response;
        });
    }

    protected processDeleteIssueProperty(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue or property is not found, or the user does not have permission to edit the issue.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get issue property
     * @param issueIdOrKey The key or ID of the issue.
     * @param propertyKey The key of the property.
     * @return Returned if the request is successful.
     */
    getIssueProperty(issueIdOrKey: string, propertyKey: string): ng.IPromise<EntityProperty> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/properties/{propertyKey}";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueProperty(_response);
            throw _response;
        });
    }

    protected processGetIssueProperty(response: any): ng.IPromise<EntityProperty> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityProperty.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue or property is not found or the user does not have permission to see the issue.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<EntityProperty>(null as any);
    }

    /**
     * Set issue property
     * @param issueIdOrKey The ID or key of the issue.
     * @param propertyKey The key of the issue property. The maximum length is 255 characters.
     * @param body The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes.
     * @return Returned if the issue property is updated.
     */
    setIssueProperty(issueIdOrKey: string, propertyKey: string, body: any): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/properties/{propertyKey}";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetIssueProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetIssueProperty(_response);
            throw _response;
        });
    }

    protected processSetIssueProperty(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to edit the issue.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue is not found or the user does not have permission to view the issue.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Delete remote issue link by global ID
     * @param issueIdOrKey The ID or key of the issue.
     * @param globalId The global ID of a remote issue link.
     * @return Returned if the request is successful.
     */
    deleteRemoteIssueLinkByGlobalId(issueIdOrKey: string, globalId: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/remotelink?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (globalId === undefined || globalId === null)
            throw new Error("The parameter 'globalId' must be defined and cannot be null.");
        else
            url_ += "globalId=" + encodeURIComponent("" + globalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteRemoteIssueLinkByGlobalId(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteRemoteIssueLinkByGlobalId(_response);
            throw _response;
        });
    }

    protected processDeleteRemoteIssueLinkByGlobalId(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if a global ID isn\'t provided.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to link issues.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue or remote issue link is not found or the user does not have permission to view the issue.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get remote issue links
     * @param issueIdOrKey The ID or key of the issue.
     * @param globalId (optional) The global ID of the remote issue link.
     * @return Returned if the request is successful.
     */
    getRemoteIssueLinks(issueIdOrKey: string, globalId?: string | undefined): ng.IPromise<RemoteIssueLink> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/remotelink?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (globalId === null)
            throw new Error("The parameter 'globalId' cannot be null.");
        else if (globalId !== undefined)
            url_ += "globalId=" + encodeURIComponent("" + globalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetRemoteIssueLinks(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetRemoteIssueLinks(_response);
            throw _response;
        });
    }

    protected processGetRemoteIssueLinks(response: any): ng.IPromise<RemoteIssueLink> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RemoteIssueLink.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if issue linking is disabled.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue or remote issue link is not found or the user does not have permission to view the issue.", status, _responseText, _headers);

        } else if (status === 413) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the per-issue limit for remote links has been breached.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<RemoteIssueLink>(null as any);
    }

    /**
     * Create or update remote issue link
     * @param issueIdOrKey The ID or key of the issue.
     * @return Returned if the remote issue link is updated.
     */
    createOrUpdateRemoteIssueLink(issueIdOrKey: string, body: RemoteIssueLinkRequest): ng.IPromise<RemoteIssueLinkIdentifies> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/remotelink";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateOrUpdateRemoteIssueLink(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateOrUpdateRemoteIssueLink(_response);
            throw _response;
        });
    }

    protected processCreateOrUpdateRemoteIssueLink(response: any): ng.IPromise<RemoteIssueLinkIdentifies> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RemoteIssueLinkIdentifies.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = RemoteIssueLinkIdentifies.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to link issues.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue is not found or the user does not have permission to view the issue.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<RemoteIssueLinkIdentifies>(null as any);
    }

    /**
     * Delete remote issue link by ID
     * @param issueIdOrKey The ID or key of the issue.
     * @param linkId The ID of a remote issue link.
     * @return Returned if the request is successful.
     */
    deleteRemoteIssueLinkById(issueIdOrKey: string, linkId: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/remotelink/{linkId}";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (linkId === undefined || linkId === null)
            throw new Error("The parameter 'linkId' must be defined.");
        url_ = url_.replace("{linkId}", encodeURIComponent("" + linkId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteRemoteIssueLinkById(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteRemoteIssueLinkById(_response);
            throw _response;
        });
    }

    protected processDeleteRemoteIssueLinkById(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the link ID is invalid or the remote issue link does not belong to the issue.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to link issues.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue or remote issue link is not found or the user does not have permission to view the issue.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get remote issue link by ID
     * @param issueIdOrKey The ID or key of the issue.
     * @param linkId The ID of the remote issue link.
     * @return Returned if the request is successful.
     */
    getRemoteIssueLinkById(issueIdOrKey: string, linkId: string): ng.IPromise<RemoteIssueLink> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/remotelink/{linkId}";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (linkId === undefined || linkId === null)
            throw new Error("The parameter 'linkId' must be defined.");
        url_ = url_.replace("{linkId}", encodeURIComponent("" + linkId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetRemoteIssueLinkById(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetRemoteIssueLinkById(_response);
            throw _response;
        });
    }

    protected processGetRemoteIssueLinkById(response: any): ng.IPromise<RemoteIssueLink> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RemoteIssueLink.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the link ID is invalid or the remote issue link does not belong to the issue.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if issue linking is disabled.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue or remote issue link is not found or the user does not have permission to view the issue.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<RemoteIssueLink>(null as any);
    }

    /**
     * Update remote issue link by ID
     * @param issueIdOrKey The ID or key of the issue.
     * @param linkId The ID of the remote issue link.
     * @return Returned if the request is successful.
     */
    updateRemoteIssueLink(issueIdOrKey: string, linkId: string, body: RemoteIssueLinkRequest): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/remotelink/{linkId}";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (linkId === undefined || linkId === null)
            throw new Error("The parameter 'linkId' must be defined.");
        url_ = url_.replace("{linkId}", encodeURIComponent("" + linkId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateRemoteIssueLink(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateRemoteIssueLink(_response);
            throw _response;
        });
    }

    protected processUpdateRemoteIssueLink(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the link ID is invalid.\n *  the remote issue link does not belong to the issue.\n *  the request body is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to link issues.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue or remote issue link is not found or the user does not have permission to view the issue.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get transitions
     * @param issueIdOrKey The ID or key of the issue.
     * @param expand (optional) Use [expand](#expansion) to include additional information about transitions in the response. This parameter accepts `transitions.fields`, which returns information about the fields in the transition screen for each transition. Fields hidden from the screen are not returned. Use this information to populate the `fields` and `update` fields in [Transition issue](#api-rest-api-3-issue-issueIdOrKey-transitions-post).
     * @param transitionId (optional) The ID of the transition.
     * @param skipRemoteOnlyCondition (optional) Whether transitions with the condition *Hide From User Condition* are included in the response.
     * @param includeUnavailableTransitions (optional) Whether details of transitions that fail a condition are included in the response
     * @param sortByOpsBarAndStatus (optional) Whether the transitions are sorted by ops-bar sequence value first then category order (Todo, In Progress, Done) or only by ops-bar sequence value.
     * @return Returned if the request is successful.
     */
    getTransitions(issueIdOrKey: string, expand?: string | undefined, transitionId?: string | undefined, skipRemoteOnlyCondition?: boolean | undefined, includeUnavailableTransitions?: boolean | undefined, sortByOpsBarAndStatus?: boolean | undefined): ng.IPromise<Transitions> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/transitions?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (transitionId === null)
            throw new Error("The parameter 'transitionId' cannot be null.");
        else if (transitionId !== undefined)
            url_ += "transitionId=" + encodeURIComponent("" + transitionId) + "&";
        if (skipRemoteOnlyCondition === null)
            throw new Error("The parameter 'skipRemoteOnlyCondition' cannot be null.");
        else if (skipRemoteOnlyCondition !== undefined)
            url_ += "skipRemoteOnlyCondition=" + encodeURIComponent("" + skipRemoteOnlyCondition) + "&";
        if (includeUnavailableTransitions === null)
            throw new Error("The parameter 'includeUnavailableTransitions' cannot be null.");
        else if (includeUnavailableTransitions !== undefined)
            url_ += "includeUnavailableTransitions=" + encodeURIComponent("" + includeUnavailableTransitions) + "&";
        if (sortByOpsBarAndStatus === null)
            throw new Error("The parameter 'sortByOpsBarAndStatus' cannot be null.");
        else if (sortByOpsBarAndStatus !== undefined)
            url_ += "sortByOpsBarAndStatus=" + encodeURIComponent("" + sortByOpsBarAndStatus) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetTransitions(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetTransitions(_response);
            throw _response;
        });
    }

    protected processGetTransitions(response: any): ng.IPromise<Transitions> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Transitions.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Transitions>(null as any);
    }

    /**
     * Transition issue
     * @param issueIdOrKey The ID or key of the issue.
     * @return Returned if the request is successful.
     */
    doTransition(issueIdOrKey: string, body: IssueUpdateDetails): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/transitions";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDoTransition(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDoTransition(_response);
            throw _response;
        });
    }

    protected processDoTransition(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  no transition is specified.\n *  the user does not have permission to transition the issue.\n *  a field that isn\'t included on the transition screen is defined in `fields` or `update`.\n *  a field is specified in both `fields` and `update`.\n *  the request is invalid for any other reason.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue could not be updated due to a conflicting update.", status, _responseText, _headers);

        } else if (status === 413) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if a per-issue limit has been breached for one of the following fields:\n\n *  comments\n *  worklogs\n *  attachments\n *  issue links\n *  remote issue links", status, _responseText, _headers);

        } else if (status === 422) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if a configuration problem prevents the creation of the issue.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Delete vote
     * @param issueIdOrKey The ID or key of the issue.
     * @return Returned if the request is successful.
     */
    removeVote(issueIdOrKey: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/votes";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveVote(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveVote(_response);
            throw _response;
        });
    }

    protected processRemoveVote(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  voting is disabled.\n *  the user has not voted on the issue.\n *  the issue is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get votes
     * @param issueIdOrKey The ID or key of the issue.
     * @return Returned if the request is successful.
     */
    getVotes(issueIdOrKey: string): ng.IPromise<Votes> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/votes";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetVotes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetVotes(_response);
            throw _response;
        });
    }

    protected processGetVotes(response: any): ng.IPromise<Votes> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Votes.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  voting is disabled.\n *  the user does not have permission to view the issue.\n *  the issue is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Votes>(null as any);
    }

    /**
     * Add vote
     * @param issueIdOrKey The ID or key of the issue.
     * @return Returned if the request is successful.
     */
    addVote(issueIdOrKey: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/votes";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddVote(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddVote(_response);
            throw _response;
        });
    }

    protected processAddVote(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  voting is disabled.\n *  the issue is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Delete watcher
     * @param issueIdOrKey The ID or key of the issue.
     * @param username (optional) This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @param accountId (optional) The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Required.
     * @return Returned if the request is successful.
     */
    removeWatcher(issueIdOrKey: string, username?: string | undefined, accountId?: string | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/watchers?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveWatcher(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveWatcher(_response);
            throw _response;
        });
    }

    protected processRemoveWatcher(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if `accountId` is not supplied.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the permission to manage the watcher list.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue or the user is not found or the user does not have permission to view the issue.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get issue watchers
     * @param issueIdOrKey The ID or key of the issue.
     * @return Returned if the request is successful
     */
    getIssueWatchers(issueIdOrKey: string): ng.IPromise<Watchers> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/watchers";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueWatchers(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueWatchers(_response);
            throw _response;
        });
    }

    protected processGetIssueWatchers(response: any): ng.IPromise<Watchers> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Watchers.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Watchers>(null as any);
    }

    /**
     * Add watcher
     * @param issueIdOrKey The ID or key of the issue.
     * @param body The account ID of the user. Note that username cannot be used due to privacy changes.
     * @return Returned if the request is successful.
     */
    addWatcher(issueIdOrKey: string, body: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/watchers";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddWatcher(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddWatcher(_response);
            throw _response;
        });
    }

    protected processAddWatcher(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the permission to manage the watcher list.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue or the user is not found or the user does not have permission to view the issue.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Bulk delete worklogs
     * @param issueIdOrKey The ID or key of the issue.
     * @param body A JSON object containing a list of worklog IDs.
     * @param adjustEstimate (optional) Defines how to update the issue's time estimate, the options are:

     *  `leave` Leaves the estimate unchanged.
     *  `auto` Reduces the estimate by the aggregate value of `timeSpent` across all worklogs being deleted.
     * @param overrideEditableFlag (optional) Whether the work log entries should be removed to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with admin permission can use this flag.
     * @return Returned if the bulk deletion request was partially successful, with a message indicating partial success.
     */
    bulkDeleteWorklogs(issueIdOrKey: string, body: WorklogIdsRequestBean, adjustEstimate?: AdjustEstimate | undefined, overrideEditableFlag?: boolean | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/worklog?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (adjustEstimate === null)
            throw new Error("The parameter 'adjustEstimate' cannot be null.");
        else if (adjustEstimate !== undefined)
            url_ += "adjustEstimate=" + encodeURIComponent("" + adjustEstimate) + "&";
        if (overrideEditableFlag === null)
            throw new Error("The parameter 'overrideEditableFlag' cannot be null.");
        else if (overrideEditableFlag !== undefined)
            url_ += "overrideEditableFlag=" + encodeURIComponent("" + overrideEditableFlag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http(options_).then((_response) => {
            return this.processBulkDeleteWorklogs(_response);
        }, (_response) => {
            if (_response.status)
                return this.processBulkDeleteWorklogs(_response);
            throw _response;
        });
    }

    protected processBulkDeleteWorklogs(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  `request` is not provided or is invalid\n *  the user does not have permission to delete the worklogs\n *  the number of worklogs being deleted exceeds the limit", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the issue is not found or user does not have permission to view the issue\n *  at least one of the worklogs is not associated with the provided issue\n *  time tracking is disabled", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get issue worklogs
     * @param issueIdOrKey The ID or key of the issue.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param startedAfter (optional) The worklog start date and time, as a UNIX timestamp in milliseconds, after which worklogs are returned.
     * @param startedBefore (optional) The worklog start date and time, as a UNIX timestamp in milliseconds, before which worklogs are returned.
     * @param expand (optional) Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts`properties`, which returns worklog properties.
     * @return Returned if the request is successful
     */
    getIssueWorklog(issueIdOrKey: string, startAt?: number | undefined, maxResults?: number | undefined, startedAfter?: number | undefined, startedBefore?: number | undefined, expand?: string | undefined): ng.IPromise<PageOfWorklogs> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/worklog?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (startedAfter === null)
            throw new Error("The parameter 'startedAfter' cannot be null.");
        else if (startedAfter !== undefined)
            url_ += "startedAfter=" + encodeURIComponent("" + startedAfter) + "&";
        if (startedBefore === null)
            throw new Error("The parameter 'startedBefore' cannot be null.");
        else if (startedBefore !== undefined)
            url_ += "startedBefore=" + encodeURIComponent("" + startedBefore) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueWorklog(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueWorklog(_response);
            throw _response;
        });
    }

    protected processGetIssueWorklog(response: any): ng.IPromise<PageOfWorklogs> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfWorklogs.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the issue is not found or the user does not have permission to view the issue.\n *  `startAt` or `maxResults` has non-numeric values.\n *  time tracking is disabled.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageOfWorklogs>(null as any);
    }

    /**
     * Add worklog
     * @param issueIdOrKey The ID or key the issue.
     * @param notifyUsers (optional) Whether users watching the issue are notified by email.
     * @param adjustEstimate (optional) Defines how to update the issue's time estimate, the options are:

     *  `new` Sets the estimate to a specific value, defined in `newEstimate`.
     *  `leave` Leaves the estimate unchanged.
     *  `manual` Reduces the estimate by amount specified in `reduceBy`.
     *  `auto` Reduces the estimate by the value of `timeSpent` in the worklog.
     * @param newEstimate (optional) The value to set as the issue's remaining time estimate, as days (\#d), hours (\#h), or minutes (\#m or \#). For example, *2d*. Required when `adjustEstimate` is `new`.
     * @param reduceBy (optional) The amount to reduce the issue's remaining estimate by, as days (\#d), hours (\#h), or minutes (\#m). For example, *2d*. Required when `adjustEstimate` is `manual`.
     * @param expand (optional) Use [expand](#expansion) to include additional information about work logs in the response. This parameter accepts `properties`, which returns worklog properties.
     * @param overrideEditableFlag (optional) Whether the worklog entry should be added to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) can use this flag.
     * @return Returned if the request is successful.
     */
    addWorklog(issueIdOrKey: string, body: Worklog, notifyUsers?: boolean | undefined, adjustEstimate?: AdjustEstimate2 | undefined, newEstimate?: string | undefined, reduceBy?: string | undefined, expand?: string | undefined, overrideEditableFlag?: boolean | undefined): ng.IPromise<Worklog> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/worklog?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (notifyUsers === null)
            throw new Error("The parameter 'notifyUsers' cannot be null.");
        else if (notifyUsers !== undefined)
            url_ += "notifyUsers=" + encodeURIComponent("" + notifyUsers) + "&";
        if (adjustEstimate === null)
            throw new Error("The parameter 'adjustEstimate' cannot be null.");
        else if (adjustEstimate !== undefined)
            url_ += "adjustEstimate=" + encodeURIComponent("" + adjustEstimate) + "&";
        if (newEstimate === null)
            throw new Error("The parameter 'newEstimate' cannot be null.");
        else if (newEstimate !== undefined)
            url_ += "newEstimate=" + encodeURIComponent("" + newEstimate) + "&";
        if (reduceBy === null)
            throw new Error("The parameter 'reduceBy' cannot be null.");
        else if (reduceBy !== undefined)
            url_ += "reduceBy=" + encodeURIComponent("" + reduceBy) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (overrideEditableFlag === null)
            throw new Error("The parameter 'overrideEditableFlag' cannot be null.");
        else if (overrideEditableFlag !== undefined)
            url_ += "overrideEditableFlag=" + encodeURIComponent("" + overrideEditableFlag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddWorklog(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddWorklog(_response);
            throw _response;
        });
    }

    protected processAddWorklog(response: any): ng.IPromise<Worklog> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Worklog.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  `adjustEstimate` is set to `new` but `newEstimate` is not provided or is invalid.\n *  `adjustEstimate` is set to `manual` but `reduceBy` is not provided or is invalid.\n *  the user does not have permission to add the worklog.\n *  the request JSON is malformed.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status === 413) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the per-issue limit has been breached for one of the following fields:\n\n *  worklogs\n *  attachments", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Worklog>(null as any);
    }

    /**
     * Bulk move worklogs
     * @param body A JSON object containing a list of worklog IDs and the ID or key of the destination issue.
     * @param adjustEstimate (optional) Defines how to update the issues' time estimate, the options are:

     *  `leave` Leaves the estimate unchanged.
     *  `auto` Reduces the estimate by the aggregate value of `timeSpent` across all worklogs being moved in the source issue, and increases it in the destination issue.
     * @param overrideEditableFlag (optional) Whether the work log entry should be moved to and from the issues even if the issues are not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with admin permission can use this flag.
     * @return Returned if the request is partially successful.
     */
    bulkMoveWorklogs(issueIdOrKey: string, body: WorklogsMoveRequestBean, adjustEstimate?: AdjustEstimate3 | undefined, overrideEditableFlag?: boolean | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/worklog/move?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (adjustEstimate === null)
            throw new Error("The parameter 'adjustEstimate' cannot be null.");
        else if (adjustEstimate !== undefined)
            url_ += "adjustEstimate=" + encodeURIComponent("" + adjustEstimate) + "&";
        if (overrideEditableFlag === null)
            throw new Error("The parameter 'overrideEditableFlag' cannot be null.");
        else if (overrideEditableFlag !== undefined)
            url_ += "overrideEditableFlag=" + encodeURIComponent("" + overrideEditableFlag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http(options_).then((_response) => {
            return this.processBulkMoveWorklogs(_response);
        }, (_response) => {
            if (_response.status)
                return this.processBulkMoveWorklogs(_response);
            throw _response;
        });
    }

    protected processBulkMoveWorklogs(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  `request` is not provided or is invalid\n *  the user does not have permission to move the worklogs\n *  the number of worklogs being moved exceeds the limit\n *  the total size of worklogs being moved is too large\n *  any worklog contains attachments", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the source or destination issue is not found or the user does not have permission to view the issues\n *  at least one of the worklogs is not associated with the provided issue\n *  time tracking is disabled", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Delete worklog
     * @param issueIdOrKey The ID or key of the issue.
     * @param id The ID of the worklog.
     * @param notifyUsers (optional) Whether users watching the issue are notified by email.
     * @param adjustEstimate (optional) Defines how to update the issue's time estimate, the options are:

     *  `new` Sets the estimate to a specific value, defined in `newEstimate`.
     *  `leave` Leaves the estimate unchanged.
     *  `manual` Increases the estimate by amount specified in `increaseBy`.
     *  `auto` Reduces the estimate by the value of `timeSpent` in the worklog.
     * @param newEstimate (optional) The value to set as the issue's remaining time estimate, as days (\#d), hours (\#h), or minutes (\#m or \#). For example, *2d*. Required when `adjustEstimate` is `new`.
     * @param increaseBy (optional) The amount to increase the issue's remaining estimate by, as days (\#d), hours (\#h), or minutes (\#m or \#). For example, *2d*. Required when `adjustEstimate` is `manual`.
     * @param overrideEditableFlag (optional) Whether the work log entry should be added to the issue even if the issue is not editable, because jira.issue.editable set to false or missing. For example, the issue is closed. Connect and Forge app users with admin permission can use this flag.
     * @return Returned if the request is successful.
     */
    deleteWorklog(issueIdOrKey: string, id: string, notifyUsers?: boolean | undefined, adjustEstimate?: AdjustEstimate4 | undefined, newEstimate?: string | undefined, increaseBy?: string | undefined, overrideEditableFlag?: boolean | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/worklog/{id}?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (notifyUsers === null)
            throw new Error("The parameter 'notifyUsers' cannot be null.");
        else if (notifyUsers !== undefined)
            url_ += "notifyUsers=" + encodeURIComponent("" + notifyUsers) + "&";
        if (adjustEstimate === null)
            throw new Error("The parameter 'adjustEstimate' cannot be null.");
        else if (adjustEstimate !== undefined)
            url_ += "adjustEstimate=" + encodeURIComponent("" + adjustEstimate) + "&";
        if (newEstimate === null)
            throw new Error("The parameter 'newEstimate' cannot be null.");
        else if (newEstimate !== undefined)
            url_ += "newEstimate=" + encodeURIComponent("" + newEstimate) + "&";
        if (increaseBy === null)
            throw new Error("The parameter 'increaseBy' cannot be null.");
        else if (increaseBy !== undefined)
            url_ += "increaseBy=" + encodeURIComponent("" + increaseBy) + "&";
        if (overrideEditableFlag === null)
            throw new Error("The parameter 'overrideEditableFlag' cannot be null.");
        else if (overrideEditableFlag !== undefined)
            url_ += "overrideEditableFlag=" + encodeURIComponent("" + overrideEditableFlag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteWorklog(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteWorklog(_response);
            throw _response;
        });
    }

    protected processDeleteWorklog(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  `adjustEstimate` is set to `new` but `newEstimate` is not provided or is invalid.\n *  `adjustEstimate` is set to `manual` but `reduceBy` is not provided or is invalid.\n *  the user does not have permission to delete the worklog.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the issue is not found or user does not have permission to view the issue.\n *  the worklog is not found or the user does not have permission to view it.\n *  time tracking is disabled.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get worklog
     * @param issueIdOrKey The ID or key of the issue.
     * @param id The ID of the worklog.
     * @param expand (optional) Use [expand](#expansion) to include additional information about work logs in the response. This parameter accepts

    `properties`, which returns worklog properties.
     * @return Returned if the request is successful.
     */
    getWorklog(issueIdOrKey: string, id: string, expand?: string | undefined): ng.IPromise<Worklog> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/worklog/{id}?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetWorklog(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetWorklog(_response);
            throw _response;
        });
    }

    protected processGetWorklog(response: any): ng.IPromise<Worklog> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Worklog.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the issue is not found or the user does not have permission to view it.\n *  the worklog is not found or the user does not have permission to view it.\n *  time tracking is disabled.\n\n.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Worklog>(null as any);
    }

    /**
     * Update worklog
     * @param issueIdOrKey The ID or key the issue.
     * @param id The ID of the worklog.
     * @param notifyUsers (optional) Whether users watching the issue are notified by email.
     * @param adjustEstimate (optional) Defines how to update the issue's time estimate, the options are:

     *  `new` Sets the estimate to a specific value, defined in `newEstimate`.
     *  `leave` Leaves the estimate unchanged.
     *  `auto` Updates the estimate by the difference between the original and updated value of `timeSpent` or `timeSpentSeconds`.
     * @param newEstimate (optional) The value to set as the issue's remaining time estimate, as days (\#d), hours (\#h), or minutes (\#m or \#). For example, *2d*. Required when `adjustEstimate` is `new`.
     * @param expand (optional) Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts `properties`, which returns worklog properties.
     * @param overrideEditableFlag (optional) Whether the worklog should be added to the issue even if the issue is not editable. For example, because the issue is closed. Connect and Forge app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) can use this flag.
     * @return Returned if the request is successful
     */
    updateWorklog(issueIdOrKey: string, id: string, body: Worklog, notifyUsers?: boolean | undefined, adjustEstimate?: AdjustEstimate5 | undefined, newEstimate?: string | undefined, expand?: string | undefined, overrideEditableFlag?: boolean | undefined): ng.IPromise<Worklog> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/worklog/{id}?";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (notifyUsers === null)
            throw new Error("The parameter 'notifyUsers' cannot be null.");
        else if (notifyUsers !== undefined)
            url_ += "notifyUsers=" + encodeURIComponent("" + notifyUsers) + "&";
        if (adjustEstimate === null)
            throw new Error("The parameter 'adjustEstimate' cannot be null.");
        else if (adjustEstimate !== undefined)
            url_ += "adjustEstimate=" + encodeURIComponent("" + adjustEstimate) + "&";
        if (newEstimate === null)
            throw new Error("The parameter 'newEstimate' cannot be null.");
        else if (newEstimate !== undefined)
            url_ += "newEstimate=" + encodeURIComponent("" + newEstimate) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (overrideEditableFlag === null)
            throw new Error("The parameter 'overrideEditableFlag' cannot be null.");
        else if (overrideEditableFlag !== undefined)
            url_ += "overrideEditableFlag=" + encodeURIComponent("" + overrideEditableFlag) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateWorklog(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateWorklog(_response);
            throw _response;
        });
    }

    protected processUpdateWorklog(response: any): ng.IPromise<Worklog> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Worklog.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  `adjustEstimate` is set to `new` but `newEstimate` is not provided or is invalid.\n *  the user does not have permission to update the worklog.\n *  the request JSON is malformed.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the issue is not found or user does not have permission to view the issue.\n *  the worklog is not found or the user does not have permission to view it.\n *  time tracking is disabled.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Worklog>(null as any);
    }

    /**
     * Get worklog property keys
     * @param issueIdOrKey The ID or key of the issue.
     * @param worklogId The ID of the worklog.
     * @return Returned if the request is successful.
     */
    getWorklogPropertyKeys(issueIdOrKey: string, worklogId: string): ng.IPromise<PropertyKeys> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/worklog/{worklogId}/properties";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (worklogId === undefined || worklogId === null)
            throw new Error("The parameter 'worklogId' must be defined.");
        url_ = url_.replace("{worklogId}", encodeURIComponent("" + worklogId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetWorklogPropertyKeys(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetWorklogPropertyKeys(_response);
            throw _response;
        });
    }

    protected processGetWorklogPropertyKeys(response: any): ng.IPromise<PropertyKeys> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyKeys.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the worklog ID is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the issue or worklog is not found.\n *  the user does not have permission to view the issue or worklog.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PropertyKeys>(null as any);
    }

    /**
     * Delete worklog property
     * @param issueIdOrKey The ID or key of the issue.
     * @param worklogId The ID of the worklog.
     * @param propertyKey The key of the property.
     * @return Returned if the worklog property is removed.
     */
    deleteWorklogProperty(issueIdOrKey: string, worklogId: string, propertyKey: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/worklog/{worklogId}/properties/{propertyKey}";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (worklogId === undefined || worklogId === null)
            throw new Error("The parameter 'worklogId' must be defined.");
        url_ = url_.replace("{worklogId}", encodeURIComponent("" + worklogId));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteWorklogProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteWorklogProperty(_response);
            throw _response;
        });
    }

    protected processDeleteWorklogProperty(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the worklog key or id is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to edit the worklog.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the issue, worklog, or property is not found.\n *  the user does not have permission to view the issue or worklog.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get worklog property
     * @param issueIdOrKey The ID or key of the issue.
     * @param worklogId The ID of the worklog.
     * @param propertyKey The key of the property.
     * @return Returned if the request is successful.
     */
    getWorklogProperty(issueIdOrKey: string, worklogId: string, propertyKey: string): ng.IPromise<EntityProperty> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/worklog/{worklogId}/properties/{propertyKey}";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (worklogId === undefined || worklogId === null)
            throw new Error("The parameter 'worklogId' must be defined.");
        url_ = url_.replace("{worklogId}", encodeURIComponent("" + worklogId));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetWorklogProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetWorklogProperty(_response);
            throw _response;
        });
    }

    protected processGetWorklogProperty(response: any): ng.IPromise<EntityProperty> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityProperty.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the worklog ID is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the issue, worklog, or property is not found.\n *  the user does not have permission to view the issue or worklog.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<EntityProperty>(null as any);
    }

    /**
     * Set worklog property
     * @param issueIdOrKey The ID or key of the issue.
     * @param worklogId The ID of the worklog.
     * @param propertyKey The key of the issue property. The maximum length is 255 characters.
     * @param body The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes.
     * @return Returned if the worklog property is updated.
     */
    setWorklogProperty(issueIdOrKey: string, worklogId: string, propertyKey: string, body: any): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issue/{issueIdOrKey}/worklog/{worklogId}/properties/{propertyKey}";
        if (issueIdOrKey === undefined || issueIdOrKey === null)
            throw new Error("The parameter 'issueIdOrKey' must be defined.");
        url_ = url_.replace("{issueIdOrKey}", encodeURIComponent("" + issueIdOrKey));
        if (worklogId === undefined || worklogId === null)
            throw new Error("The parameter 'worklogId' must be defined.");
        url_ = url_.replace("{worklogId}", encodeURIComponent("" + worklogId));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetWorklogProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetWorklogProperty(_response);
            throw _response;
        });
    }

    protected processSetWorklogProperty(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the worklog ID is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to edit the worklog.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the issue or worklog is not found.\n *  the user does not have permission to view the issue or worklog.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Create issue link
     * @param body The issue link request.
     * @return Returned if the request is successful.
     */
    linkIssues(body: LinkIssueRequestJsonBean): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issueLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processLinkIssues(_response);
        }, (_response) => {
            if (_response.status)
                return this.processLinkIssues(_response);
            throw _response;
        });
    }

    protected processLinkIssues(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the comment is not created. The response contains an error message indicating why the comment wasn\'t created. The issue link is also not created.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  issue linking is disabled.\n *  the user cannot view one or both of the issues. For example, the user doesn\'t have *Browse project* project permission for a project containing one of the issues.\n *  the user does not have *link issues* project permission.\n *  either of the link issues are not found.\n *  the issue link type is not found.", status, _responseText, _headers);

        } else if (status === 413) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the per-issue limit for issue links has been breached.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Delete issue link
     * @param linkId The ID of the issue link.
     * @return 200 response
     */
    deleteIssueLink(linkId: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issueLink/{linkId}";
        if (linkId === undefined || linkId === null)
            throw new Error("The parameter 'linkId' must be defined.");
        url_ = url_.replace("{linkId}", encodeURIComponent("" + linkId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteIssueLink(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteIssueLink(_response);
            throw _response;
        });
    }

    protected processDeleteIssueLink(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue link ID is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  issue linking is disabled.\n *  the issue link is not found.\n *  the user doesn\'t have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get issue link
     * @param linkId The ID of the issue link.
     * @return Returned if the request is successful.
     */
    getIssueLink(linkId: string): ng.IPromise<IssueLink> {
        let url_ = this.baseUrl + "/rest/api/3/issueLink/{linkId}";
        if (linkId === undefined || linkId === null)
            throw new Error("The parameter 'linkId' must be defined.");
        url_ = url_.replace("{linkId}", encodeURIComponent("" + linkId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueLink(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueLink(_response);
            throw _response;
        });
    }

    protected processGetIssueLink(response: any): ng.IPromise<IssueLink> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueLink.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue link ID is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  issue linking is disabled.\n *  the issue link is not found.\n *  the user doesn\'t have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueLink>(null as any);
    }

    /**
     * Get issue link types
     * @return Returned if the request is successful.
     */
    getIssueLinkTypes(): ng.IPromise<IssueLinkTypes> {
        let url_ = this.baseUrl + "/rest/api/3/issueLinkType";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueLinkTypes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueLinkTypes(_response);
            throw _response;
        });
    }

    protected processGetIssueLinkTypes(response: any): ng.IPromise<IssueLinkTypes> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueLinkTypes.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if issue linking is disabled.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueLinkTypes>(null as any);
    }

    /**
     * Create issue link type
     * @return Returned if the request is successful.
     */
    createIssueLinkType(body: IssueLinkType): ng.IPromise<IssueLinkType> {
        let url_ = this.baseUrl + "/rest/api/3/issueLinkType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateIssueLinkType(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateIssueLinkType(_response);
            throw _response;
        });
    }

    protected processCreateIssueLinkType(response: any): ng.IPromise<IssueLinkType> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = IssueLinkType.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  issue linking is disabled.\n *  the issue link type name is in use.\n *  the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueLinkType>(null as any);
    }

    /**
     * Delete issue link type
     * @param issueLinkTypeId The ID of the issue link type.
     * @return Returned if the request is successful.
     */
    deleteIssueLinkType(issueLinkTypeId: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issueLinkType/{issueLinkTypeId}";
        if (issueLinkTypeId === undefined || issueLinkTypeId === null)
            throw new Error("The parameter 'issueLinkTypeId' must be defined.");
        url_ = url_.replace("{issueLinkTypeId}", encodeURIComponent("" + issueLinkTypeId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteIssueLinkType(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteIssueLinkType(_response);
            throw _response;
        });
    }

    protected processDeleteIssueLinkType(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue link type ID is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  issue linking is disabled.\n *  the issue link type is not found.\n *  the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get issue link type
     * @param issueLinkTypeId The ID of the issue link type.
     * @return Returned if the request is successful.
     */
    getIssueLinkType(issueLinkTypeId: string): ng.IPromise<IssueLinkType> {
        let url_ = this.baseUrl + "/rest/api/3/issueLinkType/{issueLinkTypeId}";
        if (issueLinkTypeId === undefined || issueLinkTypeId === null)
            throw new Error("The parameter 'issueLinkTypeId' must be defined.");
        url_ = url_.replace("{issueLinkTypeId}", encodeURIComponent("" + issueLinkTypeId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueLinkType(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueLinkType(_response);
            throw _response;
        });
    }

    protected processGetIssueLinkType(response: any): ng.IPromise<IssueLinkType> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueLinkType.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue link type ID is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  issue linking is disabled.\n *  the issue link type is not found.\n *  the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueLinkType>(null as any);
    }

    /**
     * Update issue link type
     * @param issueLinkTypeId The ID of the issue link type.
     * @return Returned if the request is successful.
     */
    updateIssueLinkType(issueLinkTypeId: string, body: IssueLinkType): ng.IPromise<IssueLinkType> {
        let url_ = this.baseUrl + "/rest/api/3/issueLinkType/{issueLinkTypeId}";
        if (issueLinkTypeId === undefined || issueLinkTypeId === null)
            throw new Error("The parameter 'issueLinkTypeId' must be defined.");
        url_ = url_.replace("{issueLinkTypeId}", encodeURIComponent("" + issueLinkTypeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateIssueLinkType(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateIssueLinkType(_response);
            throw _response;
        });
    }

    protected processUpdateIssueLinkType(response: any): ng.IPromise<IssueLinkType> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueLinkType.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue link type ID or the request body are invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  issue linking is disabled.\n *  the issue link type is not found.\n *  the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueLinkType>(null as any);
    }

    /**
     * Export archived issue(s)
     * @param body You can filter the issues in your request by the `projects`, `archivedBy`, `archivedDate`, `issueTypes`, and `reporters` fields. All filters are optional. If you don't provide any filters, you'll get a list of up to one million archived issues.
     * @return Returns the details of your export task. You can use the [get task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-get) API to view the progress of your request.
     */
    exportArchivedIssues(body: ArchivedIssuesFilterRequest): ng.IPromise<ExportArchivedIssuesTaskProgressResponse> {
        let url_ = this.baseUrl + "/rest/api/3/issues/archive/export";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processExportArchivedIssues(_response);
        }, (_response) => {
            if (_response.status)
                return this.processExportArchivedIssues(_response);
            throw _response;
        });
    }

    protected processExportArchivedIssues(response: any): ng.IPromise<ExportArchivedIssuesTaskProgressResponse> {
        const status = response.status;

        let _headers: any = {};
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = ExportArchivedIssuesTaskProgressResponse.fromJS(resultData202);
            return this.q.resolve(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned when:\n\n *  The request is invalid, or the filters provided are incorrect\n *  You requested too many issues for export. The limit is one million issues per request", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if no issues were unarchived because the provided authentication credentials are either missing or invalid.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if no issues were unarchived because the user lacks the required Jira admin or site admin permissions.", status, _responseText, _headers);

        } else if (status === 412) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if a request to export archived issues is already running.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ExportArchivedIssuesTaskProgressResponse>(null as any);
    }

    /**
     * Get issue security schemes
     * @return Returned if the request is successful.
     */
    getIssueSecuritySchemes(): ng.IPromise<SecuritySchemes> {
        let url_ = this.baseUrl + "/rest/api/3/issuesecurityschemes";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueSecuritySchemes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueSecuritySchemes(_response);
            throw _response;
        });
    }

    protected processGetIssueSecuritySchemes(response: any): ng.IPromise<SecuritySchemes> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecuritySchemes.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to administer issue security schemes.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SecuritySchemes>(null as any);
    }

    /**
     * Create issue security scheme
     * @return Returned if the request is successful.
     */
    createIssueSecurityScheme(body: CreateIssueSecuritySchemeDetails): ng.IPromise<SecuritySchemeId> {
        let url_ = this.baseUrl + "/rest/api/3/issuesecurityschemes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateIssueSecurityScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateIssueSecurityScheme(_response);
            throw _response;
        });
    }

    protected processCreateIssueSecurityScheme(response: any): ng.IPromise<SecuritySchemeId> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SecuritySchemeId.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SecuritySchemeId>(null as any);
    }

    /**
     * Get issue security levels
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param id (optional) The list of issue security scheme level IDs. To include multiple issue security levels, separate IDs with an ampersand: `id=10000&id=10001`.
     * @param schemeId (optional) The list of issue security scheme IDs. To include multiple issue security schemes, separate IDs with an ampersand: `schemeId=10000&schemeId=10001`.
     * @param onlyDefault (optional) When set to true, returns multiple default levels for each security scheme containing a default. If you provide scheme and level IDs not associated with the default, returns an empty page. The default value is false.
     * @return Returned if the request is successful.
     */
    getSecurityLevels(startAt?: string | undefined, maxResults?: string | undefined, id?: string[] | undefined, schemeId?: string[] | undefined, onlyDefault?: boolean | undefined): ng.IPromise<PageBeanSecurityLevel> {
        let url_ = this.baseUrl + "/rest/api/3/issuesecurityschemes/level?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (schemeId === null)
            throw new Error("The parameter 'schemeId' cannot be null.");
        else if (schemeId !== undefined)
            schemeId && schemeId.forEach(item => { url_ += "schemeId=" + encodeURIComponent("" + item) + "&"; });
        if (onlyDefault === null)
            throw new Error("The parameter 'onlyDefault' cannot be null.");
        else if (onlyDefault !== undefined)
            url_ += "onlyDefault=" + encodeURIComponent("" + onlyDefault) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetSecurityLevels(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetSecurityLevels(_response);
            throw _response;
        });
    }

    protected processGetSecurityLevels(response: any): ng.IPromise<PageBeanSecurityLevel> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanSecurityLevel.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanSecurityLevel>(null as any);
    }

    /**
     * Set default issue security levels
     * @return Returned if the request is successful.
     */
    setDefaultLevels(body: SetDefaultLevelsRequest): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuesecurityschemes/level/default";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetDefaultLevels(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetDefaultLevels(_response);
            throw _response;
        });
    }

    protected processSetDefaultLevels(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the issue resolution isn\'t found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get issue security level members
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param id (optional) The list of issue security level member IDs. To include multiple issue security level members separate IDs with an ampersand: `id=10000&id=10001`.
     * @param schemeId (optional) The list of issue security scheme IDs. To include multiple issue security schemes separate IDs with an ampersand: `schemeId=10000&schemeId=10001`.
     * @param levelId (optional) The list of issue security level IDs. To include multiple issue security levels separate IDs with an ampersand: `levelId=10000&levelId=10001`.
     * @param expand (optional) Use expand to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `all` Returns all expandable information
     *  `field` Returns information about the custom field granted the permission
     *  `group` Returns information about the group that is granted the permission
     *  `projectRole` Returns information about the project role granted the permission
     *  `user` Returns information about the user who is granted the permission
     * @return Returned if the request is successful.
     */
    getSecurityLevelMembers(startAt?: string | undefined, maxResults?: string | undefined, id?: string[] | undefined, schemeId?: string[] | undefined, levelId?: string[] | undefined, expand?: string | undefined): ng.IPromise<PageBeanSecurityLevelMember> {
        let url_ = this.baseUrl + "/rest/api/3/issuesecurityschemes/level/member?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (schemeId === null)
            throw new Error("The parameter 'schemeId' cannot be null.");
        else if (schemeId !== undefined)
            schemeId && schemeId.forEach(item => { url_ += "schemeId=" + encodeURIComponent("" + item) + "&"; });
        if (levelId === null)
            throw new Error("The parameter 'levelId' cannot be null.");
        else if (levelId !== undefined)
            levelId && levelId.forEach(item => { url_ += "levelId=" + encodeURIComponent("" + item) + "&"; });
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetSecurityLevelMembers(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetSecurityLevelMembers(_response);
            throw _response;
        });
    }

    protected processGetSecurityLevelMembers(response: any): ng.IPromise<PageBeanSecurityLevelMember> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanSecurityLevelMember.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanSecurityLevelMember>(null as any);
    }

    /**
     * Get projects using issue security schemes
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param issueSecuritySchemeId (optional) The list of security scheme IDs to be filtered out.
     * @param projectId (optional) The list of project IDs to be filtered out.
     * @return Returned if the request is successful.
     */
    searchProjectsUsingSecuritySchemes(startAt?: string | undefined, maxResults?: string | undefined, issueSecuritySchemeId?: string[] | undefined, projectId?: string[] | undefined): ng.IPromise<PageBeanIssueSecuritySchemeToProjectMapping> {
        let url_ = this.baseUrl + "/rest/api/3/issuesecurityschemes/project?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (issueSecuritySchemeId === null)
            throw new Error("The parameter 'issueSecuritySchemeId' cannot be null.");
        else if (issueSecuritySchemeId !== undefined)
            issueSecuritySchemeId && issueSecuritySchemeId.forEach(item => { url_ += "issueSecuritySchemeId=" + encodeURIComponent("" + item) + "&"; });
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            projectId && projectId.forEach(item => { url_ += "projectId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSearchProjectsUsingSecuritySchemes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSearchProjectsUsingSecuritySchemes(_response);
            throw _response;
        });
    }

    protected processSearchProjectsUsingSecuritySchemes(response: any): ng.IPromise<PageBeanIssueSecuritySchemeToProjectMapping> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanIssueSecuritySchemeToProjectMapping.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the search criteria is invalid.If you specify the project ID parameter", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanIssueSecuritySchemeToProjectMapping>(null as any);
    }

    /**
     * Associate security scheme to project
     */
    associateSchemesToProjects(body: AssociateSecuritySchemeWithProjectDetails): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issuesecurityschemes/project";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAssociateSchemesToProjects(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAssociateSchemesToProjects(_response);
            throw _response;
        });
    }

    protected processAssociateSchemesToProjects(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 303) {
            const _responseText = response.data;
            let result303: any = null;
            let resultData303 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result303 = TaskProgressBeanObject.fromJS(resultData303);
            return throwException(this.q, "Returned if the request is successful.", status, _responseText, _headers, result303);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the security scheme isn\'t found.", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorCollection.fromJS(resultData409);
            return throwException(this.q, "Returned if a task to remove the issue security level is already running.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Search issue security schemes
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param id (optional) The list of issue security scheme IDs. To include multiple issue security scheme IDs, separate IDs with an ampersand: `id=10000&id=10001`.
     * @param projectId (optional) The list of project IDs. To include multiple project IDs, separate IDs with an ampersand: `projectId=10000&projectId=10001`.
     * @return Returned if the request is successful.
     */
    searchSecuritySchemes(startAt?: string | undefined, maxResults?: string | undefined, id?: string[] | undefined, projectId?: string[] | undefined): ng.IPromise<PageBeanSecuritySchemeWithProjects> {
        let url_ = this.baseUrl + "/rest/api/3/issuesecurityschemes/search?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            projectId && projectId.forEach(item => { url_ += "projectId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSearchSecuritySchemes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSearchSecuritySchemes(_response);
            throw _response;
        });
    }

    protected processSearchSecuritySchemes(response: any): ng.IPromise<PageBeanSecuritySchemeWithProjects> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanSecuritySchemeWithProjects.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanSecuritySchemeWithProjects>(null as any);
    }

    /**
     * Get issue security scheme
     * @param id The ID of the issue security scheme. Use the [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get) operation to get a list of issue security scheme IDs.
     * @return Returned if the request is successful.
     */
    getIssueSecurityScheme(id: number): ng.IPromise<SecurityScheme> {
        let url_ = this.baseUrl + "/rest/api/3/issuesecurityschemes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueSecurityScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueSecurityScheme(_response);
            throw _response;
        });
    }

    protected processGetIssueSecurityScheme(response: any): ng.IPromise<SecurityScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the administrator permission and the scheme is not used in any project where the user has administrative permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SecurityScheme>(null as any);
    }

    /**
     * Update issue security scheme
     * @param id The ID of the issue security scheme.
     * @return Returned if the request is successful.
     */
    updateIssueSecurityScheme(id: string, body: UpdateIssueSecuritySchemeRequestBean): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuesecurityschemes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateIssueSecurityScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateIssueSecurityScheme(_response);
            throw _response;
        });
    }

    protected processUpdateIssueSecurityScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the issue security scheme isn\'t found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get issue security level members by issue security scheme
     * @param issueSecuritySchemeId The ID of the issue security scheme. Use the [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get) operation to get a list of issue security scheme IDs.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param issueSecurityLevelId (optional) The list of issue security level IDs. To include multiple issue security levels separate IDs with ampersand: `issueSecurityLevelId=10000&issueSecurityLevelId=10001`.
     * @param expand (optional) Use expand to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `all` Returns all expandable information.
     *  `field` Returns information about the custom field granted the permission.
     *  `group` Returns information about the group that is granted the permission.
     *  `projectRole` Returns information about the project role granted the permission.
     *  `user` Returns information about the user who is granted the permission.
     * @return Returned if the request is successful.
     */
    getIssueSecurityLevelMembers(issueSecuritySchemeId: number, startAt?: number | undefined, maxResults?: number | undefined, issueSecurityLevelId?: string[] | undefined, expand?: string | undefined): ng.IPromise<PageBeanIssueSecurityLevelMember> {
        let url_ = this.baseUrl + "/rest/api/3/issuesecurityschemes/{issueSecuritySchemeId}/members?";
        if (issueSecuritySchemeId === undefined || issueSecuritySchemeId === null)
            throw new Error("The parameter 'issueSecuritySchemeId' must be defined.");
        url_ = url_.replace("{issueSecuritySchemeId}", encodeURIComponent("" + issueSecuritySchemeId));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (issueSecurityLevelId === null)
            throw new Error("The parameter 'issueSecurityLevelId' cannot be null.");
        else if (issueSecurityLevelId !== undefined)
            issueSecurityLevelId && issueSecurityLevelId.forEach(item => { url_ += "issueSecurityLevelId=" + encodeURIComponent("" + item) + "&"; });
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueSecurityLevelMembers(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueSecurityLevelMembers(_response);
            throw _response;
        });
    }

    protected processGetIssueSecurityLevelMembers(response: any): ng.IPromise<PageBeanIssueSecurityLevelMember> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanIssueSecurityLevelMember.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if no issue security level members are found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanIssueSecurityLevelMember>(null as any);
    }

    /**
     * Delete issue security scheme
     * @param schemeId The ID of the issue security scheme.
     * @return Returned if the request is successful.
     */
    deleteSecurityScheme(schemeId: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuesecurityschemes/{schemeId}";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteSecurityScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteSecurityScheme(_response);
            throw _response;
        });
    }

    protected processDeleteSecurityScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the issue security scheme isn\'t found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Add issue security levels
     * @param schemeId The ID of the issue security scheme.
     * @return Returned if the request is successful.
     */
    addSecurityLevel(schemeId: string, body: AddSecuritySchemeLevelsRequestBean): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuesecurityschemes/{schemeId}/level";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddSecurityLevel(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddSecurityLevel(_response);
            throw _response;
        });
    }

    protected processAddSecurityLevel(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the security scheme isn\'t found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Remove issue security level
     * @param schemeId The ID of the issue security scheme.
     * @param levelId The ID of the issue security level to remove.
     * @param replaceWith (optional) The ID of the issue security level that will replace the currently selected level.
     */
    removeLevel(schemeId: string, levelId: string, replaceWith?: string | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issuesecurityschemes/{schemeId}/level/{levelId}?";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (levelId === undefined || levelId === null)
            throw new Error("The parameter 'levelId' must be defined.");
        url_ = url_.replace("{levelId}", encodeURIComponent("" + levelId));
        if (replaceWith === null)
            throw new Error("The parameter 'replaceWith' cannot be null.");
        else if (replaceWith !== undefined)
            url_ += "replaceWith=" + encodeURIComponent("" + replaceWith) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveLevel(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveLevel(_response);
            throw _response;
        });
    }

    protected processRemoveLevel(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 303) {
            const _responseText = response.data;
            let result303: any = null;
            let resultData303 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result303 = TaskProgressBeanObject.fromJS(resultData303);
            return throwException(this.q, "Returned if the request is successful.", status, _responseText, _headers, result303);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the issue security level isn\'t found.", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorCollection.fromJS(resultData409);
            return throwException(this.q, "Returned if a task to remove the issue security level is already running.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Update issue security level
     * @param schemeId The ID of the issue security scheme level belongs to.
     * @param levelId The ID of the issue security level to update.
     * @return Returned if the request is successful.
     */
    updateSecurityLevel(schemeId: string, levelId: string, body: UpdateIssueSecurityLevelDetails): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuesecurityschemes/{schemeId}/level/{levelId}";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (levelId === undefined || levelId === null)
            throw new Error("The parameter 'levelId' must be defined.");
        url_ = url_.replace("{levelId}", encodeURIComponent("" + levelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateSecurityLevel(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateSecurityLevel(_response);
            throw _response;
        });
    }

    protected processUpdateSecurityLevel(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the issue security level isn\'t found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Add issue security level members
     * @param schemeId The ID of the issue security scheme.
     * @param levelId The ID of the issue security level.
     * @return Returned if the request is successful.
     */
    addSecurityLevelMembers(schemeId: string, levelId: string, body: SecuritySchemeMembersRequest): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuesecurityschemes/{schemeId}/level/{levelId}/member";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (levelId === undefined || levelId === null)
            throw new Error("The parameter 'levelId' must be defined.");
        url_ = url_.replace("{levelId}", encodeURIComponent("" + levelId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddSecurityLevelMembers(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddSecurityLevelMembers(_response);
            throw _response;
        });
    }

    protected processAddSecurityLevelMembers(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the security scheme isn\'t found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Remove member from issue security level
     * @param schemeId The ID of the issue security scheme.
     * @param levelId The ID of the issue security level.
     * @param memberId The ID of the issue security level member to be removed.
     * @return Returned if the request is successful.
     */
    removeMemberFromSecurityLevel(schemeId: string, levelId: string, memberId: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuesecurityschemes/{schemeId}/level/{levelId}/member/{memberId}";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (levelId === undefined || levelId === null)
            throw new Error("The parameter 'levelId' must be defined.");
        url_ = url_.replace("{levelId}", encodeURIComponent("" + levelId));
        if (memberId === undefined || memberId === null)
            throw new Error("The parameter 'memberId' must be defined.");
        url_ = url_.replace("{memberId}", encodeURIComponent("" + memberId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveMemberFromSecurityLevel(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveMemberFromSecurityLevel(_response);
            throw _response;
        });
    }

    protected processRemoveMemberFromSecurityLevel(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the security scheme isn\'t found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get all issue types for user
     * @return Returned if the request is successful.
     */
    getIssueAllTypes(): ng.IPromise<IssueTypeDetails[]> {
        let url_ = this.baseUrl + "/rest/api/3/issuetype";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueAllTypes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueAllTypes(_response);
            throw _response;
        });
    }

    protected processGetIssueAllTypes(response: any): ng.IPromise<IssueTypeDetails[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IssueTypeDetails.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueTypeDetails[]>(null as any);
    }

    /**
     * Create issue type
     * @return Returned if the request is successful.
     */
    createIssueType(body: IssueTypeCreateBean): ng.IPromise<IssueTypeDetails> {
        let url_ = this.baseUrl + "/rest/api/3/issuetype";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateIssueType(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateIssueType(_response);
            throw _response;
        });
    }

    protected processCreateIssueType(response: any): ng.IPromise<IssueTypeDetails> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = IssueTypeDetails.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid because:\n\n *  no content is sent.\n *  the issue type name exceeds 60 characters.\n *  a subtask issue type is requested on an instance where subtasks are disabled.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type name is in use.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueTypeDetails>(null as any);
    }

    /**
     * Get issue types for project
     * @param projectId The ID of the project.
     * @param level (optional) The level of the issue type to filter by. Use:

     *  `-1` for Subtask.
     *  `0` for Base.
     *  `1` for Epic.
     * @return Returned if the request is successful.
     */
    getIssueTypesForProject(projectId: number, level?: number | undefined): ng.IPromise<IssueTypeDetails[]> {
        let url_ = this.baseUrl + "/rest/api/3/issuetype/project?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (level === null)
            throw new Error("The parameter 'level' cannot be null.");
        else if (level !== undefined)
            url_ += "level=" + encodeURIComponent("" + level) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueTypesForProject(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueTypesForProject(_response);
            throw _response;
        });
    }

    protected processGetIssueTypesForProject(response: any): ng.IPromise<IssueTypeDetails[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IssueTypeDetails.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the project is not found.\n *  the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueTypeDetails[]>(null as any);
    }

    /**
     * Delete issue type
     * @param id The ID of the issue type.
     * @param alternativeIssueTypeId (optional) The ID of the replacement issue type.
     * @return Returned if the request is successful.
     */
    deleteIssueType(id: string, alternativeIssueTypeId?: string | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issuetype/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (alternativeIssueTypeId === null)
            throw new Error("The parameter 'alternativeIssueTypeId' cannot be null.");
        else if (alternativeIssueTypeId !== undefined)
            url_ += "alternativeIssueTypeId=" + encodeURIComponent("" + alternativeIssueTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteIssueType(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteIssueType(_response);
            throw _response;
        });
    }

    protected processDeleteIssueType(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if any issues cannot be updated with the alternative issue type.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the issue type is in use and an alternative issue type is not specified.\n *  the issue type or alternative issue type is not found.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type is in use and:\n\n *  also specified as the alternative issue type.\n *  is a *standard* issue type and the alternative issue type is a *subtask*.", status, _responseText, _headers);

        } else if (status === 423) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if a resource related to deletion is locked.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get issue type
     * @param id The ID of the issue type.
     * @return Returned if the request is successful.
     */
    getIssueType(id: string): ng.IPromise<IssueTypeDetails> {
        let url_ = this.baseUrl + "/rest/api/3/issuetype/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueType(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueType(_response);
            throw _response;
        });
    }

    protected processGetIssueType(response: any): ng.IPromise<IssueTypeDetails> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueTypeDetails.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type ID is invalid.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the issue type is not found.\n *  the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueTypeDetails>(null as any);
    }

    /**
     * Update issue type
     * @param id The ID of the issue type.
     * @return Returned if the request is successful.
     */
    updateIssueType(id: string, body: IssueTypeUpdateBean): ng.IPromise<IssueTypeDetails> {
        let url_ = this.baseUrl + "/rest/api/3/issuetype/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateIssueType(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateIssueType(_response);
            throw _response;
        });
    }

    protected processUpdateIssueType(response: any): ng.IPromise<IssueTypeDetails> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueTypeDetails.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid because:\n\n *  no content is sent.\n *  the issue type name exceeds 60 characters.\n *  the avatar is not associated with this issue type.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type is not found.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type name is in use.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueTypeDetails>(null as any);
    }

    /**
     * Get alternative issue types
     * @param id The ID of the issue type.
     * @return Returned if the request is successful.
     */
    getAlternativeIssueTypes(id: string): ng.IPromise<IssueTypeDetails[]> {
        let url_ = this.baseUrl + "/rest/api/3/issuetype/{id}/alternatives";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAlternativeIssueTypes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAlternativeIssueTypes(_response);
            throw _response;
        });
    }

    protected processGetAlternativeIssueTypes(response: any): ng.IPromise<IssueTypeDetails[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IssueTypeDetails.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the issue type is not found.\n *  the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueTypeDetails[]>(null as any);
    }

    /**
     * Load issue type avatar
     * @param id The ID of the issue type.
     * @param size The length of each side of the crop region.
     * @param x (optional) The X coordinate of the top-left corner of the crop region.
     * @param y (optional) The Y coordinate of the top-left corner of the crop region.
     * @return Returned if the request is successful.
     */
    createIssueTypeAvatar(id: string, size: number, body: any, x?: number | undefined, y?: number | undefined): ng.IPromise<Avatar> {
        let url_ = this.baseUrl + "/rest/api/3/issuetype/{id}/avatar2?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined and cannot be null.");
        else
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (x === null)
            throw new Error("The parameter 'x' cannot be null.");
        else if (x !== undefined)
            url_ += "x=" + encodeURIComponent("" + x) + "&";
        if (y === null)
            throw new Error("The parameter 'y' cannot be null.");
        else if (y !== undefined)
            url_ += "y=" + encodeURIComponent("" + y) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "*/*",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateIssueTypeAvatar(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateIssueTypeAvatar(_response);
            throw _response;
        });
    }

    protected processCreateIssueTypeAvatar(response: any): ng.IPromise<Avatar> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Avatar.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  an image isn\'t included in the request.\n *  the image type is unsupported.\n *  the crop parameters extend the crop area beyond the edge of the image.\n *  `cropSize` is missing.\n *  the issue type ID is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Avatar>(null as any);
    }

    /**
     * Get issue type property keys
     * @param issueTypeId The ID of the issue type.
     * @return Returned if the request is successful.
     */
    getIssueTypePropertyKeys(issueTypeId: string): ng.IPromise<PropertyKeys> {
        let url_ = this.baseUrl + "/rest/api/3/issuetype/{issueTypeId}/properties";
        if (issueTypeId === undefined || issueTypeId === null)
            throw new Error("The parameter 'issueTypeId' must be defined.");
        url_ = url_.replace("{issueTypeId}", encodeURIComponent("" + issueTypeId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueTypePropertyKeys(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueTypePropertyKeys(_response);
            throw _response;
        });
    }

    protected processGetIssueTypePropertyKeys(response: any): ng.IPromise<PropertyKeys> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyKeys.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type ID is invalid.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the issue type is not found.\n *  the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PropertyKeys>(null as any);
    }

    /**
     * Delete issue type property
     * @param issueTypeId The ID of the issue type.
     * @param propertyKey The key of the property. Use [Get issue type property keys](#api-rest-api-3-issuetype-issueTypeId-properties-get) to get a list of all issue type property keys.
     * @return Returned if the issue type property is deleted.
     */
    deleteIssueTypeProperty(issueTypeId: string, propertyKey: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/issuetype/{issueTypeId}/properties/{propertyKey}";
        if (issueTypeId === undefined || issueTypeId === null)
            throw new Error("The parameter 'issueTypeId' must be defined.");
        url_ = url_.replace("{issueTypeId}", encodeURIComponent("" + issueTypeId));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteIssueTypeProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteIssueTypeProperty(_response);
            throw _response;
        });
    }

    protected processDeleteIssueTypeProperty(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type ID is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type or property is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get issue type property
     * @param issueTypeId The ID of the issue type.
     * @param propertyKey The key of the property. Use [Get issue type property keys](#api-rest-api-3-issuetype-issueTypeId-properties-get) to get a list of all issue type property keys.
     * @return Returned if the request is successful.
     */
    getIssueTypeProperty(issueTypeId: string, propertyKey: string): ng.IPromise<EntityProperty> {
        let url_ = this.baseUrl + "/rest/api/3/issuetype/{issueTypeId}/properties/{propertyKey}";
        if (issueTypeId === undefined || issueTypeId === null)
            throw new Error("The parameter 'issueTypeId' must be defined.");
        url_ = url_.replace("{issueTypeId}", encodeURIComponent("" + issueTypeId));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueTypeProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueTypeProperty(_response);
            throw _response;
        });
    }

    protected processGetIssueTypeProperty(response: any): ng.IPromise<EntityProperty> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityProperty.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type ID is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type or property is not found or the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<EntityProperty>(null as any);
    }

    /**
     * Set issue type property
     * @param issueTypeId The ID of the issue type.
     * @param propertyKey The key of the issue type property. The maximum length is 255 characters.
     * @param body The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes.
     * @return Returned if the issue type property is updated.
     */
    setIssueTypeProperty(issueTypeId: string, propertyKey: string, body: any): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuetype/{issueTypeId}/properties/{propertyKey}";
        if (issueTypeId === undefined || issueTypeId === null)
            throw new Error("The parameter 'issueTypeId' must be defined.");
        url_ = url_.replace("{issueTypeId}", encodeURIComponent("" + issueTypeId));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetIssueTypeProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetIssueTypeProperty(_response);
            throw _response;
        });
    }

    protected processSetIssueTypeProperty(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the issue type ID is invalid.\n *  a property value is not provided.\n *  the property value JSON content is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to modify the issue type.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the issue type is not found.\n *  the user does not have the permission view the issue type.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get all issue type schemes
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param id (optional) The list of issue type schemes IDs. To include multiple IDs, provide an ampersand-separated list. For example, `id=10000&id=10001`.
     * @param orderBy (optional) [Order](#ordering) the results by a field:

     *  `name` Sorts by issue type scheme name.
     *  `id` Sorts by issue type scheme ID.
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `projects` For each issue type schemes, returns information about the projects the issue type scheme is assigned to.
     *  `issueTypes` For each issue type schemes, returns information about the issueTypes the issue type scheme have.
     * @param queryString (optional) String used to perform a case-insensitive partial match with issue type scheme name.
     * @return Returned if the request is successful.
     */
    getAllIssueTypeSchemes(startAt?: number | undefined, maxResults?: number | undefined, id?: number[] | undefined, orderBy?: OrderBy7 | undefined, expand?: string | undefined, queryString?: string | undefined): ng.IPromise<PageBeanIssueTypeScheme> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescheme?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (queryString === null)
            throw new Error("The parameter 'queryString' cannot be null.");
        else if (queryString !== undefined)
            url_ += "queryString=" + encodeURIComponent("" + queryString) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllIssueTypeSchemes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllIssueTypeSchemes(_response);
            throw _response;
        });
    }

    protected processGetAllIssueTypeSchemes(response: any): ng.IPromise<PageBeanIssueTypeScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanIssueTypeScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanIssueTypeScheme>(null as any);
    }

    /**
     * Create issue type scheme
     * @return Returned if the request is successful.
     */
    createIssueTypeScheme(body: IssueTypeSchemeDetails): ng.IPromise<IssueTypeSchemeID> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateIssueTypeScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateIssueTypeScheme(_response);
            throw _response;
        });
    }

    protected processCreateIssueTypeScheme(response: any): ng.IPromise<IssueTypeSchemeID> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = IssueTypeSchemeID.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the scheme name is used by another scheme.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueTypeSchemeID>(null as any);
    }

    /**
     * Get issue type scheme items
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param issueTypeSchemeId (optional) The list of issue type scheme IDs. To include multiple IDs, provide an ampersand-separated list. For example, `issueTypeSchemeId=10000&issueTypeSchemeId=10001`.
     * @return Returned if the request is successful.
     */
    getIssueTypeSchemesMapping(startAt?: number | undefined, maxResults?: number | undefined, issueTypeSchemeId?: number[] | undefined): ng.IPromise<PageBeanIssueTypeSchemeMapping> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescheme/mapping?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (issueTypeSchemeId === null)
            throw new Error("The parameter 'issueTypeSchemeId' cannot be null.");
        else if (issueTypeSchemeId !== undefined)
            issueTypeSchemeId && issueTypeSchemeId.forEach(item => { url_ += "issueTypeSchemeId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueTypeSchemesMapping(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueTypeSchemesMapping(_response);
            throw _response;
        });
    }

    protected processGetIssueTypeSchemesMapping(response: any): ng.IPromise<PageBeanIssueTypeSchemeMapping> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanIssueTypeSchemeMapping.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanIssueTypeSchemeMapping>(null as any);
    }

    /**
     * Get issue type schemes for projects
     * @param projectId The list of project IDs. To include multiple project IDs, provide an ampersand-separated list. For example, `projectId=10000&projectId=10001`.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getIssueTypeSchemeForProjects(projectId: number[], startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanIssueTypeSchemeProjects> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescheme/project?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            projectId && projectId.forEach(item => { url_ += "projectId=" + encodeURIComponent("" + item) + "&"; });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueTypeSchemeForProjects(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueTypeSchemeForProjects(_response);
            throw _response;
        });
    }

    protected processGetIssueTypeSchemeForProjects(response: any): ng.IPromise<PageBeanIssueTypeSchemeProjects> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanIssueTypeSchemeProjects.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanIssueTypeSchemeProjects>(null as any);
    }

    /**
     * Assign issue type scheme to project
     * @return Returned if the request is successful.
     */
    assignIssueTypeSchemeToProject(body: IssueTypeSchemeProjectAssociation): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescheme/project";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAssignIssueTypeSchemeToProject(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAssignIssueTypeSchemeToProject(_response);
            throw _response;
        });
    }

    protected processAssignIssueTypeSchemeToProject(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type scheme or the project is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Delete issue type scheme
     * @param issueTypeSchemeId The ID of the issue type scheme.
     * @return Returned if the issue type scheme is deleted.
     */
    deleteIssueTypeScheme(issueTypeSchemeId: number): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescheme/{issueTypeSchemeId}";
        if (issueTypeSchemeId === undefined || issueTypeSchemeId === null)
            throw new Error("The parameter 'issueTypeSchemeId' must be defined.");
        url_ = url_.replace("{issueTypeSchemeId}", encodeURIComponent("" + issueTypeSchemeId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteIssueTypeScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteIssueTypeScheme(_response);
            throw _response;
        });
    }

    protected processDeleteIssueTypeScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is to delete the default issue type scheme.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Update issue type scheme
     * @param issueTypeSchemeId The ID of the issue type scheme.
     * @return Returned if the request is successful.
     */
    updateIssueTypeScheme(issueTypeSchemeId: number, body: IssueTypeSchemeUpdateDetails): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescheme/{issueTypeSchemeId}";
        if (issueTypeSchemeId === undefined || issueTypeSchemeId === null)
            throw new Error("The parameter 'issueTypeSchemeId' must be defined.");
        url_ = url_.replace("{issueTypeSchemeId}", encodeURIComponent("" + issueTypeSchemeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateIssueTypeScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateIssueTypeScheme(_response);
            throw _response;
        });
    }

    protected processUpdateIssueTypeScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Add issue types to issue type scheme
     * @param issueTypeSchemeId The ID of the issue type scheme.
     * @return Returned if the request is successful.
     */
    addIssueTypesToIssueTypeScheme(issueTypeSchemeId: number, body: IssueTypeIds): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescheme/{issueTypeSchemeId}/issuetype";
        if (issueTypeSchemeId === undefined || issueTypeSchemeId === null)
            throw new Error("The parameter 'issueTypeSchemeId' must be defined.");
        url_ = url_.replace("{issueTypeSchemeId}", encodeURIComponent("" + issueTypeSchemeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddIssueTypesToIssueTypeScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddIssueTypesToIssueTypeScheme(_response);
            throw _response;
        });
    }

    protected processAddIssueTypesToIssueTypeScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type or the issue type scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Change order of issue types
     * @param issueTypeSchemeId The ID of the issue type scheme.
     * @return Returned if the request is successful.
     */
    reorderIssueTypesInIssueTypeScheme(issueTypeSchemeId: number, body: OrderOfIssueTypes): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescheme/{issueTypeSchemeId}/issuetype/move";
        if (issueTypeSchemeId === undefined || issueTypeSchemeId === null)
            throw new Error("The parameter 'issueTypeSchemeId' must be defined.");
        url_ = url_.replace("{issueTypeSchemeId}", encodeURIComponent("" + issueTypeSchemeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processReorderIssueTypesInIssueTypeScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processReorderIssueTypesInIssueTypeScheme(_response);
            throw _response;
        });
    }

    protected processReorderIssueTypesInIssueTypeScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Remove issue type from issue type scheme
     * @param issueTypeSchemeId The ID of the issue type scheme.
     * @param issueTypeId The ID of the issue type.
     * @return Returned if the request is successful.
     */
    removeIssueTypeFromIssueTypeScheme(issueTypeSchemeId: number, issueTypeId: number): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescheme/{issueTypeSchemeId}/issuetype/{issueTypeId}";
        if (issueTypeSchemeId === undefined || issueTypeSchemeId === null)
            throw new Error("The parameter 'issueTypeSchemeId' must be defined.");
        url_ = url_.replace("{issueTypeSchemeId}", encodeURIComponent("" + issueTypeSchemeId));
        if (issueTypeId === undefined || issueTypeId === null)
            throw new Error("The parameter 'issueTypeId' must be defined.");
        url_ = url_.replace("{issueTypeId}", encodeURIComponent("" + issueTypeId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveIssueTypeFromIssueTypeScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveIssueTypeFromIssueTypeScheme(_response);
            throw _response;
        });
    }

    protected processRemoveIssueTypeFromIssueTypeScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type scheme is missing or the issue type is not found in the issue type scheme.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get issue type screen schemes
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param id (optional) The list of issue type screen scheme IDs. To include multiple IDs, provide an ampersand-separated list. For example, `id=10000&id=10001`.
     * @param queryString (optional) String used to perform a case-insensitive partial match with issue type screen scheme name.
     * @param orderBy (optional) [Order](#ordering) the results by a field:

     *  `name` Sorts by issue type screen scheme name.
     *  `id` Sorts by issue type screen scheme ID.
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts `projects` that, for each issue type screen schemes, returns information about the projects the issue type screen scheme is assigned to.
     * @return Returned if the request is successful.
     */
    getIssueTypeScreenSchemes(startAt?: number | undefined, maxResults?: number | undefined, id?: number[] | undefined, queryString?: string | undefined, orderBy?: OrderBy8 | undefined, expand?: string | undefined): ng.IPromise<PageBeanIssueTypeScreenScheme> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescreenscheme?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (queryString === null)
            throw new Error("The parameter 'queryString' cannot be null.");
        else if (queryString !== undefined)
            url_ += "queryString=" + encodeURIComponent("" + queryString) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueTypeScreenSchemes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueTypeScreenSchemes(_response);
            throw _response;
        });
    }

    protected processGetIssueTypeScreenSchemes(response: any): ng.IPromise<PageBeanIssueTypeScreenScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanIssueTypeScreenScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanIssueTypeScreenScheme>(null as any);
    }

    /**
     * Create issue type screen scheme
     * @param body An issue type screen scheme bean.
     * @return Returned if the request is successful.
     */
    createIssueTypeScreenScheme(body: IssueTypeScreenSchemeDetails): ng.IPromise<IssueTypeScreenSchemeId> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescreenscheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateIssueTypeScreenScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateIssueTypeScreenScheme(_response);
            throw _response;
        });
    }

    protected processCreateIssueTypeScreenScheme(response: any): ng.IPromise<IssueTypeScreenSchemeId> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = IssueTypeScreenSchemeId.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type or screen scheme is not found.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type is a sub-task, but sub-tasks are disabled in Jira settings.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueTypeScreenSchemeId>(null as any);
    }

    /**
     * Get issue type screen scheme items
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param issueTypeScreenSchemeId (optional) The list of issue type screen scheme IDs. To include multiple issue type screen schemes, separate IDs with ampersand: `issueTypeScreenSchemeId=10000&issueTypeScreenSchemeId=10001`.
     * @return Returned if the request is successful.
     */
    getIssueTypeScreenSchemeMappings(startAt?: number | undefined, maxResults?: number | undefined, issueTypeScreenSchemeId?: number[] | undefined): ng.IPromise<PageBeanIssueTypeScreenSchemeItem> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescreenscheme/mapping?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (issueTypeScreenSchemeId === null)
            throw new Error("The parameter 'issueTypeScreenSchemeId' cannot be null.");
        else if (issueTypeScreenSchemeId !== undefined)
            issueTypeScreenSchemeId && issueTypeScreenSchemeId.forEach(item => { url_ += "issueTypeScreenSchemeId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueTypeScreenSchemeMappings(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueTypeScreenSchemeMappings(_response);
            throw _response;
        });
    }

    protected processGetIssueTypeScreenSchemeMappings(response: any): ng.IPromise<PageBeanIssueTypeScreenSchemeItem> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanIssueTypeScreenSchemeItem.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanIssueTypeScreenSchemeItem>(null as any);
    }

    /**
     * Get issue type screen schemes for projects
     * @param projectId The list of project IDs. To include multiple projects, separate IDs with ampersand: `projectId=10000&projectId=10001`.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getIssueTypeScreenSchemeProjectAssociations(projectId: number[], startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanIssueTypeScreenSchemesProjects> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescreenscheme/project?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            projectId && projectId.forEach(item => { url_ += "projectId=" + encodeURIComponent("" + item) + "&"; });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueTypeScreenSchemeProjectAssociations(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueTypeScreenSchemeProjectAssociations(_response);
            throw _response;
        });
    }

    protected processGetIssueTypeScreenSchemeProjectAssociations(response: any): ng.IPromise<PageBeanIssueTypeScreenSchemesProjects> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanIssueTypeScreenSchemesProjects.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanIssueTypeScreenSchemesProjects>(null as any);
    }

    /**
     * Assign issue type screen scheme to project
     * @return Returned if the request is successful.
     */
    assignIssueTypeScreenSchemeToProject(body: IssueTypeScreenSchemeProjectAssociation): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescreenscheme/project";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAssignIssueTypeScreenSchemeToProject(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAssignIssueTypeScreenSchemeToProject(_response);
            throw _response;
        });
    }

    protected processAssignIssueTypeScreenSchemeToProject(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  project is not found.\n *  issue type screen scheme is not found.\n *  the project is not a classic project.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type screen scheme or the project are missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Delete issue type screen scheme
     * @param issueTypeScreenSchemeId The ID of the issue type screen scheme.
     * @return Returned if the issue type screen scheme is deleted.
     */
    deleteIssueTypeScreenScheme(issueTypeScreenSchemeId: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}";
        if (issueTypeScreenSchemeId === undefined || issueTypeScreenSchemeId === null)
            throw new Error("The parameter 'issueTypeScreenSchemeId' must be defined.");
        url_ = url_.replace("{issueTypeScreenSchemeId}", encodeURIComponent("" + issueTypeScreenSchemeId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteIssueTypeScreenScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteIssueTypeScreenScheme(_response);
            throw _response;
        });
    }

    protected processDeleteIssueTypeScreenScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type screen scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Update issue type screen scheme
     * @param issueTypeScreenSchemeId The ID of the issue type screen scheme.
     * @param body The issue type screen scheme update details.
     * @return Returned if the request is successful.
     */
    updateIssueTypeScreenScheme(issueTypeScreenSchemeId: string, body: IssueTypeScreenSchemeUpdateDetails): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}";
        if (issueTypeScreenSchemeId === undefined || issueTypeScreenSchemeId === null)
            throw new Error("The parameter 'issueTypeScreenSchemeId' must be defined.");
        url_ = url_.replace("{issueTypeScreenSchemeId}", encodeURIComponent("" + issueTypeScreenSchemeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateIssueTypeScreenScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateIssueTypeScreenScheme(_response);
            throw _response;
        });
    }

    protected processUpdateIssueTypeScreenScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type screen scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Append mappings to issue type screen scheme
     * @param issueTypeScreenSchemeId The ID of the issue type screen scheme.
     * @return Returned if the request is successful.
     */
    appendMappingsForIssueTypeScreenScheme(issueTypeScreenSchemeId: string, body: IssueTypeScreenSchemeMappingDetails): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/mapping";
        if (issueTypeScreenSchemeId === undefined || issueTypeScreenSchemeId === null)
            throw new Error("The parameter 'issueTypeScreenSchemeId' must be defined.");
        url_ = url_.replace("{issueTypeScreenSchemeId}", encodeURIComponent("" + issueTypeScreenSchemeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAppendMappingsForIssueTypeScreenScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAppendMappingsForIssueTypeScreenScheme(_response);
            throw _response;
        });
    }

    protected processAppendMappingsForIssueTypeScreenScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type screen scheme, issue type, or screen scheme is not found.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type is a sub-task, but sub-tasks are disabled in Jira settings.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Update issue type screen scheme default screen scheme
     * @param issueTypeScreenSchemeId The ID of the issue type screen scheme.
     * @return Returned if the request is successful.
     */
    updateDefaultScreenScheme(issueTypeScreenSchemeId: string, body: UpdateDefaultScreenScheme): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/mapping/default";
        if (issueTypeScreenSchemeId === undefined || issueTypeScreenSchemeId === null)
            throw new Error("The parameter 'issueTypeScreenSchemeId' must be defined.");
        url_ = url_.replace("{issueTypeScreenSchemeId}", encodeURIComponent("" + issueTypeScreenSchemeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateDefaultScreenScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateDefaultScreenScheme(_response);
            throw _response;
        });
    }

    protected processUpdateDefaultScreenScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type screen scheme or the screen scheme is not found, or the screen scheme isn\'t used in classic projects.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Remove mappings from issue type screen scheme
     * @param issueTypeScreenSchemeId The ID of the issue type screen scheme.
     * @return Returned if the screen scheme mappings are removed from the issue type screen scheme.
     */
    removeMappingsFromIssueTypeScreenScheme(issueTypeScreenSchemeId: string, body: IssueTypeIds): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/mapping/remove";
        if (issueTypeScreenSchemeId === undefined || issueTypeScreenSchemeId === null)
            throw new Error("The parameter 'issueTypeScreenSchemeId' must be defined.");
        url_ = url_.replace("{issueTypeScreenSchemeId}", encodeURIComponent("" + issueTypeScreenSchemeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveMappingsFromIssueTypeScreenScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveMappingsFromIssueTypeScreenScheme(_response);
            throw _response;
        });
    }

    protected processRemoveMappingsFromIssueTypeScreenScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue type screen scheme or one or more issue type mappings are not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get issue type screen scheme projects
     * @param issueTypeScreenSchemeId The ID of the issue type screen scheme.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param query (optional) 
     * @return Returned if the request is successful.
     */
    getProjectsForIssueTypeScreenScheme(issueTypeScreenSchemeId: number, startAt?: number | undefined, maxResults?: number | undefined, query?: string | undefined): ng.IPromise<PageBeanProjectDetails> {
        let url_ = this.baseUrl + "/rest/api/3/issuetypescreenscheme/{issueTypeScreenSchemeId}/project?";
        if (issueTypeScreenSchemeId === undefined || issueTypeScreenSchemeId === null)
            throw new Error("The parameter 'issueTypeScreenSchemeId' must be defined.");
        url_ = url_.replace("{issueTypeScreenSchemeId}", encodeURIComponent("" + issueTypeScreenSchemeId));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectsForIssueTypeScreenScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectsForIssueTypeScreenScheme(_response);
            throw _response;
        });
    }

    protected processGetProjectsForIssueTypeScreenScheme(response: any): ng.IPromise<PageBeanProjectDetails> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanProjectDetails.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanProjectDetails>(null as any);
    }

    /**
     * Get field reference data (GET)
     * @return Returned if the request is successful.
     */
    getAutoComplete(): ng.IPromise<JQLReferenceData> {
        let url_ = this.baseUrl + "/rest/api/3/jql/autocompletedata";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAutoComplete(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAutoComplete(_response);
            throw _response;
        });
    }

    protected processGetAutoComplete(response: any): ng.IPromise<JQLReferenceData> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JQLReferenceData.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<JQLReferenceData>(null as any);
    }

    /**
     * Get field reference data (POST)
     * @return Returned if the request is successful.
     */
    getAutoCompletePost(body: SearchAutoCompleteFilter): ng.IPromise<JQLReferenceData> {
        let url_ = this.baseUrl + "/rest/api/3/jql/autocompletedata";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAutoCompletePost(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAutoCompletePost(_response);
            throw _response;
        });
    }

    protected processGetAutoCompletePost(response: any): ng.IPromise<JQLReferenceData> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JQLReferenceData.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<JQLReferenceData>(null as any);
    }

    /**
     * Get field auto complete suggestions
     * @param fieldName (optional) The name of the field.
     * @param fieldValue (optional) The partial field item name entered by the user.
     * @param predicateName (optional) The name of the [ CHANGED operator predicate](https://confluence.atlassian.com/x/hQORLQ#Advancedsearching-operatorsreference-CHANGEDCHANGED) for which the suggestions are generated. The valid predicate operators are *by*, *from*, and *to*.
     * @param predicateValue (optional) The partial predicate item name entered by the user.
     * @return Returned if the request is successful.
     */
    getFieldAutoCompleteForQueryString(fieldName?: string | undefined, fieldValue?: string | undefined, predicateName?: string | undefined, predicateValue?: string | undefined): ng.IPromise<AutoCompleteSuggestions> {
        let url_ = this.baseUrl + "/rest/api/3/jql/autocompletedata/suggestions?";
        if (fieldName === null)
            throw new Error("The parameter 'fieldName' cannot be null.");
        else if (fieldName !== undefined)
            url_ += "fieldName=" + encodeURIComponent("" + fieldName) + "&";
        if (fieldValue === null)
            throw new Error("The parameter 'fieldValue' cannot be null.");
        else if (fieldValue !== undefined)
            url_ += "fieldValue=" + encodeURIComponent("" + fieldValue) + "&";
        if (predicateName === null)
            throw new Error("The parameter 'predicateName' cannot be null.");
        else if (predicateName !== undefined)
            url_ += "predicateName=" + encodeURIComponent("" + predicateName) + "&";
        if (predicateValue === null)
            throw new Error("The parameter 'predicateValue' cannot be null.");
        else if (predicateValue !== undefined)
            url_ += "predicateValue=" + encodeURIComponent("" + predicateValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetFieldAutoCompleteForQueryString(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetFieldAutoCompleteForQueryString(_response);
            throw _response;
        });
    }

    protected processGetFieldAutoCompleteForQueryString(response: any): ng.IPromise<AutoCompleteSuggestions> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AutoCompleteSuggestions.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if an invalid combination of parameters is passed.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<AutoCompleteSuggestions>(null as any);
    }

    /**
     * Get precomputations (apps)
     * @param functionKey (optional) The function key in format:

     *  Forge: `ari:cloud:ecosystem::extension/[App ID]/[Environment ID]/static/[Function key from manifest]`
     *  Connect: `[App key]__[Module key]`
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param orderBy (optional) [Order](#ordering) the results by a field:

     *  `functionKey` Sorts by the functionKey.
     *  `used` Sorts by the used timestamp.
     *  `created` Sorts by the created timestamp.
     *  `updated` Sorts by the updated timestamp.
     * @return Returned if the request is successful.
     */
    getPrecomputations(functionKey?: string[] | undefined, startAt?: number | undefined, maxResults?: number | undefined, orderBy?: string | undefined): ng.IPromise<PageBean2JqlFunctionPrecomputationBean> {
        let url_ = this.baseUrl + "/rest/api/3/jql/function/computation?";
        if (functionKey === null)
            throw new Error("The parameter 'functionKey' cannot be null.");
        else if (functionKey !== undefined)
            functionKey && functionKey.forEach(item => { url_ += "functionKey=" + encodeURIComponent("" + item) + "&"; });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetPrecomputations(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetPrecomputations(_response);
            throw _response;
        });
    }

    protected processGetPrecomputations(response: any): ng.IPromise<PageBean2JqlFunctionPrecomputationBean> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBean2JqlFunctionPrecomputationBean.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not authenticated as the app that provided the function.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the function is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBean2JqlFunctionPrecomputationBean>(null as any);
    }

    /**
     * Update precomputations (apps)
     * @param skipNotFoundPrecomputations (optional) 
     * @return 200 response
     */
    updatePrecomputations(body: JqlFunctionPrecomputationUpdateRequestBean, skipNotFoundPrecomputations?: boolean | undefined): ng.IPromise<JqlFunctionPrecomputationUpdateResponse> {
        let url_ = this.baseUrl + "/rest/api/3/jql/function/computation?";
        if (skipNotFoundPrecomputations === null)
            throw new Error("The parameter 'skipNotFoundPrecomputations' cannot be null.");
        else if (skipNotFoundPrecomputations !== undefined)
            url_ += "skipNotFoundPrecomputations=" + encodeURIComponent("" + skipNotFoundPrecomputations) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdatePrecomputations(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdatePrecomputations(_response);
            throw _response;
        });
    }

    protected processUpdatePrecomputations(response: any): ng.IPromise<JqlFunctionPrecomputationUpdateResponse> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JqlFunctionPrecomputationUpdateResponse.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return throwException(this.q, "Returned if the request is successful.", status, _responseText, _headers, result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = JqlFunctionPrecomputationUpdateErrorResponse.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = JqlFunctionPrecomputationUpdateErrorResponse.fromJS(resultData403);
            return throwException(this.q, "Returned if the request is not authenticated as the app that provided the function.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = JqlFunctionPrecomputationUpdateErrorResponse.fromJS(resultData404);
            return throwException(this.q, "Returned if the function is not found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<JqlFunctionPrecomputationUpdateResponse>(null as any);
    }

    /**
     * Get precomputations by ID (apps)
     * @param orderBy (optional) [Order](#ordering) the results by a field:

     *  `functionKey` Sorts by the functionKey.
     *  `used` Sorts by the used timestamp.
     *  `created` Sorts by the created timestamp.
     *  `updated` Sorts by the updated timestamp.
     * @return Returned if the request is successful.
     */
    getPrecomputationsByID(body: JqlFunctionPrecomputationGetByIdRequest, orderBy?: string | undefined): ng.IPromise<JqlFunctionPrecomputationGetByIdResponse> {
        let url_ = this.baseUrl + "/rest/api/3/jql/function/computation/search?";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetPrecomputationsByID(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetPrecomputationsByID(_response);
            throw _response;
        });
    }

    protected processGetPrecomputationsByID(response: any): ng.IPromise<JqlFunctionPrecomputationGetByIdResponse> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JqlFunctionPrecomputationGetByIdResponse.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not authenticated as the app that provided the function.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the function is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<JqlFunctionPrecomputationGetByIdResponse>(null as any);
    }

    /**
     * Check issues against JQL
     * @return Returned if the request is successful.
     */
    matchIssues(body: IssuesAndJQLQueries): ng.IPromise<IssueMatches> {
        let url_ = this.baseUrl + "/rest/api/3/jql/match";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processMatchIssues(_response);
        }, (_response) => {
            if (_response.status)
                return this.processMatchIssues(_response);
            throw _response;
        });
    }

    protected processMatchIssues(response: any): ng.IPromise<IssueMatches> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueMatches.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if `jqls` exceeds the maximum number of JQL queries or `issueIds` exceeds the maximum number of issue IDs.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueMatches>(null as any);
    }

    /**
     * Parse JQL query
     * @param validation How to validate the JQL query and treat the validation results. Validation options include:

     *  `strict` Returns all errors. If validation fails, the query structure is not returned.
     *  `warn` Returns all errors. If validation fails but the JQL query is correctly formed, the query structure is returned.
     *  `none` No validation is performed. If JQL query is correctly formed, the query structure is returned.
     * @return Returned if the request is successful.
     */
    parseJqlQueries(validation: Validation, body: JqlQueriesToParse): ng.IPromise<ParsedJqlQueries> {
        let url_ = this.baseUrl + "/rest/api/3/jql/parse?";
        if (validation === undefined || validation === null)
            throw new Error("The parameter 'validation' must be defined and cannot be null.");
        else
            url_ += "validation=" + encodeURIComponent("" + validation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processParseJqlQueries(_response);
        }, (_response) => {
            if (_response.status)
                return this.processParseJqlQueries(_response);
            throw _response;
        });
    }

    protected processParseJqlQueries(response: any): ng.IPromise<ParsedJqlQueries> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParsedJqlQueries.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ParsedJqlQueries>(null as any);
    }

    /**
     * Convert user identifiers to account IDs in JQL queries
     * @return Returned if the request is successful. Note that the JQL queries are returned in the same order that they were passed.
     */
    migrateQueries(body: JQLPersonalDataMigrationRequest): ng.IPromise<ConvertedJQLQueries> {
        let url_ = this.baseUrl + "/rest/api/3/jql/pdcleaner";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processMigrateQueries(_response);
        }, (_response) => {
            if (_response.status)
                return this.processMigrateQueries(_response);
            throw _response;
        });
    }

    protected processMigrateQueries(response: any): ng.IPromise<ConvertedJQLQueries> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConvertedJQLQueries.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException(this.q, "Returned if at least one of the queries cannot be converted. For example, the JQL has invalid operators or invalid keywords, or the users in the query cannot be found.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = resultData401 !== undefined ? resultData401 : <any>null;
    
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ConvertedJQLQueries>(null as any);
    }

    /**
     * Sanitize JQL queries
     * @return Returned if the request is successful.
     */
    sanitiseJqlQueries(body: JqlQueriesToSanitize): ng.IPromise<SanitizedJqlQueries> {
        let url_ = this.baseUrl + "/rest/api/3/jql/sanitize";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSanitiseJqlQueries(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSanitiseJqlQueries(_response);
            throw _response;
        });
    }

    protected processSanitiseJqlQueries(response: any): ng.IPromise<SanitizedJqlQueries> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SanitizedJqlQueries.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SanitizedJqlQueries>(null as any);
    }

    /**
     * Get all labels
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getAllLabels(startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanString> {
        let url_ = this.baseUrl + "/rest/api/3/label?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllLabels(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllLabels(_response);
            throw _response;
        });
    }

    protected processGetAllLabels(response: any): ng.IPromise<PageBeanString> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanString.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanString>(null as any);
    }

    /**
     * Get approximate license count
     * @return Returned if the request is successful.
     */
    getApproximateLicenseCount(): ng.IPromise<LicenseMetric> {
        let url_ = this.baseUrl + "/rest/api/3/license/approximateLicenseCount";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetApproximateLicenseCount(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetApproximateLicenseCount(_response);
            throw _response;
        });
    }

    protected processGetApproximateLicenseCount(response: any): ng.IPromise<LicenseMetric> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LicenseMetric.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollections.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollections.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have permission to complete this request.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<LicenseMetric>(null as any);
    }

    /**
     * Get approximate application license count
     * @param applicationKey The ID of the application, represents a specific version of Jira.
     * @return Returned if the request is successful.
     */
    getApproximateApplicationLicenseCount(applicationKey: ApplicationKey): ng.IPromise<LicenseMetric> {
        let url_ = this.baseUrl + "/rest/api/3/license/approximateLicenseCount/product/{applicationKey}";
        if (applicationKey === undefined || applicationKey === null)
            throw new Error("The parameter 'applicationKey' must be defined.");
        url_ = url_.replace("{applicationKey}", encodeURIComponent("" + applicationKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetApproximateApplicationLicenseCount(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetApproximateApplicationLicenseCount(_response);
            throw _response;
        });
    }

    protected processGetApproximateApplicationLicenseCount(response: any): ng.IPromise<LicenseMetric> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LicenseMetric.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have permission to complete this request.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<LicenseMetric>(null as any);
    }

    /**
     * Get my permissions
     * @param projectKey (optional) The key of project. Ignored if `projectId` is provided.
     * @param projectId (optional) The ID of project.
     * @param issueKey (optional) The key of the issue. Ignored if `issueId` is provided.
     * @param issueId (optional) The ID of the issue.
     * @param permissions (optional) A list of permission keys. (Required) This parameter accepts a comma-separated list. To get the list of available permissions, use [Get all permissions](#api-rest-api-3-permissions-get).
     * @param projectUuid (optional) 
     * @param projectConfigurationUuid (optional) 
     * @param commentId (optional) The ID of the comment.
     * @return Returned if the request is successful.
     */
    getMyPermissions(projectKey?: string | undefined, projectId?: string | undefined, issueKey?: string | undefined, issueId?: string | undefined, permissions?: string | undefined, projectUuid?: string | undefined, projectConfigurationUuid?: string | undefined, commentId?: string | undefined): ng.IPromise<Permissions> {
        let url_ = this.baseUrl + "/rest/api/3/mypermissions?";
        if (projectKey === null)
            throw new Error("The parameter 'projectKey' cannot be null.");
        else if (projectKey !== undefined)
            url_ += "projectKey=" + encodeURIComponent("" + projectKey) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (issueKey === null)
            throw new Error("The parameter 'issueKey' cannot be null.");
        else if (issueKey !== undefined)
            url_ += "issueKey=" + encodeURIComponent("" + issueKey) + "&";
        if (issueId === null)
            throw new Error("The parameter 'issueId' cannot be null.");
        else if (issueId !== undefined)
            url_ += "issueId=" + encodeURIComponent("" + issueId) + "&";
        if (permissions === null)
            throw new Error("The parameter 'permissions' cannot be null.");
        else if (permissions !== undefined)
            url_ += "permissions=" + encodeURIComponent("" + permissions) + "&";
        if (projectUuid === null)
            throw new Error("The parameter 'projectUuid' cannot be null.");
        else if (projectUuid !== undefined)
            url_ += "projectUuid=" + encodeURIComponent("" + projectUuid) + "&";
        if (projectConfigurationUuid === null)
            throw new Error("The parameter 'projectConfigurationUuid' cannot be null.");
        else if (projectConfigurationUuid !== undefined)
            url_ += "projectConfigurationUuid=" + encodeURIComponent("" + projectConfigurationUuid) + "&";
        if (commentId === null)
            throw new Error("The parameter 'commentId' cannot be null.");
        else if (commentId !== undefined)
            url_ += "commentId=" + encodeURIComponent("" + commentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetMyPermissions(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetMyPermissions(_response);
            throw _response;
        });
    }

    protected processGetMyPermissions(response: any): ng.IPromise<Permissions> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Permissions.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if `permissions` is empty, contains an invalid key, or does not equal BROWSE\\_PROJECTS when commentId is provided.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the project or issue is not found or the user does not have permission to view the project or issue.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Permissions>(null as any);
    }

    /**
     * Delete preference
     * @param key The key of the preference.
     * @return Returned if the request is successful.
     */
    removePreference(key: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/mypreferences?";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined and cannot be null.");
        else
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemovePreference(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemovePreference(_response);
            throw _response;
        });
    }

    protected processRemovePreference(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the key is not provided or not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get preference
     * @param key The key of the preference.
     * @return Returned if the request is successful.
     */
    getPreference(key: string): ng.IPromise<string> {
        let url_ = this.baseUrl + "/rest/api/3/mypreferences?";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined and cannot be null.");
        else
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetPreference(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetPreference(_response);
            throw _response;
        });
    }

    protected processGetPreference(response: any): ng.IPromise<string> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the key is not provided or not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<string>(null as any);
    }

    /**
     * Set preference
     * @param key The key of the preference. The maximum length is 255 characters.
     * @param body The value of the preference as a plain text string. The maximum length is 255 characters.
     * @return Returned if the request is successful.
     */
    setPreference(key: string, body: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/mypreferences?";
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined and cannot be null.");
        else
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetPreference(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetPreference(_response);
            throw _response;
        });
    }

    protected processSetPreference(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the key or value is not provided or invalid.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Delete locale
     * @return Returned if the request is successful.
     * @deprecated
     */
    deleteLocale(): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/mypreferences/locale";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteLocale(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteLocale(_response);
            throw _response;
        });
    }

    protected processDeleteLocale(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get locale
     * @return Returned if the request is successful.
     */
    getLocale(): ng.IPromise<Locale> {
        let url_ = this.baseUrl + "/rest/api/3/mypreferences/locale";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetLocale(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetLocale(_response);
            throw _response;
        });
    }

    protected processGetLocale(response: any): ng.IPromise<Locale> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Locale.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Locale>(null as any);
    }

    /**
     * Set locale
     * @param body The locale defined in a LocaleBean.
     * @return Returned if the request is successful.
     * @deprecated
     */
    setLocale(body: Locale): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/mypreferences/locale";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetLocale(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetLocale(_response);
            throw _response;
        });
    }

    protected processSetLocale(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get current user
     * @param expand (optional) Use [expand](#expansion) to include additional information about user in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `groups` Returns all groups, including nested groups, the user belongs to.
     *  `applicationRoles` Returns the application roles the user is assigned to.
     * @return Returned if the request is successful.
     */
    getCurrentUser(expand?: string | undefined): ng.IPromise<User> {
        let url_ = this.baseUrl + "/rest/api/3/myself?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetCurrentUser(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetCurrentUser(_response);
            throw _response;
        });
    }

    protected processGetCurrentUser(response: any): ng.IPromise<User> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<User>(null as any);
    }

    /**
     * Get notification schemes paginated
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param id (optional) The list of notification schemes IDs to be filtered by
     * @param projectId (optional) The list of projects IDs to be filtered by
     * @param onlyDefault (optional) When set to true, returns only the default notification scheme. If you provide project IDs not associated with the default, returns an empty page. The default value is false.
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `all` Returns all expandable information
     *  `field` Returns information about any custom fields assigned to receive an event
     *  `group` Returns information about any groups assigned to receive an event
     *  `notificationSchemeEvents` Returns a list of event associations. This list is returned for all expandable information
     *  `projectRole` Returns information about any project roles assigned to receive an event
     *  `user` Returns information about any users assigned to receive an event
     * @return Returned if the request is successful. Only returns notification schemes that the user has permission to access. An empty list is returned if the user lacks permission to access all notification schemes.
     */
    getNotificationSchemes(startAt?: string | undefined, maxResults?: string | undefined, id?: string[] | undefined, projectId?: string[] | undefined, onlyDefault?: boolean | undefined, expand?: string | undefined): ng.IPromise<PageBeanNotificationScheme> {
        let url_ = this.baseUrl + "/rest/api/3/notificationscheme?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            projectId && projectId.forEach(item => { url_ += "projectId=" + encodeURIComponent("" + item) + "&"; });
        if (onlyDefault === null)
            throw new Error("The parameter 'onlyDefault' cannot be null.");
        else if (onlyDefault !== undefined)
            url_ += "onlyDefault=" + encodeURIComponent("" + onlyDefault) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetNotificationSchemes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetNotificationSchemes(_response);
            throw _response;
        });
    }

    protected processGetNotificationSchemes(response: any): ng.IPromise<PageBeanNotificationScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanNotificationScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanNotificationScheme>(null as any);
    }

    /**
     * Create notification scheme
     * @return Returned if the request is successful.
     */
    createNotificationScheme(body: CreateNotificationSchemeDetails): ng.IPromise<NotificationSchemeId> {
        let url_ = this.baseUrl + "/rest/api/3/notificationscheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateNotificationScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateNotificationScheme(_response);
            throw _response;
        });
    }

    protected processCreateNotificationScheme(response: any): ng.IPromise<NotificationSchemeId> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = NotificationSchemeId.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<NotificationSchemeId>(null as any);
    }

    /**
     * Get projects using notification schemes paginated
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param notificationSchemeId (optional) The list of notifications scheme IDs to be filtered out
     * @param projectId (optional) The list of project IDs to be filtered out
     * @return Returned if the request is successful.
     */
    getNotificationSchemeToProjectMappings(startAt?: string | undefined, maxResults?: string | undefined, notificationSchemeId?: string[] | undefined, projectId?: string[] | undefined): ng.IPromise<PageBeanNotificationSchemeAndProjectMappingJsonBean> {
        let url_ = this.baseUrl + "/rest/api/3/notificationscheme/project?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (notificationSchemeId === null)
            throw new Error("The parameter 'notificationSchemeId' cannot be null.");
        else if (notificationSchemeId !== undefined)
            notificationSchemeId && notificationSchemeId.forEach(item => { url_ += "notificationSchemeId=" + encodeURIComponent("" + item) + "&"; });
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            projectId && projectId.forEach(item => { url_ += "projectId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetNotificationSchemeToProjectMappings(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetNotificationSchemeToProjectMappings(_response);
            throw _response;
        });
    }

    protected processGetNotificationSchemeToProjectMappings(response: any): ng.IPromise<PageBeanNotificationSchemeAndProjectMappingJsonBean> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanNotificationSchemeAndProjectMappingJsonBean.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if search criteria are invalid, strings vs numbers for projectId, notificationSchemeId, startAt and maxResult", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanNotificationSchemeAndProjectMappingJsonBean>(null as any);
    }

    /**
     * Get notification scheme
     * @param id The ID of the notification scheme. Use [Get notification schemes paginated](#api-rest-api-3-notificationscheme-get) to get a list of notification scheme IDs.
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `all` Returns all expandable information
     *  `field` Returns information about any custom fields assigned to receive an event
     *  `group` Returns information about any groups assigned to receive an event
     *  `notificationSchemeEvents` Returns a list of event associations. This list is returned for all expandable information
     *  `projectRole` Returns information about any project roles assigned to receive an event
     *  `user` Returns information about any users assigned to receive an event
     * @return Returned if the request is successful.
     */
    getNotificationScheme(id: number, expand?: string | undefined): ng.IPromise<NotificationScheme> {
        let url_ = this.baseUrl + "/rest/api/3/notificationscheme/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetNotificationScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetNotificationScheme(_response);
            throw _response;
        });
    }

    protected processGetNotificationScheme(response: any): ng.IPromise<NotificationScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the notification scheme is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<NotificationScheme>(null as any);
    }

    /**
     * Update notification scheme
     * @param id The ID of the notification scheme.
     * @return Returned if the request is successful.
     */
    updateNotificationScheme(id: string, body: UpdateNotificationSchemeDetails): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/notificationscheme/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateNotificationScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateNotificationScheme(_response);
            throw _response;
        });
    }

    protected processUpdateNotificationScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the notification scheme isn\'t found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Add notifications to notification scheme
     * @param id The ID of the notification scheme.
     * @return Returned if the request is successful.
     */
    addNotifications(id: string, body: AddNotificationsDetails): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/notificationscheme/{id}/notification";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddNotifications(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddNotifications(_response);
            throw _response;
        });
    }

    protected processAddNotifications(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the notification scheme isn\'t found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Delete notification scheme
     * @param notificationSchemeId The ID of the notification scheme.
     * @return Returned if the request is successful.
     */
    deleteNotificationScheme(notificationSchemeId: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/notificationscheme/{notificationSchemeId}";
        if (notificationSchemeId === undefined || notificationSchemeId === null)
            throw new Error("The parameter 'notificationSchemeId' must be defined.");
        url_ = url_.replace("{notificationSchemeId}", encodeURIComponent("" + notificationSchemeId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteNotificationScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteNotificationScheme(_response);
            throw _response;
        });
    }

    protected processDeleteNotificationScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the notification scheme isn\'t found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Remove notification from notification scheme
     * @param notificationSchemeId The ID of the notification scheme.
     * @param notificationId The ID of the notification.
     * @return Returned if the request is successful.
     */
    removeNotificationFromNotificationScheme(notificationSchemeId: string, notificationId: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/notificationscheme/{notificationSchemeId}/notification/{notificationId}";
        if (notificationSchemeId === undefined || notificationSchemeId === null)
            throw new Error("The parameter 'notificationSchemeId' must be defined.");
        url_ = url_.replace("{notificationSchemeId}", encodeURIComponent("" + notificationSchemeId));
        if (notificationId === undefined || notificationId === null)
            throw new Error("The parameter 'notificationId' must be defined.");
        url_ = url_.replace("{notificationId}", encodeURIComponent("" + notificationId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveNotificationFromNotificationScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveNotificationFromNotificationScheme(_response);
            throw _response;
        });
    }

    protected processRemoveNotificationFromNotificationScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if either the notification scheme or notification isn\'t found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get all permissions
     * @return Returned if the request is successful.
     */
    getAllPermissions(): ng.IPromise<Permissions> {
        let url_ = this.baseUrl + "/rest/api/3/permissions";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllPermissions(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllPermissions(_response);
            throw _response;
        });
    }

    protected processGetAllPermissions(response: any): ng.IPromise<Permissions> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Permissions.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Permissions>(null as any);
    }

    /**
     * Get bulk permissions
     * @param body Details of the permissions to check.
     * @return Returned if the request is successful.
     */
    getBulkPermissions(body: BulkPermissionsRequestBean): ng.IPromise<BulkPermissionGrants> {
        let url_ = this.baseUrl + "/rest/api/3/permissions/check";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetBulkPermissions(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetBulkPermissions(_response);
            throw _response;
        });
    }

    protected processGetBulkPermissions(response: any): ng.IPromise<BulkPermissionGrants> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkPermissionGrants.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if:\n\n *  `projectPermissions` is provided without at least one project permission being provided.\n *  an invalid global permission is provided in the global permissions list.\n *  an invalid project permission is provided in the project permissions list.\n *  more than 1000 valid project IDs or more than 1000 valid issue IDs are provided.\n *  an invalid account ID is provided.", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<BulkPermissionGrants>(null as any);
    }

    /**
     * Get permitted projects
     * @return Returned if the request is successful.
     */
    getPermittedProjects(body: PermissionsKeysBean): ng.IPromise<PermittedProjects> {
        let url_ = this.baseUrl + "/rest/api/3/permissions/project";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetPermittedProjects(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetPermittedProjects(_response);
            throw _response;
        });
    }

    protected processGetPermittedProjects(response: any): ng.IPromise<PermittedProjects> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermittedProjects.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if a project permission is not found.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PermittedProjects>(null as any);
    }

    /**
     * Get all permission schemes
     * @param expand (optional) Use expand to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are included when you specify any value. Expand options include:

     *  `all` Returns all expandable information.
     *  `field` Returns information about the custom field granted the permission.
     *  `group` Returns information about the group that is granted the permission.
     *  `permissions` Returns all permission grants for each permission scheme.
     *  `projectRole` Returns information about the project role granted the permission.
     *  `user` Returns information about the user who is granted the permission.
     * @return Returned if the request is successful.
     */
    getAllPermissionSchemes(expand?: string | undefined): ng.IPromise<PermissionSchemes> {
        let url_ = this.baseUrl + "/rest/api/3/permissionscheme?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllPermissionSchemes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllPermissionSchemes(_response);
            throw _response;
        });
    }

    protected processGetAllPermissionSchemes(response: any): ng.IPromise<PermissionSchemes> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionSchemes.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PermissionSchemes>(null as any);
    }

    /**
     * Create permission scheme
     * @param body The permission scheme to create.
     * @param expand (optional) Use expand to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are always included when you specify any value. Expand options include:

     *  `all` Returns all expandable information.
     *  `field` Returns information about the custom field granted the permission.
     *  `group` Returns information about the group that is granted the permission.
     *  `permissions` Returns all permission grants for each permission scheme.
     *  `projectRole` Returns information about the project role granted the permission.
     *  `user` Returns information about the user who is granted the permission.
     * @return Returned if the permission scheme is created.
     */
    createPermissionScheme(body: PermissionScheme, expand?: string | undefined): ng.IPromise<PermissionScheme> {
        let url_ = this.baseUrl + "/rest/api/3/permissionscheme?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreatePermissionScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreatePermissionScheme(_response);
            throw _response;
        });
    }

    protected processCreatePermissionScheme(response: any): ng.IPromise<PermissionScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PermissionScheme.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission or the feature is not available in the Jira plan.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PermissionScheme>(null as any);
    }

    /**
     * Delete permission scheme
     * @param schemeId The ID of the permission scheme being deleted.
     * @return Returned if the permission scheme is deleted.
     */
    deletePermissionScheme(schemeId: number): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/permissionscheme/{schemeId}";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeletePermissionScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeletePermissionScheme(_response);
            throw _response;
        });
    }

    protected processDeletePermissionScheme(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the permission scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get permission scheme
     * @param schemeId The ID of the permission scheme to return.
     * @param expand (optional) Use expand to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are included when you specify any value. Expand options include:

     *  `all` Returns all expandable information.
     *  `field` Returns information about the custom field granted the permission.
     *  `group` Returns information about the group that is granted the permission.
     *  `permissions` Returns all permission grants for each permission scheme.
     *  `projectRole` Returns information about the project role granted the permission.
     *  `user` Returns information about the user who is granted the permission.
     * @return Returned if the request is successful.
     */
    getPermissionScheme(schemeId: number, expand?: string | undefined): ng.IPromise<PermissionScheme> {
        let url_ = this.baseUrl + "/rest/api/3/permissionscheme/{schemeId}?";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetPermissionScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetPermissionScheme(_response);
            throw _response;
        });
    }

    protected processGetPermissionScheme(response: any): ng.IPromise<PermissionScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the permission scheme is not found or the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PermissionScheme>(null as any);
    }

    /**
     * Update permission scheme
     * @param schemeId The ID of the permission scheme to update.
     * @param expand (optional) Use expand to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are always included when you specify any value. Expand options include:

     *  `all` Returns all expandable information.
     *  `field` Returns information about the custom field granted the permission.
     *  `group` Returns information about the group that is granted the permission.
     *  `permissions` Returns all permission grants for each permission scheme.
     *  `projectRole` Returns information about the project role granted the permission.
     *  `user` Returns information about the user who is granted the permission.
     * @return Returned if the scheme is updated.
     */
    updatePermissionScheme(schemeId: number, body: PermissionScheme, expand?: string | undefined): ng.IPromise<PermissionScheme> {
        let url_ = this.baseUrl + "/rest/api/3/permissionscheme/{schemeId}?";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdatePermissionScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdatePermissionScheme(_response);
            throw _response;
        });
    }

    protected processUpdatePermissionScheme(response: any): ng.IPromise<PermissionScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the user does not have the necessary permission to update permission schemes.\n *  the Jira instance is Jira Core Free or Jira Software Free. Permission schemes cannot be updated on free plans.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the permission scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PermissionScheme>(null as any);
    }

    /**
     * Get permission scheme grants
     * @param schemeId The ID of the permission scheme.
     * @param expand (optional) Use expand to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are always included when you specify any value. Expand options include:

     *  `permissions` Returns all permission grants for each permission scheme.
     *  `user` Returns information about the user who is granted the permission.
     *  `group` Returns information about the group that is granted the permission.
     *  `projectRole` Returns information about the project role granted the permission.
     *  `field` Returns information about the custom field granted the permission.
     *  `all` Returns all expandable information.
     * @return Returned if the request is successful.
     */
    getPermissionSchemeGrants(schemeId: number, expand?: string | undefined): ng.IPromise<PermissionGrants> {
        let url_ = this.baseUrl + "/rest/api/3/permissionscheme/{schemeId}/permission?";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetPermissionSchemeGrants(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetPermissionSchemeGrants(_response);
            throw _response;
        });
    }

    protected processGetPermissionSchemeGrants(response: any): ng.IPromise<PermissionGrants> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionGrants.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the permission schemes is not found or the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PermissionGrants>(null as any);
    }

    /**
     * Create permission grant
     * @param schemeId The ID of the permission scheme in which to create a new permission grant.
     * @param body The permission grant to create.
     * @param expand (optional) Use expand to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are always included when you specify any value. Expand options include:

     *  `permissions` Returns all permission grants for each permission scheme.
     *  `user` Returns information about the user who is granted the permission.
     *  `group` Returns information about the group that is granted the permission.
     *  `projectRole` Returns information about the project role granted the permission.
     *  `field` Returns information about the custom field granted the permission.
     *  `all` Returns all expandable information.
     * @return Returned if the scheme permission is created.
     */
    createPermissionGrant(schemeId: number, body: PermissionGrant, expand?: string | undefined): ng.IPromise<PermissionGrant> {
        let url_ = this.baseUrl + "/rest/api/3/permissionscheme/{schemeId}/permission?";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreatePermissionGrant(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreatePermissionGrant(_response);
            throw _response;
        });
    }

    protected processCreatePermissionGrant(response: any): ng.IPromise<PermissionGrant> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PermissionGrant.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the value for expand is invalid or the same permission grant is present.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PermissionGrant>(null as any);
    }

    /**
     * Delete permission scheme grant
     * @param schemeId The ID of the permission scheme to delete the permission grant from.
     * @param permissionId The ID of the permission grant to delete.
     * @return Returned if the permission grant is deleted.
     */
    deletePermissionSchemeEntity(schemeId: number, permissionId: number): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/permissionscheme/{schemeId}/permission/{permissionId}";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (permissionId === undefined || permissionId === null)
            throw new Error("The parameter 'permissionId' must be defined.");
        url_ = url_.replace("{permissionId}", encodeURIComponent("" + permissionId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeletePermissionSchemeEntity(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeletePermissionSchemeEntity(_response);
            throw _response;
        });
    }

    protected processDeletePermissionSchemeEntity(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if permission grant with the provided ID is not found.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get permission scheme grant
     * @param schemeId The ID of the permission scheme.
     * @param permissionId The ID of the permission grant.
     * @param expand (optional) Use expand to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are always included when you specify any value. Expand options include:

     *  `all` Returns all expandable information.
     *  `field` Returns information about the custom field granted the permission.
     *  `group` Returns information about the group that is granted the permission.
     *  `permissions` Returns all permission grants for each permission scheme.
     *  `projectRole` Returns information about the project role granted the permission.
     *  `user` Returns information about the user who is granted the permission.
     * @return Returned if the request is successful.
     */
    getPermissionSchemeGrant(schemeId: number, permissionId: number, expand?: string | undefined): ng.IPromise<PermissionGrant> {
        let url_ = this.baseUrl + "/rest/api/3/permissionscheme/{schemeId}/permission/{permissionId}?";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (permissionId === undefined || permissionId === null)
            throw new Error("The parameter 'permissionId' must be defined.");
        url_ = url_.replace("{permissionId}", encodeURIComponent("" + permissionId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetPermissionSchemeGrant(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetPermissionSchemeGrant(_response);
            throw _response;
        });
    }

    protected processGetPermissionSchemeGrant(response: any): ng.IPromise<PermissionGrant> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionGrant.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the permission scheme or permission grant is not found or the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PermissionGrant>(null as any);
    }

    /**
     * Get plans paginated
     * @param includeTrashed (optional) Whether to include trashed plans in the results.
     * @param includeArchived (optional) Whether to include archived plans in the results.
     * @param cursor (optional) The cursor to start from. If not provided, the first page will be returned.
     * @param maxResults (optional) The maximum number of plans to return per page. The maximum value is 50. The default value is 50.
     * @return Returned if the request is successful.
     */
    getPlans(includeTrashed?: boolean | undefined, includeArchived?: boolean | undefined, cursor?: string | undefined, maxResults?: number | undefined): ng.IPromise<PageWithCursorGetPlanResponseForPage> {
        let url_ = this.baseUrl + "/rest/api/3/plans/plan?";
        if (includeTrashed === null)
            throw new Error("The parameter 'includeTrashed' cannot be null.");
        else if (includeTrashed !== undefined)
            url_ += "includeTrashed=" + encodeURIComponent("" + includeTrashed) + "&";
        if (includeArchived === null)
            throw new Error("The parameter 'includeArchived' cannot be null.");
        else if (includeArchived !== undefined)
            url_ += "includeArchived=" + encodeURIComponent("" + includeArchived) + "&";
        if (cursor === null)
            throw new Error("The parameter 'cursor' cannot be null.");
        else if (cursor !== undefined)
            url_ += "cursor=" + encodeURIComponent("" + cursor) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetPlans(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetPlans(_response);
            throw _response;
        });
    }

    protected processGetPlans(response: any): ng.IPromise<PageWithCursorGetPlanResponseForPage> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageWithCursorGetPlanResponseForPage.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the user is not logged in.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the Administer Jira global permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageWithCursorGetPlanResponseForPage>(null as any);
    }

    /**
     * Create plan
     * @param useGroupId (optional) Whether to accept group IDs instead of group names. Group names are deprecated.
     * @return Returned if the request is successful.
     */
    createPlan(body: CreatePlanRequest, useGroupId?: boolean | undefined): ng.IPromise<number> {
        let url_ = this.baseUrl + "/rest/api/3/plans/plan?";
        if (useGroupId === null)
            throw new Error("The parameter 'useGroupId' cannot be null.");
        else if (useGroupId !== undefined)
            url_ += "useGroupId=" + encodeURIComponent("" + useGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreatePlan(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreatePlan(_response);
            throw _response;
        });
    }

    protected processCreatePlan(response: any): ng.IPromise<number> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the user is not logged in.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the Administer Jira global permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<number>(null as any);
    }

    /**
     * Get plan
     * @param planId The ID of the plan.
     * @param useGroupId (optional) Whether to return group IDs instead of group names. Group names are deprecated.
     * @return Returned if the request is successful.
     */
    getPlan(planId: number, useGroupId?: boolean | undefined): ng.IPromise<GetPlanResponse> {
        let url_ = this.baseUrl + "/rest/api/3/plans/plan/{planId}?";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        if (useGroupId === null)
            throw new Error("The parameter 'useGroupId' cannot be null.");
        else if (useGroupId !== undefined)
            url_ += "useGroupId=" + encodeURIComponent("" + useGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetPlan(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetPlan(_response);
            throw _response;
        });
    }

    protected processGetPlan(response: any): ng.IPromise<GetPlanResponse> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPlanResponse.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the user is not logged in.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the Administer Jira global permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the plan is not found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<GetPlanResponse>(null as any);
    }

    /**
     * Update plan
     * @param planId The ID of the plan.
     * @param useGroupId (optional) Whether to accept group IDs instead of group names. Group names are deprecated.
     * @return Returned if the request is successful.
     */
    updatePlan(planId: number, body: any, useGroupId?: boolean | undefined): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/plans/plan/{planId}?";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        if (useGroupId === null)
            throw new Error("The parameter 'useGroupId' cannot be null.");
        else if (useGroupId !== undefined)
            url_ += "useGroupId=" + encodeURIComponent("" + useGroupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdatePlan(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdatePlan(_response);
            throw _response;
        });
    }

    protected processUpdatePlan(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the user is not logged in.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the Administer Jira global permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the plan is not found.", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorCollection.fromJS(resultData409);
            return throwException(this.q, "Returned if the plan is not active.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Archive plan
     * @param planId The ID of the plan.
     * @return Returned if the request is successful.
     */
    archivePlan(planId: number): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/plans/plan/{planId}/archive";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processArchivePlan(_response);
        }, (_response) => {
            if (_response.status)
                return this.processArchivePlan(_response);
            throw _response;
        });
    }

    protected processArchivePlan(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the user is not logged in.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the Administer Jira global permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the plan is not found.", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorCollection.fromJS(resultData409);
            return throwException(this.q, "Returned if the plan is not active.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Duplicate plan
     * @param planId The ID of the plan.
     * @return Returned if the request is successful.
     */
    duplicatePlan(planId: number, body: DuplicatePlanRequest): ng.IPromise<number> {
        let url_ = this.baseUrl + "/rest/api/3/plans/plan/{planId}/duplicate";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDuplicatePlan(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDuplicatePlan(_response);
            throw _response;
        });
    }

    protected processDuplicatePlan(response: any): ng.IPromise<number> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the user is not logged in.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the Administer Jira global permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the plan to duplicate is not found.", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorCollection.fromJS(resultData409);
            return throwException(this.q, "Returned if the plan to duplicate is not active.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<number>(null as any);
    }

    /**
     * Get teams in plan paginated
     * @param planId The ID of the plan.
     * @param cursor (optional) The cursor to start from. If not provided, the first page will be returned.
     * @param maxResults (optional) The maximum number of plan teams to return per page. The maximum value is 50. The default value is 50.
     * @return Returned if the request is successful.
     */
    getTeams(planId: number, cursor?: string | undefined, maxResults?: number | undefined): ng.IPromise<PageWithCursorGetTeamResponseForPage> {
        let url_ = this.baseUrl + "/rest/api/3/plans/plan/{planId}/team?";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        if (cursor === null)
            throw new Error("The parameter 'cursor' cannot be null.");
        else if (cursor !== undefined)
            url_ += "cursor=" + encodeURIComponent("" + cursor) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetTeams(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetTeams(_response);
            throw _response;
        });
    }

    protected processGetTeams(response: any): ng.IPromise<PageWithCursorGetTeamResponseForPage> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageWithCursorGetTeamResponseForPage.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the user is not logged in.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the Administer Jira global permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the plan is not found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageWithCursorGetTeamResponseForPage>(null as any);
    }

    /**
     * Add Atlassian team to plan
     * @param planId The ID of the plan.
     * @return Returned if the request is successful.
     */
    addAtlassianTeam(planId: number, body: AddAtlassianTeamRequest): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/plans/plan/{planId}/team/atlassian";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddAtlassianTeam(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddAtlassianTeam(_response);
            throw _response;
        });
    }

    protected processAddAtlassianTeam(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the user is not logged in.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the Administer Jira global permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the plan or Atlassian team is not found.", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorCollection.fromJS(resultData409);
            return throwException(this.q, "Returned if the plan is not active.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Remove Atlassian team from plan
     * @param planId The ID of the plan.
     * @param atlassianTeamId The ID of the Atlassian team.
     * @return Returned if the request is successful.
     */
    removeAtlassianTeam(planId: number, atlassianTeamId: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/plans/plan/{planId}/team/atlassian/{atlassianTeamId}";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        if (atlassianTeamId === undefined || atlassianTeamId === null)
            throw new Error("The parameter 'atlassianTeamId' must be defined.");
        url_ = url_.replace("{atlassianTeamId}", encodeURIComponent("" + atlassianTeamId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveAtlassianTeam(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveAtlassianTeam(_response);
            throw _response;
        });
    }

    protected processRemoveAtlassianTeam(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the user is not logged in.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the Administer Jira global permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the plan or Atlassian team is not found, or the Atlassian team is not associated with the plan.", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorCollection.fromJS(resultData409);
            return throwException(this.q, "Returned if the plan is not active.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get Atlassian team in plan
     * @param planId The ID of the plan.
     * @param atlassianTeamId The ID of the Atlassian team.
     * @return Returned if the request is successful.
     */
    getAtlassianTeam(planId: number, atlassianTeamId: string): ng.IPromise<GetAtlassianTeamResponse> {
        let url_ = this.baseUrl + "/rest/api/3/plans/plan/{planId}/team/atlassian/{atlassianTeamId}";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        if (atlassianTeamId === undefined || atlassianTeamId === null)
            throw new Error("The parameter 'atlassianTeamId' must be defined.");
        url_ = url_.replace("{atlassianTeamId}", encodeURIComponent("" + atlassianTeamId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAtlassianTeam(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAtlassianTeam(_response);
            throw _response;
        });
    }

    protected processGetAtlassianTeam(response: any): ng.IPromise<GetAtlassianTeamResponse> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAtlassianTeamResponse.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the user is not logged in.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the Administer Jira global permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the plan or Atlassian team is not found, or the Atlassian team is not associated with the plan.", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorCollection.fromJS(resultData409);
            return throwException(this.q, "Returned if the plan is not active.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<GetAtlassianTeamResponse>(null as any);
    }

    /**
     * Update Atlassian team in plan
     * @param planId The ID of the plan.
     * @param atlassianTeamId The ID of the Atlassian team.
     * @return Returned if the request is successful.
     */
    updateAtlassianTeam(planId: number, atlassianTeamId: string, body: any): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/plans/plan/{planId}/team/atlassian/{atlassianTeamId}";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        if (atlassianTeamId === undefined || atlassianTeamId === null)
            throw new Error("The parameter 'atlassianTeamId' must be defined.");
        url_ = url_.replace("{atlassianTeamId}", encodeURIComponent("" + atlassianTeamId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateAtlassianTeam(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateAtlassianTeam(_response);
            throw _response;
        });
    }

    protected processUpdateAtlassianTeam(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the user is not logged in.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the Administer Jira global permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the plan or Atlassian team is not found, or the Atlassian team is not associated with the plan.", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorCollection.fromJS(resultData409);
            return throwException(this.q, "Returned if the plan is not active.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Create plan-only team
     * @param planId The ID of the plan.
     * @return Returned if the request is successful.
     */
    createPlanOnlyTeam(planId: number, body: CreatePlanOnlyTeamRequest): ng.IPromise<number> {
        let url_ = this.baseUrl + "/rest/api/3/plans/plan/{planId}/team/planonly";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreatePlanOnlyTeam(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreatePlanOnlyTeam(_response);
            throw _response;
        });
    }

    protected processCreatePlanOnlyTeam(response: any): ng.IPromise<number> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the user is not logged in.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the Administer Jira global permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the plan is not found.", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorCollection.fromJS(resultData409);
            return throwException(this.q, "Returned if the plan is not active.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<number>(null as any);
    }

    /**
     * Delete plan-only team
     * @param planId The ID of the plan.
     * @param planOnlyTeamId The ID of the plan-only team.
     * @return Returned if the request is successful.
     */
    deletePlanOnlyTeam(planId: number, planOnlyTeamId: number): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/plans/plan/{planId}/team/planonly/{planOnlyTeamId}";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        if (planOnlyTeamId === undefined || planOnlyTeamId === null)
            throw new Error("The parameter 'planOnlyTeamId' must be defined.");
        url_ = url_.replace("{planOnlyTeamId}", encodeURIComponent("" + planOnlyTeamId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeletePlanOnlyTeam(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeletePlanOnlyTeam(_response);
            throw _response;
        });
    }

    protected processDeletePlanOnlyTeam(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the user is not logged in.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the Administer Jira global permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the plan or plan-only team is not found, or the plan-only team is not associated with the plan.", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorCollection.fromJS(resultData409);
            return throwException(this.q, "Returned if the plan is not active.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get plan-only team
     * @param planId The ID of the plan.
     * @param planOnlyTeamId The ID of the plan-only team.
     * @return Returned if the request is successful.
     */
    getPlanOnlyTeam(planId: number, planOnlyTeamId: number): ng.IPromise<GetPlanOnlyTeamResponse> {
        let url_ = this.baseUrl + "/rest/api/3/plans/plan/{planId}/team/planonly/{planOnlyTeamId}";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        if (planOnlyTeamId === undefined || planOnlyTeamId === null)
            throw new Error("The parameter 'planOnlyTeamId' must be defined.");
        url_ = url_.replace("{planOnlyTeamId}", encodeURIComponent("" + planOnlyTeamId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetPlanOnlyTeam(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetPlanOnlyTeam(_response);
            throw _response;
        });
    }

    protected processGetPlanOnlyTeam(response: any): ng.IPromise<GetPlanOnlyTeamResponse> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPlanOnlyTeamResponse.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the user is not logged in.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the Administer Jira global permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the plan or plan-only team is not found, or the plan-only team is not associated with the plan.", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorCollection.fromJS(resultData409);
            return throwException(this.q, "Returned if the plan is not active.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<GetPlanOnlyTeamResponse>(null as any);
    }

    /**
     * Update plan-only team
     * @param planId The ID of the plan.
     * @param planOnlyTeamId The ID of the plan-only team.
     * @return Returned if the request is successful.
     */
    updatePlanOnlyTeam(planId: number, planOnlyTeamId: number, body: any): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/plans/plan/{planId}/team/planonly/{planOnlyTeamId}";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        if (planOnlyTeamId === undefined || planOnlyTeamId === null)
            throw new Error("The parameter 'planOnlyTeamId' must be defined.");
        url_ = url_.replace("{planOnlyTeamId}", encodeURIComponent("" + planOnlyTeamId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdatePlanOnlyTeam(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdatePlanOnlyTeam(_response);
            throw _response;
        });
    }

    protected processUpdatePlanOnlyTeam(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the user is not logged in.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the Administer Jira global permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the plan or plan-only team is not found, or the plan-only team is not associated with the plan.", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorCollection.fromJS(resultData409);
            return throwException(this.q, "Returned if the plan is not active.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Trash plan
     * @param planId The ID of the plan.
     * @return Returned if the request is successful.
     */
    trashPlan(planId: number): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/plans/plan/{planId}/trash";
        if (planId === undefined || planId === null)
            throw new Error("The parameter 'planId' must be defined.");
        url_ = url_.replace("{planId}", encodeURIComponent("" + planId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processTrashPlan(_response);
        }, (_response) => {
            if (_response.status)
                return this.processTrashPlan(_response);
            throw _response;
        });
    }

    protected processTrashPlan(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the user is not logged in.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the Administer Jira global permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the plan is not found.", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorCollection.fromJS(resultData409);
            return throwException(this.q, "Returned if the plan is not active.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get priorities
     * @return Returned if the request is successful.
     * @deprecated
     */
    getPriorities(): ng.IPromise<Priority[]> {
        let url_ = this.baseUrl + "/rest/api/3/priority";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetPriorities(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetPriorities(_response);
            throw _response;
        });
    }

    protected processGetPriorities(response: any): ng.IPromise<Priority[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Priority.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Priority[]>(null as any);
    }

    /**
     * Create priority
     * @return Returned if the request is successful.
     * @deprecated
     */
    createPriority(body: CreatePriorityDetails): ng.IPromise<PriorityId> {
        let url_ = this.baseUrl + "/rest/api/3/priority";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreatePriority(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreatePriority(_response);
            throw _response;
        });
    }

    protected processCreatePriority(response: any): ng.IPromise<PriorityId> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PriorityId.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PriorityId>(null as any);
    }

    /**
     * Set default priority
     * @return Returned if the request is successful.
     */
    setDefaultPriority(body: SetDefaultPriorityRequest): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/priority/default";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetDefaultPriority(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetDefaultPriority(_response);
            throw _response;
        });
    }

    protected processSetDefaultPriority(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the issue priority isn\'t found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Move priorities
     * @return Returned if the request is successful.
     */
    movePriorities(body: ReorderIssuePriorities): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/priority/move";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processMovePriorities(_response);
        }, (_response) => {
            if (_response.status)
                return this.processMovePriorities(_response);
            throw _response;
        });
    }

    protected processMovePriorities(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the issue priority isn\'t found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Search priorities
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param id (optional) The list of priority IDs. To include multiple IDs, provide an ampersand-separated list. For example, `id=2&id=3`.
     * @param projectId (optional) The list of projects IDs. To include multiple IDs, provide an ampersand-separated list. For example, `projectId=10010&projectId=10111`.
     * @param priorityName (optional) The name of priority to search for.
     * @param onlyDefault (optional) Whether only the default priority is returned.
     * @param expand (optional) Use `schemes` to return the associated priority schemes for each priority. Limited to returning first 15 priority schemes per priority.
     * @return Returned if the request is successful.
     * @deprecated
     */
    searchPriorities(startAt?: string | undefined, maxResults?: string | undefined, id?: string[] | undefined, projectId?: string[] | undefined, priorityName?: string | undefined, onlyDefault?: boolean | undefined, expand?: string | undefined): ng.IPromise<PageBeanPriority> {
        let url_ = this.baseUrl + "/rest/api/3/priority/search?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            projectId && projectId.forEach(item => { url_ += "projectId=" + encodeURIComponent("" + item) + "&"; });
        if (priorityName === null)
            throw new Error("The parameter 'priorityName' cannot be null.");
        else if (priorityName !== undefined)
            url_ += "priorityName=" + encodeURIComponent("" + priorityName) + "&";
        if (onlyDefault === null)
            throw new Error("The parameter 'onlyDefault' cannot be null.");
        else if (onlyDefault !== undefined)
            url_ += "onlyDefault=" + encodeURIComponent("" + onlyDefault) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSearchPriorities(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSearchPriorities(_response);
            throw _response;
        });
    }

    protected processSearchPriorities(response: any): ng.IPromise<PageBeanPriority> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanPriority.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanPriority>(null as any);
    }

    /**
     * Delete priority
     * @param id The ID of the issue priority.
     */
    deletePriority(id: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/priority/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeletePriority(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeletePriority(_response);
            throw _response;
        });
    }

    protected processDeletePriority(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 303) {
            const _responseText = response.data;
            let result303: any = null;
            let resultData303 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result303 = TaskProgressBeanObject.fromJS(resultData303);
            return throwException(this.q, "Returned if the request is successful.", status, _responseText, _headers, result303);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the issue priority isn\'t found.", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorCollection.fromJS(resultData409);
            return throwException(this.q, "Returned if a task to delete the issue priority is already running.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get priority
     * @param id The ID of the issue priority.
     * @return Returned if the request is successful.
     */
    getPriority(id: string): ng.IPromise<Priority> {
        let url_ = this.baseUrl + "/rest/api/3/priority/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetPriority(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetPriority(_response);
            throw _response;
        });
    }

    protected processGetPriority(response: any): ng.IPromise<Priority> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Priority.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue priority isn\'t found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Priority>(null as any);
    }

    /**
     * Update priority
     * @param id The ID of the issue priority.
     * @return Returned if the request is successful.
     * @deprecated
     */
    updatePriority(id: string, body: UpdatePriorityDetails): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/priority/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdatePriority(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdatePriority(_response);
            throw _response;
        });
    }

    protected processUpdatePriority(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the issue priority isn\'t found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get priority schemes
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param priorityId (optional) A set of priority IDs to filter by. To include multiple IDs, provide an ampersand-separated list. For example, `priorityId=10000&priorityId=10001`.
     * @param schemeId (optional) A set of priority scheme IDs. To include multiple IDs, provide an ampersand-separated list. For example, `schemeId=10000&schemeId=10001`.
     * @param schemeName (optional) The name of scheme to search for.
     * @param onlyDefault (optional) Whether only the default priority is returned.
     * @param orderBy (optional) The ordering to return the priority schemes by.
     * @param expand (optional) A comma separated list of additional information to return. "priorities" will return priorities associated with the priority scheme. "projects" will return projects associated with the priority scheme. `expand=priorities,projects`.
     * @return Returned if the request is successful.
     */
    getPrioritySchemes(startAt?: string | undefined, maxResults?: string | undefined, priorityId?: number[] | undefined, schemeId?: number[] | undefined, schemeName?: string | undefined, onlyDefault?: boolean | undefined, orderBy?: OrderBy9 | undefined, expand?: string | undefined): ng.IPromise<PageBeanPrioritySchemeWithPaginatedPrioritiesAndProjects> {
        let url_ = this.baseUrl + "/rest/api/3/priorityscheme?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (priorityId === null)
            throw new Error("The parameter 'priorityId' cannot be null.");
        else if (priorityId !== undefined)
            priorityId && priorityId.forEach(item => { url_ += "priorityId=" + encodeURIComponent("" + item) + "&"; });
        if (schemeId === null)
            throw new Error("The parameter 'schemeId' cannot be null.");
        else if (schemeId !== undefined)
            schemeId && schemeId.forEach(item => { url_ += "schemeId=" + encodeURIComponent("" + item) + "&"; });
        if (schemeName === null)
            throw new Error("The parameter 'schemeName' cannot be null.");
        else if (schemeName !== undefined)
            url_ += "schemeName=" + encodeURIComponent("" + schemeName) + "&";
        if (onlyDefault === null)
            throw new Error("The parameter 'onlyDefault' cannot be null.");
        else if (onlyDefault !== undefined)
            url_ += "onlyDefault=" + encodeURIComponent("" + onlyDefault) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetPrioritySchemes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetPrioritySchemes(_response);
            throw _response;
        });
    }

    protected processGetPrioritySchemes(response: any): ng.IPromise<PageBeanPrioritySchemeWithPaginatedPrioritiesAndProjects> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanPrioritySchemeWithPaginatedPrioritiesAndProjects.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanPrioritySchemeWithPaginatedPrioritiesAndProjects>(null as any);
    }

    /**
     * Create priority scheme
     * @return Returned if the request is completed.
     */
    createPriorityScheme(body: CreatePrioritySchemeDetails): ng.IPromise<PrioritySchemeId> {
        let url_ = this.baseUrl + "/rest/api/3/priorityscheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreatePriorityScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreatePriorityScheme(_response);
            throw _response;
        });
    }

    protected processCreatePriorityScheme(response: any): ng.IPromise<PrioritySchemeId> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PrioritySchemeId.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = PrioritySchemeId.fromJS(resultData202);
            return this.q.resolve(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request isn\'t valid.\n\n**Mappings Validation Errors**\n\n *  ``The priorities with IDs [ID 1, ID 2, ...] require mapping. Please provide mappings in the \'in\' mappings object, where these priorities are the keys with corresponding values.`` The listed priority ID(s) have not been provided as keys for ``in`` mappings but are required, add them to the mappings object.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permissions.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if an action with this priority scheme is still in progress.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PrioritySchemeId>(null as any);
    }

    /**
     * Suggested priorities for mappings
     * @return Returned if the request is successful.
     */
    suggestedPrioritiesForMappings(body: SuggestedMappingsRequestBean): ng.IPromise<PageBeanPriorityWithSequence> {
        let url_ = this.baseUrl + "/rest/api/3/priorityscheme/mappings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSuggestedPrioritiesForMappings(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSuggestedPrioritiesForMappings(_response);
            throw _response;
        });
    }

    protected processSuggestedPrioritiesForMappings(response: any): ng.IPromise<PageBeanPriorityWithSequence> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanPriorityWithSequence.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanPriorityWithSequence>(null as any);
    }

    /**
     * Get available priorities by priority scheme
     * @param schemeId The priority scheme ID.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param query (optional) The string to query priorities on by name.
     * @param exclude (optional) A list of priority IDs to exclude from the results.
     * @return Returned if the request is successful.
     */
    getAvailablePrioritiesByPriorityScheme(schemeId: string, startAt?: string | undefined, maxResults?: string | undefined, query?: string | undefined, exclude?: string[] | undefined): ng.IPromise<PageBeanPriorityWithSequence> {
        let url_ = this.baseUrl + "/rest/api/3/priorityscheme/priorities/available?";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined and cannot be null.");
        else
            url_ += "schemeId=" + encodeURIComponent("" + schemeId) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (exclude === null)
            throw new Error("The parameter 'exclude' cannot be null.");
        else if (exclude !== undefined)
            exclude && exclude.forEach(item => { url_ += "exclude=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAvailablePrioritiesByPriorityScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAvailablePrioritiesByPriorityScheme(_response);
            throw _response;
        });
    }

    protected processGetAvailablePrioritiesByPriorityScheme(response: any): ng.IPromise<PageBeanPriorityWithSequence> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanPriorityWithSequence.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanPriorityWithSequence>(null as any);
    }

    /**
     * Delete priority scheme
     * @param schemeId The priority scheme ID.
     * @return Returned if the request is successful.
     */
    deletePriorityScheme(schemeId: number): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/priorityscheme/{schemeId}";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeletePriorityScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeletePriorityScheme(_response);
            throw _response;
        });
    }

    protected processDeletePriorityScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Update priority scheme
     * @param schemeId The ID of the priority scheme.
     * @return Returned if the request is accepted.
     */
    updatePriorityScheme(schemeId: number, body: UpdatePrioritySchemeRequestBean): ng.IPromise<UpdatePrioritySchemeResponseBean> {
        let url_ = this.baseUrl + "/rest/api/3/priorityscheme/{schemeId}";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdatePriorityScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdatePriorityScheme(_response);
            throw _response;
        });
    }

    protected processUpdatePriorityScheme(response: any): ng.IPromise<UpdatePrioritySchemeResponseBean> {
        const status = response.status;

        let _headers: any = {};
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = UpdatePrioritySchemeResponseBean.fromJS(resultData202);
            return this.q.resolve(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request isn\'t valid.\n\n**Mappings Validation Errors**\n\n *  ``The changes to priority schemes require mapping of priorities. Please provide a value for the \'in\' mappings object.`` Priorities are being removed and/or projects are being added to the scheme, but ``in`` mappings are not provided.\n *  ``The changes to priority schemes require mapping of priorities. Please provide a value for the \'out\' mappings object.`` Projects are being removed from the scheme, but ``out`` mappings are not provided.\n *  ``The priorities with IDs [ID 1, ID 2, ...] provided as keys for the \'in\' mappings object do not exist. Please provide existing priority IDs.`` The listed priority ID(s) have been provided as keys for ``in`` mappings but do not exist. Please confirm the correct priority ID(s) have been provided, they should be priorities that exist on the Jira site which are used by projects being added to the current scheme, but are not in use by the current scheme.\n *  ``The priorities with IDs [ID 1, ID 2, ...] provided as values for the \'in\' mappings object do not exist. Please provide existing priority IDs used by the current priority scheme.`` The listed priority ID(s) have been provided as values for ``in`` mappings but do not exist. Please confirm the correct priority ID(s) have been provided, they should be priorities that exist on the Jira site and are in use by the current scheme.\n *  ``The priorities with IDs [ID 1, ID 2, ...] provided as keys for the \'out\' mappings object do not exist. Please provide existing priority IDs used by the current priority scheme.`` The listed priority ID(s) have been provided as keys for ``out`` mappings but are invalid. Please confirm the correct priority ID(s) have been provided, they should be priorities that exist on the Jira site and are in use by the current scheme.\n *  ``The priorities with IDs [ID 1, ID 2, ...] provided as values for the \'out\' mappings object do not exist. Please provide existing priority IDs used by the default scheme.`` The listed priority ID(s) have been provided as values for ``out`` mappings but are invalid. Please confirm the correct priority ID(s) have been provided, they should be priorities that exist on the Jira site and are in use by the Default Priority Scheme, but are not in use by the current scheme.\n *  ``The priorities with IDs [ID 1, ID 2, ...] do not require mapping. Please remove these keys and their corresponding values from the \'in\' mappings object.`` The listed priority ID(s) have been provided as keys for ``in`` mappings but are not required, they can be removed from the mappings object.\n *  ``The priorities with IDs [ID 1, ID 2, ...] require mapping. Please provide mappings in the \'in\' mappings object, where these priorities are the keys with corresponding values.`` The listed priority ID(s) have not been provided as keys for ``in`` mappings but are required, add them to the mappings object.\n *  ``The priorities with IDs [ID 1, ID 2, ...] being mapped to are not in the current scheme. Please remove these values and their corresponding keys from the \'in\' mappings object.`` The listed priority ID(s) have been provided as keys for ``in`` mappings but are not in use by the current scheme, they can be removed from the mappings object.\n *  ``The priorities with IDs [ID 1, ID 2, ...] do not require mapping. Please remove these keys and their corresponding values from the \'out\' mappings object.`` The listed priority ID(s) hve been provided as keys for ``out`` mappings but are not required, they can be removed from the mappings object.\n *  ``The priorities with IDs [ID 1, ID 2, ...] require mapping. Please provide mappings in the \'out\' mappings object, where these priorities are the keys with corresponding values.`` The listed priority ID(s) have not been provided as keys for ``out`` mappings but are required, add them to the mappings object.\n *  ``The priorities with IDs [ID 1, ID 2, ...] being mapped to are not in the default scheme. Please remove these values and their corresponding keys from the \'out\' mappings object.`` The listed priority ID(s) have been provided as keys for ``out`` mappings but are not in use by the Default Priority Scheme, they can be removed from the mappings object.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permissions.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if an action with this priority scheme is still in progress.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<UpdatePrioritySchemeResponseBean>(null as any);
    }

    /**
     * Get priorities by priority scheme
     * @param schemeId The priority scheme ID.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getPrioritiesByPriorityScheme(schemeId: string, startAt?: string | undefined, maxResults?: string | undefined): ng.IPromise<PageBeanPriorityWithSequence> {
        let url_ = this.baseUrl + "/rest/api/3/priorityscheme/{schemeId}/priorities?";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetPrioritiesByPriorityScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetPrioritiesByPriorityScheme(_response);
            throw _response;
        });
    }

    protected processGetPrioritiesByPriorityScheme(response: any): ng.IPromise<PageBeanPriorityWithSequence> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanPriorityWithSequence.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanPriorityWithSequence>(null as any);
    }

    /**
     * Get projects by priority scheme
     * @param schemeId The priority scheme ID.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param projectId (optional) The project IDs to filter by. For example, `projectId=10000&projectId=10001`.
     * @param query (optional) The string to query projects on by name.
     * @return Returned if the request is successful.
     */
    getProjectsByPriorityScheme(schemeId: string, startAt?: string | undefined, maxResults?: string | undefined, projectId?: number[] | undefined, query?: string | undefined): ng.IPromise<PageBeanProject> {
        let url_ = this.baseUrl + "/rest/api/3/priorityscheme/{schemeId}/projects?";
        if (schemeId === undefined || schemeId === null)
            throw new Error("The parameter 'schemeId' must be defined.");
        url_ = url_.replace("{schemeId}", encodeURIComponent("" + schemeId));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            projectId && projectId.forEach(item => { url_ += "projectId=" + encodeURIComponent("" + item) + "&"; });
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectsByPriorityScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectsByPriorityScheme(_response);
            throw _response;
        });
    }

    protected processGetProjectsByPriorityScheme(response: any): ng.IPromise<PageBeanProject> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanProject.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanProject>(null as any);
    }

    /**
     * Get all projects
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expanded options include:

     *  `description` Returns the project description.
     *  `issueTypes` Returns all issue types associated with the project.
     *  `lead` Returns information about the project lead.
     *  `projectKeys` Returns all project keys associated with the project.
     * @param recent (optional) Returns the user's most recently accessed projects. You may specify the number of results to return up to a maximum of 20. If access is anonymous, then the recently accessed projects are based on the current HTTP session.
     * @param properties (optional) A list of project properties to return for the project. This parameter accepts a comma-separated list.
     * @return Returned if the request is successful.
     * @deprecated
     */
    getAllProjects(expand?: string | undefined, recent?: number | undefined, properties?: string[] | undefined): ng.IPromise<Project[]> {
        let url_ = this.baseUrl + "/rest/api/3/project?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (recent === null)
            throw new Error("The parameter 'recent' cannot be null.");
        else if (recent !== undefined)
            url_ += "recent=" + encodeURIComponent("" + recent) + "&";
        if (properties === null)
            throw new Error("The parameter 'properties' cannot be null.");
        else if (properties !== undefined)
            properties && properties.forEach(item => { url_ += "properties=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllProjects(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllProjects(_response);
            throw _response;
        });
    }

    protected processGetAllProjects(response: any): ng.IPromise<Project[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Project.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Project[]>(null as any);
    }

    /**
     * Create project
     * @param body The JSON representation of the project being created.
     * @return Returned if the project is created.
     */
    createProject(body: CreateProjectDetails): ng.IPromise<ProjectIdentifiers> {
        let url_ = this.baseUrl + "/rest/api/3/project";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateProject(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateProject(_response);
            throw _response;
        });
    }

    protected processCreateProject(response: any): ng.IPromise<ProjectIdentifiers> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProjectIdentifiers.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid and the project could not be created.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to create projects.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectIdentifiers>(null as any);
    }

    /**
     * Create custom project
     * @param body The JSON payload containing the project details and capabilities
     */
    createProjectWithCustomTemplate(body: ProjectCustomTemplateCreateRequestDTO): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/project-template";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateProjectWithCustomTemplate(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateProjectWithCustomTemplate(_response);
            throw _response;
        });
    }

    protected processCreateProjectWithCustomTemplate(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 303) {
            const _responseText = response.data;
            let result303: any = null;
            let resultData303 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result303 = resultData303 !== undefined ? resultData303 : <any>null;
    
            return throwException(this.q, "The project creation task has been queued for execution", status, _responseText, _headers, result303);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get recent projects
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expanded options include:

     *  `description` Returns the project description.
     *  `projectKeys` Returns all project keys associated with a project.
     *  `lead` Returns information about the project lead.
     *  `issueTypes` Returns all issue types associated with the project.
     *  `url` Returns the URL associated with the project.
     *  `permissions` Returns the permissions associated with the project.
     *  `insight` EXPERIMENTAL. Returns the insight details of total issue count and last issue update time for the project.
     *  `*` Returns the project with all available expand options.
     * @param properties (optional) EXPERIMENTAL. A list of project properties to return for the project. This parameter accepts a comma-separated list. Invalid property names are ignored.
     * @return Returned if the request is successful.
     */
    getRecent(expand?: string | undefined, properties?: StringList[] | undefined): ng.IPromise<Project[]> {
        let url_ = this.baseUrl + "/rest/api/3/project/recent?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (properties === null)
            throw new Error("The parameter 'properties' cannot be null.");
        else if (properties !== undefined)
            properties && properties.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "properties[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetRecent(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetRecent(_response);
            throw _response;
        });
    }

    protected processGetRecent(response: any): ng.IPromise<Project[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Project.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Project[]>(null as any);
    }

    /**
     * Get projects paginated
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param orderBy (optional) [Order](#ordering) the results by a field.

     *  `category` Sorts by project category. A complete list of category IDs is found using [Get all project categories](#api-rest-api-3-projectCategory-get).
     *  `issueCount` Sorts by the total number of issues in each project.
     *  `key` Sorts by project key.
     *  `lastIssueUpdatedTime` Sorts by the last issue update time.
     *  `name` Sorts by project name.
     *  `owner` Sorts by project lead.
     *  `archivedDate` EXPERIMENTAL. Sorts by project archived date.
     *  `deletedDate` EXPERIMENTAL. Sorts by project deleted date.
     * @param id (optional) The project IDs to filter the results by. To include multiple IDs, provide an ampersand-separated list. For example, `id=10000&id=10001`. Up to 50 project IDs can be provided.
     * @param keys (optional) The project keys to filter the results by. To include multiple keys, provide an ampersand-separated list. For example, `keys=PA&keys=PB`. Up to 50 project keys can be provided.
     * @param query (optional) Filter the results using a literal string. Projects with a matching `key` or `name` are returned (case insensitive).
     * @param typeKey (optional) Orders results by the [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes). This parameter accepts a comma-separated list. Valid values are `business`, `service_desk`, and `software`.
     * @param categoryId (optional) The ID of the project's category. A complete list of category IDs is found using the [Get all project categories](#api-rest-api-3-projectCategory-get) operation.
     * @param action (optional) Filter results by projects for which the user can:

     *  `view` the project, meaning that they have one of the following permissions:
    
         *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project.
         *  *Administer projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project.
         *  *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     *  `browse` the project, meaning that they have the *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project.
     *  `edit` the project, meaning that they have one of the following permissions:
    
         *  *Administer projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project.
         *  *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
     *  `create` the project, meaning that they have the *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project in which the issue is created.
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expanded options include:

     *  `description` Returns the project description.
     *  `projectKeys` Returns all project keys associated with a project.
     *  `lead` Returns information about the project lead.
     *  `issueTypes` Returns all issue types associated with the project.
     *  `url` Returns the URL associated with the project.
     *  `insight` EXPERIMENTAL. Returns the insight details of total issue count and last issue update time for the project.
     * @param status (optional) EXPERIMENTAL. Filter results by project status:

     *  `live` Search live projects.
     *  `archived` Search archived projects.
     *  `deleted` Search deleted projects, those in the recycle bin.
     * @param properties (optional) EXPERIMENTAL. A list of project properties to return for the project. This parameter accepts a comma-separated list.
     * @param propertyQuery (optional) EXPERIMENTAL. A query string used to search properties. The query string cannot be specified using a JSON object. For example, to search for the value of `nested` from `{"something":{"nested":1,"other":2}}` use `[thepropertykey].something.nested=1`. Note that the propertyQuery key is enclosed in square brackets to enable searching where the propertyQuery key includes dot (.) or equals (=) characters. Note that `thepropertykey` is only returned when included in `properties`.
     * @return Returned if the request is successful.
     */
    searchProjects(startAt?: number | undefined, maxResults?: number | undefined, orderBy?: OrderBy10 | undefined, id?: number[] | undefined, keys?: string[] | undefined, query?: string | undefined, typeKey?: string | undefined, categoryId?: number | undefined, action?: Action | undefined, expand?: string | undefined, status?: Status4[] | undefined, properties?: StringList[] | undefined, propertyQuery?: string | undefined): ng.IPromise<PageBeanProject> {
        let url_ = this.baseUrl + "/rest/api/3/project/search?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (keys === null)
            throw new Error("The parameter 'keys' cannot be null.");
        else if (keys !== undefined)
            keys && keys.forEach(item => { url_ += "keys=" + encodeURIComponent("" + item) + "&"; });
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (typeKey === null)
            throw new Error("The parameter 'typeKey' cannot be null.");
        else if (typeKey !== undefined)
            url_ += "typeKey=" + encodeURIComponent("" + typeKey) + "&";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (action === null)
            throw new Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            status && status.forEach(item => { url_ += "status=" + encodeURIComponent("" + item) + "&"; });
        if (properties === null)
            throw new Error("The parameter 'properties' cannot be null.");
        else if (properties !== undefined)
            properties && properties.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "properties[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (propertyQuery === null)
            throw new Error("The parameter 'propertyQuery' cannot be null.");
        else if (propertyQuery !== undefined)
            url_ += "propertyQuery=" + encodeURIComponent("" + propertyQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSearchProjects(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSearchProjects(_response);
            throw _response;
        });
    }

    protected processSearchProjects(response: any): ng.IPromise<PageBeanProject> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanProject.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if no projects matching the search criteria are found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanProject>(null as any);
    }

    /**
     * Get all project types
     * @return Returned if the request is successful.
     */
    getAllProjectTypes(): ng.IPromise<ProjectType[]> {
        let url_ = this.baseUrl + "/rest/api/3/project/type";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllProjectTypes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllProjectTypes(_response);
            throw _response;
        });
    }

    protected processGetAllProjectTypes(response: any): ng.IPromise<ProjectType[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectType[]>(null as any);
    }

    /**
     * Get licensed project types
     * @return Returned if the request is successful.
     */
    getAllAccessibleProjectTypes(): ng.IPromise<ProjectType[]> {
        let url_ = this.baseUrl + "/rest/api/3/project/type/accessible";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllAccessibleProjectTypes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllAccessibleProjectTypes(_response);
            throw _response;
        });
    }

    protected processGetAllAccessibleProjectTypes(response: any): ng.IPromise<ProjectType[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectType[]>(null as any);
    }

    /**
     * Get project type by key
     * @param projectTypeKey The key of the project type.
     * @return Returned if the request is successful.
     */
    getProjectTypeByKey(projectTypeKey: ProjectTypeKey): ng.IPromise<ProjectType> {
        let url_ = this.baseUrl + "/rest/api/3/project/type/{projectTypeKey}";
        if (projectTypeKey === undefined || projectTypeKey === null)
            throw new Error("The parameter 'projectTypeKey' must be defined.");
        url_ = url_.replace("{projectTypeKey}", encodeURIComponent("" + projectTypeKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectTypeByKey(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectTypeByKey(_response);
            throw _response;
        });
    }

    protected processGetProjectTypeByKey(response: any): ng.IPromise<ProjectType> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectType.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project type is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectType>(null as any);
    }

    /**
     * Get accessible project type by key
     * @param projectTypeKey The key of the project type.
     * @return Returned if the request is successful.
     */
    getAccessibleProjectTypeByKey(projectTypeKey: ProjectTypeKey2): ng.IPromise<ProjectType> {
        let url_ = this.baseUrl + "/rest/api/3/project/type/{projectTypeKey}/accessible";
        if (projectTypeKey === undefined || projectTypeKey === null)
            throw new Error("The parameter 'projectTypeKey' must be defined.");
        url_ = url_.replace("{projectTypeKey}", encodeURIComponent("" + projectTypeKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAccessibleProjectTypeByKey(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAccessibleProjectTypeByKey(_response);
            throw _response;
        });
    }

    protected processGetAccessibleProjectTypeByKey(response: any): ng.IPromise<ProjectType> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectType.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project type is not accessible to the user.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectType>(null as any);
    }

    /**
     * Delete project
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @param enableUndo (optional) Whether this project is placed in the Jira recycle bin where it will be available for restoration.
     * @return Returned if the project is deleted.
     */
    deleteProject(projectIdOrKey: string, enableUndo?: boolean | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (enableUndo === null)
            throw new Error("The parameter 'enableUndo' cannot be null.");
        else if (enableUndo !== undefined)
            url_ += "enableUndo=" + encodeURIComponent("" + enableUndo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteProject(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteProject(_response);
            throw _response;
        });
    }

    protected processDeleteProject(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user does not have permission to delete it.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get project
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Note that the project description, issue types, and project lead are included in all responses by default. Expand options include:

     *  `description` The project description.
     *  `issueTypes` The issue types associated with the project.
     *  `lead` The project lead.
     *  `projectKeys` All project keys associated with the project.
     *  `issueTypeHierarchy` The project issue type hierarchy.
     * @param properties (optional) A list of project properties to return for the project. This parameter accepts a comma-separated list.
     * @return Returned if successful.
     */
    getProject(projectIdOrKey: string, expand?: string | undefined, properties?: string[] | undefined): ng.IPromise<Project> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (properties === null)
            throw new Error("The parameter 'properties' cannot be null.");
        else if (properties !== undefined)
            properties && properties.forEach(item => { url_ += "properties=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProject(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProject(_response);
            throw _response;
        });
    }

    protected processGetProject(response: any): ng.IPromise<Project> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Project.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Project>(null as any);
    }

    /**
     * Update project
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @param body The project details to be updated.
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Note that the project description, issue types, and project lead are included in all responses by default. Expand options include:

     *  `description` The project description.
     *  `issueTypes` The issue types associated with the project.
     *  `lead` The project lead.
     *  `projectKeys` All project keys associated with the project.
     * @return Returned if the project is updated.
     */
    updateProject(projectIdOrKey: string, body: UpdateProjectDetails, expand?: string | undefined): ng.IPromise<Project> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateProject(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateProject(_response);
            throw _response;
        });
    }

    protected processUpdateProject(response: any): ng.IPromise<Project> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Project.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the user does not have the necessary permission to update project details.\n *  the permission scheme is being changed and the Jira instance is Jira Core Free or Jira Software Free. Permission schemes cannot be changed on free plans.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Project>(null as any);
    }

    /**
     * Archive project
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @return Returned if the request is successful.
     */
    archiveProject(projectIdOrKey: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/archive";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processArchiveProject(_response);
        }, (_response) => {
            if (_response.status)
                return this.processArchiveProject(_response);
            throw _response;
        });
    }

    protected processArchiveProject(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Set project avatar
     * @param projectIdOrKey The ID or (case-sensitive) key of the project.
     * @return Returned if the request is successful.
     */
    updateProjectAvatar(projectIdOrKey: string, body: Avatar): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/avatar";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateProjectAvatar(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateProjectAvatar(_response);
            throw _response;
        });
    }

    protected processUpdateProjectAvatar(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to administer the project.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project or avatar is not found or the user does not have permission to view the project.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Delete project avatar
     * @param projectIdOrKey The project ID or (case-sensitive) key.
     * @param id The ID of the avatar.
     * @return Returned if the request is successful.
     */
    deleteProjectAvatar(projectIdOrKey: string, id: number): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/avatar/{id}";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteProjectAvatar(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteProjectAvatar(_response);
            throw _response;
        });
    }

    protected processDeleteProjectAvatar(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the avatar is a system avatar or the user does not have permission to administer the project.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project or avatar is not found or the user does not have permission to view the project.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Load project avatar
     * @param projectIdOrKey The ID or (case-sensitive) key of the project.
     * @param x (optional) The X coordinate of the top-left corner of the crop region.
     * @param y (optional) The Y coordinate of the top-left corner of the crop region.
     * @param size (optional) The length of each side of the crop region.
     * @return Returned if the request is successful.
     */
    createProjectAvatar(projectIdOrKey: string, body: any, x?: number | undefined, y?: number | undefined, size?: number | undefined): ng.IPromise<Avatar> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/avatar2?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (x === null)
            throw new Error("The parameter 'x' cannot be null.");
        else if (x !== undefined)
            url_ += "x=" + encodeURIComponent("" + x) + "&";
        if (y === null)
            throw new Error("The parameter 'y' cannot be null.");
        else if (y !== undefined)
            url_ += "y=" + encodeURIComponent("" + y) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "*/*",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateProjectAvatar(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateProjectAvatar(_response);
            throw _response;
        });
    }

    protected processCreateProjectAvatar(response: any): ng.IPromise<Avatar> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Avatar.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  an image isn\'t included in the request.\n *  the image type is unsupported.\n *  the crop parameters extend the crop area beyond the edge of the image.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to administer the project or an anonymous call is made to the operation.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user does not have permission to view the project.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Avatar>(null as any);
    }

    /**
     * Get all project avatars
     * @param projectIdOrKey The ID or (case-sensitive) key of the project.
     * @return Returned if request is successful.
     */
    getAllProjectAvatars(projectIdOrKey: string): ng.IPromise<ProjectAvatars> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/avatars";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllProjectAvatars(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllProjectAvatars(_response);
            throw _response;
        });
    }

    protected processGetAllProjectAvatars(response: any): ng.IPromise<ProjectAvatars> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectAvatars.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user does not have permission to view the project.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectAvatars>(null as any);
    }

    /**
     * Remove the default data classification level from a project
     * @param projectIdOrKey The project ID or project key (case-sensitive).
     * @return Returned if the request is successful.
     */
    removeDefaultProjectClassification(projectIdOrKey: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/classification-level/default";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveDefaultProjectClassification(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveDefaultProjectClassification(_response);
            throw _response;
        });
    }

    protected processRemoveDefaultProjectClassification(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get the default data classification level of a project
     * @param projectIdOrKey The project ID or project key (case-sensitive).
     * @return Returned if the request is successful.
     */
    getDefaultProjectClassification(projectIdOrKey: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/classification-level/default";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetDefaultProjectClassification(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetDefaultProjectClassification(_response);
            throw _response;
        });
    }

    protected processGetDefaultProjectClassification(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Update the default data classification level of a project
     * @param projectIdOrKey The project ID or project key (case-sensitive).
     * @return Returned if the request is successful.
     */
    updateDefaultProjectClassification(projectIdOrKey: string, body: UpdateDefaultProjectClassificationBean): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/classification-level/default";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateDefaultProjectClassification(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateDefaultProjectClassification(_response);
            throw _response;
        });
    }

    protected processUpdateDefaultProjectClassification(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get project components paginated
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param orderBy (optional) [Order](#ordering) the results by a field:

     *  `description` Sorts by the component description.
     *  `issueCount` Sorts by the count of issues associated with the component.
     *  `lead` Sorts by the user key of the component's project lead.
     *  `name` Sorts by component name.
     * @param componentSource (optional) The source of the components to return. Can be `jira` (default), `compass` or `auto`. When `auto` is specified, the API will return connected Compass components if the project is opted into Compass, otherwise it will return Jira components. Defaults to `jira`.
     * @param query (optional) Filter the results using a literal string. Components with a matching `name` or `description` are returned (case insensitive).
     * @return Returned if the request is successful.
     */
    getProjectComponentsPaginated(projectIdOrKey: string, startAt?: number | undefined, maxResults?: number | undefined, orderBy?: OrderBy11 | undefined, componentSource?: ComponentSource | undefined, query?: string | undefined): ng.IPromise<PageBeanComponentWithIssueCount> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/component?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (componentSource === null)
            throw new Error("The parameter 'componentSource' cannot be null.");
        else if (componentSource !== undefined)
            url_ += "componentSource=" + encodeURIComponent("" + componentSource) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectComponentsPaginated(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectComponentsPaginated(_response);
            throw _response;
        });
    }

    protected processGetProjectComponentsPaginated(response: any): ng.IPromise<PageBeanComponentWithIssueCount> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanComponentWithIssueCount.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanComponentWithIssueCount>(null as any);
    }

    /**
     * Get project components
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @param componentSource (optional) The source of the components to return. Can be `jira` (default), `compass` or `auto`. When `auto` is specified, the API will return connected Compass components if the project is opted into Compass, otherwise it will return Jira components. Defaults to `jira`.
     * @return Returned if the request is successful.
     */
    getProjectComponents(projectIdOrKey: string, componentSource?: ComponentSource2 | undefined): ng.IPromise<ProjectComponent[]> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/components?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (componentSource === null)
            throw new Error("The parameter 'componentSource' cannot be null.");
        else if (componentSource !== undefined)
            url_ += "componentSource=" + encodeURIComponent("" + componentSource) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectComponents(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectComponents(_response);
            throw _response;
        });
    }

    protected processGetProjectComponents(response: any): ng.IPromise<ProjectComponent[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectComponent.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectComponent[]>(null as any);
    }

    /**
     * Delete project asynchronously
     * @param projectIdOrKey The project ID or project key (case sensitive).
     */
    deleteProjectAsynchronously(projectIdOrKey: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/delete";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteProjectAsynchronously(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteProjectAsynchronously(_response);
            throw _response;
        });
    }

    protected processDeleteProjectAsynchronously(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 303) {
            const _responseText = response.data;
            let result303: any = null;
            let resultData303 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result303 = TaskProgressBeanObject.fromJS(resultData303);
            return throwException(this.q, "Returned if the request is successful.", status, _responseText, _headers, result303);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get project features
     * @param projectIdOrKey The ID or (case-sensitive) key of the project.
     * @return Returned if the request is successful.
     */
    getFeaturesForProject(projectIdOrKey: string): ng.IPromise<ContainerForProjectFeatures> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/features";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetFeaturesForProject(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetFeaturesForProject(_response);
            throw _response;
        });
    }

    protected processGetFeaturesForProject(response: any): ng.IPromise<ContainerForProjectFeatures> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContainerForProjectFeatures.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ContainerForProjectFeatures>(null as any);
    }

    /**
     * Set project feature state
     * @param projectIdOrKey The ID or (case-sensitive) key of the project.
     * @param featureKey The key of the feature.
     * @param body Details of the feature state change.
     * @return Returned if the request is successful.
     */
    toggleFeatureForProject(projectIdOrKey: string, featureKey: string, body: ProjectFeatureState): ng.IPromise<ContainerForProjectFeatures> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/features/{featureKey}";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (featureKey === undefined || featureKey === null)
            throw new Error("The parameter 'featureKey' must be defined.");
        url_ = url_.replace("{featureKey}", encodeURIComponent("" + featureKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processToggleFeatureForProject(_response);
        }, (_response) => {
            if (_response.status)
                return this.processToggleFeatureForProject(_response);
            throw _response;
        });
    }

    protected processToggleFeatureForProject(response: any): ng.IPromise<ContainerForProjectFeatures> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContainerForProjectFeatures.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project or project feature is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ContainerForProjectFeatures>(null as any);
    }

    /**
     * Get project property keys
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @return Returned if the request is successful.
     */
    getProjectPropertyKeys(projectIdOrKey: string): ng.IPromise<PropertyKeys> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/properties";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectPropertyKeys(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectPropertyKeys(_response);
            throw _response;
        });
    }

    protected processGetProjectPropertyKeys(response: any): ng.IPromise<PropertyKeys> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyKeys.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to view the project.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PropertyKeys>(null as any);
    }

    /**
     * Delete project property
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @param propertyKey The project property key. Use [Get project property keys](#api-rest-api-3-project-projectIdOrKey-properties-get) to get a list of all project property keys.
     * @return Returned if the project property is deleted.
     */
    deleteProjectProperty(projectIdOrKey: string, propertyKey: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/properties/{propertyKey}";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteProjectProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteProjectProperty(_response);
            throw _response;
        });
    }

    protected processDeleteProjectProperty(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to administer the project.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project or property is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get project property
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @param propertyKey The project property key. Use [Get project property keys](#api-rest-api-3-project-projectIdOrKey-properties-get) to get a list of all project property keys.
     * @return Returned if the request is successful.
     */
    getProjectProperty(projectIdOrKey: string, propertyKey: string): ng.IPromise<EntityProperty> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/properties/{propertyKey}";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectProperty(_response);
            throw _response;
        });
    }

    protected processGetProjectProperty(response: any): ng.IPromise<EntityProperty> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityProperty.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to view the project.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project or property is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<EntityProperty>(null as any);
    }

    /**
     * Set project property
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @param propertyKey The key of the project property. The maximum length is 255 characters.
     * @param body The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes.
     * @return Returned if the project property is updated.
     */
    setProjectProperty(projectIdOrKey: string, propertyKey: string, body: any): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/properties/{propertyKey}";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetProjectProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetProjectProperty(_response);
            throw _response;
        });
    }

    protected processSetProjectProperty(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project key or id is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to administer the project.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Restore deleted or archived project
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @return Returned if the request is successful.
     */
    restore(projectIdOrKey: string): ng.IPromise<Project> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/restore";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRestore(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRestore(_response);
            throw _response;
        });
    }

    protected processRestore(response: any): ng.IPromise<Project> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Project.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Project>(null as any);
    }

    /**
     * Get project roles for project
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @return Returned if the request is successful.
     */
    getProjectRoles(projectIdOrKey: string): ng.IPromise<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/role";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectRoles(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectRoles(_response);
            throw _response;
        });
    }

    protected processGetProjectRoles(response: any): ng.IPromise<{ [key: string]: string; }> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing or if the user lacks administrative permissions for the project.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or or if the user does not have administrative permissions for the project.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<{ [key: string]: string; }>(null as any);
    }

    /**
     * Delete actors from project role
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @param id The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
     * @param user (optional) The user account ID of the user to remove from the project role.
     * @param group (optional) The name of the group to remove from the project role. This parameter cannot be used with the `groupId` parameter. As a group's name can change, use of `groupId` is recommended.
     * @param groupId (optional) The ID of the group to remove from the project role. This parameter cannot be used with the `group` parameter.
     * @return Returned if the request is successful.
     */
    deleteActor(projectIdOrKey: string, id: number, user?: string | undefined, group?: string | undefined, groupId?: string | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/role/{id}?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        if (group === null)
            throw new Error("The parameter 'group' cannot be null.");
        else if (group !== undefined)
            url_ += "group=" + encodeURIComponent("" + group) + "&";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteActor(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteActor(_response);
            throw _response;
        });
    }

    protected processDeleteActor(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the project or project role is not found.\n *  the calling user does not have administrative permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get project role for project
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @param id The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
     * @param excludeInactiveUsers (optional) Exclude inactive users.
     * @return Returned if the request is successful.
     */
    getProjectRole(projectIdOrKey: string, id: number, excludeInactiveUsers?: boolean | undefined): ng.IPromise<ProjectRole> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/role/{id}?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (excludeInactiveUsers === null)
            throw new Error("The parameter 'excludeInactiveUsers' cannot be null.");
        else if (excludeInactiveUsers !== undefined)
            url_ += "excludeInactiveUsers=" + encodeURIComponent("" + excludeInactiveUsers) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectRole(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectRole(_response);
            throw _response;
        });
    }

    protected processGetProjectRole(response: any): ng.IPromise<ProjectRole> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRole.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the project or project role is not found.\n *  the user does not have administrative permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectRole>(null as any);
    }

    /**
     * Add actors to project role
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @param id The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
     * @param body The groups or users to associate with the project role for this project. Provide the user account ID, group name, or group ID. As a group's name can change, use of group ID is recommended.
     * @return Returned if the request is successful. The complete list of actors for the project is returned.

    For example, the cURL request above adds a group, *jira-developers*. For the response below to be returned as a result of that request, the user *Mia Krystof* would have previously been added as a `user` actor for this project.
     */
    addActorUsers(projectIdOrKey: string, id: number, body: ActorsMap): ng.IPromise<ProjectRole> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/role/{id}";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddActorUsers(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddActorUsers(_response);
            throw _response;
        });
    }

    protected processAddActorUsers(response: any): ng.IPromise<ProjectRole> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRole.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing or if the calling user lacks administrative permissions for the project.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the project is not found.\n *  the user or group is not found.\n *  the group or user is not active.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectRole>(null as any);
    }

    /**
     * Set actors for project role
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @param id The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
     * @param body The groups or users to associate with the project role for this project. Provide the user account ID, group name, or group ID. As a group's name can change, use of group ID is recommended.
     * @return Returned if the request is successful. The complete list of actors for the project is returned.
     */
    setActors(projectIdOrKey: string, id: number, body: ProjectRoleActorsUpdateBean): ng.IPromise<ProjectRole> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/role/{id}";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetActors(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetActors(_response);
            throw _response;
        });
    }

    protected processSetActors(response: any): ng.IPromise<ProjectRole> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRole.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing or if the calling user lacks administrative permissions for the project.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the project is not found.\n *  a user or group is not found.\n *  a group or user is not active.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectRole>(null as any);
    }

    /**
     * Get project role details
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @param currentMember (optional) Whether the roles should be filtered to include only those the user is assigned to.
     * @param excludeConnectAddons (optional) 
     * @return Returned if the request is successful.
     */
    getProjectRoleDetails(projectIdOrKey: string, currentMember?: boolean | undefined, excludeConnectAddons?: boolean | undefined): ng.IPromise<ProjectRoleDetails[]> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/roledetails?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (currentMember === null)
            throw new Error("The parameter 'currentMember' cannot be null.");
        else if (currentMember !== undefined)
            url_ += "currentMember=" + encodeURIComponent("" + currentMember) + "&";
        if (excludeConnectAddons === null)
            throw new Error("The parameter 'excludeConnectAddons' cannot be null.");
        else if (excludeConnectAddons !== undefined)
            url_ += "excludeConnectAddons=" + encodeURIComponent("" + excludeConnectAddons) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectRoleDetails(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectRoleDetails(_response);
            throw _response;
        });
    }

    protected processGetProjectRoleDetails(response: any): ng.IPromise<ProjectRoleDetails[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectRoleDetails.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or if the user does not have the necessary permissions for the project.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectRoleDetails[]>(null as any);
    }

    /**
     * Get all statuses for project
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @return Returned if the request is successful.
     */
    getAllStatuses(projectIdOrKey: string): ng.IPromise<IssueTypeWithStatus[]> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/statuses";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllStatuses(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllStatuses(_response);
            throw _response;
        });
    }

    protected processGetAllStatuses(response: any): ng.IPromise<IssueTypeWithStatus[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IssueTypeWithStatus.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueTypeWithStatus[]>(null as any);
    }

    /**
     * Get project versions paginated
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param orderBy (optional) [Order](#ordering) the results by a field:

     *  `description` Sorts by version description.
     *  `name` Sorts by version name.
     *  `releaseDate` Sorts by release date, starting with the oldest date. Versions with no release date are listed last.
     *  `sequence` Sorts by the order of appearance in the user interface.
     *  `startDate` Sorts by start date, starting with the oldest date. Versions with no start date are listed last.
     * @param query (optional) Filter the results using a literal string. Versions with matching `name` or `description` are returned (case insensitive).
     * @param status (optional) A list of status values used to filter the results by version status. This parameter accepts a comma-separated list. The status values are `released`, `unreleased`, and `archived`.
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `issuesstatus` Returns the number of issues in each status category for each version.
     *  `operations` Returns actions that can be performed on the specified version.
     *  `driver` Returns the Atlassian account ID of the version driver.
     *  `approvers` Returns a list containing the approvers for this version.
     * @return Returned if the request is successful.
     */
    getProjectVersionsPaginated(projectIdOrKey: string, startAt?: number | undefined, maxResults?: number | undefined, orderBy?: OrderBy12 | undefined, query?: string | undefined, status?: string | undefined, expand?: string | undefined): ng.IPromise<PageBeanVersion> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/version?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectVersionsPaginated(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectVersionsPaginated(_response);
            throw _response;
        });
    }

    protected processGetProjectVersionsPaginated(response: any): ng.IPromise<PageBeanVersion> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanVersion.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanVersion>(null as any);
    }

    /**
     * Get project versions
     * @param projectIdOrKey The project ID or project key (case sensitive).
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts `operations`, which returns actions that can be performed on the version.
     * @return Returned if the request is successful.
     */
    getProjectVersions(projectIdOrKey: string, expand?: string | undefined): ng.IPromise<Version[]> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectIdOrKey}/versions?";
        if (projectIdOrKey === undefined || projectIdOrKey === null)
            throw new Error("The parameter 'projectIdOrKey' must be defined.");
        url_ = url_.replace("{projectIdOrKey}", encodeURIComponent("" + projectIdOrKey));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectVersions(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectVersions(_response);
            throw _response;
        });
    }

    protected processGetProjectVersions(response: any): ng.IPromise<Version[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Version.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Version[]>(null as any);
    }

    /**
     * Get project's sender email
     * @param projectId The project ID.
     * @return Returned if the request is successful.
     */
    getProjectEmail(projectId: number): ng.IPromise<ProjectEmailAddress> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectId}/email";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectEmail(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectEmail(_response);
            throw _response;
        });
    }

    protected processGetProjectEmail(response: any): ng.IPromise<ProjectEmailAddress> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectEmailAddress.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to read project.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project or project\'s sender email address is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectEmailAddress>(null as any);
    }

    /**
     * Set project's sender email
     * @param projectId The project ID.
     * @param body The project's sender email address to be set.
     * @return Returned if the project's sender email address is successfully set.
     */
    updateProjectEmail(projectId: number, body: ProjectEmailAddress): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectId}/email";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateProjectEmail(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateProjectEmail(_response);
            throw _response;
        });
    }

    protected processUpdateProjectEmail(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid, if the email address is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to administer the project.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get project issue type hierarchy
     * @param projectId The ID of the project.
     * @return Returned if the request is successful.
     */
    getHierarchy(projectId: number): ng.IPromise<ProjectIssueTypeHierarchy> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectId}/hierarchy";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetHierarchy(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetHierarchy(_response);
            throw _response;
        });
    }

    protected processGetHierarchy(response: any): ng.IPromise<ProjectIssueTypeHierarchy> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectIssueTypeHierarchy.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectIssueTypeHierarchy>(null as any);
    }

    /**
     * Get project issue security scheme
     * @param projectKeyOrId The project ID or project key (case sensitive).
     * @return Returned if the request is successful.
     */
    getProjectIssueSecurityScheme(projectKeyOrId: string): ng.IPromise<SecurityScheme> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectKeyOrId}/issuesecuritylevelscheme";
        if (projectKeyOrId === undefined || projectKeyOrId === null)
            throw new Error("The parameter 'projectKeyOrId' must be defined.");
        url_ = url_.replace("{projectKeyOrId}", encodeURIComponent("" + projectKeyOrId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectIssueSecurityScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectIssueSecurityScheme(_response);
            throw _response;
        });
    }

    protected processGetProjectIssueSecurityScheme(response: any): ng.IPromise<SecurityScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is visible to the user but the user doesn\'t have administrative permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SecurityScheme>(null as any);
    }

    /**
     * Get project notification scheme
     * @param projectKeyOrId The project ID or project key (case sensitive).
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `all` Returns all expandable information
     *  `field` Returns information about any custom fields assigned to receive an event
     *  `group` Returns information about any groups assigned to receive an event
     *  `notificationSchemeEvents` Returns a list of event associations. This list is returned for all expandable information
     *  `projectRole` Returns information about any project roles assigned to receive an event
     *  `user` Returns information about any users assigned to receive an event
     * @return Returned if the request is successful.
     */
    getNotificationSchemeForProject(projectKeyOrId: string, expand?: string | undefined): ng.IPromise<NotificationScheme> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectKeyOrId}/notificationscheme?";
        if (projectKeyOrId === undefined || projectKeyOrId === null)
            throw new Error("The parameter 'projectKeyOrId' must be defined.");
        url_ = url_.replace("{projectKeyOrId}", encodeURIComponent("" + projectKeyOrId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetNotificationSchemeForProject(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetNotificationSchemeForProject(_response);
            throw _response;
        });
    }

    protected processGetNotificationSchemeForProject(response: any): ng.IPromise<NotificationScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user is not an administrator.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<NotificationScheme>(null as any);
    }

    /**
     * Get assigned permission scheme
     * @param projectKeyOrId The project ID or project key (case sensitive).
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are included when you specify any value. Expand options include:

     *  `all` Returns all expandable information.
     *  `field` Returns information about the custom field granted the permission.
     *  `group` Returns information about the group that is granted the permission.
     *  `permissions` Returns all permission grants for each permission scheme.
     *  `projectRole` Returns information about the project role granted the permission.
     *  `user` Returns information about the user who is granted the permission.
     * @return Returned if the request is successful.
     */
    getAssignedPermissionScheme(projectKeyOrId: string, expand?: string | undefined): ng.IPromise<PermissionScheme> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectKeyOrId}/permissionscheme?";
        if (projectKeyOrId === undefined || projectKeyOrId === null)
            throw new Error("The parameter 'projectKeyOrId' must be defined.");
        url_ = url_.replace("{projectKeyOrId}", encodeURIComponent("" + projectKeyOrId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAssignedPermissionScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAssignedPermissionScheme(_response);
            throw _response;
        });
    }

    protected processGetAssignedPermissionScheme(response: any): ng.IPromise<PermissionScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to view the project\'s configuration.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user does not have permission to view the project.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PermissionScheme>(null as any);
    }

    /**
     * Assign permission scheme
     * @param projectKeyOrId The project ID or project key (case sensitive).
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Note that permissions are included when you specify any value. Expand options include:

     *  `all` Returns all expandable information.
     *  `field` Returns information about the custom field granted the permission.
     *  `group` Returns information about the group that is granted the permission.
     *  `permissions` Returns all permission grants for each permission scheme.
     *  `projectRole` Returns information about the project role granted the permission.
     *  `user` Returns information about the user who is granted the permission.
     * @return Returned if the request is successful.
     */
    assignPermissionScheme(projectKeyOrId: string, body: IdBean, expand?: string | undefined): ng.IPromise<PermissionScheme> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectKeyOrId}/permissionscheme?";
        if (projectKeyOrId === undefined || projectKeyOrId === null)
            throw new Error("The parameter 'projectKeyOrId' must be defined.");
        url_ = url_.replace("{projectKeyOrId}", encodeURIComponent("" + projectKeyOrId));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAssignPermissionScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAssignPermissionScheme(_response);
            throw _response;
        });
    }

    protected processAssignPermissionScheme(response: any): ng.IPromise<PermissionScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the user does not have the necessary permission to edit the project\'s configuration.\n *  the Jira instance is Jira Core Free or Jira Software Free. Permission schemes cannot be assigned to projects on free plans.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project or permission scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PermissionScheme>(null as any);
    }

    /**
     * Get project issue security levels
     * @param projectKeyOrId The project ID or project key (case sensitive).
     * @return Returned if the request is successful.
     */
    getSecurityLevelsForProject(projectKeyOrId: string): ng.IPromise<ProjectIssueSecurityLevels> {
        let url_ = this.baseUrl + "/rest/api/3/project/{projectKeyOrId}/securitylevel";
        if (projectKeyOrId === undefined || projectKeyOrId === null)
            throw new Error("The parameter 'projectKeyOrId' must be defined.");
        url_ = url_.replace("{projectKeyOrId}", encodeURIComponent("" + projectKeyOrId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetSecurityLevelsForProject(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetSecurityLevelsForProject(_response);
            throw _response;
        });
    }

    protected processGetSecurityLevelsForProject(response: any): ng.IPromise<ProjectIssueSecurityLevels> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectIssueSecurityLevels.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project is not found or the user does not have permission to view it.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectIssueSecurityLevels>(null as any);
    }

    /**
     * Get all project categories
     * @return Returned if the request is successful.
     */
    getAllProjectCategories(): ng.IPromise<ProjectCategory[]> {
        let url_ = this.baseUrl + "/rest/api/3/projectCategory";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllProjectCategories(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllProjectCategories(_response);
            throw _response;
        });
    }

    protected processGetAllProjectCategories(response: any): ng.IPromise<ProjectCategory[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectCategory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectCategory[]>(null as any);
    }

    /**
     * Create project category
     * @return Returned if the request is successful.
     */
    createProjectCategory(body: ProjectCategory): ng.IPromise<ProjectCategory> {
        let url_ = this.baseUrl + "/rest/api/3/projectCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateProjectCategory(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateProjectCategory(_response);
            throw _response;
        });
    }

    protected processCreateProjectCategory(response: any): ng.IPromise<ProjectCategory> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProjectCategory.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  `name` is not provided or exceeds 255 characters.\n *  `description` exceeds 1000 characters.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project category name is in use.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectCategory>(null as any);
    }

    /**
     * Delete project category
     * @param id ID of the project category to delete.
     * @return Returned if the request is successful.
     */
    removeProjectCategory(id: number): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/projectCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveProjectCategory(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveProjectCategory(_response);
            throw _response;
        });
    }

    protected processRemoveProjectCategory(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project category is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get project category by ID
     * @param id The ID of the project category.
     * @return Returned if the request is successful.
     */
    getProjectCategoryById(id: number): ng.IPromise<ProjectCategory> {
        let url_ = this.baseUrl + "/rest/api/3/projectCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectCategoryById(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectCategoryById(_response);
            throw _response;
        });
    }

    protected processGetProjectCategoryById(response: any): ng.IPromise<ProjectCategory> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectCategory.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project category is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectCategory>(null as any);
    }

    /**
     * Update project category
     * @return Returned if the request is successful.
     */
    updateProjectCategory(id: number, body: ProjectCategory): ng.IPromise<UpdatedProjectCategory> {
        let url_ = this.baseUrl + "/rest/api/3/projectCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateProjectCategory(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateProjectCategory(_response);
            throw _response;
        });
    }

    protected processUpdateProjectCategory(response: any): ng.IPromise<UpdatedProjectCategory> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdatedProjectCategory.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  `name` has been modified and exceeds 255 characters.\n *  `description` has been modified and exceeds 1000 characters.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project category is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<UpdatedProjectCategory>(null as any);
    }

    /**
     * Validate project key
     * @param key (optional) The project key.
     * @return Returned if the request is successful.
     */
    validateProjectKey(key?: string | undefined): ng.IPromise<ErrorCollection> {
        let url_ = this.baseUrl + "/rest/api/3/projectvalidate/key?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processValidateProjectKey(_response);
        }, (_response) => {
            if (_response.status)
                return this.processValidateProjectKey(_response);
            throw _response;
        });
    }

    protected processValidateProjectKey(response: any): ng.IPromise<ErrorCollection> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ErrorCollection.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ErrorCollection>(null as any);
    }

    /**
     * Get valid project key
     * @param key (optional) The project key.
     * @return Returned if the request is successful.
     */
    getValidProjectKey(key?: string | undefined): ng.IPromise<string> {
        let url_ = this.baseUrl + "/rest/api/3/projectvalidate/validProjectKey?";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetValidProjectKey(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetValidProjectKey(_response);
            throw _response;
        });
    }

    protected processGetValidProjectKey(response: any): ng.IPromise<string> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<string>(null as any);
    }

    /**
     * Get valid project name
     * @param name The project name.
     * @return Returned if the request is successful.
     */
    getValidProjectName(name: string): ng.IPromise<string> {
        let url_ = this.baseUrl + "/rest/api/3/projectvalidate/validProjectName?";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetValidProjectName(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetValidProjectName(_response);
            throw _response;
        });
    }

    protected processGetValidProjectName(response: any): ng.IPromise<string> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if a valid project name cannot be generated.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<string>(null as any);
    }

    /**
     * Get resolutions
     * @return Returned if the request is successful.
     * @deprecated
     */
    getResolutions(): ng.IPromise<Resolution[]> {
        let url_ = this.baseUrl + "/rest/api/3/resolution";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetResolutions(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetResolutions(_response);
            throw _response;
        });
    }

    protected processGetResolutions(response: any): ng.IPromise<Resolution[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Resolution.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Resolution[]>(null as any);
    }

    /**
     * Create resolution
     * @return Returned if the request is successful.
     */
    createResolution(body: CreateResolutionDetails): ng.IPromise<ResolutionId> {
        let url_ = this.baseUrl + "/rest/api/3/resolution";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateResolution(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateResolution(_response);
            throw _response;
        });
    }

    protected processCreateResolution(response: any): ng.IPromise<ResolutionId> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResolutionId.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ResolutionId>(null as any);
    }

    /**
     * Set default resolution
     * @return Returned if the request is successful.
     */
    setDefaultResolution(body: SetDefaultResolutionRequest): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/resolution/default";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetDefaultResolution(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetDefaultResolution(_response);
            throw _response;
        });
    }

    protected processSetDefaultResolution(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the issue resolution isn\'t found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Move resolutions
     * @return Returned if the request is successful.
     */
    moveResolutions(body: ReorderIssueResolutionsRequest): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/resolution/move";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processMoveResolutions(_response);
        }, (_response) => {
            if (_response.status)
                return this.processMoveResolutions(_response);
            throw _response;
        });
    }

    protected processMoveResolutions(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the issue resolution isn\'t found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Search resolutions
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param id (optional) The list of resolutions IDs to be filtered out
     * @param onlyDefault (optional) When set to true, return default only, when IDs provided, if none of them is default, return empty page. Default value is false
     * @return Returned if the request is successful.
     */
    searchResolutions(startAt?: string | undefined, maxResults?: string | undefined, id?: string[] | undefined, onlyDefault?: boolean | undefined): ng.IPromise<PageBeanResolutionJsonBean> {
        let url_ = this.baseUrl + "/rest/api/3/resolution/search?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (onlyDefault === null)
            throw new Error("The parameter 'onlyDefault' cannot be null.");
        else if (onlyDefault !== undefined)
            url_ += "onlyDefault=" + encodeURIComponent("" + onlyDefault) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSearchResolutions(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSearchResolutions(_response);
            throw _response;
        });
    }

    protected processSearchResolutions(response: any): ng.IPromise<PageBeanResolutionJsonBean> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanResolutionJsonBean.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanResolutionJsonBean>(null as any);
    }

    /**
     * Delete resolution
     * @param id The ID of the issue resolution.
     * @param replaceWith The ID of the issue resolution that will replace the currently selected resolution.
     */
    deleteResolution(id: string, replaceWith: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/resolution/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (replaceWith === undefined || replaceWith === null)
            throw new Error("The parameter 'replaceWith' must be defined and cannot be null.");
        else
            url_ += "replaceWith=" + encodeURIComponent("" + replaceWith) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteResolution(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteResolution(_response);
            throw _response;
        });
    }

    protected processDeleteResolution(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 303) {
            const _responseText = response.data;
            let result303: any = null;
            let resultData303 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result303 = TaskProgressBeanObject.fromJS(resultData303);
            return throwException(this.q, "Returned if the request is successful.", status, _responseText, _headers, result303);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the issue resolution isn\'t found.", status, _responseText, _headers, result404);

        } else if (status === 409) {
            const _responseText = response.data;
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorCollection.fromJS(resultData409);
            return throwException(this.q, "Returned if a task to delete the issue resolution is already running.", status, _responseText, _headers, result409);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get resolution
     * @param id The ID of the issue resolution value.
     * @return Returned if the request is successful.
     */
    getResolution(id: string): ng.IPromise<Resolution> {
        let url_ = this.baseUrl + "/rest/api/3/resolution/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetResolution(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetResolution(_response);
            throw _response;
        });
    }

    protected processGetResolution(response: any): ng.IPromise<Resolution> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Resolution.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue resolution value is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Resolution>(null as any);
    }

    /**
     * Update resolution
     * @param id The ID of the issue resolution.
     * @return Returned if the request is successful.
     */
    updateResolution(id: string, body: UpdateResolutionDetails): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/resolution/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateResolution(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateResolution(_response);
            throw _response;
        });
    }

    protected processUpdateResolution(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request isn\'t valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the issue resolution isn\'t found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get all project roles
     * @return Returned if the request is successful.
     */
    getAllProjectRoles(): ng.IPromise<ProjectRole[]> {
        let url_ = this.baseUrl + "/rest/api/3/role";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllProjectRoles(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllProjectRoles(_response);
            throw _response;
        });
    }

    protected processGetAllProjectRoles(response: any): ng.IPromise<ProjectRole[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProjectRole.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have administrative permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectRole[]>(null as any);
    }

    /**
     * Create project role
     * @return Returned if the request is successful.
     */
    createProjectRole(body: CreateUpdateRoleRequestBean): ng.IPromise<ProjectRole> {
        let url_ = this.baseUrl + "/rest/api/3/role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateProjectRole(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateProjectRole(_response);
            throw _response;
        });
    }

    protected processCreateProjectRole(response: any): ng.IPromise<ProjectRole> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRole.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid. The `name` cannot be empty or start or end with whitespace.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have administrative permissions.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if a project role with the provided name already exists.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectRole>(null as any);
    }

    /**
     * Delete project role
     * @param id The ID of the project role to delete. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
     * @param swap (optional) The ID of the project role that will replace the one being deleted. The swap will attempt to swap the role in schemes (notifications, permissions, issue security), workflows, worklogs and comments.
     * @return Returned if the request is successful.
     */
    deleteProjectRole(id: number, swap?: number | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/role/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (swap === null)
            throw new Error("The parameter 'swap' cannot be null.");
        else if (swap !== undefined)
            url_ += "swap=" + encodeURIComponent("" + swap) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteProjectRole(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteProjectRole(_response);
            throw _response;
        });
    }

    protected processDeleteProjectRole(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid or if the replacement project role is not found.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have administrative permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project role being deleted is not found.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project role being deleted is in use and a replacement project role is not specified in the request.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get project role by ID
     * @param id The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
     * @return Returned if the request is successful.
     */
    getProjectRoleById(id: number): ng.IPromise<ProjectRole> {
        let url_ = this.baseUrl + "/rest/api/3/role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectRoleById(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectRoleById(_response);
            throw _response;
        });
    }

    protected processGetProjectRoleById(response: any): ng.IPromise<ProjectRole> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRole.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have administrative permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project role is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectRole>(null as any);
    }

    /**
     * Partial update project role
     * @param id The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
     * @return Returned if the request is successful.
     */
    partialUpdateProjectRole(id: number, body: CreateUpdateRoleRequestBean): ng.IPromise<ProjectRole> {
        let url_ = this.baseUrl + "/rest/api/3/role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processPartialUpdateProjectRole(_response);
        }, (_response) => {
            if (_response.status)
                return this.processPartialUpdateProjectRole(_response);
            throw _response;
        });
    }

    protected processPartialUpdateProjectRole(response: any): ng.IPromise<ProjectRole> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRole.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have administrative permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project role is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectRole>(null as any);
    }

    /**
     * Fully update project role
     * @param id The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
     * @return Returned if the request is successful.
     */
    fullyUpdateProjectRole(id: number, body: CreateUpdateRoleRequestBean): ng.IPromise<ProjectRole> {
        let url_ = this.baseUrl + "/rest/api/3/role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processFullyUpdateProjectRole(_response);
        }, (_response) => {
            if (_response.status)
                return this.processFullyUpdateProjectRole(_response);
            throw _response;
        });
    }

    protected processFullyUpdateProjectRole(response: any): ng.IPromise<ProjectRole> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRole.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid. The `name` cannot be empty or start or end with whitespace.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have administrative permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project role is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectRole>(null as any);
    }

    /**
     * Delete default actors from project role
     * @param id The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
     * @param user (optional) The user account ID of the user to remove as a default actor.
     * @param groupId (optional) The group ID of the group to be removed as a default actor. This parameter cannot be used with the `group` parameter.
     * @param group (optional) The group name of the group to be removed as a default actor.This parameter cannot be used with the `groupId` parameter. As a group's name can change, use of `groupId` is recommended.
     * @return Returned if the request is successful.
     */
    deleteProjectRoleActorsFromRole(id: number, user?: string | undefined, groupId?: string | undefined, group?: string | undefined): ng.IPromise<ProjectRole> {
        let url_ = this.baseUrl + "/rest/api/3/role/{id}/actors?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (user === null)
            throw new Error("The parameter 'user' cannot be null.");
        else if (user !== undefined)
            url_ += "user=" + encodeURIComponent("" + user) + "&";
        if (groupId === null)
            throw new Error("The parameter 'groupId' cannot be null.");
        else if (groupId !== undefined)
            url_ += "groupId=" + encodeURIComponent("" + groupId) + "&";
        if (group === null)
            throw new Error("The parameter 'group' cannot be null.");
        else if (group !== undefined)
            url_ += "group=" + encodeURIComponent("" + group) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteProjectRoleActorsFromRole(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteProjectRoleActorsFromRole(_response);
            throw _response;
        });
    }

    protected processDeleteProjectRoleActorsFromRole(response: any): ng.IPromise<ProjectRole> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRole.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have administrative permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project role is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectRole>(null as any);
    }

    /**
     * Get default actors for project role
     * @param id The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
     * @return Returned if the request is successful.
     */
    getProjectRoleActorsForRole(id: number): ng.IPromise<ProjectRole> {
        let url_ = this.baseUrl + "/rest/api/3/role/{id}/actors";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectRoleActorsForRole(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectRoleActorsForRole(_response);
            throw _response;
        });
    }

    protected processGetProjectRoleActorsForRole(response: any): ng.IPromise<ProjectRole> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRole.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have administrative permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project role is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectRole>(null as any);
    }

    /**
     * Add default actors to project role
     * @param id The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.
     * @return Returned if the request is successful.
     */
    addProjectRoleActorsToRole(id: number, body: ActorInputBean): ng.IPromise<ProjectRole> {
        let url_ = this.baseUrl + "/rest/api/3/role/{id}/actors";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddProjectRoleActorsToRole(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddProjectRoleActorsToRole(_response);
            throw _response;
        });
    }

    protected processAddProjectRoleActorsToRole(response: any): ng.IPromise<ProjectRole> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectRole.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have administrative permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project role is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ProjectRole>(null as any);
    }

    /**
     * Get screens
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param id (optional) The list of screen IDs. To include multiple IDs, provide an ampersand-separated list. For example, `id=10000&id=10001`.
     * @param queryString (optional) String used to perform a case-insensitive partial match with screen name.
     * @param scope (optional) The scope filter string. To filter by multiple scope, provide an ampersand-separated list. For example, `scope=GLOBAL&scope=PROJECT`.
     * @param orderBy (optional) [Order](#ordering) the results by a field:

     *  `id` Sorts by screen ID.
     *  `name` Sorts by screen name.
     * @return Returned if the request is successful.
     */
    getScreens(startAt?: number | undefined, maxResults?: number | undefined, id?: number[] | undefined, queryString?: string | undefined, scope?: Scope2[] | undefined, orderBy?: OrderBy13 | undefined): ng.IPromise<PageBeanScreen> {
        let url_ = this.baseUrl + "/rest/api/3/screens?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (queryString === null)
            throw new Error("The parameter 'queryString' cannot be null.");
        else if (queryString !== undefined)
            url_ += "queryString=" + encodeURIComponent("" + queryString) + "&";
        if (scope === null)
            throw new Error("The parameter 'scope' cannot be null.");
        else if (scope !== undefined)
            scope && scope.forEach(item => { url_ += "scope=" + encodeURIComponent("" + item) + "&"; });
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetScreens(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetScreens(_response);
            throw _response;
        });
    }

    protected processGetScreens(response: any): ng.IPromise<PageBeanScreen> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanScreen.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanScreen>(null as any);
    }

    /**
     * Create screen
     * @return Returned if the request is successful.
     */
    createScreen(body: ScreenDetails): ng.IPromise<Screen> {
        let url_ = this.baseUrl + "/rest/api/3/screens";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateScreen(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateScreen(_response);
            throw _response;
        });
    }

    protected processCreateScreen(response: any): ng.IPromise<Screen> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Screen.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Screen>(null as any);
    }

    /**
     * Add field to default screen
     * @param fieldId The ID of the field.
     * @return Returned if the request is successful.
     */
    addFieldToDefaultScreen(fieldId: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/screens/addToDefault/{fieldId}";
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddFieldToDefaultScreen(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddFieldToDefaultScreen(_response);
            throw _response;
        });
    }

    protected processAddFieldToDefaultScreen(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the field it not found or the field is already present.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get bulk screen tabs
     * @param screenId (optional) The list of screen IDs. To include multiple screen IDs, provide an ampersand-separated list. For example, `screenId=10000&screenId=10001`.
     * @param tabId (optional) The list of tab IDs. To include multiple tab IDs, provide an ampersand-separated list. For example, `tabId=10000&tabId=10001`.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResult (optional) The maximum number of items to return per page. The maximum number is 100,
     * @return Returned if the request is successful.
     */
    getBulkScreenTabs(screenId?: number[] | undefined, tabId?: number[] | undefined, startAt?: number | undefined, maxResult?: number | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/screens/tabs?";
        if (screenId === null)
            throw new Error("The parameter 'screenId' cannot be null.");
        else if (screenId !== undefined)
            screenId && screenId.forEach(item => { url_ += "screenId=" + encodeURIComponent("" + item) + "&"; });
        if (tabId === null)
            throw new Error("The parameter 'tabId' cannot be null.");
        else if (tabId !== undefined)
            tabId && tabId.forEach(item => { url_ += "tabId=" + encodeURIComponent("" + item) + "&"; });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "maxResult=" + encodeURIComponent("" + maxResult) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetBulkScreenTabs(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetBulkScreenTabs(_response);
            throw _response;
        });
    }

    protected processGetBulkScreenTabs(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the screen ID or the tab ID is empty.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Delete screen
     * @param screenId The ID of the screen.
     * @return Returned if the request is successful.
     */
    deleteScreen(screenId: number): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/screens/{screenId}";
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteScreen(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteScreen(_response);
            throw _response;
        });
    }

    protected processDeleteScreen(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the screen is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Update screen
     * @param screenId The ID of the screen.
     * @return Returned if the request is successful.
     */
    updateScreen(screenId: number, body: UpdateScreenDetails): ng.IPromise<Screen> {
        let url_ = this.baseUrl + "/rest/api/3/screens/{screenId}";
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateScreen(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateScreen(_response);
            throw _response;
        });
    }

    protected processUpdateScreen(response: any): ng.IPromise<Screen> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Screen.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the screen is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Screen>(null as any);
    }

    /**
     * Get available screen fields
     * @param screenId The ID of the screen.
     * @return Returned if the request is successful.
     */
    getAvailableScreenFields(screenId: number): ng.IPromise<ScreenableField[]> {
        let url_ = this.baseUrl + "/rest/api/3/screens/{screenId}/availableFields";
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAvailableScreenFields(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAvailableScreenFields(_response);
            throw _response;
        });
    }

    protected processGetAvailableScreenFields(response: any): ng.IPromise<ScreenableField[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScreenableField.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the screen is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ScreenableField[]>(null as any);
    }

    /**
     * Get all screen tabs
     * @param screenId The ID of the screen.
     * @param projectKey (optional) The key of the project.
     * @return Returned if the request is successful.
     */
    getAllScreenTabs(screenId: number, projectKey?: string | undefined): ng.IPromise<ScreenableTab[]> {
        let url_ = this.baseUrl + "/rest/api/3/screens/{screenId}/tabs?";
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        if (projectKey === null)
            throw new Error("The parameter 'projectKey' cannot be null.");
        else if (projectKey !== undefined)
            url_ += "projectKey=" + encodeURIComponent("" + projectKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllScreenTabs(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllScreenTabs(_response);
            throw _response;
        });
    }

    protected processGetAllScreenTabs(response: any): ng.IPromise<ScreenableTab[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScreenableTab.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the screen ID is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the screen is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ScreenableTab[]>(null as any);
    }

    /**
     * Create screen tab
     * @param screenId The ID of the screen.
     * @return Returned if the request is successful.
     */
    addScreenTab(screenId: number, body: ScreenableTab): ng.IPromise<ScreenableTab> {
        let url_ = this.baseUrl + "/rest/api/3/screens/{screenId}/tabs";
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddScreenTab(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddScreenTab(_response);
            throw _response;
        });
    }

    protected processAddScreenTab(response: any): ng.IPromise<ScreenableTab> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScreenableTab.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the screen is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ScreenableTab>(null as any);
    }

    /**
     * Delete screen tab
     * @param screenId The ID of the screen.
     * @param tabId The ID of the screen tab.
     * @return Returned if the request is successful.
     */
    deleteScreenTab(screenId: number, tabId: number): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/screens/{screenId}/tabs/{tabId}";
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        if (tabId === undefined || tabId === null)
            throw new Error("The parameter 'tabId' must be defined.");
        url_ = url_.replace("{tabId}", encodeURIComponent("" + tabId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteScreenTab(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteScreenTab(_response);
            throw _response;
        });
    }

    protected processDeleteScreenTab(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the screen or screen tab is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Update screen tab
     * @param screenId The ID of the screen.
     * @param tabId The ID of the screen tab.
     * @return Returned if the request is successful.
     */
    renameScreenTab(screenId: number, tabId: number, body: ScreenableTab): ng.IPromise<ScreenableTab> {
        let url_ = this.baseUrl + "/rest/api/3/screens/{screenId}/tabs/{tabId}";
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        if (tabId === undefined || tabId === null)
            throw new Error("The parameter 'tabId' must be defined.");
        url_ = url_.replace("{tabId}", encodeURIComponent("" + tabId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRenameScreenTab(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRenameScreenTab(_response);
            throw _response;
        });
    }

    protected processRenameScreenTab(response: any): ng.IPromise<ScreenableTab> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScreenableTab.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the screen or screen tab is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ScreenableTab>(null as any);
    }

    /**
     * Get all screen tab fields
     * @param screenId The ID of the screen.
     * @param tabId The ID of the screen tab.
     * @param projectKey (optional) The key of the project.
     * @return Returned if the request is successful.
     */
    getAllScreenTabFields(screenId: number, tabId: number, projectKey?: string | undefined): ng.IPromise<ScreenableField[]> {
        let url_ = this.baseUrl + "/rest/api/3/screens/{screenId}/tabs/{tabId}/fields?";
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        if (tabId === undefined || tabId === null)
            throw new Error("The parameter 'tabId' must be defined.");
        url_ = url_.replace("{tabId}", encodeURIComponent("" + tabId));
        if (projectKey === null)
            throw new Error("The parameter 'projectKey' cannot be null.");
        else if (projectKey !== undefined)
            url_ += "projectKey=" + encodeURIComponent("" + projectKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllScreenTabFields(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllScreenTabFields(_response);
            throw _response;
        });
    }

    protected processGetAllScreenTabFields(response: any): ng.IPromise<ScreenableField[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScreenableField.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the screen or screen tab is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ScreenableField[]>(null as any);
    }

    /**
     * Add screen tab field
     * @param screenId The ID of the screen.
     * @param tabId The ID of the screen tab.
     * @return Returned if the request is successful.
     */
    addScreenTabField(screenId: number, tabId: number, body: AddFieldBean): ng.IPromise<ScreenableField> {
        let url_ = this.baseUrl + "/rest/api/3/screens/{screenId}/tabs/{tabId}/fields";
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        if (tabId === undefined || tabId === null)
            throw new Error("The parameter 'tabId' must be defined.");
        url_ = url_.replace("{tabId}", encodeURIComponent("" + tabId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAddScreenTabField(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAddScreenTabField(_response);
            throw _response;
        });
    }

    protected processAddScreenTabField(response: any): ng.IPromise<ScreenableField> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScreenableField.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the screen, screen tab, or field is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ScreenableField>(null as any);
    }

    /**
     * Remove screen tab field
     * @param screenId The ID of the screen.
     * @param tabId The ID of the screen tab.
     * @param id The ID of the field.
     * @return Returned if the request is successful.
     */
    removeScreenTabField(screenId: number, tabId: number, id: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/screens/{screenId}/tabs/{tabId}/fields/{id}";
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        if (tabId === undefined || tabId === null)
            throw new Error("The parameter 'tabId' must be defined.");
        url_ = url_.replace("{tabId}", encodeURIComponent("" + tabId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveScreenTabField(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveScreenTabField(_response);
            throw _response;
        });
    }

    protected processRemoveScreenTabField(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the screen, screen tab, or field is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Move screen tab field
     * @param screenId The ID of the screen.
     * @param tabId The ID of the screen tab.
     * @param id The ID of the field.
     * @return Returned if the request is successful.
     */
    moveScreenTabField(screenId: number, tabId: number, id: string, body: MoveFieldBean): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/screens/{screenId}/tabs/{tabId}/fields/{id}/move";
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        if (tabId === undefined || tabId === null)
            throw new Error("The parameter 'tabId' must be defined.");
        url_ = url_.replace("{tabId}", encodeURIComponent("" + tabId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processMoveScreenTabField(_response);
        }, (_response) => {
            if (_response.status)
                return this.processMoveScreenTabField(_response);
            throw _response;
        });
    }

    protected processMoveScreenTabField(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the screen, screen tab, or field is not found or the field can\'t be moved to the requested position.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Move screen tab
     * @param screenId The ID of the screen.
     * @param tabId The ID of the screen tab.
     * @param pos The position of tab. The base index is 0.
     * @return Returned if the request is successful.
     */
    moveScreenTab(screenId: number, tabId: number, pos: number): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/screens/{screenId}/tabs/{tabId}/move/{pos}";
        if (screenId === undefined || screenId === null)
            throw new Error("The parameter 'screenId' must be defined.");
        url_ = url_.replace("{screenId}", encodeURIComponent("" + screenId));
        if (tabId === undefined || tabId === null)
            throw new Error("The parameter 'tabId' must be defined.");
        url_ = url_.replace("{tabId}", encodeURIComponent("" + tabId));
        if (pos === undefined || pos === null)
            throw new Error("The parameter 'pos' must be defined.");
        url_ = url_.replace("{pos}", encodeURIComponent("" + pos));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processMoveScreenTab(_response);
        }, (_response) => {
            if (_response.status)
                return this.processMoveScreenTab(_response);
            throw _response;
        });
    }

    protected processMoveScreenTab(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the screen or screen tab is not found or the position is invalid.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get screen schemes
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param id (optional) The list of screen scheme IDs. To include multiple IDs, provide an ampersand-separated list. For example, `id=10000&id=10001`.
     * @param expand (optional) Use [expand](#expansion) include additional information in the response. This parameter accepts `issueTypeScreenSchemes` that, for each screen schemes, returns information about the issue type screen scheme the screen scheme is assigned to.
     * @param queryString (optional) String used to perform a case-insensitive partial match with screen scheme name.
     * @param orderBy (optional) [Order](#ordering) the results by a field:

     *  `id` Sorts by screen scheme ID.
     *  `name` Sorts by screen scheme name.
     * @return Returned if the request is successful.
     */
    getScreenSchemes(startAt?: number | undefined, maxResults?: number | undefined, id?: number[] | undefined, expand?: string | undefined, queryString?: string | undefined, orderBy?: OrderBy14 | undefined): ng.IPromise<PageBeanScreenScheme> {
        let url_ = this.baseUrl + "/rest/api/3/screenscheme?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (queryString === null)
            throw new Error("The parameter 'queryString' cannot be null.");
        else if (queryString !== undefined)
            url_ += "queryString=" + encodeURIComponent("" + queryString) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetScreenSchemes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetScreenSchemes(_response);
            throw _response;
        });
    }

    protected processGetScreenSchemes(response: any): ng.IPromise<PageBeanScreenScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanScreenScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanScreenScheme>(null as any);
    }

    /**
     * Create screen scheme
     * @return Returned if the request is successful.
     */
    createScreenScheme(body: ScreenSchemeDetails): ng.IPromise<ScreenSchemeId> {
        let url_ = this.baseUrl + "/rest/api/3/screenscheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateScreenScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateScreenScheme(_response);
            throw _response;
        });
    }

    protected processCreateScreenScheme(response: any): ng.IPromise<ScreenSchemeId> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ScreenSchemeId.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if a screen used as one of the screen types in the screen scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ScreenSchemeId>(null as any);
    }

    /**
     * Delete screen scheme
     * @param screenSchemeId The ID of the screen scheme.
     * @return Returned if the screen scheme is deleted.
     */
    deleteScreenScheme(screenSchemeId: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/screenscheme/{screenSchemeId}";
        if (screenSchemeId === undefined || screenSchemeId === null)
            throw new Error("The parameter 'screenSchemeId' must be defined.");
        url_ = url_.replace("{screenSchemeId}", encodeURIComponent("" + screenSchemeId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteScreenScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteScreenScheme(_response);
            throw _response;
        });
    }

    protected processDeleteScreenScheme(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the screen scheme is used in an issue type screen scheme.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the screen scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Update screen scheme
     * @param screenSchemeId The ID of the screen scheme.
     * @param body The screen scheme update details.
     * @return Returned if the request is successful.
     */
    updateScreenScheme(screenSchemeId: string, body: UpdateScreenSchemeDetails): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/screenscheme/{screenSchemeId}";
        if (screenSchemeId === undefined || screenSchemeId === null)
            throw new Error("The parameter 'screenSchemeId' must be defined.");
        url_ = url_.replace("{screenSchemeId}", encodeURIComponent("" + screenSchemeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateScreenScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateScreenScheme(_response);
            throw _response;
        });
    }

    protected processUpdateScreenScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the screen scheme or a screen used as one of the screen types is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Search for issues using JQL (GET)
     * @param jql (optional) The [JQL](https://confluence.atlassian.com/x/egORLQ) that defines the search. Note:

     *  If no JQL expression is provided, all issues are returned.
     *  `username` and `userkey` cannot be used as search terms due to privacy reasons. Use `accountId` instead.
     *  If a user has hidden their email address in their user profile, partial matches of the email address will not find the user. An exact match is required.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page. To manage page size, Jira may return fewer items per page where a large number of fields or properties are requested. The greatest number of items returned per page is achieved when requesting `id` or `key` only.
     * @param validateQuery (optional) Determines how to validate the JQL query and treat the validation results. Supported values are:

     *  `strict` Returns a 400 response code if any errors are found, along with a list of all errors (and warnings).
     *  `warn` Returns all errors as warnings.
     *  `none` No validation is performed.
     *  `true` *Deprecated* A legacy synonym for `strict`.
     *  `false` *Deprecated* A legacy synonym for `warn`.

    Note: If the JQL is not correctly formed a 400 response code is returned, regardless of the `validateQuery` value.
     * @param fields (optional) A list of fields to return for each issue, use it to retrieve a subset of fields. This parameter accepts a comma-separated list. Expand options include:

     *  `*all` Returns all fields.
     *  `*navigable` Returns navigable fields.
     *  Any issue field, prefixed with a minus to exclude.

    Examples:

     *  `summary,comment` Returns only the summary and comments fields.
     *  `-description` Returns all navigable (default) fields except description.
     *  `*all,-comment` Returns all fields except comments.

    This parameter may be specified multiple times. For example, `fields=field1,field2&fields=field3`.

    Note: All navigable fields are returned by default. This differs from [GET issue](#api-rest-api-3-issue-issueIdOrKey-get) where the default is all fields.
     * @param expand (optional) Use [expand](#expansion) to include additional information about issues in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `renderedFields` Returns field values rendered in HTML format.
     *  `names` Returns the display name of each field.
     *  `schema` Returns the schema describing a field type.
     *  `transitions` Returns all possible transitions for the issue.
     *  `operations` Returns all possible operations for the issue.
     *  `editmeta` Returns information about how each field can be edited.
     *  `changelog` Returns a list of recent updates to an issue, sorted by date, starting from the most recent.
     *  `versionedRepresentations` Instead of `fields`, returns `versionedRepresentations` a JSON array containing each version of a field's value, with the highest numbered item representing the most recent version.
     * @param properties (optional) A list of issue property keys for issue properties to include in the results. This parameter accepts a comma-separated list. Multiple properties can also be provided using an ampersand separated list. For example, `properties=prop1,prop2&properties=prop3`. A maximum of 5 issue property keys can be specified.
     * @param fieldsByKeys (optional) Reference fields by their key (rather than ID).
     * @param failFast (optional) Whether to fail the request quickly in case of an error while loading fields for an issue. For `failFast=true`, if one field fails, the entire operation fails. For `failFast=false`, the operation will continue even if a field fails. It will return a valid response, but without values for the failed field(s).
     * @return Returned if the request is successful.
     * @deprecated
     */
    searchForIssuesUsingJql(jql?: string | undefined, startAt?: number | undefined, maxResults?: number | undefined, validateQuery?: ValidateQuery | undefined, fields?: string[] | undefined, expand?: string | undefined, properties?: string[] | undefined, fieldsByKeys?: boolean | undefined, failFast?: boolean | undefined): ng.IPromise<SearchResults> {
        let url_ = this.baseUrl + "/rest/api/3/search?";
        if (jql === null)
            throw new Error("The parameter 'jql' cannot be null.");
        else if (jql !== undefined)
            url_ += "jql=" + encodeURIComponent("" + jql) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (validateQuery === null)
            throw new Error("The parameter 'validateQuery' cannot be null.");
        else if (validateQuery !== undefined)
            url_ += "validateQuery=" + encodeURIComponent("" + validateQuery) + "&";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (properties === null)
            throw new Error("The parameter 'properties' cannot be null.");
        else if (properties !== undefined)
            properties && properties.forEach(item => { url_ += "properties=" + encodeURIComponent("" + item) + "&"; });
        if (fieldsByKeys === null)
            throw new Error("The parameter 'fieldsByKeys' cannot be null.");
        else if (fieldsByKeys !== undefined)
            url_ += "fieldsByKeys=" + encodeURIComponent("" + fieldsByKeys) + "&";
        if (failFast === null)
            throw new Error("The parameter 'failFast' cannot be null.");
        else if (failFast !== undefined)
            url_ += "failFast=" + encodeURIComponent("" + failFast) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSearchForIssuesUsingJql(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSearchForIssuesUsingJql(_response);
            throw _response;
        });
    }

    protected processSearchForIssuesUsingJql(response: any): ng.IPromise<SearchResults> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResults.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the JQL query is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SearchResults>(null as any);
    }

    /**
     * Search for issues using JQL (POST)
     * @param body A JSON object containing the search request.
     * @return Returned if the request is successful.
     * @deprecated
     */
    searchForIssuesUsingJqlPost(body: SearchRequestBean): ng.IPromise<SearchResults> {
        let url_ = this.baseUrl + "/rest/api/3/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSearchForIssuesUsingJqlPost(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSearchForIssuesUsingJqlPost(_response);
            throw _response;
        });
    }

    protected processSearchForIssuesUsingJqlPost(response: any): ng.IPromise<SearchResults> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResults.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the JQL query is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SearchResults>(null as any);
    }

    /**
     * Count issues using JQL
     * @param body A JSON object containing the search request.
     * @return Returned if the request is successful.
     */
    countIssues(body: JQLCountRequestBean): ng.IPromise<JQLCountResultsBean> {
        let url_ = this.baseUrl + "/rest/api/3/search/approximate-count";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCountIssues(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCountIssues(_response);
            throw _response;
        });
    }

    protected processCountIssues(response: any): ng.IPromise<JQLCountResultsBean> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JQLCountResultsBean.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the JQL query cannot be parsed.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<JQLCountResultsBean>(null as any);
    }

    /**
     * Search issue IDs using JQL
     * @param body A JSON object containing the search request.
     * @return Returned if the request is successful.
     * @deprecated
     */
    searchForIssuesIds(body: IdSearchRequestBean): ng.IPromise<IdSearchResults> {
        let url_ = this.baseUrl + "/rest/api/3/search/id";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSearchForIssuesIds(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSearchForIssuesIds(_response);
            throw _response;
        });
    }

    protected processSearchForIssuesIds(response: any): ng.IPromise<IdSearchResults> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdSearchResults.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the JQL query is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IdSearchResults>(null as any);
    }

    /**
     * Search for issues using JQL enhanced search (GET)
     * @param jql (optional) A [JQL](https://confluence.atlassian.com/x/egORLQ) expression. For performance reasons, this parameter requires a bounded query. A bounded query is a query with a search restriction.

     *  Example of an unbounded query: `order by key desc`.
     *  Example of a bounded query: `assignee = currentUser() order by key`.

    Additionally, `orderBy` clause can contain a maximum of 7 fields.
     * @param nextPageToken (optional) The token for a page to fetch that is not the first page. The first page has a `nextPageToken` of `null`. Use the `nextPageToken` to fetch the next page of issues.

    Note: The `nextPageToken` field is **not included** in the response for the last page, indicating there is no next page.
     * @param maxResults (optional) The maximum number of items to return per page. To manage page size, API may return fewer items per page where a large number of fields or properties are requested. The greatest number of items returned per page is achieved when requesting `id` or `key` only. It returns max 5000 issues.
     * @param fields (optional) A list of fields to return for each issue, use it to retrieve a subset of fields. This parameter accepts a comma-separated list. Expand options include:

     *  `*all` Returns all fields.
     *  `*navigable` Returns navigable fields.
     *  `id` Returns only issue IDs.
     *  Any issue field, prefixed with a minus to exclude.

    The default is `id`.

    Examples:

     *  `summary,comment` Returns only the summary and comments fields only.
     *  `-description` Returns all navigable (default) fields except description.
     *  `*all,-comment` Returns all fields except comments.

    Multiple `fields` parameters can be included in a request.

    Note: By default, this resource returns IDs only. This differs from [GET issue](#api-rest-api-3-issue-issueIdOrKey-get) where the default is all fields.
     * @param expand (optional) Use [expand](#expansion) to include additional information about issues in the response. Note that, unlike the majority of instances where `expand` is specified, `expand` is defined as a comma-delimited string of values. The expand options are:

     *  `renderedFields` Returns field values rendered in HTML format.
     *  `names` Returns the display name of each field.
     *  `schema` Returns the schema describing a field type.
     *  `transitions` Returns all possible transitions for the issue.
     *  `operations` Returns all possible operations for the issue.
     *  `editmeta` Returns information about how each field can be edited.
     *  `changelog` Returns a list of recent updates to an issue, sorted by date, starting from the most recent.
     *  `versionedRepresentations` Instead of `fields`, returns `versionedRepresentations` a JSON array containing each version of a field's value, with the highest numbered item representing the most recent version.

    Examples: `"names,changelog"` Returns the display name of each field as well as a list of recent updates to an issue.
     * @param properties (optional) A list of up to 5 issue properties to include in the results. This parameter accepts a comma-separated list.
     * @param fieldsByKeys (optional) Reference fields by their key (rather than ID). The default is `false`.
     * @param failFast (optional) Fail this request early if we can't retrieve all field data.
     * @param reconcileIssues (optional) Strong consistency issue ids to be reconciled with search results. Accepts max 50 ids
     * @return Returned if the request is successful.
     */
    searchAndReconsileIssuesUsingJql(jql?: string | undefined, nextPageToken?: string | undefined, maxResults?: number | undefined, fields?: string[] | undefined, expand?: string | undefined, properties?: string[] | undefined, fieldsByKeys?: boolean | undefined, failFast?: boolean | undefined, reconcileIssues?: number[] | undefined): ng.IPromise<SearchAndReconcileResults> {
        let url_ = this.baseUrl + "/rest/api/3/search/jql?";
        if (jql === null)
            throw new Error("The parameter 'jql' cannot be null.");
        else if (jql !== undefined)
            url_ += "jql=" + encodeURIComponent("" + jql) + "&";
        if (nextPageToken === null)
            throw new Error("The parameter 'nextPageToken' cannot be null.");
        else if (nextPageToken !== undefined)
            url_ += "nextPageToken=" + encodeURIComponent("" + nextPageToken) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (properties === null)
            throw new Error("The parameter 'properties' cannot be null.");
        else if (properties !== undefined)
            properties && properties.forEach(item => { url_ += "properties=" + encodeURIComponent("" + item) + "&"; });
        if (fieldsByKeys === null)
            throw new Error("The parameter 'fieldsByKeys' cannot be null.");
        else if (fieldsByKeys !== undefined)
            url_ += "fieldsByKeys=" + encodeURIComponent("" + fieldsByKeys) + "&";
        if (failFast === null)
            throw new Error("The parameter 'failFast' cannot be null.");
        else if (failFast !== undefined)
            url_ += "failFast=" + encodeURIComponent("" + failFast) + "&";
        if (reconcileIssues === null)
            throw new Error("The parameter 'reconcileIssues' cannot be null.");
        else if (reconcileIssues !== undefined)
            reconcileIssues && reconcileIssues.forEach(item => { url_ += "reconcileIssues=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSearchAndReconsileIssuesUsingJql(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSearchAndReconsileIssuesUsingJql(_response);
            throw _response;
        });
    }

    protected processSearchAndReconsileIssuesUsingJql(response: any): ng.IPromise<SearchAndReconcileResults> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchAndReconcileResults.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the search request is invalid", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SearchAndReconcileResults>(null as any);
    }

    /**
     * Search for issues using JQL enhanced search (POST)
     * @return Returned if the request is successful.
     */
    searchAndReconsileIssuesUsingJqlPost(body: SearchAndReconcileRequestBean): ng.IPromise<SearchAndReconcileResults> {
        let url_ = this.baseUrl + "/rest/api/3/search/jql";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSearchAndReconsileIssuesUsingJqlPost(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSearchAndReconsileIssuesUsingJqlPost(_response);
            throw _response;
        });
    }

    protected processSearchAndReconsileIssuesUsingJqlPost(response: any): ng.IPromise<SearchAndReconcileResults> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchAndReconcileResults.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the search request is invalid", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SearchAndReconcileResults>(null as any);
    }

    /**
     * Get issue security level
     * @param id The ID of the issue security level.
     * @return Returned if the request is successful.
     */
    getIssueSecurityLevel(id: string): ng.IPromise<SecurityLevel> {
        let url_ = this.baseUrl + "/rest/api/3/securitylevel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueSecurityLevel(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueSecurityLevel(_response);
            throw _response;
        });
    }

    protected processGetIssueSecurityLevel(response: any): ng.IPromise<SecurityLevel> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityLevel.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue security level is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<SecurityLevel>(null as any);
    }

    /**
     * Get Jira instance info
     * @return Returned if the request is successful.
     */
    getServerInfo(): ng.IPromise<ServerInformation> {
        let url_ = this.baseUrl + "/rest/api/3/serverInfo";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetServerInfo(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetServerInfo(_response);
            throw _response;
        });
    }

    protected processGetServerInfo(response: any): ng.IPromise<ServerInformation> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServerInformation.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ServerInformation>(null as any);
    }

    /**
     * Get issue navigator default columns
     * @return Returned if the request is successful.
     */
    getIssueNavigatorDefaultColumns(): ng.IPromise<ColumnItem[]> {
        let url_ = this.baseUrl + "/rest/api/3/settings/columns";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIssueNavigatorDefaultColumns(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIssueNavigatorDefaultColumns(_response);
            throw _response;
        });
    }

    protected processGetIssueNavigatorDefaultColumns(response: any): ng.IPromise<ColumnItem[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ColumnItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ColumnItem[]>(null as any);
    }

    /**
     * Set issue navigator default columns
     * @param body A navigable field value.
     * @param columns (optional) 
     * @return Returned if the request is successful.
     */
    setIssueNavigatorDefaultColumns(body: ColumnRequestBody, columns?: string[] | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/settings/columns";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (columns === null || columns === undefined)
            throw new Error("The parameter 'columns' cannot be null.");
        else
            columns.forEach(item_ => content_.append("columns", item_.toString()));

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "*/*",
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetIssueNavigatorDefaultColumns(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetIssueNavigatorDefaultColumns(_response);
            throw _response;
        });
    }

    protected processSetIssueNavigatorDefaultColumns(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if invalid parameters are passed.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if a navigable field value is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get all statuses
     * @return Returned if the request is successful.
     */
    getStatuses(): ng.IPromise<StatusDetails[]> {
        let url_ = this.baseUrl + "/rest/api/3/status";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetStatuses(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetStatuses(_response);
            throw _response;
        });
    }

    protected processGetStatuses(response: any): ng.IPromise<StatusDetails[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StatusDetails.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<StatusDetails[]>(null as any);
    }

    /**
     * Get status
     * @param idOrName The ID or name of the status.
     * @return Returned if the request is successful.
     */
    getStatus(idOrName: string): ng.IPromise<StatusDetails> {
        let url_ = this.baseUrl + "/rest/api/3/status/{idOrName}";
        if (idOrName === undefined || idOrName === null)
            throw new Error("The parameter 'idOrName' must be defined.");
        url_ = url_.replace("{idOrName}", encodeURIComponent("" + idOrName));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetStatus(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetStatus(_response);
            throw _response;
        });
    }

    protected processGetStatus(response: any): ng.IPromise<StatusDetails> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusDetails.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the status is not found.\n *  the status is not associated with a workflow.\n *  the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<StatusDetails>(null as any);
    }

    /**
     * Get all status categories
     * @return Returned if the request is successful.
     */
    getStatusCategories(): ng.IPromise<StatusCategory[]> {
        let url_ = this.baseUrl + "/rest/api/3/statuscategory";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetStatusCategories(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetStatusCategories(_response);
            throw _response;
        });
    }

    protected processGetStatusCategories(response: any): ng.IPromise<StatusCategory[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(StatusCategory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<StatusCategory[]>(null as any);
    }

    /**
     * Get status category
     * @param idOrKey The ID or key of the status category.
     * @return Returned if the request is successful.
     */
    getStatusCategory(idOrKey: string): ng.IPromise<StatusCategory> {
        let url_ = this.baseUrl + "/rest/api/3/statuscategory/{idOrKey}";
        if (idOrKey === undefined || idOrKey === null)
            throw new Error("The parameter 'idOrKey' must be defined.");
        url_ = url_.replace("{idOrKey}", encodeURIComponent("" + idOrKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetStatusCategory(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetStatusCategory(_response);
            throw _response;
        });
    }

    protected processGetStatusCategory(response: any): ng.IPromise<StatusCategory> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusCategory.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the status category is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<StatusCategory>(null as any);
    }

    /**
     * Bulk delete Statuses
     * @param id The list of status IDs. To include multiple IDs, provide an ampersand-separated list. For example, id=10000&id=10001.

    Min items `1`, Max items `50`
     * @return Returned if the request is successful.
     */
    deleteStatusesById(id: string[]): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/statuses?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteStatusesById(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteStatusesById(_response);
            throw _response;
        });
    }

    protected processDeleteStatusesById(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Bulk get statuses
     * @param id The list of status IDs. To include multiple IDs, provide an ampersand-separated list. For example, id=10000&id=10001.

    Min items `1`, Max items `50`
     * @param expand (optional) Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details.

    Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `usages` Returns the project and issue types that use the status in their workflow.
     *  `workflowUsages` Returns the workflows that use the status.
     * @return Returned if the request is successful.
     */
    getStatusesById(id: string[], expand?: string | undefined): ng.IPromise<JiraStatus[]> {
        let url_ = this.baseUrl + "/rest/api/3/statuses?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            id && id.forEach(item => { url_ += "id=" + encodeURIComponent("" + item) + "&"; });
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetStatusesById(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetStatusesById(_response);
            throw _response;
        });
    }

    protected processGetStatusesById(response: any): ng.IPromise<JiraStatus[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JiraStatus.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<JiraStatus[]>(null as any);
    }

    /**
     * Bulk create statuses
     * @param body Details of the statuses being created and their scope.
     * @return Returned if the request is successful.
     */
    createStatuses(body: StatusCreateRequest): ng.IPromise<JiraStatus[]> {
        let url_ = this.baseUrl + "/rest/api/3/statuses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateStatuses(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateStatuses(_response);
            throw _response;
        });
    }

    protected processCreateStatuses(response: any): ng.IPromise<JiraStatus[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JiraStatus.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if another workflow configuration update task is ongoing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<JiraStatus[]>(null as any);
    }

    /**
     * Bulk update statuses
     * @param body The list of statuses that will be updated.
     * @return Returned if the request is successful.
     */
    updateStatuses(body: StatusUpdateRequest): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/statuses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateStatuses(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateStatuses(_response);
            throw _response;
        });
    }

    protected processUpdateStatuses(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if another workflow configuration update task is ongoing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Search statuses paginated
     * @param expand (optional) Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details.

    Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `usages` Returns the project and issue types that use the status in their workflow.
     *  `workflowUsages` Returns the workflows that use the status.
     * @param projectId (optional) The project the status is part of or null for global statuses.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param searchString (optional) Term to match status names against or null to search for all statuses in the search scope.
     * @param statusCategory (optional) Category of the status to filter by. The supported values are: `TODO`, `IN_PROGRESS`, and `DONE`.
     * @return Returned if the request is successful.
     */
    search(expand?: string | undefined, projectId?: string | undefined, startAt?: number | undefined, maxResults?: number | undefined, searchString?: string | undefined, statusCategory?: string | undefined): ng.IPromise<PageOfStatuses> {
        let url_ = this.baseUrl + "/rest/api/3/statuses/search?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (searchString === null)
            throw new Error("The parameter 'searchString' cannot be null.");
        else if (searchString !== undefined)
            url_ += "searchString=" + encodeURIComponent("" + searchString) + "&";
        if (statusCategory === null)
            throw new Error("The parameter 'statusCategory' cannot be null.");
        else if (statusCategory !== undefined)
            url_ += "statusCategory=" + encodeURIComponent("" + statusCategory) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSearch(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSearch(_response);
            throw _response;
        });
    }

    protected processSearch(response: any): ng.IPromise<PageOfStatuses> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageOfStatuses.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageOfStatuses>(null as any);
    }

    /**
     * Get issue type usages by status and project
     * @param statusId The statusId to fetch issue type usages for
     * @param projectId The projectId to fetch issue type usages for
     * @param nextPageToken (optional) The cursor for pagination
     * @param maxResults (optional) The maximum number of results to return. Must be an integer between 1 and 200.
     * @return Returned if the request is successful.
     */
    getProjectIssueTypeUsagesForStatus(statusId: string, projectId: string, nextPageToken?: string | undefined, maxResults?: number | undefined): ng.IPromise<StatusProjectIssueTypeUsageDTO> {
        let url_ = this.baseUrl + "/rest/api/3/statuses/{statusId}/project/{projectId}/issueTypeUsages?";
        if (statusId === undefined || statusId === null)
            throw new Error("The parameter 'statusId' must be defined.");
        url_ = url_.replace("{statusId}", encodeURIComponent("" + statusId));
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (nextPageToken === null)
            throw new Error("The parameter 'nextPageToken' cannot be null.");
        else if (nextPageToken !== undefined)
            url_ += "nextPageToken=" + encodeURIComponent("" + nextPageToken) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectIssueTypeUsagesForStatus(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectIssueTypeUsagesForStatus(_response);
            throw _response;
        });
    }

    protected processGetProjectIssueTypeUsagesForStatus(response: any): ng.IPromise<StatusProjectIssueTypeUsageDTO> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusProjectIssueTypeUsageDTO.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the status with the given ID does not exist.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<StatusProjectIssueTypeUsageDTO>(null as any);
    }

    /**
     * Get project usages by status
     * @param statusId The statusId to fetch project usages for
     * @param nextPageToken (optional) The cursor for pagination
     * @param maxResults (optional) The maximum number of results to return. Must be an integer between 1 and 200.
     * @return Returned if the request is successful.
     */
    getProjectUsagesForStatus(statusId: string, nextPageToken?: string | undefined, maxResults?: number | undefined): ng.IPromise<StatusProjectUsageDTO> {
        let url_ = this.baseUrl + "/rest/api/3/statuses/{statusId}/projectUsages?";
        if (statusId === undefined || statusId === null)
            throw new Error("The parameter 'statusId' must be defined.");
        url_ = url_.replace("{statusId}", encodeURIComponent("" + statusId));
        if (nextPageToken === null)
            throw new Error("The parameter 'nextPageToken' cannot be null.");
        else if (nextPageToken !== undefined)
            url_ += "nextPageToken=" + encodeURIComponent("" + nextPageToken) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectUsagesForStatus(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectUsagesForStatus(_response);
            throw _response;
        });
    }

    protected processGetProjectUsagesForStatus(response: any): ng.IPromise<StatusProjectUsageDTO> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusProjectUsageDTO.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the status with the given ID does not exist.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<StatusProjectUsageDTO>(null as any);
    }

    /**
     * Get workflow usages by status
     * @param statusId The statusId to fetch workflow usages for
     * @param nextPageToken (optional) The cursor for pagination
     * @param maxResults (optional) The maximum number of results to return. Must be an integer between 1 and 200.
     * @return Returned if the request is successful.
     */
    getWorkflowUsagesForStatus(statusId: string, nextPageToken?: string | undefined, maxResults?: number | undefined): ng.IPromise<StatusWorkflowUsageDTO> {
        let url_ = this.baseUrl + "/rest/api/3/statuses/{statusId}/workflowUsages?";
        if (statusId === undefined || statusId === null)
            throw new Error("The parameter 'statusId' must be defined.");
        url_ = url_.replace("{statusId}", encodeURIComponent("" + statusId));
        if (nextPageToken === null)
            throw new Error("The parameter 'nextPageToken' cannot be null.");
        else if (nextPageToken !== undefined)
            url_ += "nextPageToken=" + encodeURIComponent("" + nextPageToken) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetWorkflowUsagesForStatus(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetWorkflowUsagesForStatus(_response);
            throw _response;
        });
    }

    protected processGetWorkflowUsagesForStatus(response: any): ng.IPromise<StatusWorkflowUsageDTO> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusWorkflowUsageDTO.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the status with the given ID does not exist.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<StatusWorkflowUsageDTO>(null as any);
    }

    /**
     * Get task
     * @param taskId The ID of the task.
     * @return Returned if the request is successful.
     */
    getTask(taskId: string): ng.IPromise<TaskProgressBeanObject> {
        let url_ = this.baseUrl + "/rest/api/3/task/{taskId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetTask(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetTask(_response);
            throw _response;
        });
    }

    protected processGetTask(response: any): ng.IPromise<TaskProgressBeanObject> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaskProgressBeanObject.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the task is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<TaskProgressBeanObject>(null as any);
    }

    /**
     * Cancel task
     * @param taskId The ID of the task.
     * @return Returned if the request is successful.
     */
    cancelTask(taskId: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/task/{taskId}/cancel";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCancelTask(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCancelTask(_response);
            throw _response;
        });
    }

    protected processCancelTask(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 202) {
            const _responseText = response.data;
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result202 = resultData202 !== undefined ? resultData202 : <any>null;
    
            return this.q.resolve(result202);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData400)) {
                result400 = [] as any;
                for (let item of resultData400)
                    result400!.push(item);
            }
            else {
                result400 = <any>null;
            }
            return throwException(this.q, "Returned if cancellation of the task is not possible.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData401)) {
                result401 = [] as any;
                for (let item of resultData401)
                    result401!.push(item);
            }
            else {
                result401 = <any>null;
            }
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData403)) {
                result403 = [] as any;
                for (let item of resultData403)
                    result403!.push(item);
            }
            else {
                result403 = <any>null;
            }
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData404)) {
                result404 = [] as any;
                for (let item of resultData404)
                    result404!.push(item);
            }
            else {
                result404 = <any>null;
            }
            return throwException(this.q, "Returned if the task is not found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get UI modifications
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param expand (optional) Use expand to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `data` Returns UI modification data.
     *  `contexts` Returns UI modification contexts.
     * @return Returned if the request is successful.
     */
    getUiModifications(startAt?: number | undefined, maxResults?: number | undefined, expand?: string | undefined): ng.IPromise<PageBeanUiModificationDetails> {
        let url_ = this.baseUrl + "/rest/api/3/uiModifications?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetUiModifications(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetUiModifications(_response);
            throw _response;
        });
    }

    protected processGetUiModifications(response: any): ng.IPromise<PageBeanUiModificationDetails> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanUiModificationDetails.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not from a Forge app.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanUiModificationDetails>(null as any);
    }

    /**
     * Create UI modification
     * @param body Details of the UI modification.
     * @return Returned if the UI modification is created.
     */
    createUiModification(body: CreateUiModificationDetails): ng.IPromise<UiModificationIdentifiers> {
        let url_ = this.baseUrl + "/rest/api/3/uiModifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateUiModification(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateUiModification(_response);
            throw _response;
        });
    }

    protected processCreateUiModification(response: any): ng.IPromise<UiModificationIdentifiers> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UiModificationIdentifiers.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not from a Forge app.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = DetailedErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if a project or an issue type in the context are not found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<UiModificationIdentifiers>(null as any);
    }

    /**
     * Delete UI modification
     * @param uiModificationId The ID of the UI modification.
     * @return Returned if the UI modification is deleted.
     */
    deleteUiModification(uiModificationId: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/uiModifications/{uiModificationId}";
        if (uiModificationId === undefined || uiModificationId === null)
            throw new Error("The parameter 'uiModificationId' must be defined.");
        url_ = url_.replace("{uiModificationId}", encodeURIComponent("" + uiModificationId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteUiModification(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteUiModification(_response);
            throw _response;
        });
    }

    protected processDeleteUiModification(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not from a Forge app.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the UI modification is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Update UI modification
     * @param uiModificationId The ID of the UI modification.
     * @param body Details of the UI modification.
     * @return Returned if the UI modification is updated.
     */
    updateUiModification(uiModificationId: string, body: UpdateUiModificationDetails): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/uiModifications/{uiModificationId}";
        if (uiModificationId === undefined || uiModificationId === null)
            throw new Error("The parameter 'uiModificationId' must be defined.");
        url_ = url_.replace("{uiModificationId}", encodeURIComponent("" + uiModificationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateUiModification(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateUiModification(_response);
            throw _response;
        });
    }

    protected processUpdateUiModification(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not from a Forge app.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = DetailedErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if the UI modification, a project or an issue type in the context are not found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get avatars
     * @param type The avatar type.
     * @param entityId The ID of the item the avatar is associated with.
     * @return Returned if the request is successful.
     */
    getAvatars(type: Type3, entityId: string): ng.IPromise<Avatars> {
        let url_ = this.baseUrl + "/rest/api/3/universal_avatar/type/{type}/owner/{entityId}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAvatars(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAvatars(_response);
            throw _response;
        });
    }

    protected processGetAvatars(response: any): ng.IPromise<Avatars> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Avatars.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the avatar type is invalid, the associated item ID is missing, or the item is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Avatars>(null as any);
    }

    /**
     * Load avatar
     * @param type The avatar type.
     * @param entityId The ID of the item the avatar is associated with.
     * @param size The length of each side of the crop region.
     * @param x (optional) The X coordinate of the top-left corner of the crop region.
     * @param y (optional) The Y coordinate of the top-left corner of the crop region.
     * @return Returned if the request is successful.
     */
    storeAvatar(type: Type4, entityId: string, size: number, body: any, x?: number | undefined, y?: number | undefined): ng.IPromise<Avatar> {
        let url_ = this.baseUrl + "/rest/api/3/universal_avatar/type/{type}/owner/{entityId}?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (size === undefined || size === null)
            throw new Error("The parameter 'size' must be defined and cannot be null.");
        else
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (x === null)
            throw new Error("The parameter 'x' cannot be null.");
        else if (x !== undefined)
            url_ += "x=" + encodeURIComponent("" + x) + "&";
        if (y === null)
            throw new Error("The parameter 'y' cannot be null.");
        else if (y !== undefined)
            url_ += "y=" + encodeURIComponent("" + y) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "*/*",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processStoreAvatar(_response);
        }, (_response) => {
            if (_response.status)
                return this.processStoreAvatar(_response);
            throw _response;
        });
    }

    protected processStoreAvatar(response: any): ng.IPromise<Avatar> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Avatar.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  an image isn\'t included in the request.\n *  the image type is unsupported.\n *  the crop parameters extend the crop area beyond the edge of the image.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the avatar type is invalid, the associated item ID is missing, or the item is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Avatar>(null as any);
    }

    /**
     * Delete avatar
     * @param type The avatar type.
     * @param owningObjectId The ID of the item the avatar is associated with.
     * @param id The ID of the avatar.
     * @return Returned if the request is successful.
     */
    deleteAvatar(type: Type5, owningObjectId: string, id: number): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/universal_avatar/type/{type}/owner/{owningObjectId}/avatar/{id}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (owningObjectId === undefined || owningObjectId === null)
            throw new Error("The parameter 'owningObjectId' must be defined.");
        url_ = url_.replace("{owningObjectId}", encodeURIComponent("" + owningObjectId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteAvatar(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteAvatar(_response);
            throw _response;
        });
    }

    protected processDeleteAvatar(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have permission to delete the avatar, the avatar is not deletable.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the avatar type, associated item ID, or avatar ID is invalid.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get avatar image by type
     * @param type The icon type of the avatar.
     * @param size (optional) The size of the avatar image. If not provided the default size is returned.
     * @param format (optional) The format to return the avatar image in. If not provided the original content format is returned.
     * @return Returned if the request is successful.
     */
    getAvatarImageByType(type: Type6, size?: Size | undefined, format?: Format | undefined): ng.IPromise<StreamingResponseBody> {
        let url_ = this.baseUrl + "/rest/api/3/universal_avatar/view/type/{type}?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (format === null)
            throw new Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAvatarImageByType(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAvatarImageByType(_response);
            throw _response;
        });
    }

    protected processGetAvatarImageByType(response: any): ng.IPromise<StreamingResponseBody> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StreamingResponseBody.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if an avatar is not found or an avatar matching the requested size is not found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<StreamingResponseBody>(null as any);
    }

    /**
     * Get avatar image by ID
     * @param type The icon type of the avatar.
     * @param id The ID of the avatar.
     * @param size (optional) The size of the avatar image. If not provided the default size is returned.
     * @param format (optional) The format to return the avatar image in. If not provided the original content format is returned.
     * @return Returned if the request is successful.
     */
    getAvatarImageByID(type: Type7, id: number, size?: Size2 | undefined, format?: Format2 | undefined): ng.IPromise<StreamingResponseBody> {
        let url_ = this.baseUrl + "/rest/api/3/universal_avatar/view/type/{type}/avatar/{id}?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (format === null)
            throw new Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAvatarImageByID(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAvatarImageByID(_response);
            throw _response;
        });
    }

    protected processGetAvatarImageByID(response: any): ng.IPromise<StreamingResponseBody> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StreamingResponseBody.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if an avatar is not found or an avatar matching the requested size is not found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<StreamingResponseBody>(null as any);
    }

    /**
     * Get avatar image by owner
     * @param type The icon type of the avatar.
     * @param entityId The ID of the project or issue type the avatar belongs to.
     * @param size (optional) The size of the avatar image. If not provided the default size is returned.
     * @param format (optional) The format to return the avatar image in. If not provided the original content format is returned.
     * @return Returned if the request is successful.
     */
    getAvatarImageByOwner(type: Type8, entityId: string, size?: Size3 | undefined, format?: Format3 | undefined): ng.IPromise<StreamingResponseBody> {
        let url_ = this.baseUrl + "/rest/api/3/universal_avatar/view/type/{type}/owner/{entityId}?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (format === null)
            throw new Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAvatarImageByOwner(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAvatarImageByOwner(_response);
            throw _response;
        });
    }

    protected processGetAvatarImageByOwner(response: any): ng.IPromise<StreamingResponseBody> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StreamingResponseBody.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorCollection.fromJS(resultData404);
            return throwException(this.q, "Returned if an avatar is not found or an avatar matching the requested size is not found.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<StreamingResponseBody>(null as any);
    }

    /**
     * Delete user
     * @param accountId The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     * @param username (optional) This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @param key (optional) This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @return Returned if the request is successful.
     */
    removeUser(accountId: string, username?: string | undefined, key?: string | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/user?";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined and cannot be null.");
        else
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRemoveUser(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRemoveUser(_response);
            throw _response;
        });
    }

    protected processRemoveUser(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user cannot be removed.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get user
     * @param accountId (optional) The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Required.
     * @param username (optional) This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide) for details.
     * @param key (optional) This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide) for details.
     * @param expand (optional) Use [expand](#expansion) to include additional information about users in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `groups` includes all groups and nested groups to which the user belongs.
     *  `applicationRoles` includes details of all the applications to which the user has access.
     * @return Returned if the request is successful.
     */
    getUser(accountId?: string | undefined, username?: string | undefined, key?: string | undefined, expand?: string | undefined): ng.IPromise<User> {
        let url_ = this.baseUrl + "/rest/api/3/user?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetUser(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetUser(_response);
            throw _response;
        });
    }

    protected processGetUser(response: any): ng.IPromise<User> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the calling user does not have the *Browse users and groups* global permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<User>(null as any);
    }

    /**
     * Create user
     * @param body Details about the user to be created.
     * @return Returned if the request is successful.
     */
    createUser(body: NewUserDetails): ng.IPromise<User> {
        let url_ = this.baseUrl + "/rest/api/3/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateUser(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateUser(_response);
            throw _response;
        });
    }

    protected processCreateUser(response: any): ng.IPromise<User> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = User.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid or the number of licensed users is exceeded.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<User>(null as any);
    }

    /**
     * Find users assignable to projects
     * @param projectKeys A list of project keys (case sensitive). This parameter accepts a comma-separated list.
     * @param query (optional) A query string that is matched against user attributes, such as `displayName` and `emailAddress`, to find relevant users. The string can match the prefix of the attribute's value. For example, *query=john* matches a user with a `displayName` of *John Smith* and a user with an `emailAddress` of *johnson@example.com*. Required, unless `accountId` is specified.
     * @param username (optional) This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @param accountId (optional) A query string that is matched exactly against user `accountId`. Required, unless `query` is specified.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    findBulkAssignableUsers(projectKeys: string, query?: string | undefined, username?: string | undefined, accountId?: string | undefined, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<User[]> {
        let url_ = this.baseUrl + "/rest/api/3/user/assignable/multiProjectSearch?";
        if (projectKeys === undefined || projectKeys === null)
            throw new Error("The parameter 'projectKeys' must be defined and cannot be null.");
        else
            url_ += "projectKeys=" + encodeURIComponent("" + projectKeys) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processFindBulkAssignableUsers(_response);
        }, (_response) => {
            if (_response.status)
                return this.processFindBulkAssignableUsers(_response);
            throw _response;
        });
    }

    protected processFindBulkAssignableUsers(response: any): ng.IPromise<User[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  `projectKeys` is missing.\n *  `query` or `accountId` is missing.\n *  `query` and `accountId` are provided.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if one or more of the projects is not found.", status, _responseText, _headers);

        } else if (status === 429) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the rate limit is exceeded. User search endpoints share a collective rate limit for the tenant, in addition to Jira\'s normal rate limiting you may receive a rate limit for user search. Please respect the Retry-After header.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<User[]>(null as any);
    }

    /**
     * Find users assignable to issues
     * @param query (optional) A query string that is matched against user attributes, such as `displayName`, and `emailAddress`, to find relevant users. The string can match the prefix of the attribute's value. For example, *query=john* matches a user with a `displayName` of *John Smith* and a user with an `emailAddress` of *johnson@example.com*. Required, unless `username` or `accountId` is specified.
     * @param sessionId (optional) The sessionId of this request. SessionId is the same until the assignee is set.
     * @param username (optional) This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @param accountId (optional) A query string that is matched exactly against user `accountId`. Required, unless `query` is specified.
     * @param project (optional) The project ID or project key (case sensitive). Required, unless `issueKey` or `issueId` is specified.
     * @param issueKey (optional) The key of the issue. Required, unless `issueId` or `project` is specified.
     * @param issueId (optional) The ID of the issue. Required, unless `issueKey` or `project` is specified.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return. This operation may return less than the maximum number of items even if more are available. The operation fetches users up to the maximum and then, from the fetched users, returns only the users that can be assigned to the issue.
     * @param actionDescriptorId (optional) The ID of the transition.
     * @param recommend (optional) 
     * @return Returned if the request is successful.
     */
    findAssignableUsers(query?: string | undefined, sessionId?: string | undefined, username?: string | undefined, accountId?: string | undefined, project?: string | undefined, issueKey?: string | undefined, issueId?: string | undefined, startAt?: number | undefined, maxResults?: number | undefined, actionDescriptorId?: number | undefined, recommend?: boolean | undefined): ng.IPromise<User[]> {
        let url_ = this.baseUrl + "/rest/api/3/user/assignable/search?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (sessionId === null)
            throw new Error("The parameter 'sessionId' cannot be null.");
        else if (sessionId !== undefined)
            url_ += "sessionId=" + encodeURIComponent("" + sessionId) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (project === null)
            throw new Error("The parameter 'project' cannot be null.");
        else if (project !== undefined)
            url_ += "project=" + encodeURIComponent("" + project) + "&";
        if (issueKey === null)
            throw new Error("The parameter 'issueKey' cannot be null.");
        else if (issueKey !== undefined)
            url_ += "issueKey=" + encodeURIComponent("" + issueKey) + "&";
        if (issueId === null)
            throw new Error("The parameter 'issueId' cannot be null.");
        else if (issueId !== undefined)
            url_ += "issueId=" + encodeURIComponent("" + issueId) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (actionDescriptorId === null)
            throw new Error("The parameter 'actionDescriptorId' cannot be null.");
        else if (actionDescriptorId !== undefined)
            url_ += "actionDescriptorId=" + encodeURIComponent("" + actionDescriptorId) + "&";
        if (recommend === null)
            throw new Error("The parameter 'recommend' cannot be null.");
        else if (recommend !== undefined)
            url_ += "recommend=" + encodeURIComponent("" + recommend) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processFindAssignableUsers(_response);
        }, (_response) => {
            if (_response.status)
                return this.processFindAssignableUsers(_response);
            throw _response;
        });
    }

    protected processFindAssignableUsers(response: any): ng.IPromise<User[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  None of `issueKey`, `issueId` or `project` is present.\n *  `issueId` parameter is not valid.\n *  `query` or `accountId` is missing.\n *  `query` and `accountId` are provided.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the project, issue, or transition is not found.", status, _responseText, _headers);

        } else if (status === 429) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the rate limit is exceeded. User search endpoints share a collective rate limit for the tenant, in addition to Jira\'s normal rate limiting you may receive a rate limit for user search. Please respect the Retry-After header.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<User[]>(null as any);
    }

    /**
     * Bulk get users
     * @param accountId The account ID of a user. To specify multiple users, pass multiple `accountId` parameters. For example, `accountId=5b10a2844c20165700ede21g&accountId=5b10ac8d82e05b22cc7d4ef5`.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param username (optional) This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @param key (optional) This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @return Returned if the request is successful.
     */
    bulkGetUsers(accountId: string[], startAt?: number | undefined, maxResults?: number | undefined, username?: string[] | undefined, key?: string[] | undefined): ng.IPromise<PageBeanUser> {
        let url_ = this.baseUrl + "/rest/api/3/user/bulk?";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined and cannot be null.");
        else
            accountId && accountId.forEach(item => { url_ += "accountId=" + encodeURIComponent("" + item) + "&"; });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            username && username.forEach(item => { url_ += "username=" + encodeURIComponent("" + item) + "&"; });
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            key && key.forEach(item => { url_ += "key=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processBulkGetUsers(_response);
        }, (_response) => {
            if (_response.status)
                return this.processBulkGetUsers(_response);
            throw _response;
        });
    }

    protected processBulkGetUsers(response: any): ng.IPromise<PageBeanUser> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanUser.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if `accountID` is missing.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanUser>(null as any);
    }

    /**
     * Get account IDs for users
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param username (optional) Username of a user. To specify multiple users, pass multiple copies of this parameter. For example, `username=fred&username=barney`. Required if `key` isn't provided. Cannot be provided if `key` is present.
     * @param key (optional) Key of a user. To specify multiple users, pass multiple copies of this parameter. For example, `key=fred&key=barney`. Required if `username` isn't provided. Cannot be provided if `username` is present.
     * @return Returned if the request is successful.
     */
    bulkGetUsersMigration(startAt?: number | undefined, maxResults?: number | undefined, username?: string[] | undefined, key?: string[] | undefined): ng.IPromise<UserMigrationBean[]> {
        let url_ = this.baseUrl + "/rest/api/3/user/bulk/migration?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            username && username.forEach(item => { url_ += "username=" + encodeURIComponent("" + item) + "&"; });
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            key && key.forEach(item => { url_ += "key=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processBulkGetUsersMigration(_response);
        }, (_response) => {
            if (_response.status)
                return this.processBulkGetUsersMigration(_response);
            throw _response;
        });
    }

    protected processBulkGetUsersMigration(response: any): ng.IPromise<UserMigrationBean[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserMigrationBean.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if `key` or `username`", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<UserMigrationBean[]>(null as any);
    }

    /**
     * Reset user default columns
     * @param accountId (optional) The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     * @param username (optional) This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @return Returned if the request is successful.
     */
    resetUserColumns(accountId?: string | undefined, username?: string | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/user/columns?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processResetUserColumns(_response);
        }, (_response) => {
            if (_response.status)
                return this.processResetUserColumns(_response);
            throw _response;
        });
    }

    protected processResetUserColumns(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission or is not accessing their user record.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get user default columns
     * @param accountId (optional) The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     * @param username (optional) This parameter is no longer available See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @return Returned if the request is successful.
     */
    getUserDefaultColumns(accountId?: string | undefined, username?: string | undefined): ng.IPromise<ColumnItem[]> {
        let url_ = this.baseUrl + "/rest/api/3/user/columns?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetUserDefaultColumns(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetUserDefaultColumns(_response);
            throw _response;
        });
    }

    protected processGetUserDefaultColumns(response: any): ng.IPromise<ColumnItem[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ColumnItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission or is not accessing their user record.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the requested user is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ColumnItem[]>(null as any);
    }

    /**
     * Set user default columns
     * @param body The ID of a column to set. To set multiple columns, send multiple `columns` parameters.
     * @param accountId (optional) The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     * @param columns (optional) 
     * @return Returned if the request is successful.
     */
    setUserColumns(body: UserColumnRequestBody, accountId?: string | undefined, columns?: string[] | undefined): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/user/columns?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (columns === null || columns === undefined)
            throw new Error("The parameter 'columns' cannot be null.");
        else
            columns.forEach(item_ => content_.append("columns", item_.toString()));

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "*/*",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetUserColumns(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetUserColumns(_response);
            throw _response;
        });
    }

    protected processSetUserColumns(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission or is not accessing their user record.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the requested user is not found.", status, _responseText, _headers);

        } else if (status === 429) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the rate limit is exceeded. User search endpoints share a collective rate limit for the tenant, in addition to Jira\'s normal rate limiting you may receive a rate limit for user search. Please respect the Retry-After header.", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if an invalid issue table column ID is sent.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get user email
     * @param accountId The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, `5b10ac8d82e05b22cc7d4ef5`.
     * @return Returned if the request is successful.
     */
    getUserEmail(accountId: string): ng.IPromise<UnrestrictedUserEmail> {
        let url_ = this.baseUrl + "/rest/api/3/user/email?";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined and cannot be null.");
        else
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetUserEmail(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetUserEmail(_response);
            throw _response;
        });
    }

    protected processGetUserEmail(response: any): ng.IPromise<UnrestrictedUserEmail> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnrestrictedUserEmail.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the calling app is not approved to use this API.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing from the request (for example if a user is trying to access this API).", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if a user with the given `accountId` doesn\'t exist", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException(this.q, "Indicates the API is not currently enabled", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<UnrestrictedUserEmail>(null as any);
    }

    /**
     * Get user email bulk
     * @param accountId The account IDs of the users for which emails are required. An `accountId` is an identifier that uniquely identifies the user across all Atlassian products. For example, `5b10ac8d82e05b22cc7d4ef5`. Note, this should be treated as an opaque identifier (that is, do not assume any structure in the value).
     * @return Returned if the request is successful.
     */
    getUserEmailBulk(accountId: string[]): ng.IPromise<UnrestrictedUserEmail> {
        let url_ = this.baseUrl + "/rest/api/3/user/email/bulk?";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined and cannot be null.");
        else
            accountId && accountId.forEach(item => { url_ += "accountId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetUserEmailBulk(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetUserEmailBulk(_response);
            throw _response;
        });
    }

    protected processGetUserEmailBulk(response: any): ng.IPromise<UnrestrictedUserEmail> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnrestrictedUserEmail.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the calling app is not approved to use this API.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect, or missing from the request (for example if a user is trying to access this API).", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException(this.q, "Indicates the API is not currently enabled.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<UnrestrictedUserEmail>(null as any);
    }

    /**
     * Get user groups
     * @param accountId The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     * @param username (optional) This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @param key (optional) This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @return Returned if the request is successful.
     */
    getUserGroups(accountId: string, username?: string | undefined, key?: string | undefined): ng.IPromise<GroupName[]> {
        let url_ = this.baseUrl + "/rest/api/3/user/groups?";
        if (accountId === undefined || accountId === null)
            throw new Error("The parameter 'accountId' must be defined and cannot be null.");
        else
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetUserGroups(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetUserGroups(_response);
            throw _response;
        });
    }

    protected processGetUserGroups(response: any): ng.IPromise<GroupName[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GroupName.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the calling user does not have the *Browse users and groups* global permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<GroupName[]>(null as any);
    }

    /**
     * Get user nav property
     * @param propertyKey The key of the user's property.
     * @param accountId (optional) The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     * @return Returned if the request is successful.
     */
    getUserNavProperty(propertyKey: string, accountId?: string | undefined): ng.IPromise<UserNavPropertyJsonBean> {
        let url_ = this.baseUrl + "/rest/api/3/user/nav4-opt-property/{propertyKey}?";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetUserNavProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetUserNavProperty(_response);
            throw _response;
        });
    }

    protected processGetUserNavProperty(response: any): ng.IPromise<UserNavPropertyJsonBean> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserNavPropertyJsonBean.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if `accountId` is missing or `propertyKey` is missing.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission or is not accessing their user record.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if either the user or property key is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<UserNavPropertyJsonBean>(null as any);
    }

    /**
     * Set user nav property
     * @param propertyKey The key of the nav property. The maximum length is 255 characters.
     * @param body The value of the property. The value has to be a boolean [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes.
     * @param accountId (optional) The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     * @return Returned if the user property is updated/created.
     */
    setUserNavProperty(propertyKey: string, body: any, accountId?: string | undefined): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/user/nav4-opt-property/{propertyKey}?";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetUserNavProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetUserNavProperty(_response);
            throw _response;
        });
    }

    protected processSetUserNavProperty(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if `accountId` is missing.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission or is not accessing their user record.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user is not found.", status, _responseText, _headers);

        } else if (status === 405) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the property key is not specified.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Find users with permissions
     * @param permissions A comma separated list of permissions. Permissions can be specified as any:

     *  permission returned by [Get all permissions](#api-rest-api-3-permissions-get).
     *  custom project permission added by Connect apps.
     *  (deprecated) one of the following:
    
         *  ASSIGNABLE\_USER
         *  ASSIGN\_ISSUE
         *  ATTACHMENT\_DELETE\_ALL
         *  ATTACHMENT\_DELETE\_OWN
         *  BROWSE
         *  CLOSE\_ISSUE
         *  COMMENT\_DELETE\_ALL
         *  COMMENT\_DELETE\_OWN
         *  COMMENT\_EDIT\_ALL
         *  COMMENT\_EDIT\_OWN
         *  COMMENT\_ISSUE
         *  CREATE\_ATTACHMENT
         *  CREATE\_ISSUE
         *  DELETE\_ISSUE
         *  EDIT\_ISSUE
         *  LINK\_ISSUE
         *  MANAGE\_WATCHER\_LIST
         *  MODIFY\_REPORTER
         *  MOVE\_ISSUE
         *  PROJECT\_ADMIN
         *  RESOLVE\_ISSUE
         *  SCHEDULE\_ISSUE
         *  SET\_ISSUE\_SECURITY
         *  TRANSITION\_ISSUE
         *  VIEW\_VERSION\_CONTROL
         *  VIEW\_VOTERS\_AND\_WATCHERS
         *  VIEW\_WORKFLOW\_READONLY
         *  WORKLOG\_DELETE\_ALL
         *  WORKLOG\_DELETE\_OWN
         *  WORKLOG\_EDIT\_ALL
         *  WORKLOG\_EDIT\_OWN
         *  WORK\_ISSUE
     * @param query (optional) A query string that is matched against user attributes, such as `displayName` and `emailAddress`, to find relevant users. The string can match the prefix of the attribute's value. For example, *query=john* matches a user with a `displayName` of *John Smith* and a user with an `emailAddress` of *johnson@example.com*. Required, unless `accountId` is specified.
     * @param username (optional) This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @param accountId (optional) A query string that is matched exactly against user `accountId`. Required, unless `query` is specified.
     * @param issueKey (optional) The issue key for the issue.
     * @param projectKey (optional) The project key for the project (case sensitive).
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    findUsersWithAllPermissions(permissions: string, query?: string | undefined, username?: string | undefined, accountId?: string | undefined, issueKey?: string | undefined, projectKey?: string | undefined, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<User[]> {
        let url_ = this.baseUrl + "/rest/api/3/user/permission/search?";
        if (permissions === undefined || permissions === null)
            throw new Error("The parameter 'permissions' must be defined and cannot be null.");
        else
            url_ += "permissions=" + encodeURIComponent("" + permissions) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (issueKey === null)
            throw new Error("The parameter 'issueKey' cannot be null.");
        else if (issueKey !== undefined)
            url_ += "issueKey=" + encodeURIComponent("" + issueKey) + "&";
        if (projectKey === null)
            throw new Error("The parameter 'projectKey' cannot be null.");
        else if (projectKey !== undefined)
            url_ += "projectKey=" + encodeURIComponent("" + projectKey) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processFindUsersWithAllPermissions(_response);
        }, (_response) => {
            if (_response.status)
                return this.processFindUsersWithAllPermissions(_response);
            throw _response;
        });
    }

    protected processFindUsersWithAllPermissions(response: any): ng.IPromise<User[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  `issueKey` or `projectKey` is missing.\n *  `query` or `accountId` is missing.\n *  `query` and `accountId` are provided.\n *  `permissions` is empty or contains an invalid entry.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue or project is not found.", status, _responseText, _headers);

        } else if (status === 429) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the rate limit is exceeded. User search endpoints share a collective rate limit for the tenant, in addition to Jira\'s normal rate limiting you may receive a rate limit for user search. Please respect the Retry-After header.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<User[]>(null as any);
    }

    /**
     * Find users for picker
     * @param query A query string that is matched against user attributes, such as `displayName`, and `emailAddress`, to find relevant users. The string can match the prefix of the attribute's value. For example, *query=john* matches a user with a `displayName` of *John Smith* and a user with an `emailAddress` of *johnson@example.com*.
     * @param maxResults (optional) The maximum number of items to return. The total number of matched users is returned in `total`.
     * @param showAvatar (optional) Include the URI to the user's avatar.
     * @param exclude (optional) This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @param excludeAccountIds (optional) A list of account IDs to exclude from the search results. This parameter accepts a comma-separated list. Multiple account IDs can also be provided using an ampersand-separated list. For example, `excludeAccountIds=5b10a2844c20165700ede21g,5b10a0effa615349cb016cd8&excludeAccountIds=5b10ac8d82e05b22cc7d4ef5`. Cannot be provided with `exclude`.
     * @param avatarSize (optional) 
     * @param excludeConnectUsers (optional) 
     * @return Returned if the request is successful.
     */
    findUsersForPicker(query: string, maxResults?: number | undefined, showAvatar?: boolean | undefined, exclude?: string[] | undefined, excludeAccountIds?: string[] | undefined, avatarSize?: string | undefined, excludeConnectUsers?: boolean | undefined): ng.IPromise<FoundUsers> {
        let url_ = this.baseUrl + "/rest/api/3/user/picker?";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined and cannot be null.");
        else
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (showAvatar === null)
            throw new Error("The parameter 'showAvatar' cannot be null.");
        else if (showAvatar !== undefined)
            url_ += "showAvatar=" + encodeURIComponent("" + showAvatar) + "&";
        if (exclude === null)
            throw new Error("The parameter 'exclude' cannot be null.");
        else if (exclude !== undefined)
            exclude && exclude.forEach(item => { url_ += "exclude=" + encodeURIComponent("" + item) + "&"; });
        if (excludeAccountIds === null)
            throw new Error("The parameter 'excludeAccountIds' cannot be null.");
        else if (excludeAccountIds !== undefined)
            excludeAccountIds && excludeAccountIds.forEach(item => { url_ += "excludeAccountIds=" + encodeURIComponent("" + item) + "&"; });
        if (avatarSize === null)
            throw new Error("The parameter 'avatarSize' cannot be null.");
        else if (avatarSize !== undefined)
            url_ += "avatarSize=" + encodeURIComponent("" + avatarSize) + "&";
        if (excludeConnectUsers === null)
            throw new Error("The parameter 'excludeConnectUsers' cannot be null.");
        else if (excludeConnectUsers !== undefined)
            url_ += "excludeConnectUsers=" + encodeURIComponent("" + excludeConnectUsers) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processFindUsersForPicker(_response);
        }, (_response) => {
            if (_response.status)
                return this.processFindUsersForPicker(_response);
            throw _response;
        });
    }

    protected processFindUsersForPicker(response: any): ng.IPromise<FoundUsers> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FoundUsers.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if `exclude` and `excludeAccountIds` are provided.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 429) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the rate limit is exceeded. User search endpoints share a collective rate limit for the tenant, in addition to Jira\'s normal rate limiting you may receive a rate limit for user search. Please respect the Retry-After header.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<FoundUsers>(null as any);
    }

    /**
     * Get user property keys
     * @param accountId (optional) The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     * @param userKey (optional) This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @param username (optional) This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @return Returned if the request is successful.
     */
    getUserPropertyKeys(accountId?: string | undefined, userKey?: string | undefined, username?: string | undefined): ng.IPromise<PropertyKeys> {
        let url_ = this.baseUrl + "/rest/api/3/user/properties?";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (userKey === null)
            throw new Error("The parameter 'userKey' cannot be null.");
        else if (userKey !== undefined)
            url_ += "userKey=" + encodeURIComponent("" + userKey) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetUserPropertyKeys(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetUserPropertyKeys(_response);
            throw _response;
        });
    }

    protected processGetUserPropertyKeys(response: any): ng.IPromise<PropertyKeys> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyKeys.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if `accountId` is missing.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission or is not accessing their user record.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PropertyKeys>(null as any);
    }

    /**
     * Delete user property
     * @param propertyKey The key of the user's property.
     * @param accountId (optional) The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     * @param userKey (optional) This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @param username (optional) This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @return Returned if the user property is deleted.
     */
    deleteUserProperty(propertyKey: string, accountId?: string | undefined, userKey?: string | undefined, username?: string | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/user/properties/{propertyKey}?";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (userKey === null)
            throw new Error("The parameter 'userKey' cannot be null.");
        else if (userKey !== undefined)
            url_ += "userKey=" + encodeURIComponent("" + userKey) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteUserProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteUserProperty(_response);
            throw _response;
        });
    }

    protected processDeleteUserProperty(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if `accountId` is missing.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission or is not accessing their user record.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user or the property is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get user property
     * @param propertyKey The key of the user's property.
     * @param accountId (optional) The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     * @param userKey (optional) This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @param username (optional) This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @return Returned if the request is successful.
     */
    getUserProperty(propertyKey: string, accountId?: string | undefined, userKey?: string | undefined, username?: string | undefined): ng.IPromise<EntityProperty> {
        let url_ = this.baseUrl + "/rest/api/3/user/properties/{propertyKey}?";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (userKey === null)
            throw new Error("The parameter 'userKey' cannot be null.");
        else if (userKey !== undefined)
            url_ += "userKey=" + encodeURIComponent("" + userKey) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetUserProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetUserProperty(_response);
            throw _response;
        });
    }

    protected processGetUserProperty(response: any): ng.IPromise<EntityProperty> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityProperty.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if `accountId` is missing.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission or is not accessing their user record.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<EntityProperty>(null as any);
    }

    /**
     * Set user property
     * @param propertyKey The key of the user's property. The maximum length is 255 characters.
     * @param body The value of the property. The value has to be a valid, non-empty [JSON](https://tools.ietf.org/html/rfc4627) value. The maximum length of the property value is 32768 bytes.
     * @param accountId (optional) The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.
     * @param userKey (optional) This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @param username (optional) This parameter is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @return Returned if the user property is updated.
     */
    setUserProperty(propertyKey: string, body: any, accountId?: string | undefined, userKey?: string | undefined, username?: string | undefined): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/user/properties/{propertyKey}?";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (userKey === null)
            throw new Error("The parameter 'userKey' cannot be null.");
        else if (userKey !== undefined)
            url_ += "userKey=" + encodeURIComponent("" + userKey) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetUserProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetUserProperty(_response);
            throw _response;
        });
    }

    protected processSetUserProperty(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if `accountId` is missing.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission or is not accessing their user record.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user is not found.", status, _responseText, _headers);

        } else if (status === 405) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the property key is not specified.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Find users
     * @param query (optional) A query string that is matched against user attributes ( `displayName`, and `emailAddress`) to find relevant users. The string can match the prefix of the attribute's value. For example, *query=john* matches a user with a `displayName` of *John Smith* and a user with an `emailAddress` of *johnson@example.com*. Required, unless `accountId` or `property` is specified.
     * @param username (optional) 
     * @param accountId (optional) A query string that is matched exactly against a user `accountId`. Required, unless `query` or `property` is specified.
     * @param startAt (optional) The index of the first item to return in a page of filtered results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param property (optional) A query string used to search properties. Property keys are specified by path, so property keys containing dot (.) or equals (=) characters cannot be used. The query string cannot be specified using a JSON object. Example: To search for the value of `nested` from `{"something":{"nested":1,"other":2}}` use `thepropertykey.something.nested=1`. Required, unless `accountId` or `query` is specified.
     * @return Returned if the request is successful.
     */
    findUsers(query?: string | undefined, username?: string | undefined, accountId?: string | undefined, startAt?: number | undefined, maxResults?: number | undefined, property?: string | undefined): ng.IPromise<User[]> {
        let url_ = this.baseUrl + "/rest/api/3/user/search?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (property === null)
            throw new Error("The parameter 'property' cannot be null.");
        else if (property !== undefined)
            url_ += "property=" + encodeURIComponent("" + property) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processFindUsers(_response);
        }, (_response) => {
            if (_response.status)
                return this.processFindUsers(_response);
            throw _response;
        });
    }

    protected processFindUsers(response: any): ng.IPromise<User[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  `accountId`, `query` or `property` is missing.\n *  `query` and `accountId` are provided.\n *  `property` parameter is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 429) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the rate limit is exceeded. User search endpoints share a collective rate limit for the tenant, in addition to Jira\'s normal rate limiting you may receive a rate limit for user search. Please respect the Retry-After header.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<User[]>(null as any);
    }

    /**
     * Find users by query
     * @param query The search query.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    findUsersByQuery(query: string, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanUser> {
        let url_ = this.baseUrl + "/rest/api/3/user/search/query?";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined and cannot be null.");
        else
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processFindUsersByQuery(_response);
        }, (_response) => {
            if (_response.status)
                return this.processFindUsersByQuery(_response);
            throw _response;
        });
    }

    protected processFindUsersByQuery(response: any): ng.IPromise<PageBeanUser> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanUser.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the query is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 408) {
            const _responseText = response.data;
            let result408: any = null;
            let resultData408 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result408 = ErrorCollection.fromJS(resultData408);
            return throwException(this.q, "Returned if the search is timed out.", status, _responseText, _headers, result408);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanUser>(null as any);
    }

    /**
     * Find user keys by query
     * @param query The search query.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResult (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    findUserKeysByQuery(query: string, startAt?: number | undefined, maxResult?: number | undefined): ng.IPromise<PageBeanUserKey> {
        let url_ = this.baseUrl + "/rest/api/3/user/search/query/key?";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined and cannot be null.");
        else
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResult === null)
            throw new Error("The parameter 'maxResult' cannot be null.");
        else if (maxResult !== undefined)
            url_ += "maxResult=" + encodeURIComponent("" + maxResult) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processFindUserKeysByQuery(_response);
        }, (_response) => {
            if (_response.status)
                return this.processFindUserKeysByQuery(_response);
            throw _response;
        });
    }

    protected processFindUserKeysByQuery(response: any): ng.IPromise<PageBeanUserKey> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanUserKey.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the query is invalid.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorCollection.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status === 408) {
            const _responseText = response.data;
            let result408: any = null;
            let resultData408 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result408 = ErrorCollection.fromJS(resultData408);
            return throwException(this.q, "Returned if the search is timed out.", status, _responseText, _headers, result408);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanUserKey>(null as any);
    }

    /**
     * Find users with browse permission
     * @param query (optional) A query string that is matched against user attributes, such as `displayName` and `emailAddress`, to find relevant users. The string can match the prefix of the attribute's value. For example, *query=john* matches a user with a `displayName` of *John Smith* and a user with an `emailAddress` of *johnson@example.com*. Required, unless `accountId` is specified.
     * @param username (optional) This parameter is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.
     * @param accountId (optional) A query string that is matched exactly against user `accountId`. Required, unless `query` is specified.
     * @param issueKey (optional) The issue key for the issue. Required, unless `projectKey` is specified.
     * @param projectKey (optional) The project key for the project (case sensitive). Required, unless `issueKey` is specified.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    findUsersWithBrowsePermission(query?: string | undefined, username?: string | undefined, accountId?: string | undefined, issueKey?: string | undefined, projectKey?: string | undefined, startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<User[]> {
        let url_ = this.baseUrl + "/rest/api/3/user/viewissue/search?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        if (accountId === null)
            throw new Error("The parameter 'accountId' cannot be null.");
        else if (accountId !== undefined)
            url_ += "accountId=" + encodeURIComponent("" + accountId) + "&";
        if (issueKey === null)
            throw new Error("The parameter 'issueKey' cannot be null.");
        else if (issueKey !== undefined)
            url_ += "issueKey=" + encodeURIComponent("" + issueKey) + "&";
        if (projectKey === null)
            throw new Error("The parameter 'projectKey' cannot be null.");
        else if (projectKey !== undefined)
            url_ += "projectKey=" + encodeURIComponent("" + projectKey) + "&";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processFindUsersWithBrowsePermission(_response);
        }, (_response) => {
            if (_response.status)
                return this.processFindUsersWithBrowsePermission(_response);
            throw _response;
        });
    }

    protected processFindUsersWithBrowsePermission(response: any): ng.IPromise<User[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  `issueKey` or `projectKey` is missing.\n *  `query` or `accountId` is missing.\n *  `query` and `accountId` are provided.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the issue or project is not found.", status, _responseText, _headers);

        } else if (status === 429) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the rate limit is exceeded. User search endpoints share a collective rate limit for the tenant, in addition to Jira\'s normal rate limiting you may receive a rate limit for user search. Please respect the Retry-After header.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<User[]>(null as any);
    }

    /**
     * Get all users default
     * @param startAt (optional) The index of the first item to return.
     * @param maxResults (optional) The maximum number of items to return.
     * @return Returned if the request is successful.
     */
    getAllUsersDefault(startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<User[]> {
        let url_ = this.baseUrl + "/rest/api/3/users?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllUsersDefault(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllUsersDefault(_response);
            throw _response;
        });
    }

    protected processGetAllUsersDefault(response: any): ng.IPromise<User[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request takes longer than 10 seconds or is interrupted.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<User[]>(null as any);
    }

    /**
     * Get all users
     * @param startAt (optional) The index of the first item to return.
     * @param maxResults (optional) The maximum number of items to return.
     * @return Returned if the request is successful.
     */
    getAllUsers(startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<User[]> {
        let url_ = this.baseUrl + "/rest/api/3/users/search?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllUsers(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllUsers(_response);
            throw _response;
        });
    }

    protected processGetAllUsers(response: any): ng.IPromise<User[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user doesn\'t have the necessary permission.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request takes longer than 10 seconds or is interrupted.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<User[]>(null as any);
    }

    /**
     * Create version
     * @return Returned if the request is successful.
     */
    createVersion(body: Version): ng.IPromise<Version> {
        let url_ = this.baseUrl + "/rest/api/3/version";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateVersion(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateVersion(_response);
            throw _response;
        });
    }

    protected processCreateVersion(response: any): ng.IPromise<Version> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Version.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the project is not found.\n *  the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Version>(null as any);
    }

    /**
     * Delete version
     * @param id The ID of the version.
     * @param moveFixIssuesTo (optional) The ID of the version to update `fixVersion` to when the field contains the deleted version. The replacement version must be in the same project as the version being deleted and cannot be the version being deleted.
     * @param moveAffectedIssuesTo (optional) The ID of the version to update `affectedVersion` to when the field contains the deleted version. The replacement version must be in the same project as the version being deleted and cannot be the version being deleted.
     * @return Returned if the version is deleted.
     * @deprecated
     */
    deleteVersion(id: string, moveFixIssuesTo?: string | undefined, moveAffectedIssuesTo?: string | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/version/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (moveFixIssuesTo === null)
            throw new Error("The parameter 'moveFixIssuesTo' cannot be null.");
        else if (moveFixIssuesTo !== undefined)
            url_ += "moveFixIssuesTo=" + encodeURIComponent("" + moveFixIssuesTo) + "&";
        if (moveAffectedIssuesTo === null)
            throw new Error("The parameter 'moveAffectedIssuesTo' cannot be null.");
        else if (moveAffectedIssuesTo !== undefined)
            url_ += "moveAffectedIssuesTo=" + encodeURIComponent("" + moveAffectedIssuesTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteVersion(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteVersion(_response);
            throw _response;
        });
    }

    protected processDeleteVersion(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the authentication credentials are incorrect.\n *  the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the version is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get version
     * @param id The ID of the version.
     * @param expand (optional) Use [expand](#expansion) to include additional information about version in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `operations` Returns the list of operations available for this version.
     *  `issuesstatus` Returns the count of issues in this version for each of the status categories *to do*, *in progress*, *done*, and *unmapped*. The *unmapped* property represents the number of issues with a status other than *to do*, *in progress*, and *done*.
     *  `driver` Returns the Atlassian account ID of the version driver.
     *  `approvers` Returns a list containing the Atlassian account IDs of approvers for this version.
     * @return Returned if the request is successful.
     */
    getVersion(id: string, expand?: string | undefined): ng.IPromise<Version> {
        let url_ = this.baseUrl + "/rest/api/3/version/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetVersion(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetVersion(_response);
            throw _response;
        });
    }

    protected processGetVersion(response: any): ng.IPromise<Version> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Version.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the version is not found or the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Version>(null as any);
    }

    /**
     * Update version
     * @param id The ID of the version.
     * @return Returned if the request is successful.
     */
    updateVersion(id: string, body: Version): ng.IPromise<Version> {
        let url_ = this.baseUrl + "/rest/api/3/version/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateVersion(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateVersion(_response);
            throw _response;
        });
    }

    protected processUpdateVersion(response: any): ng.IPromise<Version> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Version.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the request is invalid.\n *  the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the version is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Version>(null as any);
    }

    /**
     * Merge versions
     * @param id The ID of the version to delete.
     * @param moveIssuesTo The ID of the version to merge into.
     * @return Returned if the version is deleted.
     */
    mergeVersions(id: string, moveIssuesTo: string): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/version/{id}/mergeto/{moveIssuesTo}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (moveIssuesTo === undefined || moveIssuesTo === null)
            throw new Error("The parameter 'moveIssuesTo' must be defined.");
        url_ = url_.replace("{moveIssuesTo}", encodeURIComponent("" + moveIssuesTo));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processMergeVersions(_response);
        }, (_response) => {
            if (_response.status)
                return this.processMergeVersions(_response);
            throw _response;
        });
    }

    protected processMergeVersions(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the authentication credentials are incorrect or missing.\n *  the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the version to be deleted or the version to merge to are not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Move version
     * @param id The ID of the version to be moved.
     * @return Returned if the request is successful.
     */
    moveVersion(id: string, body: VersionMoveBean): ng.IPromise<Version> {
        let url_ = this.baseUrl + "/rest/api/3/version/{id}/move";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processMoveVersion(_response);
        }, (_response) => {
            if (_response.status)
                return this.processMoveVersion(_response);
            throw _response;
        });
    }

    protected processMoveVersion(response: any): ng.IPromise<Version> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Version.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  no body parameters are provided.\n *  `after` and `position` are provided.\n *  `position` is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the authentication credentials are incorrect or missing\n *  the user does not have the required commissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the version or move after version are not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Version>(null as any);
    }

    /**
     * Get version's related issues count
     * @param id The ID of the version.
     * @return Returned if the request is successful.
     */
    getVersionRelatedIssues(id: string): ng.IPromise<VersionIssueCounts> {
        let url_ = this.baseUrl + "/rest/api/3/version/{id}/relatedIssueCounts";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetVersionRelatedIssues(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetVersionRelatedIssues(_response);
            throw _response;
        });
    }

    protected processGetVersionRelatedIssues(response: any): ng.IPromise<VersionIssueCounts> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VersionIssueCounts.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the version is not found.\n *  the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<VersionIssueCounts>(null as any);
    }

    /**
     * Get related work
     * @param id The ID of the version.
     * @return Returned if the request is successful.
     */
    getRelatedWork(id: string): ng.IPromise<VersionRelatedWork[]> {
        let url_ = this.baseUrl + "/rest/api/3/version/{id}/relatedwork";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetRelatedWork(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetRelatedWork(_response);
            throw _response;
        });
    }

    protected processGetRelatedWork(response: any): ng.IPromise<VersionRelatedWork[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VersionRelatedWork.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the version is not found or the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if reading related work fails", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<VersionRelatedWork[]>(null as any);
    }

    /**
     * Create related work
     * @return Returned if the request is successful.
     */
    createRelatedWork(id: string, body: VersionRelatedWork): ng.IPromise<VersionRelatedWork> {
        let url_ = this.baseUrl + "/rest/api/3/version/{id}/relatedwork";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateRelatedWork(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateRelatedWork(_response);
            throw _response;
        });
    }

    protected processCreateRelatedWork(response: any): ng.IPromise<VersionRelatedWork> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = VersionRelatedWork.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the version is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<VersionRelatedWork>(null as any);
    }

    /**
     * Update related work
     * @param id The ID of the version to update the related work on. For the related work id, pass it to the input JSON.
     * @return Returned if the request is successful together with updated related work.
     */
    updateRelatedWork(id: string, body: VersionRelatedWork): ng.IPromise<VersionRelatedWork> {
        let url_ = this.baseUrl + "/rest/api/3/version/{id}/relatedwork";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateRelatedWork(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateRelatedWork(_response);
            throw _response;
        });
    }

    protected processUpdateRelatedWork(response: any): ng.IPromise<VersionRelatedWork> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VersionRelatedWork.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request data is invalid", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the version or the related work is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<VersionRelatedWork>(null as any);
    }

    /**
     * Delete and replace version
     * @param id The ID of the version.
     * @return Returned if the version is deleted.
     */
    deleteAndReplaceVersion(id: string, body: DeleteAndReplaceVersionBean): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/version/{id}/removeAndSwap";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteAndReplaceVersion(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteAndReplaceVersion(_response);
            throw _response;
        });
    }

    protected processDeleteAndReplaceVersion(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the version to delete is not found.\n *  the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get version's unresolved issues count
     * @param id The ID of the version.
     * @return Returned if the request is successful.
     */
    getVersionUnresolvedIssues(id: string): ng.IPromise<VersionUnresolvedIssuesCount> {
        let url_ = this.baseUrl + "/rest/api/3/version/{id}/unresolvedIssueCount";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetVersionUnresolvedIssues(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetVersionUnresolvedIssues(_response);
            throw _response;
        });
    }

    protected processGetVersionUnresolvedIssues(response: any): ng.IPromise<VersionUnresolvedIssuesCount> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VersionUnresolvedIssuesCount.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the version is not found.\n *  the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<VersionUnresolvedIssuesCount>(null as any);
    }

    /**
     * Delete related work
     * @param versionId The ID of the version that the target related work belongs to.
     * @param relatedWorkId The ID of the related work to delete.
     * @return Returned if the related work is deleted.
     */
    deleteRelatedWork(versionId: string, relatedWorkId: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/version/{versionId}/relatedwork/{relatedWorkId}";
        if (versionId === undefined || versionId === null)
            throw new Error("The parameter 'versionId' must be defined.");
        url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
        if (relatedWorkId === undefined || relatedWorkId === null)
            throw new Error("The parameter 'relatedWorkId' must be defined.");
        url_ = url_.replace("{relatedWorkId}", encodeURIComponent("" + relatedWorkId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteRelatedWork(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteRelatedWork(_response);
            throw _response;
        });
    }

    protected processDeleteRelatedWork(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if\n\nthe authentication credentials are incorrect.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the version/related work is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Delete webhooks by ID
     * @return Returned if the request is successful.
     */
    deleteWebhookById(body: ContainerForWebhookIDs): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/webhook";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteWebhookById(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteWebhookById(_response);
            throw _response;
        });
    }

    protected processDeleteWebhookById(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 202) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the list of webhook IDs is missing.", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the caller isn\'t an app.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get dynamic webhooks for app
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getDynamicWebhooksForApp(startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanWebhook> {
        let url_ = this.baseUrl + "/rest/api/3/webhook?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetDynamicWebhooksForApp(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetDynamicWebhooksForApp(_response);
            throw _response;
        });
    }

    protected processGetDynamicWebhooksForApp(response: any): ng.IPromise<PageBeanWebhook> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanWebhook.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the caller isn\'t an app.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanWebhook>(null as any);
    }

    /**
     * Register dynamic webhooks
     * @return Returned if the request is successful.
     */
    registerDynamicWebhooks(body: WebhookRegistrationDetails): ng.IPromise<ContainerForRegisteredWebhooks> {
        let url_ = this.baseUrl + "/rest/api/3/webhook";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRegisterDynamicWebhooks(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRegisterDynamicWebhooks(_response);
            throw _response;
        });
    }

    protected processRegisterDynamicWebhooks(response: any): ng.IPromise<ContainerForRegisteredWebhooks> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContainerForRegisteredWebhooks.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the caller isn\'t an app.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ContainerForRegisteredWebhooks>(null as any);
    }

    /**
     * Get failed webhooks
     * @param maxResults (optional) The maximum number of webhooks to return per page. If obeying the maxResults directive would result in records with the same failure time being split across pages, the directive is ignored and all records with the same failure time included on the page.
     * @param after (optional) The time after which any webhook failure must have occurred for the record to be returned, expressed as milliseconds since the UNIX epoch.
     * @return Returned if the request is successful.
     */
    getFailedWebhooks(maxResults?: number | undefined, after?: number | undefined): ng.IPromise<FailedWebhooks> {
        let url_ = this.baseUrl + "/rest/api/3/webhook/failed?";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (after === null)
            throw new Error("The parameter 'after' cannot be null.");
        else if (after !== undefined)
            url_ += "after=" + encodeURIComponent("" + after) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetFailedWebhooks(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetFailedWebhooks(_response);
            throw _response;
        });
    }

    protected processGetFailedWebhooks(response: any): ng.IPromise<FailedWebhooks> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FailedWebhooks.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "400 response", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the caller is not a Connect app.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<FailedWebhooks>(null as any);
    }

    /**
     * Extend webhook life
     * @return Returned if the request is successful.
     */
    refreshWebhooks(body: ContainerForWebhookIDs): ng.IPromise<WebhooksExpirationDate> {
        let url_ = this.baseUrl + "/rest/api/3/webhook/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processRefreshWebhooks(_response);
        }, (_response) => {
            if (_response.status)
                return this.processRefreshWebhooks(_response);
            throw _response;
        });
    }

    protected processRefreshWebhooks(response: any): ng.IPromise<WebhooksExpirationDate> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebhooksExpirationDate.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the caller isn\'t an app.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WebhooksExpirationDate>(null as any);
    }

    /**
     * Get all workflows
     * @param workflowName (optional) The name of the workflow to be returned. Only one workflow can be specified.
     * @return Returned if the request is successful.
     * @deprecated
     */
    getAllWorkflows(workflowName?: string | undefined): ng.IPromise<DeprecatedWorkflow[]> {
        let url_ = this.baseUrl + "/rest/api/3/workflow?";
        if (workflowName === null)
            throw new Error("The parameter 'workflowName' cannot be null.");
        else if (workflowName !== undefined)
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllWorkflows(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllWorkflows(_response);
            throw _response;
        });
    }

    protected processGetAllWorkflows(response: any): ng.IPromise<DeprecatedWorkflow[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeprecatedWorkflow.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<DeprecatedWorkflow[]>(null as any);
    }

    /**
     * Create workflow
     * @param body The workflow details.
     * @return Returned if the workflow is created.
     * @deprecated
     */
    createWorkflow(body: CreateWorkflowDetails): ng.IPromise<WorkflowIDs> {
        let url_ = this.baseUrl + "/rest/api/3/workflow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateWorkflow(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateWorkflow(_response);
            throw _response;
        });
    }

    protected processCreateWorkflow(response: any): ng.IPromise<WorkflowIDs> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = WorkflowIDs.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if one or more statuses is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowIDs>(null as any);
    }

    /**
     * Get workflow transition rule configurations
     * @param types The types of the transition rules to return.
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param keys (optional) The transition rule class keys, as defined in the Connect or the Forge app descriptor, of the transition rules to return.
     * @param workflowNames (optional) The list of workflow names to filter by.
     * @param withTags (optional) The list of `tags` to filter by.
     * @param draft (optional) Whether draft or published workflows are returned. If not provided, both workflow types are returned.
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts `transition`, which, for each rule, returns information about the transition the rule is assigned to.
     * @return Returned if the request is successful.
     */
    getWorkflowTransitionRuleConfigurations(types: Types[], startAt?: number | undefined, maxResults?: number | undefined, keys?: string[] | undefined, workflowNames?: string[] | undefined, withTags?: string[] | undefined, draft?: boolean | undefined, expand?: string | undefined): ng.IPromise<PageBeanWorkflowTransitionRules> {
        let url_ = this.baseUrl + "/rest/api/3/workflow/rule/config?";
        if (types === undefined || types === null)
            throw new Error("The parameter 'types' must be defined and cannot be null.");
        else
            types && types.forEach(item => { url_ += "types=" + encodeURIComponent("" + item) + "&"; });
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (keys === null)
            throw new Error("The parameter 'keys' cannot be null.");
        else if (keys !== undefined)
            keys && keys.forEach(item => { url_ += "keys=" + encodeURIComponent("" + item) + "&"; });
        if (workflowNames === null)
            throw new Error("The parameter 'workflowNames' cannot be null.");
        else if (workflowNames !== undefined)
            workflowNames && workflowNames.forEach(item => { url_ += "workflowNames=" + encodeURIComponent("" + item) + "&"; });
        if (withTags === null)
            throw new Error("The parameter 'withTags' cannot be null.");
        else if (withTags !== undefined)
            withTags && withTags.forEach(item => { url_ += "withTags=" + encodeURIComponent("" + item) + "&"; });
        if (draft === null)
            throw new Error("The parameter 'draft' cannot be null.");
        else if (draft !== undefined)
            url_ += "draft=" + encodeURIComponent("" + draft) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetWorkflowTransitionRuleConfigurations(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetWorkflowTransitionRuleConfigurations(_response);
            throw _response;
        });
    }

    protected processGetWorkflowTransitionRuleConfigurations(response: any): ng.IPromise<PageBeanWorkflowTransitionRules> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanWorkflowTransitionRules.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the caller is not a Connect or Forge app.", status, _responseText, _headers, result403);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if any transition rule type is not supported.", status, _responseText, _headers);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if we encounter a problem while trying to access the required data.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanWorkflowTransitionRules>(null as any);
    }

    /**
     * Update workflow transition rule configurations
     * @return Returned if the request is successful.
     */
    updateWorkflowTransitionRuleConfigurations(body: WorkflowTransitionRulesUpdate): ng.IPromise<WorkflowTransitionRulesUpdateErrors> {
        let url_ = this.baseUrl + "/rest/api/3/workflow/rule/config";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateWorkflowTransitionRuleConfigurations(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateWorkflowTransitionRuleConfigurations(_response);
            throw _response;
        });
    }

    protected processUpdateWorkflowTransitionRuleConfigurations(response: any): ng.IPromise<WorkflowTransitionRulesUpdateErrors> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowTransitionRulesUpdateErrors.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the caller is not a Connect or Forge app.", status, _responseText, _headers, result403);

        } else if (status === 503) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if we encounter a problem while trying to access the required data.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowTransitionRulesUpdateErrors>(null as any);
    }

    /**
     * Delete workflow transition rule configurations
     * @return Returned if the request is successful.
     */
    deleteWorkflowTransitionRuleConfigurations(body: WorkflowsWithTransitionRulesDetails): ng.IPromise<WorkflowTransitionRulesUpdateErrors> {
        let url_ = this.baseUrl + "/rest/api/3/workflow/rule/config/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteWorkflowTransitionRuleConfigurations(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteWorkflowTransitionRuleConfigurations(_response);
            throw _response;
        });
    }

    protected processDeleteWorkflowTransitionRuleConfigurations(response: any): ng.IPromise<WorkflowTransitionRulesUpdateErrors> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowTransitionRulesUpdateErrors.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorCollection.fromJS(resultData400);
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers, result400);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the caller is not a Connect app.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowTransitionRulesUpdateErrors>(null as any);
    }

    /**
     * Get workflows paginated
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param workflowName (optional) The name of a workflow to return. To include multiple workflows, provide an ampersand-separated list. For example, `workflowName=name1&workflowName=name2`.
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `transitions` For each workflow, returns information about the transitions inside the workflow.
     *  `transitions.rules` For each workflow transition, returns information about its rules. Transitions are included automatically if this expand is requested.
     *  `transitions.properties` For each workflow transition, returns information about its properties. Transitions are included automatically if this expand is requested.
     *  `statuses` For each workflow, returns information about the statuses inside the workflow.
     *  `statuses.properties` For each workflow status, returns information about its properties. Statuses are included automatically if this expand is requested.
     *  `default` For each workflow, returns information about whether this is the default workflow.
     *  `schemes` For each workflow, returns information about the workflow schemes the workflow is assigned to.
     *  `projects` For each workflow, returns information about the projects the workflow is assigned to, through workflow schemes.
     *  `hasDraftWorkflow` For each workflow, returns information about whether the workflow has a draft version.
     *  `operations` For each workflow, returns information about the actions that can be undertaken on the workflow.
     * @param queryString (optional) String used to perform a case-insensitive partial match with workflow name.
     * @param orderBy (optional) [Order](#ordering) the results by a field:

     *  `name` Sorts by workflow name.
     *  `created` Sorts by create time.
     *  `updated` Sorts by update time.
     * @param isActive (optional) Filters active and inactive workflows.
     * @return Returned if the request is successful.
     */
    getWorkflowsPaginated(startAt?: number | undefined, maxResults?: number | undefined, workflowName?: string[] | undefined, expand?: string | undefined, queryString?: string | undefined, orderBy?: OrderBy15 | undefined, isActive?: boolean | undefined): ng.IPromise<PageBeanWorkflow> {
        let url_ = this.baseUrl + "/rest/api/3/workflow/search?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (workflowName === null)
            throw new Error("The parameter 'workflowName' cannot be null.");
        else if (workflowName !== undefined)
            workflowName && workflowName.forEach(item => { url_ += "workflowName=" + encodeURIComponent("" + item) + "&"; });
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (queryString === null)
            throw new Error("The parameter 'queryString' cannot be null.");
        else if (queryString !== undefined)
            url_ += "queryString=" + encodeURIComponent("" + queryString) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetWorkflowsPaginated(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetWorkflowsPaginated(_response);
            throw _response;
        });
    }

    protected processGetWorkflowsPaginated(response: any): ng.IPromise<PageBeanWorkflow> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanWorkflow.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorCollection.fromJS(resultData403);
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers, result403);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanWorkflow>(null as any);
    }

    /**
     * Delete workflow transition property
     * @param transitionId The ID of the transition. To get the ID, view the workflow in text mode in the Jira admin settings. The ID is shown next to the transition.
     * @param key The name of the transition property to delete, also known as the name of the property.
     * @param workflowName The name of the workflow that the transition belongs to.
     * @param workflowMode (optional) The workflow status. Set to `live` for inactive workflows or `draft` for draft workflows. Active workflows cannot be edited.
     * @return 200 response
     */
    deleteWorkflowTransitionProperty(transitionId: number, key: string, workflowName: string, workflowMode?: WorkflowMode | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/workflow/transitions/{transitionId}/properties?";
        if (transitionId === undefined || transitionId === null)
            throw new Error("The parameter 'transitionId' must be defined.");
        url_ = url_.replace("{transitionId}", encodeURIComponent("" + transitionId));
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined and cannot be null.");
        else
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (workflowName === undefined || workflowName === null)
            throw new Error("The parameter 'workflowName' must be defined and cannot be null.");
        else
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        if (workflowMode === null)
            throw new Error("The parameter 'workflowMode' cannot be null.");
        else if (workflowMode !== undefined)
            url_ += "workflowMode=" + encodeURIComponent("" + workflowMode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteWorkflowTransitionProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteWorkflowTransitionProperty(_response);
            throw _response;
        });
    }

    protected processDeleteWorkflowTransitionProperty(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 304) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if no changes were made by the request. For example, trying to delete a property that cannot be found.", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow transition is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get workflow transition properties
     * @param transitionId The ID of the transition. To get the ID, view the workflow in text mode in the Jira administration console. The ID is shown next to the transition.
     * @param workflowName The name of the workflow that the transition belongs to.
     * @param includeReservedKeys (optional) Some properties with keys that have the *jira.* prefix are reserved, which means they are not editable. To include these properties in the results, set this parameter to *true*.
     * @param key (optional) The key of the property being returned, also known as the name of the property. If this parameter is not specified, all properties on the transition are returned.
     * @param workflowMode (optional) The workflow status. Set to *live* for active and inactive workflows, or *draft* for draft workflows.
     * @return 200 response
     */
    getWorkflowTransitionProperties(transitionId: number, workflowName: string, includeReservedKeys?: boolean | undefined, key?: string | undefined, workflowMode?: WorkflowMode2 | undefined): ng.IPromise<WorkflowTransitionProperty> {
        let url_ = this.baseUrl + "/rest/api/3/workflow/transitions/{transitionId}/properties?";
        if (transitionId === undefined || transitionId === null)
            throw new Error("The parameter 'transitionId' must be defined.");
        url_ = url_.replace("{transitionId}", encodeURIComponent("" + transitionId));
        if (workflowName === undefined || workflowName === null)
            throw new Error("The parameter 'workflowName' must be defined and cannot be null.");
        else
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        if (includeReservedKeys === null)
            throw new Error("The parameter 'includeReservedKeys' cannot be null.");
        else if (includeReservedKeys !== undefined)
            url_ += "includeReservedKeys=" + encodeURIComponent("" + includeReservedKeys) + "&";
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (workflowMode === null)
            throw new Error("The parameter 'workflowMode' cannot be null.");
        else if (workflowMode !== undefined)
            url_ += "workflowMode=" + encodeURIComponent("" + workflowMode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetWorkflowTransitionProperties(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetWorkflowTransitionProperties(_response);
            throw _response;
        });
    }

    protected processGetWorkflowTransitionProperties(response: any): ng.IPromise<WorkflowTransitionProperty> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowTransitionProperty.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have admin permission", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow transition or property is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowTransitionProperty>(null as any);
    }

    /**
     * Create workflow transition property
     * @param transitionId The ID of the transition. To get the ID, view the workflow in text mode in the Jira admin settings. The ID is shown next to the transition.
     * @param key The key of the property being added, also known as the name of the property. Set this to the same value as the `key` defined in the request body.
     * @param workflowName The name of the workflow that the transition belongs to.
     * @param workflowMode (optional) The workflow status. Set to *live* for inactive workflows or *draft* for draft workflows. Active workflows cannot be edited.
     * @return 200 response
     */
    createWorkflowTransitionProperty(transitionId: number, key: string, workflowName: string, body: WorkflowTransitionProperty, workflowMode?: WorkflowMode3 | undefined): ng.IPromise<WorkflowTransitionProperty> {
        let url_ = this.baseUrl + "/rest/api/3/workflow/transitions/{transitionId}/properties?";
        if (transitionId === undefined || transitionId === null)
            throw new Error("The parameter 'transitionId' must be defined.");
        url_ = url_.replace("{transitionId}", encodeURIComponent("" + transitionId));
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined and cannot be null.");
        else
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (workflowName === undefined || workflowName === null)
            throw new Error("The parameter 'workflowName' must be defined and cannot be null.");
        else
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        if (workflowMode === null)
            throw new Error("The parameter 'workflowMode' cannot be null.");
        else if (workflowMode !== undefined)
            url_ += "workflowMode=" + encodeURIComponent("" + workflowMode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateWorkflowTransitionProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateWorkflowTransitionProperty(_response);
            throw _response;
        });
    }

    protected processCreateWorkflowTransitionProperty(response: any): ng.IPromise<WorkflowTransitionProperty> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowTransitionProperty.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if a workflow property with the same key is present on the transition.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow transition is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowTransitionProperty>(null as any);
    }

    /**
     * Update workflow transition property
     * @param transitionId The ID of the transition. To get the ID, view the workflow in text mode in the Jira admin settings. The ID is shown next to the transition.
     * @param key The key of the property being updated, also known as the name of the property. Set this to the same value as the `key` defined in the request body.
     * @param workflowName The name of the workflow that the transition belongs to.
     * @param workflowMode (optional) The workflow status. Set to `live` for inactive workflows or `draft` for draft workflows. Active workflows cannot be edited.
     * @return 200 response
     */
    updateWorkflowTransitionProperty(transitionId: number, key: string, workflowName: string, body: WorkflowTransitionProperty, workflowMode?: WorkflowMode4 | undefined): ng.IPromise<WorkflowTransitionProperty> {
        let url_ = this.baseUrl + "/rest/api/3/workflow/transitions/{transitionId}/properties?";
        if (transitionId === undefined || transitionId === null)
            throw new Error("The parameter 'transitionId' must be defined.");
        url_ = url_.replace("{transitionId}", encodeURIComponent("" + transitionId));
        if (key === undefined || key === null)
            throw new Error("The parameter 'key' must be defined and cannot be null.");
        else
            url_ += "key=" + encodeURIComponent("" + key) + "&";
        if (workflowName === undefined || workflowName === null)
            throw new Error("The parameter 'workflowName' must be defined and cannot be null.");
        else
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        if (workflowMode === null)
            throw new Error("The parameter 'workflowMode' cannot be null.");
        else if (workflowMode !== undefined)
            url_ += "workflowMode=" + encodeURIComponent("" + workflowMode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateWorkflowTransitionProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateWorkflowTransitionProperty(_response);
            throw _response;
        });
    }

    protected processUpdateWorkflowTransitionProperty(response: any): ng.IPromise<WorkflowTransitionProperty> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowTransitionProperty.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 304) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if no changes were made by the request. For example, attempting to update a property with its current value.", status, _responseText, _headers);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow transition is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowTransitionProperty>(null as any);
    }

    /**
     * Delete inactive workflow
     * @param entityId The entity ID of the workflow.
     * @return Returned if the workflow is deleted.
     */
    deleteInactiveWorkflow(entityId: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/workflow/{entityId}";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteInactiveWorkflow(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteInactiveWorkflow(_response);
            throw _response;
        });
    }

    protected processDeleteInactiveWorkflow(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get issue types in a project that are using a given workflow
     * @param workflowId The workflow ID
     * @param projectId The project ID
     * @param nextPageToken (optional) The cursor for pagination
     * @param maxResults (optional) The maximum number of results to return. Must be an integer between 1 and 200.
     * @return Returned if the request is successful.
     */
    getWorkflowProjectIssueTypeUsages(workflowId: string, projectId: number, nextPageToken?: string | undefined, maxResults?: number | undefined): ng.IPromise<WorkflowProjectIssueTypeUsageDTO> {
        let url_ = this.baseUrl + "/rest/api/3/workflow/{workflowId}/project/{projectId}/issueTypeUsages?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (nextPageToken === null)
            throw new Error("The parameter 'nextPageToken' cannot be null.");
        else if (nextPageToken !== undefined)
            url_ += "nextPageToken=" + encodeURIComponent("" + nextPageToken) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetWorkflowProjectIssueTypeUsages(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetWorkflowProjectIssueTypeUsages(_response);
            throw _response;
        });
    }

    protected processGetWorkflowProjectIssueTypeUsages(response: any): ng.IPromise<WorkflowProjectIssueTypeUsageDTO> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowProjectIssueTypeUsageDTO.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow with the given ID does not exist.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowProjectIssueTypeUsageDTO>(null as any);
    }

    /**
     * Get projects using a given workflow
     * @param workflowId The workflow ID
     * @param nextPageToken (optional) The cursor for pagination
     * @param maxResults (optional) The maximum number of results to return. Must be an integer between 1 and 200.
     * @return Returned if the request is successful.
     */
    getProjectUsagesForWorkflow(workflowId: string, nextPageToken?: string | undefined, maxResults?: number | undefined): ng.IPromise<WorkflowProjectUsageDTO> {
        let url_ = this.baseUrl + "/rest/api/3/workflow/{workflowId}/projectUsages?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (nextPageToken === null)
            throw new Error("The parameter 'nextPageToken' cannot be null.");
        else if (nextPageToken !== undefined)
            url_ += "nextPageToken=" + encodeURIComponent("" + nextPageToken) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectUsagesForWorkflow(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectUsagesForWorkflow(_response);
            throw _response;
        });
    }

    protected processGetProjectUsagesForWorkflow(response: any): ng.IPromise<WorkflowProjectUsageDTO> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowProjectUsageDTO.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow with the given ID does not exist.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowProjectUsageDTO>(null as any);
    }

    /**
     * Get workflow schemes which are using a given workflow
     * @param workflowId The workflow ID
     * @param nextPageToken (optional) The cursor for pagination
     * @param maxResults (optional) The maximum number of results to return. Must be an integer between 1 and 200.
     * @return Returned if the request is successful.
     */
    getWorkflowSchemeUsagesForWorkflow(workflowId: string, nextPageToken?: string | undefined, maxResults?: number | undefined): ng.IPromise<WorkflowSchemeUsageDTO> {
        let url_ = this.baseUrl + "/rest/api/3/workflow/{workflowId}/workflowSchemes?";
        if (workflowId === undefined || workflowId === null)
            throw new Error("The parameter 'workflowId' must be defined.");
        url_ = url_.replace("{workflowId}", encodeURIComponent("" + workflowId));
        if (nextPageToken === null)
            throw new Error("The parameter 'nextPageToken' cannot be null.");
        else if (nextPageToken !== undefined)
            url_ += "nextPageToken=" + encodeURIComponent("" + nextPageToken) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetWorkflowSchemeUsagesForWorkflow(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetWorkflowSchemeUsagesForWorkflow(_response);
            throw _response;
        });
    }

    protected processGetWorkflowSchemeUsagesForWorkflow(response: any): ng.IPromise<WorkflowSchemeUsageDTO> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeUsageDTO.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow with the given ID does not exist.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowSchemeUsageDTO>(null as any);
    }

    /**
     * Bulk get workflows
     * @param expand (optional) Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details.

    Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `workflows.usages` Returns the project and issue types that each workflow is associated with.
     *  `statuses.usages` Returns the project and issue types that each status is associated with.
     * @param useApprovalConfiguration (optional) Return the new field `approvalConfiguration` instead of the deprecated status properties for approval configuration.
     * @return Returned if the request is successful.
     */
    readWorkflows(body: WorkflowReadRequest, expand?: string | undefined, useApprovalConfiguration?: boolean | undefined): ng.IPromise<WorkflowReadResponse> {
        let url_ = this.baseUrl + "/rest/api/3/workflows?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (useApprovalConfiguration === null)
            throw new Error("The parameter 'useApprovalConfiguration' cannot be null.");
        else if (useApprovalConfiguration !== undefined)
            url_ += "useApprovalConfiguration=" + encodeURIComponent("" + useApprovalConfiguration) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processReadWorkflows(_response);
        }, (_response) => {
            if (_response.status)
                return this.processReadWorkflows(_response);
            throw _response;
        });
    }

    protected processReadWorkflows(response: any): ng.IPromise<WorkflowReadResponse> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowReadResponse.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowReadResponse>(null as any);
    }

    /**
     * Get available workflow capabilities
     * @param workflowId (optional) 
     * @param projectId (optional) 
     * @param issueTypeId (optional) 
     * @return Returned if the request is successful.
     */
    workflowCapabilities(workflowId?: string | undefined, projectId?: string | undefined, issueTypeId?: string | undefined): ng.IPromise<WorkflowCapabilities> {
        let url_ = this.baseUrl + "/rest/api/3/workflows/capabilities?";
        if (workflowId === null)
            throw new Error("The parameter 'workflowId' cannot be null.");
        else if (workflowId !== undefined)
            url_ += "workflowId=" + encodeURIComponent("" + workflowId) + "&";
        if (projectId === null)
            throw new Error("The parameter 'projectId' cannot be null.");
        else if (projectId !== undefined)
            url_ += "projectId=" + encodeURIComponent("" + projectId) + "&";
        if (issueTypeId === null)
            throw new Error("The parameter 'issueTypeId' cannot be null.");
        else if (issueTypeId !== undefined)
            url_ += "issueTypeId=" + encodeURIComponent("" + issueTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processWorkflowCapabilities(_response);
        }, (_response) => {
            if (_response.status)
                return this.processWorkflowCapabilities(_response);
            throw _response;
        });
    }

    protected processWorkflowCapabilities(response: any): ng.IPromise<WorkflowCapabilities> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowCapabilities.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowCapabilities>(null as any);
    }

    /**
     * Bulk create workflows
     * @return Returned if the request is successful.
     */
    createWorkflows(body: WorkflowCreateRequest): ng.IPromise<WorkflowCreateResponse> {
        let url_ = this.baseUrl + "/rest/api/3/workflows/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateWorkflows(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateWorkflows(_response);
            throw _response;
        });
    }

    protected processCreateWorkflows(response: any): ng.IPromise<WorkflowCreateResponse> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowCreateResponse.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if another workflow configuration update task is ongoing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowCreateResponse>(null as any);
    }

    /**
     * Validate create workflows
     * @return Returned if the request is successful.
     */
    validateCreateWorkflows(body: WorkflowCreateValidateRequest): ng.IPromise<WorkflowValidationErrorList> {
        let url_ = this.baseUrl + "/rest/api/3/workflows/create/validation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processValidateCreateWorkflows(_response);
        }, (_response) => {
            if (_response.status)
                return this.processValidateCreateWorkflows(_response);
            throw _response;
        });
    }

    protected processValidateCreateWorkflows(response: any): ng.IPromise<WorkflowValidationErrorList> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowValidationErrorList.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowValidationErrorList>(null as any);
    }

    /**
     * Search workflows
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `values.transitions` Returns the transitions that each workflow is associated with.
     * @param queryString (optional) String used to perform a case-insensitive partial match with workflow name.
     * @param orderBy (optional) [Order](#ordering) the results by a field:

     *  `name` Sorts by workflow name.
     *  `created` Sorts by create time.
     *  `updated` Sorts by update time.
     * @param scope (optional) The scope of the workflow. Global for company-managed projects and Project for team-managed projects.
     * @param isActive (optional) Filters active and inactive workflows.
     * @return Returned if the request is successful.
     */
    searchWorkflows(startAt?: number | undefined, maxResults?: number | undefined, expand?: string | undefined, queryString?: string | undefined, orderBy?: string | undefined, scope?: string | undefined, isActive?: boolean | undefined): ng.IPromise<WorkflowSearchResponse> {
        let url_ = this.baseUrl + "/rest/api/3/workflows/search?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        if (queryString === null)
            throw new Error("The parameter 'queryString' cannot be null.");
        else if (queryString !== undefined)
            url_ += "queryString=" + encodeURIComponent("" + queryString) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (scope === null)
            throw new Error("The parameter 'scope' cannot be null.");
        else if (scope !== undefined)
            url_ += "scope=" + encodeURIComponent("" + scope) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSearchWorkflows(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSearchWorkflows(_response);
            throw _response;
        });
    }

    protected processSearchWorkflows(response: any): ng.IPromise<WorkflowSearchResponse> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSearchResponse.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowSearchResponse>(null as any);
    }

    /**
     * Bulk update workflows
     * @param expand (optional) Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `workflows.usages` Returns the project and issue types that each workflow is associated with.
     *  `statuses.usages` Returns the project and issue types that each status is associated with.
     * @return Returned if the request is successful.
     */
    updateWorkflows(body: WorkflowUpdateRequest, expand?: string | undefined): ng.IPromise<WorkflowUpdateResponse> {
        let url_ = this.baseUrl + "/rest/api/3/workflows/update?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateWorkflows(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateWorkflows(_response);
            throw _response;
        });
    }

    protected processUpdateWorkflows(response: any): ng.IPromise<WorkflowUpdateResponse> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowUpdateResponse.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if another workflow configuration update task is ongoing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowUpdateResponse>(null as any);
    }

    /**
     * Validate update workflows
     * @return Returned if the request is successful.
     */
    validateUpdateWorkflows(body: WorkflowUpdateValidateRequestBean): ng.IPromise<WorkflowValidationErrorList> {
        let url_ = this.baseUrl + "/rest/api/3/workflows/update/validation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processValidateUpdateWorkflows(_response);
        }, (_response) => {
            if (_response.status)
                return this.processValidateUpdateWorkflows(_response);
            throw _response;
        });
    }

    protected processValidateUpdateWorkflows(response: any): ng.IPromise<WorkflowValidationErrorList> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowValidationErrorList.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowValidationErrorList>(null as any);
    }

    /**
     * Get all workflow schemes
     * @param startAt (optional) The index of the first item to return in a page of results (page offset).
     * @param maxResults (optional) The maximum number of items to return per page.
     * @return Returned if the request is successful.
     */
    getAllWorkflowSchemes(startAt?: number | undefined, maxResults?: number | undefined): ng.IPromise<PageBeanWorkflowScheme> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme?";
        if (startAt === null)
            throw new Error("The parameter 'startAt' cannot be null.");
        else if (startAt !== undefined)
            url_ += "startAt=" + encodeURIComponent("" + startAt) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetAllWorkflowSchemes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetAllWorkflowSchemes(_response);
            throw _response;
        });
    }

    protected processGetAllWorkflowSchemes(response: any): ng.IPromise<PageBeanWorkflowScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageBeanWorkflowScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PageBeanWorkflowScheme>(null as any);
    }

    /**
     * Create workflow scheme
     * @return Returned if the request is successful.
     */
    createWorkflowScheme(body: WorkflowScheme): ng.IPromise<WorkflowScheme> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateWorkflowScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateWorkflowScheme(_response);
            throw _response;
        });
    }

    protected processCreateWorkflowScheme(response: any): ng.IPromise<WorkflowScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = WorkflowScheme.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowScheme>(null as any);
    }

    /**
     * Get workflow scheme project associations
     * @param projectId The ID of a project to return the workflow schemes for. To include multiple projects, provide an ampersand-Jim: oneseparated list. For example, `projectId=10000&projectId=10001`.
     * @return Returned if the request is successful.
     */
    getWorkflowSchemeProjectAssociations(projectId: number[]): ng.IPromise<ContainerOfWorkflowSchemeAssociations> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/project?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined and cannot be null.");
        else
            projectId && projectId.forEach(item => { url_ += "projectId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetWorkflowSchemeProjectAssociations(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetWorkflowSchemeProjectAssociations(_response);
            throw _response;
        });
    }

    protected processGetWorkflowSchemeProjectAssociations(response: any): ng.IPromise<ContainerOfWorkflowSchemeAssociations> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContainerOfWorkflowSchemeAssociations.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ContainerOfWorkflowSchemeAssociations>(null as any);
    }

    /**
     * Assign workflow scheme to project
     * @return Returned if the request is successful.
     */
    assignSchemeToProject(body: WorkflowSchemeProjectAssociation): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/project";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processAssignSchemeToProject(_response);
        }, (_response) => {
            if (_response.status)
                return this.processAssignSchemeToProject(_response);
            throw _response;
        });
    }

    protected processAssignSchemeToProject(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the required permissions.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow scheme or the project are not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Bulk get workflow schemes
     * @param expand (optional) Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details.

    Use [expand](#expansion) to include additional information in the response. This parameter accepts a comma-separated list. Expand options include:

     *  `workflows.usages` Returns the project and issue types that each workflow in the workflow scheme is associated with.
     * @return Returned if the request is successful.
     */
    readWorkflowSchemes(body: WorkflowSchemeReadRequest, expand?: string | undefined): ng.IPromise<WorkflowSchemeReadResponse[]> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/read?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processReadWorkflowSchemes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processReadWorkflowSchemes(_response);
            throw _response;
        });
    }

    protected processReadWorkflowSchemes(response: any): ng.IPromise<WorkflowSchemeReadResponse[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkflowSchemeReadResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowSchemeReadResponse[]>(null as any);
    }

    /**
     * Update workflow scheme
     * @return Returned if the request is successful and there is no asynchronous task.
     */
    updateSchemes(body: WorkflowSchemeUpdateRequest): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateSchemes(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateSchemes(_response);
            throw _response;
        });
    }

    protected processUpdateSchemes(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 303) {
            const _responseText = response.data;
            let result303: any = null;
            let resultData303 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result303 = TaskProgressBeanObject.fromJS(resultData303);
            return throwException(this.q, "Returned if the request is successful and there is an asynchronous task for the migrations.", status, _responseText, _headers, result303);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status === 409) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if another workflow configuration update task is ongoing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get required status mappings for workflow scheme update
     * @return Returned if the request is successful.
     */
    updateWorkflowSchemeMappings(body: WorkflowSchemeUpdateRequiredMappingsRequest): ng.IPromise<WorkflowSchemeUpdateRequiredMappingsResponse> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/update/mappings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateWorkflowSchemeMappings(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateWorkflowSchemeMappings(_response);
            throw _response;
        });
    }

    protected processUpdateWorkflowSchemeMappings(response: any): ng.IPromise<WorkflowSchemeUpdateRequiredMappingsResponse> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeUpdateRequiredMappingsResponse.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowSchemeUpdateRequiredMappingsResponse>(null as any);
    }

    /**
     * Delete workflow scheme
     * @param id The ID of the workflow scheme. Find this ID by editing the desired workflow scheme in Jira. The ID is shown in the URL as `schemeId`. For example, *schemeId=10301*.
     * @return Returned if the request is successful.
     */
    deleteWorkflowScheme(id: number): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteWorkflowScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteWorkflowScheme(_response);
            throw _response;
        });
    }

    protected processDeleteWorkflowScheme(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result204 = resultData204 !== undefined ? resultData204 : <any>null;
    
            return this.q.resolve(result204);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the scheme is active.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }

    /**
     * Get workflow scheme
     * @param id The ID of the workflow scheme. Find this ID by editing the desired workflow scheme in Jira. The ID is shown in the URL as `schemeId`. For example, *schemeId=10301*.
     * @param returnDraftIfExists (optional) Returns the workflow scheme's draft rather than scheme itself, if set to true. If the workflow scheme does not have a draft, then the workflow scheme is returned.
     * @return Returned if the request is successful.
     */
    getWorkflowScheme(id: number, returnDraftIfExists?: boolean | undefined): ng.IPromise<WorkflowScheme> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (returnDraftIfExists === null)
            throw new Error("The parameter 'returnDraftIfExists' cannot be null.");
        else if (returnDraftIfExists !== undefined)
            url_ += "returnDraftIfExists=" + encodeURIComponent("" + returnDraftIfExists) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetWorkflowScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetWorkflowScheme(_response);
            throw _response;
        });
    }

    protected processGetWorkflowScheme(response: any): ng.IPromise<WorkflowScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowScheme>(null as any);
    }

    /**
     * Classic update workflow scheme
     * @param id The ID of the workflow scheme. Find this ID by editing the desired workflow scheme in Jira. The ID is shown in the URL as `schemeId`. For example, *schemeId=10301*.
     * @return Returned if the request is successful.
     */
    updateWorkflowScheme(id: number, body: WorkflowScheme): ng.IPromise<WorkflowScheme> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateWorkflowScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateWorkflowScheme(_response);
            throw _response;
        });
    }

    protected processUpdateWorkflowScheme(response: any): ng.IPromise<WorkflowScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowScheme>(null as any);
    }

    /**
     * Create draft workflow scheme
     * @param id The ID of the active workflow scheme that the draft is created from.
     * @return Returned if the request is successful.
     */
    createWorkflowSchemeDraftFromParent(id: number): ng.IPromise<WorkflowScheme> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/createdraft";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processCreateWorkflowSchemeDraftFromParent(_response);
        }, (_response) => {
            if (_response.status)
                return this.processCreateWorkflowSchemeDraftFromParent(_response);
            throw _response;
        });
    }

    protected processCreateWorkflowSchemeDraftFromParent(response: any): ng.IPromise<WorkflowScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = WorkflowScheme.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowScheme>(null as any);
    }

    /**
     * Delete default workflow
     * @param id The ID of the workflow scheme.
     * @param updateDraftIfNeeded (optional) Set to true to create or update the draft of a workflow scheme and delete the mapping from the draft, when the workflow scheme cannot be edited. Defaults to `false`.
     * @return Returned if the request is successful.
     */
    deleteDefaultWorkflow(id: number, updateDraftIfNeeded?: boolean | undefined): ng.IPromise<WorkflowScheme> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/default?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (updateDraftIfNeeded === null)
            throw new Error("The parameter 'updateDraftIfNeeded' cannot be null.");
        else if (updateDraftIfNeeded !== undefined)
            url_ += "updateDraftIfNeeded=" + encodeURIComponent("" + updateDraftIfNeeded) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteDefaultWorkflow(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteDefaultWorkflow(_response);
            throw _response;
        });
    }

    protected processDeleteDefaultWorkflow(response: any): ng.IPromise<WorkflowScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow scheme cannot be edited and `updateDraftIfNeeded` is not `true`.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowScheme>(null as any);
    }

    /**
     * Get default workflow
     * @param id The ID of the workflow scheme.
     * @param returnDraftIfExists (optional) Set to `true` to return the default workflow for the workflow scheme's draft rather than scheme itself. If the workflow scheme does not have a draft, then the default workflow for the workflow scheme is returned.
     * @return Returned if the request is successful.
     */
    getDefaultWorkflow(id: number, returnDraftIfExists?: boolean | undefined): ng.IPromise<DefaultWorkflow> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/default?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (returnDraftIfExists === null)
            throw new Error("The parameter 'returnDraftIfExists' cannot be null.");
        else if (returnDraftIfExists !== undefined)
            url_ += "returnDraftIfExists=" + encodeURIComponent("" + returnDraftIfExists) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetDefaultWorkflow(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetDefaultWorkflow(_response);
            throw _response;
        });
    }

    protected processGetDefaultWorkflow(response: any): ng.IPromise<DefaultWorkflow> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DefaultWorkflow.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<DefaultWorkflow>(null as any);
    }

    /**
     * Update default workflow
     * @param id The ID of the workflow scheme.
     * @param body The new default workflow.
     * @return Returned if the request is successful.
     */
    updateDefaultWorkflow(id: number, body: DefaultWorkflow): ng.IPromise<WorkflowScheme> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/default";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateDefaultWorkflow(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateDefaultWorkflow(_response);
            throw _response;
        });
    }

    protected processUpdateDefaultWorkflow(response: any): ng.IPromise<WorkflowScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow scheme cannot be edited and `updateDraftIfNeeded` is not `true`.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowScheme>(null as any);
    }

    /**
     * Delete draft workflow scheme
     * @param id The ID of the active workflow scheme that the draft was created from.
     * @return Returned if the request is successful.
     */
    deleteWorkflowSchemeDraft(id: number): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/draft";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteWorkflowSchemeDraft(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteWorkflowSchemeDraft(_response);
            throw _response;
        });
    }

    protected processDeleteWorkflowSchemeDraft(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission..", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the original active workflow scheme is not found.\n *  the original active workflow scheme does not have a draft.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get draft workflow scheme
     * @param id The ID of the active workflow scheme that the draft was created from.
     * @return Returned if the request is successful.
     */
    getWorkflowSchemeDraft(id: number): ng.IPromise<WorkflowScheme> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/draft";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetWorkflowSchemeDraft(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetWorkflowSchemeDraft(_response);
            throw _response;
        });
    }

    protected processGetWorkflowSchemeDraft(response: any): ng.IPromise<WorkflowScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the original active workflow scheme is not found.\n *  the original active workflow scheme does not have a draft.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowScheme>(null as any);
    }

    /**
     * Update draft workflow scheme
     * @param id The ID of the active workflow scheme that the draft was created from.
     * @return Returned if the request is successful.
     */
    updateWorkflowSchemeDraft(id: number, body: WorkflowScheme): ng.IPromise<WorkflowScheme> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/draft";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateWorkflowSchemeDraft(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateWorkflowSchemeDraft(_response);
            throw _response;
        });
    }

    protected processUpdateWorkflowSchemeDraft(response: any): ng.IPromise<WorkflowScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n\n *  the original active workflow scheme is not found.\n *  the original active workflow scheme does not have a draft.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowScheme>(null as any);
    }

    /**
     * Delete draft default workflow
     * @param id The ID of the workflow scheme that the draft belongs to.
     * @return Returned if the request is successful.
     */
    deleteDraftDefaultWorkflow(id: number): ng.IPromise<WorkflowScheme> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/draft/default";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteDraftDefaultWorkflow(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteDraftDefaultWorkflow(_response);
            throw _response;
        });
    }

    protected processDeleteDraftDefaultWorkflow(response: any): ng.IPromise<WorkflowScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if any of the following is true:\n\n *  The workflow scheme is not found.\n *  The workflow scheme does not have a draft.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowScheme>(null as any);
    }

    /**
     * Get draft default workflow
     * @param id The ID of the workflow scheme that the draft belongs to.
     * @return Returned if the request is successful.
     */
    getDraftDefaultWorkflow(id: number): ng.IPromise<DefaultWorkflow> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/draft/default";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetDraftDefaultWorkflow(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetDraftDefaultWorkflow(_response);
            throw _response;
        });
    }

    protected processGetDraftDefaultWorkflow(response: any): ng.IPromise<DefaultWorkflow> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DefaultWorkflow.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission..", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if any of the following is true:\n\n *  The workflow scheme is not found.\n *  The workflow scheme does not have a draft.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<DefaultWorkflow>(null as any);
    }

    /**
     * Update draft default workflow
     * @param id The ID of the workflow scheme that the draft belongs to.
     * @param body The object for the new default workflow.
     * @return Returned if the request is successful.
     */
    updateDraftDefaultWorkflow(id: number, body: DefaultWorkflow): ng.IPromise<WorkflowScheme> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/draft/default";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateDraftDefaultWorkflow(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateDraftDefaultWorkflow(_response);
            throw _response;
        });
    }

    protected processUpdateDraftDefaultWorkflow(response: any): ng.IPromise<WorkflowScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if any of the following is true:\n\n *  The workflow scheme is not found.\n *  The workflow scheme does not have a draft.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowScheme>(null as any);
    }

    /**
     * Delete workflow for issue type in draft workflow scheme
     * @param id The ID of the workflow scheme that the draft belongs to.
     * @param issueType The ID of the issue type.
     * @return Returned if the request is successful.
     */
    deleteWorkflowSchemeDraftIssueType(id: number, issueType: string): ng.IPromise<WorkflowScheme> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/draft/issuetype/{issueType}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (issueType === undefined || issueType === null)
            throw new Error("The parameter 'issueType' must be defined.");
        url_ = url_.replace("{issueType}", encodeURIComponent("" + issueType));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteWorkflowSchemeDraftIssueType(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteWorkflowSchemeDraftIssueType(_response);
            throw _response;
        });
    }

    protected processDeleteWorkflowSchemeDraftIssueType(response: any): ng.IPromise<WorkflowScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow scheme or issue type is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowScheme>(null as any);
    }

    /**
     * Get workflow for issue type in draft workflow scheme
     * @param id The ID of the workflow scheme that the draft belongs to.
     * @param issueType The ID of the issue type.
     * @return Returned if the request is successful.
     */
    getWorkflowSchemeDraftIssueType(id: number, issueType: string): ng.IPromise<IssueTypeWorkflowMapping> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/draft/issuetype/{issueType}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (issueType === undefined || issueType === null)
            throw new Error("The parameter 'issueType' must be defined.");
        url_ = url_.replace("{issueType}", encodeURIComponent("" + issueType));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetWorkflowSchemeDraftIssueType(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetWorkflowSchemeDraftIssueType(_response);
            throw _response;
        });
    }

    protected processGetWorkflowSchemeDraftIssueType(response: any): ng.IPromise<IssueTypeWorkflowMapping> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueTypeWorkflowMapping.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow scheme or issue type is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueTypeWorkflowMapping>(null as any);
    }

    /**
     * Set workflow for issue type in draft workflow scheme
     * @param id The ID of the workflow scheme that the draft belongs to.
     * @param issueType The ID of the issue type.
     * @param body The issue type-project mapping.
     * @return Returned if the request is successful.
     */
    setWorkflowSchemeDraftIssueType(id: number, issueType: string, body: IssueTypeWorkflowMapping): ng.IPromise<WorkflowScheme> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/draft/issuetype/{issueType}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (issueType === undefined || issueType === null)
            throw new Error("The parameter 'issueType' must be defined.");
        url_ = url_.replace("{issueType}", encodeURIComponent("" + issueType));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetWorkflowSchemeDraftIssueType(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetWorkflowSchemeDraftIssueType(_response);
            throw _response;
        });
    }

    protected processSetWorkflowSchemeDraftIssueType(response: any): ng.IPromise<WorkflowScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow scheme or issue type is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowScheme>(null as any);
    }

    /**
     * Publish draft workflow scheme
     * @param id The ID of the workflow scheme that the draft belongs to.
     * @param body Details of the status mappings.
     * @param validateOnly (optional) Whether the request only performs a validation.
     * @return Returned if the request is only for validation and is successful.
     */
    publishDraftWorkflowScheme(id: number, body: PublishDraftWorkflowScheme, validateOnly?: boolean | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/draft/publish?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (validateOnly === null)
            throw new Error("The parameter 'validateOnly' cannot be null.");
        else if (validateOnly !== undefined)
            url_ += "validateOnly=" + encodeURIComponent("" + validateOnly) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http(options_).then((_response) => {
            return this.processPublishDraftWorkflowScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processPublishDraftWorkflowScheme(_response);
            throw _response;
        });
    }

    protected processPublishDraftWorkflowScheme(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 303) {
            const _responseText = response.data;
            let result303: any = null;
            let resultData303 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result303 = TaskProgressBeanObject.fromJS(resultData303);
            return throwException(this.q, "Returned if the request is successful.", status, _responseText, _headers, result303);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if any of these are true:\n\n *  The workflow scheme is not found.\n *  The workflow scheme does not have a draft.\n *  A new status in the draft workflow scheme is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Delete issue types for workflow in draft workflow scheme
     * @param id The ID of the workflow scheme that the draft belongs to.
     * @param workflowName The name of the workflow.
     * @return Returned if the request is successful.
     */
    deleteDraftWorkflowMapping(id: number, workflowName: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/draft/workflow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (workflowName === undefined || workflowName === null)
            throw new Error("The parameter 'workflowName' must be defined and cannot be null.");
        else
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteDraftWorkflowMapping(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteDraftWorkflowMapping(_response);
            throw _response;
        });
    }

    protected processDeleteDraftWorkflowMapping(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if any of the following is true:\n\n *  The workflow scheme is not found.\n *  The workflow scheme does not have a draft.\n *  The workflow is not found.\n *  The workflow is not specified.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get issue types for workflows in draft workflow scheme
     * @param id The ID of the workflow scheme that the draft belongs to.
     * @param workflowName (optional) The name of a workflow in the scheme. Limits the results to the workflow-issue type mapping for the specified workflow.
     * @return Returned if the request is successful.
     */
    getDraftWorkflow(id: number, workflowName?: string | undefined): ng.IPromise<IssueTypesWorkflowMapping> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/draft/workflow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (workflowName === null)
            throw new Error("The parameter 'workflowName' cannot be null.");
        else if (workflowName !== undefined)
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetDraftWorkflow(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetDraftWorkflow(_response);
            throw _response;
        });
    }

    protected processGetDraftWorkflow(response: any): ng.IPromise<IssueTypesWorkflowMapping> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueTypesWorkflowMapping.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if either the workflow scheme or workflow (if specified) is not found. session.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueTypesWorkflowMapping>(null as any);
    }

    /**
     * Set issue types for workflow in workflow scheme
     * @param id The ID of the workflow scheme that the draft belongs to.
     * @param workflowName The name of the workflow.
     * @return Returned if the request is successful.
     */
    updateDraftWorkflowMapping(id: number, workflowName: string, body: IssueTypesWorkflowMapping): ng.IPromise<WorkflowScheme> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/draft/workflow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (workflowName === undefined || workflowName === null)
            throw new Error("The parameter 'workflowName' must be defined and cannot be null.");
        else
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateDraftWorkflowMapping(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateDraftWorkflowMapping(_response);
            throw _response;
        });
    }

    protected processUpdateDraftWorkflowMapping(response: any): ng.IPromise<WorkflowScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if any of the following is true:\n\n *  The workflow scheme is not found.\n *  The workflow scheme does not have a draft.\n *  The workflow is not found.\n *  The workflow is not specified.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowScheme>(null as any);
    }

    /**
     * Delete workflow for issue type in workflow scheme
     * @param id The ID of the workflow scheme.
     * @param issueType The ID of the issue type.
     * @param updateDraftIfNeeded (optional) Set to true to create or update the draft of a workflow scheme and update the mapping in the draft, when the workflow scheme cannot be edited. Defaults to `false`.
     * @return Returned if the request is successful.
     */
    deleteWorkflowSchemeIssueType(id: number, issueType: string, updateDraftIfNeeded?: boolean | undefined): ng.IPromise<WorkflowScheme> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/issuetype/{issueType}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (issueType === undefined || issueType === null)
            throw new Error("The parameter 'issueType' must be defined.");
        url_ = url_.replace("{issueType}", encodeURIComponent("" + issueType));
        if (updateDraftIfNeeded === null)
            throw new Error("The parameter 'updateDraftIfNeeded' cannot be null.");
        else if (updateDraftIfNeeded !== undefined)
            url_ += "updateDraftIfNeeded=" + encodeURIComponent("" + updateDraftIfNeeded) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteWorkflowSchemeIssueType(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteWorkflowSchemeIssueType(_response);
            throw _response;
        });
    }

    protected processDeleteWorkflowSchemeIssueType(response: any): ng.IPromise<WorkflowScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow cannot be edited and `updateDraftIfNeeded` is false.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow scheme or issue type is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowScheme>(null as any);
    }

    /**
     * Get workflow for issue type in workflow scheme
     * @param id The ID of the workflow scheme.
     * @param issueType The ID of the issue type.
     * @param returnDraftIfExists (optional) Returns the mapping from the workflow scheme's draft rather than the workflow scheme, if set to true. If no draft exists, the mapping from the workflow scheme is returned.
     * @return Returned if the request is successful.
     */
    getWorkflowSchemeIssueType(id: number, issueType: string, returnDraftIfExists?: boolean | undefined): ng.IPromise<IssueTypeWorkflowMapping> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/issuetype/{issueType}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (issueType === undefined || issueType === null)
            throw new Error("The parameter 'issueType' must be defined.");
        url_ = url_.replace("{issueType}", encodeURIComponent("" + issueType));
        if (returnDraftIfExists === null)
            throw new Error("The parameter 'returnDraftIfExists' cannot be null.");
        else if (returnDraftIfExists !== undefined)
            url_ += "returnDraftIfExists=" + encodeURIComponent("" + returnDraftIfExists) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetWorkflowSchemeIssueType(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetWorkflowSchemeIssueType(_response);
            throw _response;
        });
    }

    protected processGetWorkflowSchemeIssueType(response: any): ng.IPromise<IssueTypeWorkflowMapping> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueTypeWorkflowMapping.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow scheme or issue type is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueTypeWorkflowMapping>(null as any);
    }

    /**
     * Set workflow for issue type in workflow scheme
     * @param id The ID of the workflow scheme.
     * @param issueType The ID of the issue type.
     * @param body The issue type-project mapping.
     * @return Returned if the request is successful.
     */
    setWorkflowSchemeIssueType(id: number, issueType: string, body: IssueTypeWorkflowMapping): ng.IPromise<WorkflowScheme> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/issuetype/{issueType}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (issueType === undefined || issueType === null)
            throw new Error("The parameter 'issueType' must be defined.");
        url_ = url_.replace("{issueType}", encodeURIComponent("" + issueType));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processSetWorkflowSchemeIssueType(_response);
        }, (_response) => {
            if (_response.status)
                return this.processSetWorkflowSchemeIssueType(_response);
            throw _response;
        });
    }

    protected processSetWorkflowSchemeIssueType(response: any): ng.IPromise<WorkflowScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow cannot be edited and `updateDraftIfNeeded` is false.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow scheme or issue type is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowScheme>(null as any);
    }

    /**
     * Delete issue types for workflow in workflow scheme
     * @param id The ID of the workflow scheme.
     * @param workflowName The name of the workflow.
     * @param updateDraftIfNeeded (optional) Set to true to create or update the draft of a workflow scheme and delete the mapping from the draft, when the workflow scheme cannot be edited. Defaults to `false`.
     * @return Returned if the request is successful.
     */
    deleteWorkflowMapping(id: number, workflowName: string, updateDraftIfNeeded?: boolean | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/workflow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (workflowName === undefined || workflowName === null)
            throw new Error("The parameter 'workflowName' must be defined and cannot be null.");
        else
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        if (updateDraftIfNeeded === null)
            throw new Error("The parameter 'updateDraftIfNeeded' cannot be null.");
        else if (updateDraftIfNeeded !== undefined)
            url_ += "updateDraftIfNeeded=" + encodeURIComponent("" + updateDraftIfNeeded) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteWorkflowMapping(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteWorkflowMapping(_response);
            throw _response;
        });
    }

    protected processDeleteWorkflowMapping(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow cannot be edited and `updateDraftIfNeeded` is not true.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if any of the following is true:\n\n *  The workflow scheme is not found.\n *  The workflow is not found.\n *  The workflow is not specified.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Get issue types for workflows in workflow scheme
     * @param id The ID of the workflow scheme.
     * @param workflowName (optional) The name of a workflow in the scheme. Limits the results to the workflow-issue type mapping for the specified workflow.
     * @param returnDraftIfExists (optional) Returns the mapping from the workflow scheme's draft rather than the workflow scheme, if set to true. If no draft exists, the mapping from the workflow scheme is returned.
     * @return Returned if the request is successful.
     */
    getWorkflow(id: number, workflowName?: string | undefined, returnDraftIfExists?: boolean | undefined): ng.IPromise<IssueTypesWorkflowMapping> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/workflow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (workflowName === null)
            throw new Error("The parameter 'workflowName' cannot be null.");
        else if (workflowName !== undefined)
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        if (returnDraftIfExists === null)
            throw new Error("The parameter 'returnDraftIfExists' cannot be null.");
        else if (returnDraftIfExists !== undefined)
            url_ += "returnDraftIfExists=" + encodeURIComponent("" + returnDraftIfExists) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetWorkflow(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetWorkflow(_response);
            throw _response;
        });
    }

    protected processGetWorkflow(response: any): ng.IPromise<IssueTypesWorkflowMapping> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IssueTypesWorkflowMapping.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if either the workflow scheme or workflow is not found.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<IssueTypesWorkflowMapping>(null as any);
    }

    /**
     * Set issue types for workflow in workflow scheme
     * @param id The ID of the workflow scheme.
     * @param workflowName The name of the workflow.
     * @return Returned if the request is successful.
     */
    updateWorkflowMapping(id: number, workflowName: string, body: IssueTypesWorkflowMapping): ng.IPromise<WorkflowScheme> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{id}/workflow?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (workflowName === undefined || workflowName === null)
            throw new Error("The parameter 'workflowName' must be defined and cannot be null.");
        else
            url_ += "workflowName=" + encodeURIComponent("" + workflowName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processUpdateWorkflowMapping(_response);
        }, (_response) => {
            if (_response.status)
                return this.processUpdateWorkflowMapping(_response);
            throw _response;
        });
    }

    protected processUpdateWorkflowMapping(response: any): ng.IPromise<WorkflowScheme> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowScheme.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the user does not have the necessary permission.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if any of the following is true:\n\n *  The workflow scheme is not found.\n *  The workflow is not found.\n *  The workflow is not specified.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowScheme>(null as any);
    }

    /**
     * Get projects which are using a given workflow scheme
     * @param workflowSchemeId The workflow scheme ID
     * @param nextPageToken (optional) The cursor for pagination
     * @param maxResults (optional) The maximum number of results to return. Must be an integer between 1 and 200.
     * @return Returned if the request is successful.
     */
    getProjectUsagesForWorkflowScheme(workflowSchemeId: string, nextPageToken?: string | undefined, maxResults?: number | undefined): ng.IPromise<WorkflowSchemeProjectUsageDTO> {
        let url_ = this.baseUrl + "/rest/api/3/workflowscheme/{workflowSchemeId}/projectUsages?";
        if (workflowSchemeId === undefined || workflowSchemeId === null)
            throw new Error("The parameter 'workflowSchemeId' must be defined.");
        url_ = url_.replace("{workflowSchemeId}", encodeURIComponent("" + workflowSchemeId));
        if (nextPageToken === null)
            throw new Error("The parameter 'nextPageToken' cannot be null.");
        else if (nextPageToken !== undefined)
            url_ += "nextPageToken=" + encodeURIComponent("" + nextPageToken) + "&";
        if (maxResults === null)
            throw new Error("The parameter 'maxResults' cannot be null.");
        else if (maxResults !== undefined)
            url_ += "maxResults=" + encodeURIComponent("" + maxResults) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetProjectUsagesForWorkflowScheme(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetProjectUsagesForWorkflowScheme(_response);
            throw _response;
        });
    }

    protected processGetProjectUsagesForWorkflowScheme(response: any): ng.IPromise<WorkflowSchemeProjectUsageDTO> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowSchemeProjectUsageDTO.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing, or the caller doesn\'t have permissions to perform the operation.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the workflow scheme with the given ID does not exist.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowSchemeProjectUsageDTO>(null as any);
    }

    /**
     * Get IDs of deleted worklogs
     * @param since (optional) The date and time, as a UNIX timestamp in milliseconds, after which deleted worklogs are returned.
     * @return Returned if the request is successful.
     */
    getIdsOfWorklogsDeletedSince(since?: number | undefined): ng.IPromise<ChangedWorklogs> {
        let url_ = this.baseUrl + "/rest/api/3/worklog/deleted?";
        if (since === null)
            throw new Error("The parameter 'since' cannot be null.");
        else if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIdsOfWorklogsDeletedSince(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIdsOfWorklogsDeletedSince(_response);
            throw _response;
        });
    }

    protected processGetIdsOfWorklogsDeletedSince(response: any): ng.IPromise<ChangedWorklogs> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangedWorklogs.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ChangedWorklogs>(null as any);
    }

    /**
     * Get worklogs
     * @param body A JSON object containing a list of worklog IDs.
     * @param expand (optional) Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts `properties` that returns the properties of each worklog.
     * @return Returned if the request is successful.
     */
    getWorklogsForIds(body: WorklogIdsRequestBean, expand?: string | undefined): ng.IPromise<Worklog[]> {
        let url_ = this.baseUrl + "/rest/api/3/worklog/list?";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetWorklogsForIds(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetWorklogsForIds(_response);
            throw _response;
        });
    }

    protected processGetWorklogsForIds(response: any): ng.IPromise<Worklog[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Worklog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request contains more than 1000 worklog IDs or is empty.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<Worklog[]>(null as any);
    }

    /**
     * Get IDs of updated worklogs
     * @param since (optional) The date and time, as a UNIX timestamp in milliseconds, after which updated worklogs are returned.
     * @param expand (optional) Use [expand](#expansion) to include additional information about worklogs in the response. This parameter accepts `properties` that returns the properties of each worklog.
     * @return Returned if the request is successful.
     */
    getIdsOfWorklogsModifiedSince(since?: number | undefined, expand?: string | undefined): ng.IPromise<ChangedWorklogs> {
        let url_ = this.baseUrl + "/rest/api/3/worklog/updated?";
        if (since === null)
            throw new Error("The parameter 'since' cannot be null.");
        else if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&";
        if (expand === null)
            throw new Error("The parameter 'expand' cannot be null.");
        else if (expand !== undefined)
            url_ += "expand=" + encodeURIComponent("" + expand) + "&";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGetIdsOfWorklogsModifiedSince(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGetIdsOfWorklogsModifiedSince(_response);
            throw _response;
        });
    }

    protected processGetIdsOfWorklogsModifiedSince(response: any): ng.IPromise<ChangedWorklogs> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangedWorklogs.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ChangedWorklogs>(null as any);
    }

    /**
     * Delete app property (Forge)
     * @param propertyKey The key of the property.
     * @return Returned if the request is successful.
     */
    deleteForgeAppProperty(propertyKey: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/forge/1/app/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDeleteForgeAppProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDeleteForgeAppProperty(_response);
            throw _response;
        });
    }

    protected processDeleteForgeAppProperty(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = OperationMessage.fromJS(resultData400);
            return throwException(this.q, "Returned if the property key is longer than 127 characters.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request isn\'t made directly by an app or if it\'s an impersonated request.", status, _responseText, _headers);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = OperationMessage.fromJS(resultData404);
            return throwException(this.q, "Returned if the property isn\'t found or doesn\'t belong to the app.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }

    /**
     * Set app property (Forge)
     * @param propertyKey The key of the property.
     * @return Returned if the property is updated.
     */
    putForgeAppProperty(propertyKey: string, body: any): ng.IPromise<OperationMessage> {
        let url_ = this.baseUrl + "/rest/forge/1/app/properties/{propertyKey}";
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processPutForgeAppProperty(_response);
        }, (_response) => {
            if (_response.status)
                return this.processPutForgeAppProperty(_response);
            throw _response;
        });
    }

    protected processPutForgeAppProperty(response: any): ng.IPromise<OperationMessage> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationMessage.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = OperationMessage.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = OperationMessage.fromJS(resultData400);
            return throwException(this.q, "Returned if:\n  * the property key is longer than 127 characters.\n  * the value isn\'t valid JSON.\n  * the value is longer than 32768 characters.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request isn\'t made directly by an app or if it\'s an impersonated request.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<OperationMessage>(null as any);
    }
}

export class AddonPropertiesResource.getAddonPropertiesClient {
    private baseUrl: string | undefined = undefined;
    private http: ng.IHttpService;
    private q: ng.IQService;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor($http: ng.IHttpService, $q: ng.IQService, baseUrl?: string) {
        this.http = $http;
        this.q = $q;
        this.baseUrl = baseUrl ?? "https://your-domain.atlassian.net";
    }

    /**
     * Get app properties
     * @param addonKey The key of the app, as defined in its descriptor.
     * @return Returned if the request is successful.
     */
    get(addonKey: string): ng.IPromise<PropertyKeys> {
        let url_ = this.baseUrl + "/rest/atlassian-connect/1/addons/{addonKey}/properties";
        if (addonKey === undefined || addonKey === null)
            throw new Error("The parameter 'addonKey' must be defined.");
        url_ = url_.replace("{addonKey}", encodeURIComponent("" + addonKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGet(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGet(_response);
            throw _response;
        });
    }

    protected processGet(response: any): ng.IPromise<PropertyKeys> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyKeys.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = OperationMessage.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<PropertyKeys>(null as any);
    }
}

export class AddonPropertiesResource.deleteAddonPropertyClient {
    private baseUrl: string | undefined = undefined;
    private http: ng.IHttpService;
    private q: ng.IQService;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor($http: ng.IHttpService, $q: ng.IQService, baseUrl?: string) {
        this.http = $http;
        this.q = $q;
        this.baseUrl = baseUrl ?? "https://your-domain.atlassian.net";
    }

    /**
     * Delete app property
     * @param addonKey The key of the app, as defined in its descriptor.
     * @param propertyKey The key of the property.
     * @return Returned if the request is successful.
     */
    delete(addonKey: string, propertyKey: string): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/atlassian-connect/1/addons/{addonKey}/properties/{propertyKey}";
        if (addonKey === undefined || addonKey === null)
            throw new Error("The parameter 'addonKey' must be defined.");
        url_ = url_.replace("{addonKey}", encodeURIComponent("" + addonKey));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDelete(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDelete(_response);
            throw _response;
        });
    }

    protected processDelete(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = OperationMessage.fromJS(resultData400);
            return throwException(this.q, "Returned if the property key is longer than 127 characters.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = OperationMessage.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = OperationMessage.fromJS(resultData404);
            return throwException(this.q, "Returned if the property is not found or doesn\'t belong to the app.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }
}

export class AddonPropertiesResource.getAddonPropertyClient {
    private baseUrl: string | undefined = undefined;
    private http: ng.IHttpService;
    private q: ng.IQService;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor($http: ng.IHttpService, $q: ng.IQService, baseUrl?: string) {
        this.http = $http;
        this.q = $q;
        this.baseUrl = baseUrl ?? "https://your-domain.atlassian.net";
    }

    /**
     * Get app property
     * @param addonKey The key of the app, as defined in its descriptor.
     * @param propertyKey The key of the property.
     * @return Returned if the request is successful.
     */
    get(addonKey: string, propertyKey: string): ng.IPromise<EntityProperty> {
        let url_ = this.baseUrl + "/rest/atlassian-connect/1/addons/{addonKey}/properties/{propertyKey}";
        if (addonKey === undefined || addonKey === null)
            throw new Error("The parameter 'addonKey' must be defined.");
        url_ = url_.replace("{addonKey}", encodeURIComponent("" + addonKey));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGet(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGet(_response);
            throw _response;
        });
    }

    protected processGet(response: any): ng.IPromise<EntityProperty> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityProperty.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = OperationMessage.fromJS(resultData400);
            return throwException(this.q, "Returned if the property key is longer than 127 characters.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = OperationMessage.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status === 404) {
            const _responseText = response.data;
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = OperationMessage.fromJS(resultData404);
            return throwException(this.q, "Returned if the property is not found or doesn\'t belong to the app.", status, _responseText, _headers, result404);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<EntityProperty>(null as any);
    }
}

export class AddonPropertiesResource.putAddonPropertyClient {
    private baseUrl: string | undefined = undefined;
    private http: ng.IHttpService;
    private q: ng.IQService;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor($http: ng.IHttpService, $q: ng.IQService, baseUrl?: string) {
        this.http = $http;
        this.q = $q;
        this.baseUrl = baseUrl ?? "https://your-domain.atlassian.net";
    }

    /**
     * Set app property
     * @param addonKey The key of the app, as defined in its descriptor.
     * @param propertyKey The key of the property.
     * @return Returned if the property is updated.
     */
    put(addonKey: string, propertyKey: string, body: any): ng.IPromise<OperationMessage> {
        let url_ = this.baseUrl + "/rest/atlassian-connect/1/addons/{addonKey}/properties/{propertyKey}";
        if (addonKey === undefined || addonKey === null)
            throw new Error("The parameter 'addonKey' must be defined.");
        url_ = url_.replace("{addonKey}", encodeURIComponent("" + addonKey));
        if (propertyKey === undefined || propertyKey === null)
            throw new Error("The parameter 'propertyKey' must be defined.");
        url_ = url_.replace("{propertyKey}", encodeURIComponent("" + propertyKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processPut(_response);
        }, (_response) => {
            if (_response.status)
                return this.processPut(_response);
            throw _response;
        });
    }

    protected processPut(response: any): ng.IPromise<OperationMessage> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationMessage.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = OperationMessage.fromJS(resultData201);
            return this.q.resolve(result201);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = OperationMessage.fromJS(resultData400);
            return throwException(this.q, "Returned if:\n  * the property key is longer than 127 characters.\n  * the value is not valid JSON.\n  * the value is longer than 32768 characters.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = OperationMessage.fromJS(resultData401);
            return throwException(this.q, "Returned if the authentication credentials are incorrect or missing.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<OperationMessage>(null as any);
    }
}

export class DynamicModulesResource.removeModulesClient {
    private baseUrl: string | undefined = undefined;
    private http: ng.IHttpService;
    private q: ng.IQService;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor($http: ng.IHttpService, $q: ng.IQService, baseUrl?: string) {
        this.http = $http;
        this.q = $q;
        this.baseUrl = baseUrl ?? "https://your-domain.atlassian.net";
    }

    /**
     * Remove modules
     * @param moduleKey (optional) The key of the module to remove. To include multiple module keys, provide multiple copies of this parameter.
    For example, `moduleKey=dynamic-attachment-entity-property&moduleKey=dynamic-select-field`.
    Nonexistent keys are ignored.
     * @return Returned if the request is successful.
     */
    delete(moduleKey?: string[] | undefined): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/atlassian-connect/1/app/module/dynamic?";
        if (moduleKey === null)
            throw new Error("The parameter 'moduleKey' cannot be null.");
        else if (moduleKey !== undefined)
            moduleKey && moduleKey.forEach(item => { url_ += "moduleKey=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "DELETE",
            transformResponse: [],
            headers: {
            }
        };

        return this.http(options_).then((_response) => {
            return this.processDelete(_response);
        }, (_response) => {
            if (_response.status)
                return this.processDelete(_response);
            throw _response;
        });
    }

    protected processDelete(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 204) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorMessage.fromJS(resultData401);
            return throwException(this.q, "Returned if the call is not from a Connect app.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }
}

export class DynamicModulesResource.getModulesClient {
    private baseUrl: string | undefined = undefined;
    private http: ng.IHttpService;
    private q: ng.IQService;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor($http: ng.IHttpService, $q: ng.IQService, baseUrl?: string) {
        this.http = $http;
        this.q = $q;
        this.baseUrl = baseUrl ?? "https://your-domain.atlassian.net";
    }

    /**
     * Get modules
     * @return Returned if the request is successful.
     */
    get(): ng.IPromise<ConnectModules> {
        let url_ = this.baseUrl + "/rest/atlassian-connect/1/app/module/dynamic";
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGet(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGet(_response);
            throw _response;
        });
    }

    protected processGet(response: any): ng.IPromise<ConnectModules> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConnectModules.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorMessage.fromJS(resultData401);
            return throwException(this.q, "Returned if the call is not from a Connect app.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ConnectModules>(null as any);
    }
}

export class DynamicModulesResource.registerModulesClient {
    private baseUrl: string | undefined = undefined;
    private http: ng.IHttpService;
    private q: ng.IQService;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor($http: ng.IHttpService, $q: ng.IQService, baseUrl?: string) {
        this.http = $http;
        this.q = $q;
        this.baseUrl = baseUrl ?? "https://your-domain.atlassian.net";
    }

    /**
     * Register modules
     * @return Returned if the request is successful.
     */
    post(body: ConnectModules): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/atlassian-connect/1/app/module/dynamic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http(options_).then((_response) => {
            return this.processPost(_response);
        }, (_response) => {
            if (_response.status)
                return this.processPost(_response);
            throw _response;
        });
    }

    protected processPost(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorMessage.fromJS(resultData400);
            return throwException(this.q, "Returned if:\n* any of the provided modules is invalid. For example, required properties are missing.\n* any of the modules conflict with registered dynamic modules or modules defined in the app descriptor. For example, there are duplicate keys.\n\nDetails of the issues encountered are included in the error message.", status, _responseText, _headers, result400);

        } else if (status === 401) {
            const _responseText = response.data;
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorMessage.fromJS(resultData401);
            return throwException(this.q, "Returned if the call is not from a Connect app.", status, _responseText, _headers, result401);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }
}

export class AppIssueFieldValueUpdateResource.updateIssueFieldsClient {
    private baseUrl: string | undefined = undefined;
    private http: ng.IHttpService;
    private q: ng.IQService;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor($http: ng.IHttpService, $q: ng.IQService, baseUrl?: string) {
        this.http = $http;
        this.q = $q;
        this.baseUrl = baseUrl ?? "https://your-domain.atlassian.net";
    }

    /**
     * Bulk update custom field value
     * @param atlassian_Transfer_Id The ID of the transfer.
     * @return Returned if the request is successful.
     */
    put(atlassian_Transfer_Id: string, body: ConnectCustomFieldValues): ng.IPromise<any> {
        let url_ = this.baseUrl + "/rest/atlassian-connect/1/migration/field";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Atlassian-Transfer-Id": atlassian_Transfer_Id !== undefined && atlassian_Transfer_Id !== null ? "" + atlassian_Transfer_Id : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processPut(_response);
        }, (_response) => {
            if (_response.status)
                return this.processPut(_response);
            throw _response;
        });
    }

    protected processPut(response: any): ng.IPromise<any> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if:\n* the transfer ID is not found.\n* the authorisation credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<any>(null as any);
    }
}

export class MigrationResource.updateEntityPropertiesValueClient {
    private baseUrl: string | undefined = undefined;
    private http: ng.IHttpService;
    private q: ng.IQService;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor($http: ng.IHttpService, $q: ng.IQService, baseUrl?: string) {
        this.http = $http;
        this.q = $q;
        this.baseUrl = baseUrl ?? "https://your-domain.atlassian.net";
    }

    /**
     * Bulk update entity properties
     * @param atlassian_Transfer_Id The app migration transfer ID.
     * @param entityType The type indicating the object that contains the entity properties.
     * @return Returned if the request is successful.
     */
    put(atlassian_Transfer_Id: string, entityType: EntityType, body: EntityPropertyDetails[]): ng.IPromise<void> {
        let url_ = this.baseUrl + "/rest/atlassian-connect/1/migration/properties/{entityType}";
        if (entityType === undefined || entityType === null)
            throw new Error("The parameter 'entityType' must be defined.");
        url_ = url_.replace("{entityType}", encodeURIComponent("" + entityType));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "PUT",
            data: content_,
            transformResponse: [],
            headers: {
                "Atlassian-Transfer-Id": atlassian_Transfer_Id !== undefined && atlassian_Transfer_Id !== null ? "" + atlassian_Transfer_Id : "",
                "Content-Type": "application/json",
            }
        };

        return this.http(options_).then((_response) => {
            return this.processPut(_response);
        }, (_response) => {
            if (_response.status)
                return this.processPut(_response);
            throw _response;
        });
    }

    protected processPut(response: any): ng.IPromise<void> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            return this.q.resolve<void>(null as any);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authorisation credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<void>(null as any);
    }
}

export class MigrationResource.workflowRuleSearchClient {
    private baseUrl: string | undefined = undefined;
    private http: ng.IHttpService;
    private q: ng.IQService;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor($http: ng.IHttpService, $q: ng.IQService, baseUrl?: string) {
        this.http = $http;
        this.q = $q;
        this.baseUrl = baseUrl ?? "https://your-domain.atlassian.net";
    }

    /**
     * Get workflow transition rule configurations
     * @param atlassian_Transfer_Id The app migration transfer ID.
     * @return Returned if the request is successful.
     */
    post(atlassian_Transfer_Id: string, body: WorkflowRulesSearch): ng.IPromise<WorkflowRulesSearchDetails> {
        let url_ = this.baseUrl + "/rest/atlassian-connect/1/migration/workflow/rule/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "POST",
            data: content_,
            transformResponse: [],
            headers: {
                "Atlassian-Transfer-Id": atlassian_Transfer_Id !== undefined && atlassian_Transfer_Id !== null ? "" + atlassian_Transfer_Id : "",
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processPost(_response);
        }, (_response) => {
            if (_response.status)
                return this.processPost(_response);
            throw _response;
        });
    }

    protected processPost(response: any): ng.IPromise<WorkflowRulesSearchDetails> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkflowRulesSearchDetails.fromJS(resultData200);
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is not valid.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the authorisation credentials are incorrect or missing.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<WorkflowRulesSearchDetails>(null as any);
    }
}

export class ServiceRegistryResource.servicesClient {
    private baseUrl: string | undefined = undefined;
    private http: ng.IHttpService;
    private q: ng.IQService;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor($http: ng.IHttpService, $q: ng.IQService, baseUrl?: string) {
        this.http = $http;
        this.q = $q;
        this.baseUrl = baseUrl ?? "https://your-domain.atlassian.net";
    }

    /**
     * Retrieve the attributes of service registries
     * @param serviceIds The ID of the services (the strings starting with "b:" need to be decoded in Base64).
     * @return Returned if the request is successful.
     */
    get(serviceIds: string[]): ng.IPromise<ServiceRegistry[]> {
        let url_ = this.baseUrl + "/rest/atlassian-connect/1/service-registry?";
        if (serviceIds === undefined || serviceIds === null)
            throw new Error("The parameter 'serviceIds' must be defined and cannot be null.");
        else
            serviceIds && serviceIds.forEach(item => { url_ += "serviceIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        var options_: ng.IRequestConfig = {
            url: url_,
            method: "GET",
            transformResponse: [],
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http(options_).then((_response) => {
            return this.processGet(_response);
        }, (_response) => {
            if (_response.status)
                return this.processGet(_response);
            throw _response;
        });
    }

    protected processGet(response: any): ng.IPromise<ServiceRegistry[]> {
        const status = response.status;

        let _headers: any = {};
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServiceRegistry.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return this.q.resolve(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            return throwException(this.q, "Returned if the request is invalid.", status, _responseText, _headers);

        } else if (status === 401) {
            const _responseText = response.data;
            return throwException(this.q, "The request needs to be authenticated.", status, _responseText, _headers);

        } else if (status === 403) {
            const _responseText = response.data;
            return throwException(this.q, "The request isn\'t authorized.", status, _responseText, _headers);

        } else if (status === 500) {
            const _responseText = response.data;
            return throwException(this.q, "The endpoint failed internally.", status, _responseText, _headers);

        } else if (status === 501) {
            const _responseText = response.data;
            return throwException(this.q, "The endpoint isn\'t ready for receiving requests.", status, _responseText, _headers);

        } else if (status === 504) {
            const _responseText = response.data;
            return throwException(this.q, "The upstream service is busy.", status, _responseText, _headers);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException(this.q, "An unexpected server error occurred.", status, _responseText, _headers);
        }
        return this.q.resolve<ServiceRegistry[]>(null as any);
    }
}

export class ActorInputBean implements IActorInputBean {
    /** The name of the group to add as a default actor. This parameter cannot be used with the `groupId` parameter. As a group's name can change,use of `groupId` is recommended. This parameter accepts a comma-separated list. For example, `"group":["project-admin", "jira-developers"]`. */
    group?: string[];
    /** The ID of the group to add as a default actor. This parameter cannot be used with the `group` parameter This parameter accepts a comma-separated list. For example, `"groupId":["77f6ab39-e755-4570-a6ae-2d7a8df0bcb8", "0c011f85-69ed-49c4-a801-3b18d0f771bc"]`. */
    groupId?: string[];
    /** The account IDs of the users to add as default actors. This parameter accepts a comma-separated list. For example, `"user":["5b10a2844c20165700ede21g", "5b109f2e9729b51b54dc274d"]`. */
    user?: string[];

    constructor(data?: IActorInputBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["group"])) {
                this.group = [] as any;
                for (let item of _data["group"])
                    this.group!.push(item);
            }
            if (Array.isArray(_data["groupId"])) {
                this.groupId = [] as any;
                for (let item of _data["groupId"])
                    this.groupId!.push(item);
            }
            if (Array.isArray(_data["user"])) {
                this.user = [] as any;
                for (let item of _data["user"])
                    this.user!.push(item);
            }
        }
    }

    static fromJS(data: any): ActorInputBean {
        data = typeof data === 'object' ? data : {};
        let result = new ActorInputBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.group)) {
            data["group"] = [];
            for (let item of this.group)
                data["group"].push(item);
        }
        if (Array.isArray(this.groupId)) {
            data["groupId"] = [];
            for (let item of this.groupId)
                data["groupId"].push(item);
        }
        if (Array.isArray(this.user)) {
            data["user"] = [];
            for (let item of this.user)
                data["user"].push(item);
        }
        return data;
    }
}

export interface IActorInputBean {
    /** The name of the group to add as a default actor. This parameter cannot be used with the `groupId` parameter. As a group's name can change,use of `groupId` is recommended. This parameter accepts a comma-separated list. For example, `"group":["project-admin", "jira-developers"]`. */
    group?: string[];
    /** The ID of the group to add as a default actor. This parameter cannot be used with the `group` parameter This parameter accepts a comma-separated list. For example, `"groupId":["77f6ab39-e755-4570-a6ae-2d7a8df0bcb8", "0c011f85-69ed-49c4-a801-3b18d0f771bc"]`. */
    groupId?: string[];
    /** The account IDs of the users to add as default actors. This parameter accepts a comma-separated list. For example, `"user":["5b10a2844c20165700ede21g", "5b109f2e9729b51b54dc274d"]`. */
    user?: string[];
}

export class ActorsMap implements IActorsMap {
    /** The name of the group to add. This parameter cannot be used with the `groupId` parameter. As a group's name can change, use of `groupId` is recommended. */
    group?: string[];
    /** The ID of the group to add. This parameter cannot be used with the `group` parameter. */
    groupId?: string[];
    /** The user account ID of the user to add. */
    user?: string[];

    constructor(data?: IActorsMap) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["group"])) {
                this.group = [] as any;
                for (let item of _data["group"])
                    this.group!.push(item);
            }
            if (Array.isArray(_data["groupId"])) {
                this.groupId = [] as any;
                for (let item of _data["groupId"])
                    this.groupId!.push(item);
            }
            if (Array.isArray(_data["user"])) {
                this.user = [] as any;
                for (let item of _data["user"])
                    this.user!.push(item);
            }
        }
    }

    static fromJS(data: any): ActorsMap {
        data = typeof data === 'object' ? data : {};
        let result = new ActorsMap();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.group)) {
            data["group"] = [];
            for (let item of this.group)
                data["group"].push(item);
        }
        if (Array.isArray(this.groupId)) {
            data["groupId"] = [];
            for (let item of this.groupId)
                data["groupId"].push(item);
        }
        if (Array.isArray(this.user)) {
            data["user"] = [];
            for (let item of this.user)
                data["user"].push(item);
        }
        return data;
    }
}

export interface IActorsMap {
    /** The name of the group to add. This parameter cannot be used with the `groupId` parameter. As a group's name can change, use of `groupId` is recommended. */
    group?: string[];
    /** The ID of the group to add. This parameter cannot be used with the `group` parameter. */
    groupId?: string[];
    /** The user account ID of the user to add. */
    user?: string[];
}

export class AddAtlassianTeamRequest implements IAddAtlassianTeamRequest {
    /** The capacity for the Atlassian team. */
    capacity?: number;
    /** The Atlassian team ID. */
    id!: string;
    /** The ID of the issue source for the Atlassian team. */
    issueSourceId?: number;
    /** The planning style for the Atlassian team. This must be "Scrum" or "Kanban". */
    planningStyle!: AddAtlassianTeamRequestPlanningStyle;
    /** The sprint length for the Atlassian team. */
    sprintLength?: number;

    constructor(data?: IAddAtlassianTeamRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.capacity = _data["capacity"];
            this.id = _data["id"];
            this.issueSourceId = _data["issueSourceId"];
            this.planningStyle = _data["planningStyle"];
            this.sprintLength = _data["sprintLength"];
        }
    }

    static fromJS(data: any): AddAtlassianTeamRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddAtlassianTeamRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["capacity"] = this.capacity;
        data["id"] = this.id;
        data["issueSourceId"] = this.issueSourceId;
        data["planningStyle"] = this.planningStyle;
        data["sprintLength"] = this.sprintLength;
        return data;
    }
}

export interface IAddAtlassianTeamRequest {
    /** The capacity for the Atlassian team. */
    capacity?: number;
    /** The Atlassian team ID. */
    id: string;
    /** The ID of the issue source for the Atlassian team. */
    issueSourceId?: number;
    /** The planning style for the Atlassian team. This must be "Scrum" or "Kanban". */
    planningStyle: AddAtlassianTeamRequestPlanningStyle;
    /** The sprint length for the Atlassian team. */
    sprintLength?: number;
}

export class AddFieldBean implements IAddFieldBean {
    /** The ID of the field to add. */
    fieldId!: string;

    constructor(data?: IAddFieldBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
        }
    }

    static fromJS(data: any): AddFieldBean {
        data = typeof data === 'object' ? data : {};
        let result = new AddFieldBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        return data;
    }
}

export interface IAddFieldBean {
    /** The ID of the field to add. */
    fieldId: string;
}

export class AddGroupBean implements IAddGroupBean {
    /** The name of the group. */
    name!: string;

    [key: string]: any;

    constructor(data?: IAddGroupBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): AddGroupBean {
        data = typeof data === 'object' ? data : {};
        let result = new AddGroupBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        return data;
    }
}

export interface IAddGroupBean {
    /** The name of the group. */
    name: string;

    [key: string]: any;
}

/** Details of notifications which should be added to the notification scheme. */
export class AddNotificationsDetails implements IAddNotificationsDetails {
    /** The list of notifications which should be added to the notification scheme. */
    notificationSchemeEvents!: NotificationSchemeEventDetails[];

    [key: string]: any;

    constructor(data?: IAddNotificationsDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.notificationSchemeEvents = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["notificationSchemeEvents"])) {
                this.notificationSchemeEvents = [] as any;
                for (let item of _data["notificationSchemeEvents"])
                    this.notificationSchemeEvents!.push(NotificationSchemeEventDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddNotificationsDetails {
        data = typeof data === 'object' ? data : {};
        let result = new AddNotificationsDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.notificationSchemeEvents)) {
            data["notificationSchemeEvents"] = [];
            for (let item of this.notificationSchemeEvents)
                data["notificationSchemeEvents"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of notifications which should be added to the notification scheme. */
export interface IAddNotificationsDetails {
    /** The list of notifications which should be added to the notification scheme. */
    notificationSchemeEvents: NotificationSchemeEventDetails[];

    [key: string]: any;
}

export class AddSecuritySchemeLevelsRequestBean implements IAddSecuritySchemeLevelsRequestBean {
    /** The list of scheme levels which should be added to the security scheme. */
    levels?: SecuritySchemeLevelBean[];

    constructor(data?: IAddSecuritySchemeLevelsRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["levels"])) {
                this.levels = [] as any;
                for (let item of _data["levels"])
                    this.levels!.push(SecuritySchemeLevelBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AddSecuritySchemeLevelsRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new AddSecuritySchemeLevelsRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.levels)) {
            data["levels"] = [];
            for (let item of this.levels)
                data["levels"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAddSecuritySchemeLevelsRequestBean {
    /** The list of scheme levels which should be added to the security scheme. */
    levels?: SecuritySchemeLevelBean[];
}

/** Announcement banner configuration. */
export class AnnouncementBannerConfiguration implements IAnnouncementBannerConfiguration {
    /** Hash of the banner data. The client detects updates by comparing hash IDs. */
    readonly hashId?: string;
    /** Flag indicating if the announcement banner can be dismissed by the user. */
    readonly isDismissible?: boolean;
    /** Flag indicating if the announcement banner is enabled or not. */
    readonly isEnabled?: boolean;
    /** The text on the announcement banner. */
    readonly message?: string;
    /** Visibility of the announcement banner. */
    readonly visibility?: AnnouncementBannerConfigurationVisibility;

    constructor(data?: IAnnouncementBannerConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).hashId = _data["hashId"];
            (<any>this).isDismissible = _data["isDismissible"];
            (<any>this).isEnabled = _data["isEnabled"];
            (<any>this).message = _data["message"];
            (<any>this).visibility = _data["visibility"];
        }
    }

    static fromJS(data: any): AnnouncementBannerConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new AnnouncementBannerConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hashId"] = this.hashId;
        data["isDismissible"] = this.isDismissible;
        data["isEnabled"] = this.isEnabled;
        data["message"] = this.message;
        data["visibility"] = this.visibility;
        return data;
    }
}

/** Announcement banner configuration. */
export interface IAnnouncementBannerConfiguration {
    /** Hash of the banner data. The client detects updates by comparing hash IDs. */
    hashId?: string;
    /** Flag indicating if the announcement banner can be dismissed by the user. */
    isDismissible?: boolean;
    /** Flag indicating if the announcement banner is enabled or not. */
    isEnabled?: boolean;
    /** The text on the announcement banner. */
    message?: string;
    /** Visibility of the announcement banner. */
    visibility?: AnnouncementBannerConfigurationVisibility;
}

/** Configuration of the announcement banner. */
export class AnnouncementBannerConfigurationUpdate implements IAnnouncementBannerConfigurationUpdate {
    /** Flag indicating if the announcement banner can be dismissed by the user. */
    isDismissible?: boolean;
    /** Flag indicating if the announcement banner is enabled or not. */
    isEnabled?: boolean;
    /** The text on the announcement banner. */
    message?: string;
    /** Visibility of the announcement banner. Can be public or private. */
    visibility?: string;

    constructor(data?: IAnnouncementBannerConfigurationUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isDismissible = _data["isDismissible"];
            this.isEnabled = _data["isEnabled"];
            this.message = _data["message"];
            this.visibility = _data["visibility"];
        }
    }

    static fromJS(data: any): AnnouncementBannerConfigurationUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new AnnouncementBannerConfigurationUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDismissible"] = this.isDismissible;
        data["isEnabled"] = this.isEnabled;
        data["message"] = this.message;
        data["visibility"] = this.visibility;
        return data;
    }
}

/** Configuration of the announcement banner. */
export interface IAnnouncementBannerConfigurationUpdate {
    /** Flag indicating if the announcement banner can be dismissed by the user. */
    isDismissible?: boolean;
    /** Flag indicating if the announcement banner is enabled or not. */
    isEnabled?: boolean;
    /** The text on the announcement banner. */
    message?: string;
    /** Visibility of the announcement banner. Can be public or private. */
    visibility?: string;
}

/** A workflow transition rule. */
export class AppWorkflowTransitionRule implements IAppWorkflowTransitionRule {
    configuration!: RuleConfiguration;
    /** The ID of the transition rule. */
    id!: string;
    /** The key of the rule, as defined in the Connect or the Forge app descriptor. */
    readonly key!: string;
    readonly transition?: WorkflowTransition;

    constructor(data?: IAppWorkflowTransitionRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.configuration = new RuleConfiguration();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.configuration = _data["configuration"] ? RuleConfiguration.fromJS(_data["configuration"]) : new RuleConfiguration();
            this.id = _data["id"];
            (<any>this).key = _data["key"];
            (<any>this).transition = _data["transition"] ? WorkflowTransition.fromJS(_data["transition"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AppWorkflowTransitionRule {
        data = typeof data === 'object' ? data : {};
        let result = new AppWorkflowTransitionRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["configuration"] = this.configuration ? this.configuration.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["key"] = this.key;
        data["transition"] = this.transition ? this.transition.toJSON() : <any>undefined;
        return data;
    }
}

/** A workflow transition rule. */
export interface IAppWorkflowTransitionRule {
    configuration: RuleConfiguration;
    /** The ID of the transition rule. */
    id: string;
    /** The key of the rule, as defined in the Connect or the Forge app descriptor. */
    key: string;
    transition?: WorkflowTransition;
}

/** The application the linked item is in. */
export class Application implements IApplication {
    /** The name of the application. Used in conjunction with the (remote) object icon title to display a tooltip for the link's icon. The tooltip takes the format "\[application name\] icon title". Blank items are excluded from the tooltip title. If both items are blank, the icon tooltop displays as "Web Link". Grouping and sorting of links may place links without an application name last. */
    name?: string;
    /** The name-spaced type of the application, used by registered rendering apps. */
    type?: string;

    [key: string]: any;

    constructor(data?: IApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Application {
        data = typeof data === 'object' ? data : {};
        let result = new Application();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

/** The application the linked item is in. */
export interface IApplication {
    /** The name of the application. Used in conjunction with the (remote) object icon title to display a tooltip for the link's icon. The tooltip takes the format "\[application name\] icon title". Blank items are excluded from the tooltip title. If both items are blank, the icon tooltop displays as "Web Link". Grouping and sorting of links may place links without an application name last. */
    name?: string;
    /** The name-spaced type of the application, used by registered rendering apps. */
    type?: string;

    [key: string]: any;
}

/** Details of an application property. */
export class ApplicationProperty implements IApplicationProperty {
    /** The allowed values, if applicable. */
    allowedValues?: string[];
    /** The default value of the application property. */
    defaultValue?: string;
    /** The description of the application property. */
    desc?: string;
    example?: string;
    /** The ID of the application property. The ID and key are the same. */
    id?: string;
    /** The key of the application property. The ID and key are the same. */
    key?: string;
    /** The name of the application property. */
    name?: string;
    /** The data type of the application property. */
    type?: string;
    /** The new value. */
    value?: string;

    constructor(data?: IApplicationProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["allowedValues"])) {
                this.allowedValues = [] as any;
                for (let item of _data["allowedValues"])
                    this.allowedValues!.push(item);
            }
            this.defaultValue = _data["defaultValue"];
            this.desc = _data["desc"];
            this.example = _data["example"];
            this.id = _data["id"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ApplicationProperty {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allowedValues)) {
            data["allowedValues"] = [];
            for (let item of this.allowedValues)
                data["allowedValues"].push(item);
        }
        data["defaultValue"] = this.defaultValue;
        data["desc"] = this.desc;
        data["example"] = this.example;
        data["id"] = this.id;
        data["key"] = this.key;
        data["name"] = this.name;
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

/** Details of an application property. */
export interface IApplicationProperty {
    /** The allowed values, if applicable. */
    allowedValues?: string[];
    /** The default value of the application property. */
    defaultValue?: string;
    /** The description of the application property. */
    desc?: string;
    example?: string;
    /** The ID of the application property. The ID and key are the same. */
    id?: string;
    /** The key of the application property. The ID and key are the same. */
    key?: string;
    /** The name of the application property. */
    name?: string;
    /** The data type of the application property. */
    type?: string;
    /** The new value. */
    value?: string;
}

/** Details of an application role. */
export class ApplicationRole implements IApplicationRole {
    /** The groups that are granted default access for this application role. As a group's name can change, use of `defaultGroupsDetails` is recommended to identify a groups. */
    defaultGroups?: string[];
    /** The groups that are granted default access for this application role. */
    defaultGroupsDetails?: GroupName[];
    /** Deprecated. */
    defined?: boolean;
    /** The groups associated with the application role. */
    groupDetails?: GroupName[];
    /** The groups associated with the application role. As a group's name can change, use of `groupDetails` is recommended to identify a groups. */
    groups?: string[];
    hasUnlimitedSeats?: boolean;
    /** The key of the application role. */
    key?: string;
    /** The display name of the application role. */
    name?: string;
    /** The maximum count of users on your license. */
    numberOfSeats?: number;
    /** Indicates if the application role belongs to Jira platform (`jira-core`). */
    platform?: boolean;
    /** The count of users remaining on your license. */
    remainingSeats?: number;
    /** Determines whether this application role should be selected by default on user creation. */
    selectedByDefault?: boolean;
    /** The number of users counting against your license. */
    userCount?: number;
    /** The [type of users](https://confluence.atlassian.com/x/lRW3Ng) being counted against your license. */
    userCountDescription?: string;

    constructor(data?: IApplicationRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["defaultGroups"])) {
                this.defaultGroups = [] as any;
                for (let item of _data["defaultGroups"])
                    this.defaultGroups!.push(item);
            }
            if (Array.isArray(_data["defaultGroupsDetails"])) {
                this.defaultGroupsDetails = [] as any;
                for (let item of _data["defaultGroupsDetails"])
                    this.defaultGroupsDetails!.push(GroupName.fromJS(item));
            }
            this.defined = _data["defined"];
            if (Array.isArray(_data["groupDetails"])) {
                this.groupDetails = [] as any;
                for (let item of _data["groupDetails"])
                    this.groupDetails!.push(GroupName.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            this.hasUnlimitedSeats = _data["hasUnlimitedSeats"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.numberOfSeats = _data["numberOfSeats"];
            this.platform = _data["platform"];
            this.remainingSeats = _data["remainingSeats"];
            this.selectedByDefault = _data["selectedByDefault"];
            this.userCount = _data["userCount"];
            this.userCountDescription = _data["userCountDescription"];
        }
    }

    static fromJS(data: any): ApplicationRole {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.defaultGroups)) {
            data["defaultGroups"] = [];
            for (let item of this.defaultGroups)
                data["defaultGroups"].push(item);
        }
        if (Array.isArray(this.defaultGroupsDetails)) {
            data["defaultGroupsDetails"] = [];
            for (let item of this.defaultGroupsDetails)
                data["defaultGroupsDetails"].push(item.toJSON());
        }
        data["defined"] = this.defined;
        if (Array.isArray(this.groupDetails)) {
            data["groupDetails"] = [];
            for (let item of this.groupDetails)
                data["groupDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        data["hasUnlimitedSeats"] = this.hasUnlimitedSeats;
        data["key"] = this.key;
        data["name"] = this.name;
        data["numberOfSeats"] = this.numberOfSeats;
        data["platform"] = this.platform;
        data["remainingSeats"] = this.remainingSeats;
        data["selectedByDefault"] = this.selectedByDefault;
        data["userCount"] = this.userCount;
        data["userCountDescription"] = this.userCountDescription;
        return data;
    }
}

/** Details of an application role. */
export interface IApplicationRole {
    /** The groups that are granted default access for this application role. As a group's name can change, use of `defaultGroupsDetails` is recommended to identify a groups. */
    defaultGroups?: string[];
    /** The groups that are granted default access for this application role. */
    defaultGroupsDetails?: GroupName[];
    /** Deprecated. */
    defined?: boolean;
    /** The groups associated with the application role. */
    groupDetails?: GroupName[];
    /** The groups associated with the application role. As a group's name can change, use of `groupDetails` is recommended to identify a groups. */
    groups?: string[];
    hasUnlimitedSeats?: boolean;
    /** The key of the application role. */
    key?: string;
    /** The display name of the application role. */
    name?: string;
    /** The maximum count of users on your license. */
    numberOfSeats?: number;
    /** Indicates if the application role belongs to Jira platform (`jira-core`). */
    platform?: boolean;
    /** The count of users remaining on your license. */
    remainingSeats?: number;
    /** Determines whether this application role should be selected by default on user creation. */
    selectedByDefault?: boolean;
    /** The number of users counting against your license. */
    userCount?: number;
    /** The [type of users](https://confluence.atlassian.com/x/lRW3Ng) being counted against your license. */
    userCountDescription?: string;
}

/** The approval configuration of a status within a workflow. Applies only to Jira Service Management approvals. */
export class ApprovalConfiguration implements IApprovalConfiguration {
    /** Whether the approval configuration is active. */
    active!: ApprovalConfigurationActive;
    /** How the required approval count is calculated. It may be configured to require a specific number of approvals, or approval by a percentage of approvers. If the approvers source field is Approver groups, you can configure how many approvals per group are required for the request to be approved. The number will be the same across all groups. */
    conditionType!: ApprovalConfigurationConditionType;
    /** The number or percentage of approvals required for a request to be approved. If `conditionType` is `number`, the value must be 20 or less. If `conditionType` is `percent`, the value must be 100 or less. */
    conditionValue!: string;
    /** A list of roles that should be excluded as possible approvers. */
    exclude?: ApprovalConfigurationExclude | undefined;
    /** The custom field ID of the "Approvers" or "Approver Groups" field. */
    fieldId!: string;
    /** The custom field ID of the field used to pre-populate the Approver field. Only supports the "Affected Services" field. */
    prePopulatedFieldId?: string | undefined;
    /** The numeric ID of the transition to be executed if the request is approved. */
    transitionApproved!: string;
    /** The numeric ID of the transition to be executed if the request is declined. */
    transitionRejected!: string;

    constructor(data?: IApprovalConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.active = _data["active"];
            this.conditionType = _data["conditionType"];
            this.conditionValue = _data["conditionValue"];
            if (Array.isArray(_data["exclude"])) {
                this.exclude = [] as any;
                for (let item of _data["exclude"])
                    this.exclude!.push(item);
            }
            this.fieldId = _data["fieldId"];
            this.prePopulatedFieldId = _data["prePopulatedFieldId"];
            this.transitionApproved = _data["transitionApproved"];
            this.transitionRejected = _data["transitionRejected"];
        }
    }

    static fromJS(data: any): ApprovalConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new ApprovalConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["conditionType"] = this.conditionType;
        data["conditionValue"] = this.conditionValue;
        if (Array.isArray(this.exclude)) {
            data["exclude"] = [];
            for (let item of this.exclude)
                data["exclude"].push(item);
        }
        data["fieldId"] = this.fieldId;
        data["prePopulatedFieldId"] = this.prePopulatedFieldId;
        data["transitionApproved"] = this.transitionApproved;
        data["transitionRejected"] = this.transitionRejected;
        return data;
    }
}

/** The approval configuration of a status within a workflow. Applies only to Jira Service Management approvals. */
export interface IApprovalConfiguration {
    /** Whether the approval configuration is active. */
    active: ApprovalConfigurationActive;
    /** How the required approval count is calculated. It may be configured to require a specific number of approvals, or approval by a percentage of approvers. If the approvers source field is Approver groups, you can configure how many approvals per group are required for the request to be approved. The number will be the same across all groups. */
    conditionType: ApprovalConfigurationConditionType;
    /** The number or percentage of approvals required for a request to be approved. If `conditionType` is `number`, the value must be 20 or less. If `conditionType` is `percent`, the value must be 100 or less. */
    conditionValue: string;
    /** A list of roles that should be excluded as possible approvers. */
    exclude?: ApprovalConfigurationExclude | undefined;
    /** The custom field ID of the "Approvers" or "Approver Groups" field. */
    fieldId: string;
    /** The custom field ID of the field used to pre-populate the Approver field. Only supports the "Affected Services" field. */
    prePopulatedFieldId?: string | undefined;
    /** The numeric ID of the transition to be executed if the request is approved. */
    transitionApproved: string;
    /** The numeric ID of the transition to be executed if the request is declined. */
    transitionRejected: string;
}

export class ArchiveIssueAsyncRequest implements IArchiveIssueAsyncRequest {
    jql?: string;

    constructor(data?: IArchiveIssueAsyncRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jql = _data["jql"];
        }
    }

    static fromJS(data: any): ArchiveIssueAsyncRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ArchiveIssueAsyncRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jql"] = this.jql;
        return data;
    }
}

export interface IArchiveIssueAsyncRequest {
    jql?: string;
}

/** Details of a filter for exporting archived issues. */
export class ArchivedIssuesFilterRequest implements IArchivedIssuesFilterRequest {
    /** List archived issues archived by a specified account ID. */
    archivedBy?: string[];
    archivedDateRange?: DateRangeFilterRequest;
    /** List archived issues with a specified issue type ID. */
    issueTypes?: string[];
    /** List archived issues with a specified project key. */
    projects?: string[];
    /** List archived issues where the reporter is a specified account ID. */
    reporters?: string[];

    [key: string]: any;

    constructor(data?: IArchivedIssuesFilterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["archivedBy"])) {
                this.archivedBy = [] as any;
                for (let item of _data["archivedBy"])
                    this.archivedBy!.push(item);
            }
            this.archivedDateRange = _data["archivedDateRange"] ? DateRangeFilterRequest.fromJS(_data["archivedDateRange"]) : <any>undefined;
            if (Array.isArray(_data["issueTypes"])) {
                this.issueTypes = [] as any;
                for (let item of _data["issueTypes"])
                    this.issueTypes!.push(item);
            }
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects!.push(item);
            }
            if (Array.isArray(_data["reporters"])) {
                this.reporters = [] as any;
                for (let item of _data["reporters"])
                    this.reporters!.push(item);
            }
        }
    }

    static fromJS(data: any): ArchivedIssuesFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ArchivedIssuesFilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.archivedBy)) {
            data["archivedBy"] = [];
            for (let item of this.archivedBy)
                data["archivedBy"].push(item);
        }
        data["archivedDateRange"] = this.archivedDateRange ? this.archivedDateRange.toJSON() : <any>undefined;
        if (Array.isArray(this.issueTypes)) {
            data["issueTypes"] = [];
            for (let item of this.issueTypes)
                data["issueTypes"].push(item);
        }
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item);
        }
        if (Array.isArray(this.reporters)) {
            data["reporters"] = [];
            for (let item of this.reporters)
                data["reporters"].push(item);
        }
        return data;
    }
}

/** Details of a filter for exporting archived issues. */
export interface IArchivedIssuesFilterRequest {
    /** List archived issues archived by a specified account ID. */
    archivedBy?: string[];
    archivedDateRange?: DateRangeFilterRequest;
    /** List archived issues with a specified issue type ID. */
    issueTypes?: string[];
    /** List archived issues with a specified project key. */
    projects?: string[];
    /** List archived issues where the reporter is a specified account ID. */
    reporters?: string[];

    [key: string]: any;
}

/** Details of a field configuration to issue type mappings. */
export class AssociateFieldConfigurationsWithIssueTypesRequest implements IAssociateFieldConfigurationsWithIssueTypesRequest {
    /** Field configuration to issue type mappings. */
    mappings!: FieldConfigurationToIssueTypeMapping[];

    constructor(data?: IAssociateFieldConfigurationsWithIssueTypesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.mappings = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["mappings"])) {
                this.mappings = [] as any;
                for (let item of _data["mappings"])
                    this.mappings!.push(FieldConfigurationToIssueTypeMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssociateFieldConfigurationsWithIssueTypesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AssociateFieldConfigurationsWithIssueTypesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.mappings)) {
            data["mappings"] = [];
            for (let item of this.mappings)
                data["mappings"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of a field configuration to issue type mappings. */
export interface IAssociateFieldConfigurationsWithIssueTypesRequest {
    /** Field configuration to issue type mappings. */
    mappings: FieldConfigurationToIssueTypeMapping[];
}

/** Issue security scheme, project, and remapping details. */
export class AssociateSecuritySchemeWithProjectDetails implements IAssociateSecuritySchemeWithProjectDetails {
    /** The list of scheme levels which should be remapped to new levels of the issue security scheme. */
    oldToNewSecurityLevelMappings?: OldToNewSecurityLevelMappingsBean[];
    /** The ID of the project. */
    projectId!: string;
    /** The ID of the issue security scheme. Providing null will clear the association with the issue security scheme. */
    schemeId!: string;

    constructor(data?: IAssociateSecuritySchemeWithProjectDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["oldToNewSecurityLevelMappings"])) {
                this.oldToNewSecurityLevelMappings = [] as any;
                for (let item of _data["oldToNewSecurityLevelMappings"])
                    this.oldToNewSecurityLevelMappings!.push(OldToNewSecurityLevelMappingsBean.fromJS(item));
            }
            this.projectId = _data["projectId"];
            this.schemeId = _data["schemeId"];
        }
    }

    static fromJS(data: any): AssociateSecuritySchemeWithProjectDetails {
        data = typeof data === 'object' ? data : {};
        let result = new AssociateSecuritySchemeWithProjectDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.oldToNewSecurityLevelMappings)) {
            data["oldToNewSecurityLevelMappings"] = [];
            for (let item of this.oldToNewSecurityLevelMappings)
                data["oldToNewSecurityLevelMappings"].push(item.toJSON());
        }
        data["projectId"] = this.projectId;
        data["schemeId"] = this.schemeId;
        return data;
    }
}

/** Issue security scheme, project, and remapping details. */
export interface IAssociateSecuritySchemeWithProjectDetails {
    /** The list of scheme levels which should be remapped to new levels of the issue security scheme. */
    oldToNewSecurityLevelMappings?: OldToNewSecurityLevelMappingsBean[];
    /** The ID of the project. */
    projectId: string;
    /** The ID of the issue security scheme. Providing null will clear the association with the issue security scheme. */
    schemeId: string;
}

/** Details of an item associated with the changed record. */
export class AssociatedItemBean implements IAssociatedItemBean {
    /** The ID of the associated record. */
    readonly id?: string;
    /** The name of the associated record. */
    readonly name?: string;
    /** The ID of the associated parent record. */
    readonly parentId?: string;
    /** The name of the associated parent record. */
    readonly parentName?: string;
    /** The type of the associated record. */
    readonly typeName?: string;

    constructor(data?: IAssociatedItemBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            (<any>this).parentId = _data["parentId"];
            (<any>this).parentName = _data["parentName"];
            (<any>this).typeName = _data["typeName"];
        }
    }

    static fromJS(data: any): AssociatedItemBean {
        data = typeof data === 'object' ? data : {};
        let result = new AssociatedItemBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["parentName"] = this.parentName;
        data["typeName"] = this.typeName;
        return data;
    }
}

/** Details of an item associated with the changed record. */
export interface IAssociatedItemBean {
    /** The ID of the associated record. */
    id?: string;
    /** The name of the associated record. */
    name?: string;
    /** The ID of the associated parent record. */
    parentId?: string;
    /** The name of the associated parent record. */
    parentName?: string;
    /** The type of the associated record. */
    typeName?: string;
}

/** Field association for example PROJECT\_ID. */
export class AssociationContextObject implements IAssociationContextObject {
    identifier?: any;

    protected _discriminator: string;

    constructor(data?: IAssociationContextObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "AssociationContextObject";
    }

    init(_data?: any) {
        if (_data) {
            this.identifier = _data["identifier"];
        }
    }

    static fromJS(data: any): AssociationContextObject {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "ProjectIdAssociationContext") {
            let result = new ProjectIdAssociationContext();
            result.init(data);
            return result;
        }
        let result = new AssociationContextObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this._discriminator;
        data["identifier"] = this.identifier;
        return data;
    }
}

/** Field association for example PROJECT\_ID. */
export interface IAssociationContextObject {
    identifier?: any;
}

/** Details about an attachment. */
export class Attachment implements IAttachment {
    /** Details of the user who added the attachment. */
    readonly author?: UserDetails;
    /** The content of the attachment. */
    readonly content?: string;
    /** The datetime the attachment was created. */
    readonly created?: Date;
    /** The file name of the attachment. */
    readonly filename?: string;
    /** The ID of the attachment. */
    readonly id?: string;
    /** The MIME type of the attachment. */
    readonly mimeType?: string;
    /** The URL of the attachment details response. */
    readonly self?: string;
    /** The size of the attachment. */
    readonly size?: number;
    /** The URL of a thumbnail representing the attachment. */
    readonly thumbnail?: string;

    [key: string]: any;

    constructor(data?: IAttachment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).author = _data["author"] ? UserDetails.fromJS(_data["author"]) : <any>undefined;
            (<any>this).content = _data["content"];
            (<any>this).created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            (<any>this).filename = _data["filename"];
            (<any>this).id = _data["id"];
            (<any>this).mimeType = _data["mimeType"];
            (<any>this).self = _data["self"];
            (<any>this).size = _data["size"];
            (<any>this).thumbnail = _data["thumbnail"];
        }
    }

    static fromJS(data: any): Attachment {
        data = typeof data === 'object' ? data : {};
        let result = new Attachment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["content"] = this.content;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["filename"] = this.filename;
        data["id"] = this.id;
        data["mimeType"] = this.mimeType;
        data["self"] = this.self;
        data["size"] = this.size;
        data["thumbnail"] = this.thumbnail;
        return data;
    }
}

/** Details about an attachment. */
export interface IAttachment {
    /** Details of the user who added the attachment. */
    author?: UserDetails;
    /** The content of the attachment. */
    content?: string;
    /** The datetime the attachment was created. */
    created?: Date;
    /** The file name of the attachment. */
    filename?: string;
    /** The ID of the attachment. */
    id?: string;
    /** The MIME type of the attachment. */
    mimeType?: string;
    /** The URL of the attachment details response. */
    self?: string;
    /** The size of the attachment. */
    size?: number;
    /** The URL of a thumbnail representing the attachment. */
    thumbnail?: string;

    [key: string]: any;
}

export class AttachmentArchive implements IAttachmentArchive {
    entries?: AttachmentArchiveEntry[];
    moreAvailable?: boolean;
    totalEntryCount?: number;
    totalNumberOfEntriesAvailable?: number;

    constructor(data?: IAttachmentArchive) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entries"])) {
                this.entries = [] as any;
                for (let item of _data["entries"])
                    this.entries!.push(AttachmentArchiveEntry.fromJS(item));
            }
            this.moreAvailable = _data["moreAvailable"];
            this.totalEntryCount = _data["totalEntryCount"];
            this.totalNumberOfEntriesAvailable = _data["totalNumberOfEntriesAvailable"];
        }
    }

    static fromJS(data: any): AttachmentArchive {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentArchive();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        data["moreAvailable"] = this.moreAvailable;
        data["totalEntryCount"] = this.totalEntryCount;
        data["totalNumberOfEntriesAvailable"] = this.totalNumberOfEntriesAvailable;
        return data;
    }
}

export interface IAttachmentArchive {
    entries?: AttachmentArchiveEntry[];
    moreAvailable?: boolean;
    totalEntryCount?: number;
    totalNumberOfEntriesAvailable?: number;
}

export class AttachmentArchiveEntry implements IAttachmentArchiveEntry {
    abbreviatedName?: string;
    entryIndex?: number;
    mediaType?: string;
    name?: string;
    size?: number;

    constructor(data?: IAttachmentArchiveEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.abbreviatedName = _data["abbreviatedName"];
            this.entryIndex = _data["entryIndex"];
            this.mediaType = _data["mediaType"];
            this.name = _data["name"];
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): AttachmentArchiveEntry {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentArchiveEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["abbreviatedName"] = this.abbreviatedName;
        data["entryIndex"] = this.entryIndex;
        data["mediaType"] = this.mediaType;
        data["name"] = this.name;
        data["size"] = this.size;
        return data;
    }
}

export interface IAttachmentArchiveEntry {
    abbreviatedName?: string;
    entryIndex?: number;
    mediaType?: string;
    name?: string;
    size?: number;
}

export class AttachmentArchiveImpl implements IAttachmentArchiveImpl {
    /** The list of the items included in the archive. */
    entries?: AttachmentArchiveEntry[];
    /** The number of items in the archive. */
    totalEntryCount?: number;

    constructor(data?: IAttachmentArchiveImpl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entries"])) {
                this.entries = [] as any;
                for (let item of _data["entries"])
                    this.entries!.push(AttachmentArchiveEntry.fromJS(item));
            }
            this.totalEntryCount = _data["totalEntryCount"];
        }
    }

    static fromJS(data: any): AttachmentArchiveImpl {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentArchiveImpl();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        data["totalEntryCount"] = this.totalEntryCount;
        return data;
    }
}

export interface IAttachmentArchiveImpl {
    /** The list of the items included in the archive. */
    entries?: AttachmentArchiveEntry[];
    /** The number of items in the archive. */
    totalEntryCount?: number;
}

/** Metadata for an item in an attachment archive. */
export class AttachmentArchiveItemReadable implements IAttachmentArchiveItemReadable {
    /** The position of the item within the archive. */
    readonly index?: number;
    /** The label for the archive item. */
    readonly label?: string;
    /** The MIME type of the archive item. */
    readonly mediaType?: string;
    /** The path of the archive item. */
    readonly path?: string;
    /** The size of the archive item. */
    readonly size?: string;

    constructor(data?: IAttachmentArchiveItemReadable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).index = _data["index"];
            (<any>this).label = _data["label"];
            (<any>this).mediaType = _data["mediaType"];
            (<any>this).path = _data["path"];
            (<any>this).size = _data["size"];
        }
    }

    static fromJS(data: any): AttachmentArchiveItemReadable {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentArchiveItemReadable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["label"] = this.label;
        data["mediaType"] = this.mediaType;
        data["path"] = this.path;
        data["size"] = this.size;
        return data;
    }
}

/** Metadata for an item in an attachment archive. */
export interface IAttachmentArchiveItemReadable {
    /** The position of the item within the archive. */
    index?: number;
    /** The label for the archive item. */
    label?: string;
    /** The MIME type of the archive item. */
    mediaType?: string;
    /** The path of the archive item. */
    path?: string;
    /** The size of the archive item. */
    size?: string;
}

/** Metadata for an archive (for example a zip) and its contents. */
export class AttachmentArchiveMetadataReadable implements IAttachmentArchiveMetadataReadable {
    /** The list of the items included in the archive. */
    readonly entries?: AttachmentArchiveItemReadable[];
    /** The ID of the attachment. */
    readonly id?: number;
    /** The MIME type of the attachment. */
    readonly mediaType?: string;
    /** The name of the archive file. */
    readonly name?: string;
    /** The number of items included in the archive. */
    readonly totalEntryCount?: number;

    constructor(data?: IAttachmentArchiveMetadataReadable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entries"])) {
                (<any>this).entries = [] as any;
                for (let item of _data["entries"])
                    (<any>this).entries!.push(AttachmentArchiveItemReadable.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).mediaType = _data["mediaType"];
            (<any>this).name = _data["name"];
            (<any>this).totalEntryCount = _data["totalEntryCount"];
        }
    }

    static fromJS(data: any): AttachmentArchiveMetadataReadable {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentArchiveMetadataReadable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entries)) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["mediaType"] = this.mediaType;
        data["name"] = this.name;
        data["totalEntryCount"] = this.totalEntryCount;
        return data;
    }
}

/** Metadata for an archive (for example a zip) and its contents. */
export interface IAttachmentArchiveMetadataReadable {
    /** The list of the items included in the archive. */
    entries?: AttachmentArchiveItemReadable[];
    /** The ID of the attachment. */
    id?: number;
    /** The MIME type of the attachment. */
    mediaType?: string;
    /** The name of the archive file. */
    name?: string;
    /** The number of items included in the archive. */
    totalEntryCount?: number;
}

/** Metadata for an issue attachment. */
export class AttachmentMetadata implements IAttachmentMetadata {
    /** Details of the user who attached the file. */
    readonly author?: User;
    /** The URL of the attachment. */
    readonly content?: string;
    /** The datetime the attachment was created. */
    readonly created?: Date;
    /** The name of the attachment file. */
    readonly filename?: string;
    /** The ID of the attachment. */
    readonly id?: number;
    /** The MIME type of the attachment. */
    readonly mimeType?: string;
    /** Additional properties of the attachment. */
    readonly properties?: { [key: string]: any; };
    /** The URL of the attachment metadata details. */
    readonly self?: string;
    /** The size of the attachment. */
    readonly size?: number;
    /** The URL of a thumbnail representing the attachment. */
    readonly thumbnail?: string;

    constructor(data?: IAttachmentMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).author = _data["author"] ? User.fromJS(_data["author"]) : <any>undefined;
            (<any>this).content = _data["content"];
            (<any>this).created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            (<any>this).filename = _data["filename"];
            (<any>this).id = _data["id"];
            (<any>this).mimeType = _data["mimeType"];
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key];
                }
            }
            (<any>this).self = _data["self"];
            (<any>this).size = _data["size"];
            (<any>this).thumbnail = _data["thumbnail"];
        }
    }

    static fromJS(data: any): AttachmentMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["content"] = this.content;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["filename"] = this.filename;
        data["id"] = this.id;
        data["mimeType"] = this.mimeType;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["self"] = this.self;
        data["size"] = this.size;
        data["thumbnail"] = this.thumbnail;
        return data;
    }
}

/** Metadata for an issue attachment. */
export interface IAttachmentMetadata {
    /** Details of the user who attached the file. */
    author?: User;
    /** The URL of the attachment. */
    content?: string;
    /** The datetime the attachment was created. */
    created?: Date;
    /** The name of the attachment file. */
    filename?: string;
    /** The ID of the attachment. */
    id?: number;
    /** The MIME type of the attachment. */
    mimeType?: string;
    /** Additional properties of the attachment. */
    properties?: { [key: string]: any; };
    /** The URL of the attachment metadata details. */
    self?: string;
    /** The size of the attachment. */
    size?: number;
    /** The URL of a thumbnail representing the attachment. */
    thumbnail?: string;
}

/** Details of the instance's attachment settings. */
export class AttachmentSettings implements IAttachmentSettings {
    /** Whether the ability to add attachments is enabled. */
    readonly enabled?: boolean;
    /** The maximum size of attachments permitted, in bytes. */
    readonly uploadLimit?: number;

    constructor(data?: IAttachmentSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).enabled = _data["enabled"];
            (<any>this).uploadLimit = _data["uploadLimit"];
        }
    }

    static fromJS(data: any): AttachmentSettings {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        data["uploadLimit"] = this.uploadLimit;
        return data;
    }
}

/** Details of the instance's attachment settings. */
export interface IAttachmentSettings {
    /** Whether the ability to add attachments is enabled. */
    enabled?: boolean;
    /** The maximum size of attachments permitted, in bytes. */
    uploadLimit?: number;
}

/** An audit record. */
export class AuditRecordBean implements IAuditRecordBean {
    /** The list of items associated with the changed record. */
    readonly associatedItems?: AssociatedItemBean[];
    /** Deprecated, use `authorAccountId` instead. The key of the user who created the audit record. */
    readonly authorKey?: string;
    /** The category of the audit record. For a list of these categories, see the help article [Auditing in Jira applications](https://confluence.atlassian.com/x/noXKM). */
    readonly category?: string;
    /** The list of values changed in the record event. */
    readonly changedValues?: ChangedValueBean[];
    /** The date and time on which the audit record was created. */
    readonly created?: Date;
    /** The description of the audit record. */
    readonly description?: string;
    /** The event the audit record originated from. */
    readonly eventSource?: string;
    /** The ID of the audit record. */
    readonly id?: number;
    objectItem?: AssociatedItemBean;
    /** The URL of the computer where the creation of the audit record was initiated. */
    readonly remoteAddress?: string;
    /** The summary of the audit record. */
    readonly summary?: string;

    constructor(data?: IAuditRecordBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["associatedItems"])) {
                (<any>this).associatedItems = [] as any;
                for (let item of _data["associatedItems"])
                    (<any>this).associatedItems!.push(AssociatedItemBean.fromJS(item));
            }
            (<any>this).authorKey = _data["authorKey"];
            (<any>this).category = _data["category"];
            if (Array.isArray(_data["changedValues"])) {
                (<any>this).changedValues = [] as any;
                for (let item of _data["changedValues"])
                    (<any>this).changedValues!.push(ChangedValueBean.fromJS(item));
            }
            (<any>this).created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            (<any>this).description = _data["description"];
            (<any>this).eventSource = _data["eventSource"];
            (<any>this).id = _data["id"];
            this.objectItem = _data["objectItem"] ? AssociatedItemBean.fromJS(_data["objectItem"]) : <any>undefined;
            (<any>this).remoteAddress = _data["remoteAddress"];
            (<any>this).summary = _data["summary"];
        }
    }

    static fromJS(data: any): AuditRecordBean {
        data = typeof data === 'object' ? data : {};
        let result = new AuditRecordBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.associatedItems)) {
            data["associatedItems"] = [];
            for (let item of this.associatedItems)
                data["associatedItems"].push(item.toJSON());
        }
        data["authorKey"] = this.authorKey;
        data["category"] = this.category;
        if (Array.isArray(this.changedValues)) {
            data["changedValues"] = [];
            for (let item of this.changedValues)
                data["changedValues"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["eventSource"] = this.eventSource;
        data["id"] = this.id;
        data["objectItem"] = this.objectItem ? this.objectItem.toJSON() : <any>undefined;
        data["remoteAddress"] = this.remoteAddress;
        data["summary"] = this.summary;
        return data;
    }
}

/** An audit record. */
export interface IAuditRecordBean {
    /** The list of items associated with the changed record. */
    associatedItems?: AssociatedItemBean[];
    /** Deprecated, use `authorAccountId` instead. The key of the user who created the audit record. */
    authorKey?: string;
    /** The category of the audit record. For a list of these categories, see the help article [Auditing in Jira applications](https://confluence.atlassian.com/x/noXKM). */
    category?: string;
    /** The list of values changed in the record event. */
    changedValues?: ChangedValueBean[];
    /** The date and time on which the audit record was created. */
    created?: Date;
    /** The description of the audit record. */
    description?: string;
    /** The event the audit record originated from. */
    eventSource?: string;
    /** The ID of the audit record. */
    id?: number;
    objectItem?: AssociatedItemBean;
    /** The URL of the computer where the creation of the audit record was initiated. */
    remoteAddress?: string;
    /** The summary of the audit record. */
    summary?: string;
}

/** Container for a list of audit records. */
export class AuditRecords implements IAuditRecords {
    /** The requested or default limit on the number of audit items to be returned. */
    readonly limit?: number;
    /** The number of audit items skipped before the first item in this list. */
    readonly offset?: number;
    /** The list of audit items. */
    readonly records?: AuditRecordBean[];
    /** The total number of audit items returned. */
    readonly total?: number;

    constructor(data?: IAuditRecords) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).limit = _data["limit"];
            (<any>this).offset = _data["offset"];
            if (Array.isArray(_data["records"])) {
                (<any>this).records = [] as any;
                for (let item of _data["records"])
                    (<any>this).records!.push(AuditRecordBean.fromJS(item));
            }
            (<any>this).total = _data["total"];
        }
    }

    static fromJS(data: any): AuditRecords {
        data = typeof data === 'object' ? data : {};
        let result = new AuditRecords();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["offset"] = this.offset;
        if (Array.isArray(this.records)) {
            data["records"] = [];
            for (let item of this.records)
                data["records"].push(item.toJSON());
        }
        data["total"] = this.total;
        return data;
    }
}

/** Container for a list of audit records. */
export interface IAuditRecords {
    /** The requested or default limit on the number of audit items to be returned. */
    limit?: number;
    /** The number of audit items skipped before the first item in this list. */
    offset?: number;
    /** The list of audit items. */
    records?: AuditRecordBean[];
    /** The total number of audit items returned. */
    total?: number;
}

/** A field auto-complete suggestion. */
export class AutoCompleteSuggestion implements IAutoCompleteSuggestion {
    /** The display name of a suggested item. If `fieldValue` or `predicateValue` are provided, the matching text is highlighted with the HTML bold tag. */
    displayName?: string;
    /** The value of a suggested item. */
    value?: string;

    constructor(data?: IAutoCompleteSuggestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AutoCompleteSuggestion {
        data = typeof data === 'object' ? data : {};
        let result = new AutoCompleteSuggestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["value"] = this.value;
        return data;
    }
}

/** A field auto-complete suggestion. */
export interface IAutoCompleteSuggestion {
    /** The display name of a suggested item. If `fieldValue` or `predicateValue` are provided, the matching text is highlighted with the HTML bold tag. */
    displayName?: string;
    /** The value of a suggested item. */
    value?: string;
}

/** The results from a JQL query. */
export class AutoCompleteSuggestions implements IAutoCompleteSuggestions {
    /** The list of suggested item. */
    results?: AutoCompleteSuggestion[];

    constructor(data?: IAutoCompleteSuggestions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(AutoCompleteSuggestion.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AutoCompleteSuggestions {
        data = typeof data === 'object' ? data : {};
        let result = new AutoCompleteSuggestions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

/** The results from a JQL query. */
export interface IAutoCompleteSuggestions {
    /** The list of suggested item. */
    results?: AutoCompleteSuggestion[];
}

/** The details of the available dashboard gadget. */
export class AvailableDashboardGadget implements IAvailableDashboardGadget {
    /** The module key of the gadget type. */
    readonly moduleKey?: string;
    /** The title of the gadget. */
    readonly title!: string;
    /** The URI of the gadget type. */
    readonly uri?: string;

    constructor(data?: IAvailableDashboardGadget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).moduleKey = _data["moduleKey"];
            (<any>this).title = _data["title"];
            (<any>this).uri = _data["uri"];
        }
    }

    static fromJS(data: any): AvailableDashboardGadget {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableDashboardGadget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["moduleKey"] = this.moduleKey;
        data["title"] = this.title;
        data["uri"] = this.uri;
        return data;
    }
}

/** The details of the available dashboard gadget. */
export interface IAvailableDashboardGadget {
    /** The module key of the gadget type. */
    moduleKey?: string;
    /** The title of the gadget. */
    title: string;
    /** The URI of the gadget type. */
    uri?: string;
}

/** The list of available gadgets. */
export class AvailableDashboardGadgetsResponse implements IAvailableDashboardGadgetsResponse {
    /** The list of available gadgets. */
    readonly gadgets!: AvailableDashboardGadget[];

    constructor(data?: IAvailableDashboardGadgetsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.gadgets = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["gadgets"])) {
                (<any>this).gadgets = [] as any;
                for (let item of _data["gadgets"])
                    (<any>this).gadgets!.push(AvailableDashboardGadget.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AvailableDashboardGadgetsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableDashboardGadgetsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.gadgets)) {
            data["gadgets"] = [];
            for (let item of this.gadgets)
                data["gadgets"].push(item.toJSON());
        }
        return data;
    }
}

/** The list of available gadgets. */
export interface IAvailableDashboardGadgetsResponse {
    /** The list of available gadgets. */
    gadgets: AvailableDashboardGadget[];
}

/** The Connect provided ecosystem rules available. */
export class AvailableWorkflowConnectRule implements IAvailableWorkflowConnectRule {
    /** The add-on providing the rule. */
    addonKey?: string;
    /** The URL creation path segment defined in the Connect module. */
    createUrl?: string;
    /** The rule description. */
    description?: string;
    /** The URL edit path segment defined in the Connect module. */
    editUrl?: string;
    /** The module providing the rule. */
    moduleKey?: string;
    /** The rule name. */
    name?: string;
    /** The rule key. */
    ruleKey?: string;
    /** The rule type. */
    ruleType?: AvailableWorkflowConnectRuleRuleType;
    /** The URL view path segment defined in the Connect module. */
    viewUrl?: string;

    constructor(data?: IAvailableWorkflowConnectRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addonKey = _data["addonKey"];
            this.createUrl = _data["createUrl"];
            this.description = _data["description"];
            this.editUrl = _data["editUrl"];
            this.moduleKey = _data["moduleKey"];
            this.name = _data["name"];
            this.ruleKey = _data["ruleKey"];
            this.ruleType = _data["ruleType"];
            this.viewUrl = _data["viewUrl"];
        }
    }

    static fromJS(data: any): AvailableWorkflowConnectRule {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableWorkflowConnectRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addonKey"] = this.addonKey;
        data["createUrl"] = this.createUrl;
        data["description"] = this.description;
        data["editUrl"] = this.editUrl;
        data["moduleKey"] = this.moduleKey;
        data["name"] = this.name;
        data["ruleKey"] = this.ruleKey;
        data["ruleType"] = this.ruleType;
        data["viewUrl"] = this.viewUrl;
        return data;
    }
}

/** The Connect provided ecosystem rules available. */
export interface IAvailableWorkflowConnectRule {
    /** The add-on providing the rule. */
    addonKey?: string;
    /** The URL creation path segment defined in the Connect module. */
    createUrl?: string;
    /** The rule description. */
    description?: string;
    /** The URL edit path segment defined in the Connect module. */
    editUrl?: string;
    /** The module providing the rule. */
    moduleKey?: string;
    /** The rule name. */
    name?: string;
    /** The rule key. */
    ruleKey?: string;
    /** The rule type. */
    ruleType?: AvailableWorkflowConnectRuleRuleType;
    /** The URL view path segment defined in the Connect module. */
    viewUrl?: string;
}

/** The Forge provided ecosystem rules available. */
export class AvailableWorkflowForgeRule implements IAvailableWorkflowForgeRule {
    /** The rule description. */
    description?: string;
    /** The unique ARI of the forge rule type. */
    id?: string;
    /** The rule name. */
    name?: string;
    /** The rule key. */
    ruleKey?: string;
    /** The rule type. */
    ruleType?: AvailableWorkflowForgeRuleRuleType;

    constructor(data?: IAvailableWorkflowForgeRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.ruleKey = _data["ruleKey"];
            this.ruleType = _data["ruleType"];
        }
    }

    static fromJS(data: any): AvailableWorkflowForgeRule {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableWorkflowForgeRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["ruleKey"] = this.ruleKey;
        data["ruleType"] = this.ruleType;
        return data;
    }
}

/** The Forge provided ecosystem rules available. */
export interface IAvailableWorkflowForgeRule {
    /** The rule description. */
    description?: string;
    /** The unique ARI of the forge rule type. */
    id?: string;
    /** The rule name. */
    name?: string;
    /** The rule key. */
    ruleKey?: string;
    /** The rule type. */
    ruleType?: AvailableWorkflowForgeRuleRuleType;
}

/** The Atlassian provided system rules available. */
export class AvailableWorkflowSystemRule implements IAvailableWorkflowSystemRule {
    /** The rule description. */
    description!: string;
    /** List of rules that conflict with this one. */
    incompatibleRuleKeys!: string[];
    /** Whether the rule can be added added to an initial transition. */
    isAvailableForInitialTransition!: boolean;
    /** Whether the rule is visible. */
    isVisible!: boolean;
    /** The rule name. */
    name!: string;
    /** The rule key. */
    ruleKey!: string;
    /** The rule type. */
    ruleType!: AvailableWorkflowSystemRuleRuleType;

    constructor(data?: IAvailableWorkflowSystemRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.incompatibleRuleKeys = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            if (Array.isArray(_data["incompatibleRuleKeys"])) {
                this.incompatibleRuleKeys = [] as any;
                for (let item of _data["incompatibleRuleKeys"])
                    this.incompatibleRuleKeys!.push(item);
            }
            this.isAvailableForInitialTransition = _data["isAvailableForInitialTransition"];
            this.isVisible = _data["isVisible"];
            this.name = _data["name"];
            this.ruleKey = _data["ruleKey"];
            this.ruleType = _data["ruleType"];
        }
    }

    static fromJS(data: any): AvailableWorkflowSystemRule {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableWorkflowSystemRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        if (Array.isArray(this.incompatibleRuleKeys)) {
            data["incompatibleRuleKeys"] = [];
            for (let item of this.incompatibleRuleKeys)
                data["incompatibleRuleKeys"].push(item);
        }
        data["isAvailableForInitialTransition"] = this.isAvailableForInitialTransition;
        data["isVisible"] = this.isVisible;
        data["name"] = this.name;
        data["ruleKey"] = this.ruleKey;
        data["ruleType"] = this.ruleType;
        return data;
    }
}

/** The Atlassian provided system rules available. */
export interface IAvailableWorkflowSystemRule {
    /** The rule description. */
    description: string;
    /** List of rules that conflict with this one. */
    incompatibleRuleKeys: string[];
    /** Whether the rule can be added added to an initial transition. */
    isAvailableForInitialTransition: boolean;
    /** Whether the rule is visible. */
    isVisible: boolean;
    /** The rule name. */
    name: string;
    /** The rule key. */
    ruleKey: string;
    /** The rule type. */
    ruleType: AvailableWorkflowSystemRuleRuleType;
}

/** The list of available trigger types. */
export class AvailableWorkflowTriggerTypes implements IAvailableWorkflowTriggerTypes {
    /** The description of the trigger rule. */
    description?: string;
    /** The name of the trigger rule. */
    name?: string;
    /** The type identifier of trigger rule. */
    type?: string;

    constructor(data?: IAvailableWorkflowTriggerTypes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): AvailableWorkflowTriggerTypes {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableWorkflowTriggerTypes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

/** The list of available trigger types. */
export interface IAvailableWorkflowTriggerTypes {
    /** The description of the trigger rule. */
    description?: string;
    /** The name of the trigger rule. */
    name?: string;
    /** The type identifier of trigger rule. */
    type?: string;
}

/** The trigger rules available. */
export class AvailableWorkflowTriggers implements IAvailableWorkflowTriggers {
    /** The list of available trigger types. */
    availableTypes!: AvailableWorkflowTriggerTypes[];
    /** The rule key of the rule. */
    ruleKey!: string;

    constructor(data?: IAvailableWorkflowTriggers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.availableTypes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["availableTypes"])) {
                this.availableTypes = [] as any;
                for (let item of _data["availableTypes"])
                    this.availableTypes!.push(AvailableWorkflowTriggerTypes.fromJS(item));
            }
            this.ruleKey = _data["ruleKey"];
        }
    }

    static fromJS(data: any): AvailableWorkflowTriggers {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableWorkflowTriggers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.availableTypes)) {
            data["availableTypes"] = [];
            for (let item of this.availableTypes)
                data["availableTypes"].push(item.toJSON());
        }
        data["ruleKey"] = this.ruleKey;
        return data;
    }
}

/** The trigger rules available. */
export interface IAvailableWorkflowTriggers {
    /** The list of available trigger types. */
    availableTypes: AvailableWorkflowTriggerTypes[];
    /** The rule key of the rule. */
    ruleKey: string;
}

/** Details of an avatar. */
export class Avatar implements IAvatar {
    /** The file name of the avatar icon. Returned for system avatars. */
    readonly fileName?: string;
    /** The ID of the avatar. */
    id!: string;
    /** Whether the avatar can be deleted. */
    readonly isDeletable?: boolean;
    /** Whether the avatar is used in Jira. For example, shown as a project's avatar. */
    readonly isSelected?: boolean;
    /** Whether the avatar is a system avatar. */
    readonly isSystemAvatar?: boolean;
    /** The owner of the avatar. For a system avatar the owner is null (and nothing is returned). For non-system avatars this is the appropriate identifier, such as the ID for a project or the account ID for a user. */
    readonly owner?: string;
    /** The list of avatar icon URLs. */
    readonly urls?: { [key: string]: string; };

    [key: string]: any;

    constructor(data?: IAvatar) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).fileName = _data["fileName"];
            this.id = _data["id"];
            (<any>this).isDeletable = _data["isDeletable"];
            (<any>this).isSelected = _data["isSelected"];
            (<any>this).isSystemAvatar = _data["isSystemAvatar"];
            (<any>this).owner = _data["owner"];
            if (_data["urls"]) {
                (<any>this).urls = {} as any;
                for (let key in _data["urls"]) {
                    if (_data["urls"].hasOwnProperty(key))
                        (<any>(<any>this).urls)![key] = _data["urls"][key];
                }
            }
        }
    }

    static fromJS(data: any): Avatar {
        data = typeof data === 'object' ? data : {};
        let result = new Avatar();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["fileName"] = this.fileName;
        data["id"] = this.id;
        data["isDeletable"] = this.isDeletable;
        data["isSelected"] = this.isSelected;
        data["isSystemAvatar"] = this.isSystemAvatar;
        data["owner"] = this.owner;
        if (this.urls) {
            data["urls"] = {};
            for (let key in this.urls) {
                if (this.urls.hasOwnProperty(key))
                    (<any>data["urls"])[key] = (<any>this.urls)[key];
            }
        }
        return data;
    }
}

/** Details of an avatar. */
export interface IAvatar {
    /** The file name of the avatar icon. Returned for system avatars. */
    fileName?: string;
    /** The ID of the avatar. */
    id: string;
    /** Whether the avatar can be deleted. */
    isDeletable?: boolean;
    /** Whether the avatar is used in Jira. For example, shown as a project's avatar. */
    isSelected?: boolean;
    /** Whether the avatar is a system avatar. */
    isSystemAvatar?: boolean;
    /** The owner of the avatar. For a system avatar the owner is null (and nothing is returned). For non-system avatars this is the appropriate identifier, such as the ID for a project or the account ID for a user. */
    owner?: string;
    /** The list of avatar icon URLs. */
    urls?: { [key: string]: string; };

    [key: string]: any;
}

export class AvatarUrlsBean implements IAvatarUrlsBean {
    /** The URL of the item's 16x16 pixel avatar. */
    _16x16?: string;
    /** The URL of the item's 24x24 pixel avatar. */
    _24x24?: string;
    /** The URL of the item's 32x32 pixel avatar. */
    _32x32?: string;
    /** The URL of the item's 48x48 pixel avatar. */
    _48x48?: string;

    constructor(data?: IAvatarUrlsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this._16x16 = _data["16x16"];
            this._24x24 = _data["24x24"];
            this._32x32 = _data["32x32"];
            this._48x48 = _data["48x48"];
        }
    }

    static fromJS(data: any): AvatarUrlsBean {
        data = typeof data === 'object' ? data : {};
        let result = new AvatarUrlsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["16x16"] = this._16x16;
        data["24x24"] = this._24x24;
        data["32x32"] = this._32x32;
        data["48x48"] = this._48x48;
        return data;
    }
}

export interface IAvatarUrlsBean {
    /** The URL of the item's 16x16 pixel avatar. */
    _16x16?: string;
    /** The URL of the item's 24x24 pixel avatar. */
    _24x24?: string;
    /** The URL of the item's 32x32 pixel avatar. */
    _32x32?: string;
    /** The URL of the item's 48x48 pixel avatar. */
    _48x48?: string;
}

/** Details about system and custom avatars. */
export class Avatars implements IAvatars {
    /** Custom avatars list. */
    readonly custom?: Avatar[];
    /** System avatars list. */
    readonly system?: Avatar[];

    constructor(data?: IAvatars) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["custom"])) {
                (<any>this).custom = [] as any;
                for (let item of _data["custom"])
                    (<any>this).custom!.push(Avatar.fromJS(item));
            }
            if (Array.isArray(_data["system"])) {
                (<any>this).system = [] as any;
                for (let item of _data["system"])
                    (<any>this).system!.push(Avatar.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Avatars {
        data = typeof data === 'object' ? data : {};
        let result = new Avatars();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.custom)) {
            data["custom"] = [];
            for (let item of this.custom)
                data["custom"].push(item.toJSON());
        }
        if (Array.isArray(this.system)) {
            data["system"] = [];
            for (let item of this.system)
                data["system"].push(item.toJSON());
        }
        return data;
    }
}

/** Details about system and custom avatars. */
export interface IAvatars {
    /** Custom avatars list. */
    custom?: Avatar[];
    /** System avatars list. */
    system?: Avatar[];
}

/** The payload for creating a board column */
export class BoardColumnPayload implements IBoardColumnPayload {
    /** The maximum issue constraint for the column */
    maximumIssueConstraint?: number;
    /** The minimum issue constraint for the column */
    minimumIssueConstraint?: number;
    /** The name of the column */
    name?: string;
    /** The status IDs for the column */
    statusIds?: ProjectCreateResourceIdentifier[];

    constructor(data?: IBoardColumnPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maximumIssueConstraint = _data["maximumIssueConstraint"];
            this.minimumIssueConstraint = _data["minimumIssueConstraint"];
            this.name = _data["name"];
            if (Array.isArray(_data["statusIds"])) {
                this.statusIds = [] as any;
                for (let item of _data["statusIds"])
                    this.statusIds!.push(ProjectCreateResourceIdentifier.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BoardColumnPayload {
        data = typeof data === 'object' ? data : {};
        let result = new BoardColumnPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maximumIssueConstraint"] = this.maximumIssueConstraint;
        data["minimumIssueConstraint"] = this.minimumIssueConstraint;
        data["name"] = this.name;
        if (Array.isArray(this.statusIds)) {
            data["statusIds"] = [];
            for (let item of this.statusIds)
                data["statusIds"].push(item.toJSON());
        }
        return data;
    }
}

/** The payload for creating a board column */
export interface IBoardColumnPayload {
    /** The maximum issue constraint for the column */
    maximumIssueConstraint?: number;
    /** The minimum issue constraint for the column */
    minimumIssueConstraint?: number;
    /** The name of the column */
    name?: string;
    /** The status IDs for the column */
    statusIds?: ProjectCreateResourceIdentifier[];
}

/** The payload for setting a board feature */
export class BoardFeaturePayload implements IBoardFeaturePayload {
    /** The key of the feature */
    featureKey?: BoardFeaturePayloadFeatureKey;
    /** Whether the feature should be turned on or off */
    state?: boolean;

    constructor(data?: IBoardFeaturePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.featureKey = _data["featureKey"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): BoardFeaturePayload {
        data = typeof data === 'object' ? data : {};
        let result = new BoardFeaturePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["featureKey"] = this.featureKey;
        data["state"] = this.state;
        return data;
    }
}

/** The payload for setting a board feature */
export interface IBoardFeaturePayload {
    /** The key of the feature */
    featureKey?: BoardFeaturePayloadFeatureKey;
    /** Whether the feature should be turned on or off */
    state?: boolean;
}

/** The payload for creating a board */
export class BoardPayload implements IBoardPayload {
    /** Takes in a JQL string to create a new filter. If no value is provided, it'll default to a JQL filter for the project creating */
    boardFilterJQL?: string;
    /** Card color settings of the board */
    cardColorStrategy?: BoardPayloadCardColorStrategy;
    cardLayout?: CardLayout;
    /** Card layout settings of the board */
    cardLayouts?: CardLayoutField[];
    /** The columns of the board */
    columns?: BoardColumnPayload[];
    /** Feature settings for the board */
    features?: BoardFeaturePayload[];
    /** The name of the board */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;
    /** The quick filters for the board. */
    quickFilters?: QuickFilterPayload[];
    /** Whether sprints are supported on the board */
    supportsSprint?: boolean;
    swimlanes?: SwimlanesPayload;
    workingDaysConfig?: WorkingDaysConfig;

    constructor(data?: IBoardPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.supportsSprint = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.boardFilterJQL = _data["boardFilterJQL"];
            this.cardColorStrategy = _data["cardColorStrategy"];
            this.cardLayout = _data["cardLayout"] ? CardLayout.fromJS(_data["cardLayout"]) : <any>undefined;
            if (Array.isArray(_data["cardLayouts"])) {
                this.cardLayouts = [] as any;
                for (let item of _data["cardLayouts"])
                    this.cardLayouts!.push(CardLayoutField.fromJS(item));
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(BoardColumnPayload.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(BoardFeaturePayload.fromJS(item));
            }
            this.name = _data["name"];
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
            if (Array.isArray(_data["quickFilters"])) {
                this.quickFilters = [] as any;
                for (let item of _data["quickFilters"])
                    this.quickFilters!.push(QuickFilterPayload.fromJS(item));
            }
            this.supportsSprint = _data["supportsSprint"] !== undefined ? _data["supportsSprint"] : true;
            this.swimlanes = _data["swimlanes"] ? SwimlanesPayload.fromJS(_data["swimlanes"]) : <any>undefined;
            this.workingDaysConfig = _data["workingDaysConfig"] ? WorkingDaysConfig.fromJS(_data["workingDaysConfig"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BoardPayload {
        data = typeof data === 'object' ? data : {};
        let result = new BoardPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["boardFilterJQL"] = this.boardFilterJQL;
        data["cardColorStrategy"] = this.cardColorStrategy;
        data["cardLayout"] = this.cardLayout ? this.cardLayout.toJSON() : <any>undefined;
        if (Array.isArray(this.cardLayouts)) {
            data["cardLayouts"] = [];
            for (let item of this.cardLayouts)
                data["cardLayouts"].push(item.toJSON());
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        if (Array.isArray(this.quickFilters)) {
            data["quickFilters"] = [];
            for (let item of this.quickFilters)
                data["quickFilters"].push(item.toJSON());
        }
        data["supportsSprint"] = this.supportsSprint;
        data["swimlanes"] = this.swimlanes ? this.swimlanes.toJSON() : <any>undefined;
        data["workingDaysConfig"] = this.workingDaysConfig ? this.workingDaysConfig.toJSON() : <any>undefined;
        return data;
    }
}

/** The payload for creating a board */
export interface IBoardPayload {
    /** Takes in a JQL string to create a new filter. If no value is provided, it'll default to a JQL filter for the project creating */
    boardFilterJQL?: string;
    /** Card color settings of the board */
    cardColorStrategy?: BoardPayloadCardColorStrategy;
    cardLayout?: CardLayout;
    /** Card layout settings of the board */
    cardLayouts?: CardLayoutField[];
    /** The columns of the board */
    columns?: BoardColumnPayload[];
    /** Feature settings for the board */
    features?: BoardFeaturePayload[];
    /** The name of the board */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;
    /** The quick filters for the board. */
    quickFilters?: QuickFilterPayload[];
    /** Whether sprints are supported on the board */
    supportsSprint?: boolean;
    swimlanes?: SwimlanesPayload;
    workingDaysConfig?: WorkingDaysConfig;
}

export class BoardsPayload implements IBoardsPayload {
    /** The boards to be associated with the project. */
    boards?: BoardPayload[];

    constructor(data?: IBoardsPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["boards"])) {
                this.boards = [] as any;
                for (let item of _data["boards"])
                    this.boards!.push(BoardPayload.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BoardsPayload {
        data = typeof data === 'object' ? data : {};
        let result = new BoardsPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.boards)) {
            data["boards"] = [];
            for (let item of this.boards)
                data["boards"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBoardsPayload {
    /** The boards to be associated with the project. */
    boards?: BoardPayload[];
}

/** Details for changing owners of shareable entities */
export class BulkChangeOwnerDetails implements IBulkChangeOwnerDetails {
    /** Whether the name is fixed automatically if it's duplicated after changing owner. */
    autofixName!: boolean;
    /** The account id of the new owner. */
    newOwner!: string;

    constructor(data?: IBulkChangeOwnerDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autofixName = _data["autofixName"];
            this.newOwner = _data["newOwner"];
        }
    }

    static fromJS(data: any): BulkChangeOwnerDetails {
        data = typeof data === 'object' ? data : {};
        let result = new BulkChangeOwnerDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autofixName"] = this.autofixName;
        data["newOwner"] = this.newOwner;
        return data;
    }
}

/** Details for changing owners of shareable entities */
export interface IBulkChangeOwnerDetails {
    /** Whether the name is fixed automatically if it's duplicated after changing owner. */
    autofixName: boolean;
    /** The account id of the new owner. */
    newOwner: string;
}

/** Request bean for bulk changelog retrieval */
export class BulkChangelogRequestBean implements IBulkChangelogRequestBean {
    /** List of field IDs to filter changelogs */
    fieldIds?: string[];
    /** List of issue IDs/keys to fetch changelogs for */
    issueIdsOrKeys!: string[];
    /** The maximum number of items to return per page */
    maxResults?: number;
    /** The cursor for pagination */
    nextPageToken?: string;

    constructor(data?: IBulkChangelogRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueIdsOrKeys = [];
            this.maxResults = 1000;
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fieldIds"])) {
                this.fieldIds = [] as any;
                for (let item of _data["fieldIds"])
                    this.fieldIds!.push(item);
            }
            if (Array.isArray(_data["issueIdsOrKeys"])) {
                this.issueIdsOrKeys = [] as any;
                for (let item of _data["issueIdsOrKeys"])
                    this.issueIdsOrKeys!.push(item);
            }
            this.maxResults = _data["maxResults"] !== undefined ? _data["maxResults"] : 1000;
            this.nextPageToken = _data["nextPageToken"];
        }
    }

    static fromJS(data: any): BulkChangelogRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new BulkChangelogRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fieldIds)) {
            data["fieldIds"] = [];
            for (let item of this.fieldIds)
                data["fieldIds"].push(item);
        }
        if (Array.isArray(this.issueIdsOrKeys)) {
            data["issueIdsOrKeys"] = [];
            for (let item of this.issueIdsOrKeys)
                data["issueIdsOrKeys"].push(item);
        }
        data["maxResults"] = this.maxResults;
        data["nextPageToken"] = this.nextPageToken;
        return data;
    }
}

/** Request bean for bulk changelog retrieval */
export interface IBulkChangelogRequestBean {
    /** List of field IDs to filter changelogs */
    fieldIds?: string[];
    /** List of issue IDs/keys to fetch changelogs for */
    issueIdsOrKeys: string[];
    /** The maximum number of items to return per page */
    maxResults?: number;
    /** The cursor for pagination */
    nextPageToken?: string;
}

/** A page of changelogs which is designed to handle multiple issues */
export class BulkChangelogResponseBean implements IBulkChangelogResponseBean {
    /** The list of issues changelogs. */
    readonly issueChangeLogs?: IssueChangeLog[];
    /** Continuation token to fetch the next page. If this result represents the last or the only page, this token will be null. */
    readonly nextPageToken?: string;

    constructor(data?: IBulkChangelogResponseBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueChangeLogs"])) {
                (<any>this).issueChangeLogs = [] as any;
                for (let item of _data["issueChangeLogs"])
                    (<any>this).issueChangeLogs!.push(IssueChangeLog.fromJS(item));
            }
            (<any>this).nextPageToken = _data["nextPageToken"];
        }
    }

    static fromJS(data: any): BulkChangelogResponseBean {
        data = typeof data === 'object' ? data : {};
        let result = new BulkChangelogResponseBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueChangeLogs)) {
            data["issueChangeLogs"] = [];
            for (let item of this.issueChangeLogs)
                data["issueChangeLogs"].push(item.toJSON());
        }
        data["nextPageToken"] = this.nextPageToken;
        return data;
    }
}

/** A page of changelogs which is designed to handle multiple issues */
export interface IBulkChangelogResponseBean {
    /** The list of issues changelogs. */
    issueChangeLogs?: IssueChangeLog[];
    /** Continuation token to fetch the next page. If this result represents the last or the only page, this token will be null. */
    nextPageToken?: string;
}

/** Details of the contextual configuration for a custom field. */
export class BulkContextualConfiguration implements IBulkContextualConfiguration {
    /** The field configuration. */
    configuration?: any;
    /** The ID of the custom field. */
    customFieldId!: string;
    /** The ID of the field context the configuration is associated with. */
    readonly fieldContextId!: string;
    /** The ID of the configuration. */
    id!: string;
    /** The field value schema. */
    schema?: any;

    constructor(data?: IBulkContextualConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.configuration = _data["configuration"];
            this.customFieldId = _data["customFieldId"];
            (<any>this).fieldContextId = _data["fieldContextId"];
            this.id = _data["id"];
            this.schema = _data["schema"];
        }
    }

    static fromJS(data: any): BulkContextualConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new BulkContextualConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["configuration"] = this.configuration;
        data["customFieldId"] = this.customFieldId;
        data["fieldContextId"] = this.fieldContextId;
        data["id"] = this.id;
        data["schema"] = this.schema;
        return data;
    }
}

/** Details of the contextual configuration for a custom field. */
export interface IBulkContextualConfiguration {
    /** The field configuration. */
    configuration?: any;
    /** The ID of the custom field. */
    customFieldId: string;
    /** The ID of the field context the configuration is associated with. */
    fieldContextId: string;
    /** The ID of the configuration. */
    id: string;
    /** The field value schema. */
    schema?: any;
}

/** Details of the options to create for a custom field. */
export class BulkCustomFieldOptionCreateRequest implements IBulkCustomFieldOptionCreateRequest {
    /** Details of options to create. */
    options?: CustomFieldOptionCreate[];

    constructor(data?: IBulkCustomFieldOptionCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(CustomFieldOptionCreate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkCustomFieldOptionCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkCustomFieldOptionCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of the options to create for a custom field. */
export interface IBulkCustomFieldOptionCreateRequest {
    /** Details of options to create. */
    options?: CustomFieldOptionCreate[];
}

/** Details of the options to update for a custom field. */
export class BulkCustomFieldOptionUpdateRequest implements IBulkCustomFieldOptionUpdateRequest {
    /** Details of the options to update. */
    options?: CustomFieldOptionUpdate[];

    constructor(data?: IBulkCustomFieldOptionUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(CustomFieldOptionUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkCustomFieldOptionUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkCustomFieldOptionUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of the options to update for a custom field. */
export interface IBulkCustomFieldOptionUpdateRequest {
    /** Details of the options to update. */
    options?: CustomFieldOptionUpdate[];
}

/** Errors of bulk edit action. */
export class BulkEditActionError implements IBulkEditActionError {
    /** The error messages. */
    errorMessages!: string[];
    /** The errors. */
    errors!: { [key: string]: string; };

    constructor(data?: IBulkEditActionError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.errorMessages = [];
            this.errors = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages!.push(item);
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key];
                }
            }
        }
    }

    static fromJS(data: any): BulkEditActionError {
        data = typeof data === 'object' ? data : {};
        let result = new BulkEditActionError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        return data;
    }
}

/** Errors of bulk edit action. */
export interface IBulkEditActionError {
    /** The error messages. */
    errorMessages: string[];
    /** The errors. */
    errors: { [key: string]: string; };
}

/** Bulk Edit Get Fields Response. */
export class BulkEditGetFields implements IBulkEditGetFields {
    /** The end cursor for use in pagination. */
    readonly endingBefore?: string;
    /** List of all the fields */
    readonly fields?: IssueBulkEditField[];
    /** The start cursor for use in pagination. */
    readonly startingAfter?: string;

    constructor(data?: IBulkEditGetFields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).endingBefore = _data["endingBefore"];
            if (Array.isArray(_data["fields"])) {
                (<any>this).fields = [] as any;
                for (let item of _data["fields"])
                    (<any>this).fields!.push(IssueBulkEditField.fromJS(item));
            }
            (<any>this).startingAfter = _data["startingAfter"];
        }
    }

    static fromJS(data: any): BulkEditGetFields {
        data = typeof data === 'object' ? data : {};
        let result = new BulkEditGetFields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["endingBefore"] = this.endingBefore;
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        data["startingAfter"] = this.startingAfter;
        return data;
    }
}

/** Bulk Edit Get Fields Response. */
export interface IBulkEditGetFields {
    /** The end cursor for use in pagination. */
    endingBefore?: string;
    /** List of all the fields */
    fields?: IssueBulkEditField[];
    /** The start cursor for use in pagination. */
    startingAfter?: string;
}

/** Details of a request to bulk edit shareable entity. */
export class BulkEditShareableEntityRequest implements IBulkEditShareableEntityRequest {
    /** Allowed action for bulk edit shareable entity */
    action!: BulkEditShareableEntityRequestAction;
    /** The details of change owner action. */
    changeOwnerDetails?: BulkChangeOwnerDetails;
    /** The id list of shareable entities to be changed. */
    entityIds!: number[];
    /** Whether the actions are executed by users with Administer Jira global permission. */
    extendAdminPermissions?: boolean;
    /** The permission details to be changed. */
    permissionDetails?: PermissionDetails;

    constructor(data?: IBulkEditShareableEntityRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.entityIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            this.changeOwnerDetails = _data["changeOwnerDetails"] ? BulkChangeOwnerDetails.fromJS(_data["changeOwnerDetails"]) : <any>undefined;
            if (Array.isArray(_data["entityIds"])) {
                this.entityIds = [] as any;
                for (let item of _data["entityIds"])
                    this.entityIds!.push(item);
            }
            this.extendAdminPermissions = _data["extendAdminPermissions"];
            this.permissionDetails = _data["permissionDetails"] ? PermissionDetails.fromJS(_data["permissionDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BulkEditShareableEntityRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkEditShareableEntityRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["changeOwnerDetails"] = this.changeOwnerDetails ? this.changeOwnerDetails.toJSON() : <any>undefined;
        if (Array.isArray(this.entityIds)) {
            data["entityIds"] = [];
            for (let item of this.entityIds)
                data["entityIds"].push(item);
        }
        data["extendAdminPermissions"] = this.extendAdminPermissions;
        data["permissionDetails"] = this.permissionDetails ? this.permissionDetails.toJSON() : <any>undefined;
        return data;
    }
}

/** Details of a request to bulk edit shareable entity. */
export interface IBulkEditShareableEntityRequest {
    /** Allowed action for bulk edit shareable entity */
    action: BulkEditShareableEntityRequestAction;
    /** The details of change owner action. */
    changeOwnerDetails?: BulkChangeOwnerDetails;
    /** The id list of shareable entities to be changed. */
    entityIds: number[];
    /** Whether the actions are executed by users with Administer Jira global permission. */
    extendAdminPermissions?: boolean;
    /** The permission details to be changed. */
    permissionDetails?: PermissionDetails;
}

/** Details of a request to bulk edit shareable entity. */
export class BulkEditShareableEntityResponse implements IBulkEditShareableEntityResponse {
    /** Allowed action for bulk edit shareable entity */
    action!: BulkEditShareableEntityResponseAction;
    /** The mapping dashboard id to errors if any. */
    entityErrors?: { [key: string]: BulkEditActionError; };

    constructor(data?: IBulkEditShareableEntityResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.action = _data["action"];
            if (_data["entityErrors"]) {
                this.entityErrors = {} as any;
                for (let key in _data["entityErrors"]) {
                    if (_data["entityErrors"].hasOwnProperty(key))
                        (<any>this.entityErrors)![key] = _data["entityErrors"][key] ? BulkEditActionError.fromJS(_data["entityErrors"][key]) : new BulkEditActionError();
                }
            }
        }
    }

    static fromJS(data: any): BulkEditShareableEntityResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BulkEditShareableEntityResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        if (this.entityErrors) {
            data["entityErrors"] = {};
            for (let key in this.entityErrors) {
                if (this.entityErrors.hasOwnProperty(key))
                    (<any>data["entityErrors"])[key] = this.entityErrors[key] ? this.entityErrors[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Details of a request to bulk edit shareable entity. */
export interface IBulkEditShareableEntityResponse {
    /** Allowed action for bulk edit shareable entity */
    action: BulkEditShareableEntityResponseAction;
    /** The mapping dashboard id to errors if any. */
    entityErrors?: { [key: string]: BulkEditActionError; };
}

export class BulkFetchIssueRequestBean implements IBulkFetchIssueRequestBean {
    /** Use [expand](#expansion) to include additional information about issues in the response. Note that, unlike the majority of instances where `expand` is specified, `expand` is defined as a list of values. The expand options are:

 *  `renderedFields` Returns field values rendered in HTML format.
 *  `names` Returns the display name of each field.
 *  `schema` Returns the schema describing a field type.
 *  `transitions` Returns all possible transitions for the issue.
 *  `operations` Returns all possible operations for the issue.
 *  `editmeta` Returns information about how each field can be edited.
 *  `changelog` Returns a list of recent updates to an issue, sorted by date, starting from the most recent.
 *  `versionedRepresentations` Instead of `fields`, returns `versionedRepresentations` a JSON array containing each version of a field's value, with the highest numbered item representing the most recent version. */
    expand?: string[];
    /** A list of fields to return for each issue, use it to retrieve a subset of fields. This parameter accepts a comma-separated list. Expand options include:

 *  `*all` Returns all fields.
 *  `*navigable` Returns navigable fields.
 *  Any issue field, prefixed with a minus to exclude.

The default is `*navigable`.

Examples:

 *  `summary,comment` Returns the summary and comments fields only.
 *  `-description` Returns all navigable (default) fields except description.
 *  `*all,-comment` Returns all fields except comments.

Multiple `fields` parameters can be included in a request.

Note: All navigable fields are returned by default. This differs from [GET issue](#api-rest-api-3-issue-issueIdOrKey-get) where the default is all fields. */
    fields?: string[];
    /** Reference fields by their key (rather than ID). The default is `false`. */
    fieldsByKeys?: boolean;
    /** An array of issue IDs or issue keys to fetch. You can mix issue IDs and keys in the same query. */
    issueIdsOrKeys!: string[];
    /** A list of issue property keys of issue properties to be included in the results. A maximum of 5 issue property keys can be specified. */
    properties?: string[];

    constructor(data?: IBulkFetchIssueRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueIdsOrKeys = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["expand"])) {
                this.expand = [] as any;
                for (let item of _data["expand"])
                    this.expand!.push(item);
            }
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(item);
            }
            this.fieldsByKeys = _data["fieldsByKeys"];
            if (Array.isArray(_data["issueIdsOrKeys"])) {
                this.issueIdsOrKeys = [] as any;
                for (let item of _data["issueIdsOrKeys"])
                    this.issueIdsOrKeys!.push(item);
            }
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(item);
            }
        }
    }

    static fromJS(data: any): BulkFetchIssueRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new BulkFetchIssueRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.expand)) {
            data["expand"] = [];
            for (let item of this.expand)
                data["expand"].push(item);
        }
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item);
        }
        data["fieldsByKeys"] = this.fieldsByKeys;
        if (Array.isArray(this.issueIdsOrKeys)) {
            data["issueIdsOrKeys"] = [];
            for (let item of this.issueIdsOrKeys)
                data["issueIdsOrKeys"].push(item);
        }
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item);
        }
        return data;
    }
}

export interface IBulkFetchIssueRequestBean {
    /** Use [expand](#expansion) to include additional information about issues in the response. Note that, unlike the majority of instances where `expand` is specified, `expand` is defined as a list of values. The expand options are:

 *  `renderedFields` Returns field values rendered in HTML format.
 *  `names` Returns the display name of each field.
 *  `schema` Returns the schema describing a field type.
 *  `transitions` Returns all possible transitions for the issue.
 *  `operations` Returns all possible operations for the issue.
 *  `editmeta` Returns information about how each field can be edited.
 *  `changelog` Returns a list of recent updates to an issue, sorted by date, starting from the most recent.
 *  `versionedRepresentations` Instead of `fields`, returns `versionedRepresentations` a JSON array containing each version of a field's value, with the highest numbered item representing the most recent version. */
    expand?: string[];
    /** A list of fields to return for each issue, use it to retrieve a subset of fields. This parameter accepts a comma-separated list. Expand options include:

 *  `*all` Returns all fields.
 *  `*navigable` Returns navigable fields.
 *  Any issue field, prefixed with a minus to exclude.

The default is `*navigable`.

Examples:

 *  `summary,comment` Returns the summary and comments fields only.
 *  `-description` Returns all navigable (default) fields except description.
 *  `*all,-comment` Returns all fields except comments.

Multiple `fields` parameters can be included in a request.

Note: All navigable fields are returned by default. This differs from [GET issue](#api-rest-api-3-issue-issueIdOrKey-get) where the default is all fields. */
    fields?: string[];
    /** Reference fields by their key (rather than ID). The default is `false`. */
    fieldsByKeys?: boolean;
    /** An array of issue IDs or issue keys to fetch. You can mix issue IDs and keys in the same query. */
    issueIdsOrKeys: string[];
    /** A list of issue property keys of issue properties to be included in the results. A maximum of 5 issue property keys can be specified. */
    properties?: string[];
}

/** A container for the watch status of a list of issues. */
export class BulkIssueIsWatching implements IBulkIssueIsWatching {
    /** The map of issue ID to boolean watch status. */
    readonly issuesIsWatching?: { [key: string]: boolean; };

    constructor(data?: IBulkIssueIsWatching) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["issuesIsWatching"]) {
                (<any>this).issuesIsWatching = {} as any;
                for (let key in _data["issuesIsWatching"]) {
                    if (_data["issuesIsWatching"].hasOwnProperty(key))
                        (<any>(<any>this).issuesIsWatching)![key] = _data["issuesIsWatching"][key];
                }
            }
        }
    }

    static fromJS(data: any): BulkIssueIsWatching {
        data = typeof data === 'object' ? data : {};
        let result = new BulkIssueIsWatching();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.issuesIsWatching) {
            data["issuesIsWatching"] = {};
            for (let key in this.issuesIsWatching) {
                if (this.issuesIsWatching.hasOwnProperty(key))
                    (<any>data["issuesIsWatching"])[key] = (<any>this.issuesIsWatching)[key];
            }
        }
        return data;
    }
}

/** A container for the watch status of a list of issues. */
export interface IBulkIssueIsWatching {
    /** The map of issue ID to boolean watch status. */
    issuesIsWatching?: { [key: string]: boolean; };
}

/** Bulk issue property update request details. */
export class BulkIssuePropertyUpdateRequest implements IBulkIssuePropertyUpdateRequest {
    /** EXPERIMENTAL. The Jira expression to calculate the value of the property. The value of the expression must be an object that can be converted to JSON, such as a number, boolean, string, list, or map. The context variables available to the expression are `issue` and `user`. Issues for which the expression returns a value whose JSON representation is longer than 32768 characters are ignored. */
    expression?: string;
    /** The bulk operation filter. */
    filter?: IssueFilterForBulkPropertySet;
    /** The value of the property. The value must be a [valid](https://tools.ietf.org/html/rfc4627), non-empty JSON blob. The maximum length is 32768 characters. */
    value?: any;

    constructor(data?: IBulkIssuePropertyUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expression = _data["expression"];
            this.filter = _data["filter"] ? IssueFilterForBulkPropertySet.fromJS(_data["filter"]) : <any>undefined;
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): BulkIssuePropertyUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkIssuePropertyUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expression"] = this.expression;
        data["filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["value"] = this.value;
        return data;
    }
}

/** Bulk issue property update request details. */
export interface IBulkIssuePropertyUpdateRequest {
    /** EXPERIMENTAL. The Jira expression to calculate the value of the property. The value of the expression must be an object that can be converted to JSON, such as a number, boolean, string, list, or map. The context variables available to the expression are `issue` and `user`. Issues for which the expression returns a value whose JSON representation is longer than 32768 characters are ignored. */
    expression?: string;
    /** The bulk operation filter. */
    filter?: IssueFilterForBulkPropertySet;
    /** The value of the property. The value must be a [valid](https://tools.ietf.org/html/rfc4627), non-empty JSON blob. The maximum length is 32768 characters. */
    value?: any;
}

/** The list of requested issues & fields. */
export class BulkIssueResults implements IBulkIssueResults {
    /** When Jira can't return an issue enumerated in a request due to a retriable error or payload constraint, we'll return the respective issue ID with a corresponding error message. This list is empty when there are no errors Issues which aren't found or that the user doesn't have permission to view won't be returned in this list. */
    readonly issueErrors?: IssueError[];
    /** The list of issues. */
    readonly issues?: IssueBean[];

    constructor(data?: IBulkIssueResults) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueErrors"])) {
                (<any>this).issueErrors = [] as any;
                for (let item of _data["issueErrors"])
                    (<any>this).issueErrors!.push(IssueError.fromJS(item));
            }
            if (Array.isArray(_data["issues"])) {
                (<any>this).issues = [] as any;
                for (let item of _data["issues"])
                    (<any>this).issues!.push(IssueBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkIssueResults {
        data = typeof data === 'object' ? data : {};
        let result = new BulkIssueResults();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueErrors)) {
            data["issueErrors"] = [];
            for (let item of this.issueErrors)
                data["issueErrors"].push(item.toJSON());
        }
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item.toJSON());
        }
        return data;
    }
}

/** The list of requested issues & fields. */
export interface IBulkIssueResults {
    /** When Jira can't return an issue enumerated in a request due to a retriable error or payload constraint, we'll return the respective issue ID with a corresponding error message. This list is empty when there are no errors Issues which aren't found or that the user doesn't have permission to view won't be returned in this list. */
    issueErrors?: IssueError[];
    /** The list of issues. */
    issues?: IssueBean[];
}

export class BulkOperationErrorResponse implements IBulkOperationErrorResponse {
    errors?: ErrorMessage[];

    constructor(data?: IBulkOperationErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkOperationErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BulkOperationErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBulkOperationErrorResponse {
    errors?: ErrorMessage[];
}

export class BulkOperationErrorResult implements IBulkOperationErrorResult {
    elementErrors?: ErrorCollection;
    failedElementNumber?: number;
    status?: number;

    constructor(data?: IBulkOperationErrorResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.elementErrors = _data["elementErrors"] ? ErrorCollection.fromJS(_data["elementErrors"]) : <any>undefined;
            this.failedElementNumber = _data["failedElementNumber"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): BulkOperationErrorResult {
        data = typeof data === 'object' ? data : {};
        let result = new BulkOperationErrorResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elementErrors"] = this.elementErrors ? this.elementErrors.toJSON() : <any>undefined;
        data["failedElementNumber"] = this.failedElementNumber;
        data["status"] = this.status;
        return data;
    }
}

export interface IBulkOperationErrorResult {
    elementErrors?: ErrorCollection;
    failedElementNumber?: number;
    status?: number;
}

export class BulkOperationProgress implements IBulkOperationProgress {
    /** A timestamp of when the task was submitted. */
    created?: Date;
    /** Map of issue IDs for which the operation failed and that the user has permission to view, to their one or more reasons for failure. These reasons are open-ended text descriptions of the error and are not selected from a predefined list of standard reasons. */
    failedAccessibleIssues?: { [key: string]: string[]; };
    /** The number of issues that are either invalid or issues that the user doesn't have permission to view, regardless of the success or failure of the operation. */
    invalidOrInaccessibleIssueCount?: number;
    /** List of issue IDs for which the operation was successful and that the user has permission to view. */
    processedAccessibleIssues?: number[];
    /** Progress of the task as a percentage. */
    progressPercent?: number;
    /** A timestamp of when the task was started. */
    started?: Date;
    /** The status of the task. */
    status?: BulkOperationProgressStatus;
    submittedBy?: User;
    /** The ID of the task. */
    readonly taskId?: string;
    /** The number of issues that the bulk operation was attempted on. */
    totalIssueCount?: number;
    /** A timestamp of when the task progress was last updated. */
    updated?: Date;

    constructor(data?: IBulkOperationProgress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            if (_data["failedAccessibleIssues"]) {
                this.failedAccessibleIssues = {} as any;
                for (let key in _data["failedAccessibleIssues"]) {
                    if (_data["failedAccessibleIssues"].hasOwnProperty(key))
                        (<any>this.failedAccessibleIssues)![key] = _data["failedAccessibleIssues"][key] !== undefined ? _data["failedAccessibleIssues"][key] : [];
                }
            }
            this.invalidOrInaccessibleIssueCount = _data["invalidOrInaccessibleIssueCount"];
            if (Array.isArray(_data["processedAccessibleIssues"])) {
                this.processedAccessibleIssues = [] as any;
                for (let item of _data["processedAccessibleIssues"])
                    this.processedAccessibleIssues!.push(item);
            }
            this.progressPercent = _data["progressPercent"];
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.submittedBy = _data["submittedBy"] ? User.fromJS(_data["submittedBy"]) : <any>undefined;
            (<any>this).taskId = _data["taskId"];
            this.totalIssueCount = _data["totalIssueCount"];
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BulkOperationProgress {
        data = typeof data === 'object' ? data : {};
        let result = new BulkOperationProgress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        if (this.failedAccessibleIssues) {
            data["failedAccessibleIssues"] = {};
            for (let key in this.failedAccessibleIssues) {
                if (this.failedAccessibleIssues.hasOwnProperty(key))
                    (<any>data["failedAccessibleIssues"])[key] = (<any>this.failedAccessibleIssues)[key];
            }
        }
        data["invalidOrInaccessibleIssueCount"] = this.invalidOrInaccessibleIssueCount;
        if (Array.isArray(this.processedAccessibleIssues)) {
            data["processedAccessibleIssues"] = [];
            for (let item of this.processedAccessibleIssues)
                data["processedAccessibleIssues"].push(item);
        }
        data["progressPercent"] = this.progressPercent;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["submittedBy"] = this.submittedBy ? this.submittedBy.toJSON() : <any>undefined;
        data["taskId"] = this.taskId;
        data["totalIssueCount"] = this.totalIssueCount;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBulkOperationProgress {
    /** A timestamp of when the task was submitted. */
    created?: Date;
    /** Map of issue IDs for which the operation failed and that the user has permission to view, to their one or more reasons for failure. These reasons are open-ended text descriptions of the error and are not selected from a predefined list of standard reasons. */
    failedAccessibleIssues?: { [key: string]: string[]; };
    /** The number of issues that are either invalid or issues that the user doesn't have permission to view, regardless of the success or failure of the operation. */
    invalidOrInaccessibleIssueCount?: number;
    /** List of issue IDs for which the operation was successful and that the user has permission to view. */
    processedAccessibleIssues?: number[];
    /** Progress of the task as a percentage. */
    progressPercent?: number;
    /** A timestamp of when the task was started. */
    started?: Date;
    /** The status of the task. */
    status?: BulkOperationProgressStatus;
    submittedBy?: User;
    /** The ID of the task. */
    taskId?: string;
    /** The number of issues that the bulk operation was attempted on. */
    totalIssueCount?: number;
    /** A timestamp of when the task progress was last updated. */
    updated?: Date;
}

/** Details of global and project permissions granted to the user. */
export class BulkPermissionGrants implements IBulkPermissionGrants {
    /** List of permissions granted to the user. */
    globalPermissions!: string[];
    /** List of project permissions and the projects and issues those permissions provide access to. */
    projectPermissions!: BulkProjectPermissionGrants[];

    constructor(data?: IBulkPermissionGrants) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.globalPermissions = [];
            this.projectPermissions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["globalPermissions"])) {
                this.globalPermissions = [] as any;
                for (let item of _data["globalPermissions"])
                    this.globalPermissions!.push(item);
            }
            if (Array.isArray(_data["projectPermissions"])) {
                this.projectPermissions = [] as any;
                for (let item of _data["projectPermissions"])
                    this.projectPermissions!.push(BulkProjectPermissionGrants.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkPermissionGrants {
        data = typeof data === 'object' ? data : {};
        let result = new BulkPermissionGrants();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.globalPermissions)) {
            data["globalPermissions"] = [];
            for (let item of this.globalPermissions)
                data["globalPermissions"].push(item);
        }
        if (Array.isArray(this.projectPermissions)) {
            data["projectPermissions"] = [];
            for (let item of this.projectPermissions)
                data["projectPermissions"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of global and project permissions granted to the user. */
export interface IBulkPermissionGrants {
    /** List of permissions granted to the user. */
    globalPermissions: string[];
    /** List of project permissions and the projects and issues those permissions provide access to. */
    projectPermissions: BulkProjectPermissionGrants[];
}

/** Details of global permissions to look up and project permissions with associated projects and issues to look up. */
export class BulkPermissionsRequestBean implements IBulkPermissionsRequestBean {
    /** The account ID of a user. */
    accountId?: string;
    /** Global permissions to look up. */
    globalPermissions?: string[];
    /** Project permissions with associated projects and issues to look up. */
    projectPermissions?: BulkProjectPermissions[];

    constructor(data?: IBulkPermissionsRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            if (Array.isArray(_data["globalPermissions"])) {
                this.globalPermissions = [] as any;
                for (let item of _data["globalPermissions"])
                    this.globalPermissions!.push(item);
            }
            if (Array.isArray(_data["projectPermissions"])) {
                this.projectPermissions = [] as any;
                for (let item of _data["projectPermissions"])
                    this.projectPermissions!.push(BulkProjectPermissions.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BulkPermissionsRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new BulkPermissionsRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        if (Array.isArray(this.globalPermissions)) {
            data["globalPermissions"] = [];
            for (let item of this.globalPermissions)
                data["globalPermissions"].push(item);
        }
        if (Array.isArray(this.projectPermissions)) {
            data["projectPermissions"] = [];
            for (let item of this.projectPermissions)
                data["projectPermissions"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of global permissions to look up and project permissions with associated projects and issues to look up. */
export interface IBulkPermissionsRequestBean {
    /** The account ID of a user. */
    accountId?: string;
    /** Global permissions to look up. */
    globalPermissions?: string[];
    /** Project permissions with associated projects and issues to look up. */
    projectPermissions?: BulkProjectPermissions[];
}

/** List of project permissions and the projects and issues those permissions grant access to. */
export class BulkProjectPermissionGrants implements IBulkProjectPermissionGrants {
    /** IDs of the issues the user has the permission for. */
    issues!: number[];
    /** A project permission, */
    permission!: string;
    /** IDs of the projects the user has the permission for. */
    projects!: number[];

    constructor(data?: IBulkProjectPermissionGrants) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issues = [];
            this.projects = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issues"])) {
                this.issues = [] as any;
                for (let item of _data["issues"])
                    this.issues!.push(item);
            }
            this.permission = _data["permission"];
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects!.push(item);
            }
        }
    }

    static fromJS(data: any): BulkProjectPermissionGrants {
        data = typeof data === 'object' ? data : {};
        let result = new BulkProjectPermissionGrants();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item);
        }
        data["permission"] = this.permission;
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item);
        }
        return data;
    }
}

/** List of project permissions and the projects and issues those permissions grant access to. */
export interface IBulkProjectPermissionGrants {
    /** IDs of the issues the user has the permission for. */
    issues: number[];
    /** A project permission, */
    permission: string;
    /** IDs of the projects the user has the permission for. */
    projects: number[];
}

/** Details of project permissions and associated issues and projects to look up. */
export class BulkProjectPermissions implements IBulkProjectPermissions {
    /** List of issue IDs. */
    issues?: number[];
    /** List of project permissions. */
    permissions!: string[];
    /** List of project IDs. */
    projects?: number[];

    constructor(data?: IBulkProjectPermissions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.permissions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issues"])) {
                this.issues = [] as any;
                for (let item of _data["issues"])
                    this.issues!.push(item);
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects!.push(item);
            }
        }
    }

    static fromJS(data: any): BulkProjectPermissions {
        data = typeof data === 'object' ? data : {};
        let result = new BulkProjectPermissions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item);
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item);
        }
        return data;
    }
}

/** Details of project permissions and associated issues and projects to look up. */
export interface IBulkProjectPermissions {
    /** List of issue IDs. */
    issues?: number[];
    /** List of project permissions. */
    permissions: string[];
    /** List of project IDs. */
    projects?: number[];
}

/** Bulk Transition Get Available Transitions Response. */
export class BulkTransitionGetAvailableTransitions implements IBulkTransitionGetAvailableTransitions {
    /** List of available transitions for bulk transition operation for requested issues grouped by workflow */
    readonly availableTransitions?: IssueBulkTransitionForWorkflow[];
    /** The end cursor for use in pagination. */
    readonly endingBefore?: string;
    /** The start cursor for use in pagination. */
    readonly startingAfter?: string;

    constructor(data?: IBulkTransitionGetAvailableTransitions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["availableTransitions"])) {
                (<any>this).availableTransitions = [] as any;
                for (let item of _data["availableTransitions"])
                    (<any>this).availableTransitions!.push(IssueBulkTransitionForWorkflow.fromJS(item));
            }
            (<any>this).endingBefore = _data["endingBefore"];
            (<any>this).startingAfter = _data["startingAfter"];
        }
    }

    static fromJS(data: any): BulkTransitionGetAvailableTransitions {
        data = typeof data === 'object' ? data : {};
        let result = new BulkTransitionGetAvailableTransitions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.availableTransitions)) {
            data["availableTransitions"] = [];
            for (let item of this.availableTransitions)
                data["availableTransitions"].push(item.toJSON());
        }
        data["endingBefore"] = this.endingBefore;
        data["startingAfter"] = this.startingAfter;
        return data;
    }
}

/** Bulk Transition Get Available Transitions Response. */
export interface IBulkTransitionGetAvailableTransitions {
    /** List of available transitions for bulk transition operation for requested issues grouped by workflow */
    availableTransitions?: IssueBulkTransitionForWorkflow[];
    /** The end cursor for use in pagination. */
    endingBefore?: string;
    /** The start cursor for use in pagination. */
    startingAfter?: string;
}

export class BulkTransitionSubmitInput implements IBulkTransitionSubmitInput {
    /** List of all the issue IDs or keys that are to be bulk transitioned. */
    selectedIssueIdsOrKeys!: string[];
    /** The ID of the transition that is to be performed on the issues. */
    transitionId!: string;

    constructor(data?: IBulkTransitionSubmitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.selectedIssueIdsOrKeys = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["selectedIssueIdsOrKeys"])) {
                this.selectedIssueIdsOrKeys = [] as any;
                for (let item of _data["selectedIssueIdsOrKeys"])
                    this.selectedIssueIdsOrKeys!.push(item);
            }
            this.transitionId = _data["transitionId"];
        }
    }

    static fromJS(data: any): BulkTransitionSubmitInput {
        data = typeof data === 'object' ? data : {};
        let result = new BulkTransitionSubmitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.selectedIssueIdsOrKeys)) {
            data["selectedIssueIdsOrKeys"] = [];
            for (let item of this.selectedIssueIdsOrKeys)
                data["selectedIssueIdsOrKeys"].push(item);
        }
        data["transitionId"] = this.transitionId;
        return data;
    }
}

export interface IBulkTransitionSubmitInput {
    /** List of all the issue IDs or keys that are to be bulk transitioned. */
    selectedIssueIdsOrKeys: string[];
    /** The ID of the transition that is to be performed on the issues. */
    transitionId: string;
}

/** Card layout configuration. */
export class CardLayout implements ICardLayout {
    /** Whether to show days in column */
    showDaysInColumn?: boolean;

    constructor(data?: ICardLayout) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.showDaysInColumn = boolean.False;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.showDaysInColumn = _data["showDaysInColumn"] !== undefined ? _data["showDaysInColumn"] : boolean.False;
        }
    }

    static fromJS(data: any): CardLayout {
        data = typeof data === 'object' ? data : {};
        let result = new CardLayout();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["showDaysInColumn"] = this.showDaysInColumn;
        return data;
    }
}

/** Card layout configuration. */
export interface ICardLayout {
    /** Whether to show days in column */
    showDaysInColumn?: boolean;
}

/** Card layout settings of the board */
export class CardLayoutField implements ICardLayoutField {
    fieldId?: string;
    id?: number;
    mode?: CardLayoutFieldMode;
    position?: number;

    constructor(data?: ICardLayoutField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.id = _data["id"];
            this.mode = _data["mode"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): CardLayoutField {
        data = typeof data === 'object' ? data : {};
        let result = new CardLayoutField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["id"] = this.id;
        data["mode"] = this.mode;
        data["position"] = this.position;
        return data;
    }
}

/** Card layout settings of the board */
export interface ICardLayoutField {
    fieldId?: string;
    id?: number;
    mode?: CardLayoutFieldMode;
    position?: number;
}

/** A change item. */
export class ChangeDetails implements IChangeDetails {
    /** The name of the field changed. */
    readonly field?: string;
    /** The ID of the field changed. */
    readonly fieldId?: string;
    /** The type of the field changed. */
    readonly fieldtype?: string;
    /** The details of the original value. */
    readonly from?: string;
    /** The details of the original value as a string. */
    readonly fromString?: string;
    /** The details of the new value. */
    readonly to?: string;
    /** The details of the new value as a string. */
    readonly toString?: string;

    constructor(data?: IChangeDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).field = _data["field"];
            (<any>this).fieldId = _data["fieldId"];
            (<any>this).fieldtype = _data["fieldtype"];
            (<any>this).from = _data["from"];
            (<any>this).fromString = _data["fromString"];
            (<any>this).to = _data["to"];
            (<any>this).toString = _data["toString"];
        }
    }

    static fromJS(data: any): ChangeDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["fieldId"] = this.fieldId;
        data["fieldtype"] = this.fieldtype;
        data["from"] = this.from;
        data["fromString"] = this.fromString;
        data["to"] = this.to;
        data["toString"] = this.toString;
        return data;
    }
}

/** A change item. */
export interface IChangeDetails {
    /** The name of the field changed. */
    field?: string;
    /** The ID of the field changed. */
    fieldId?: string;
    /** The type of the field changed. */
    fieldtype?: string;
    /** The details of the original value. */
    from?: string;
    /** The details of the original value as a string. */
    fromString?: string;
    /** The details of the new value. */
    to?: string;
    /** The details of the new value as a string. */
    toString?: string;
}

/** The account ID of the new owner. */
export class ChangeFilterOwner implements IChangeFilterOwner {
    /** The account ID of the new owner. */
    accountId!: string;

    constructor(data?: IChangeFilterOwner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
        }
    }

    static fromJS(data: any): ChangeFilterOwner {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeFilterOwner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        return data;
    }
}

/** The account ID of the new owner. */
export interface IChangeFilterOwner {
    /** The account ID of the new owner. */
    accountId: string;
}

/** Details of names changed in the record event. */
export class ChangedValueBean implements IChangedValueBean {
    /** The value of the field before the change. */
    readonly changedFrom?: string;
    /** The value of the field after the change. */
    readonly changedTo?: string;
    /** The name of the field changed. */
    readonly fieldName?: string;

    constructor(data?: IChangedValueBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).changedFrom = _data["changedFrom"];
            (<any>this).changedTo = _data["changedTo"];
            (<any>this).fieldName = _data["fieldName"];
        }
    }

    static fromJS(data: any): ChangedValueBean {
        data = typeof data === 'object' ? data : {};
        let result = new ChangedValueBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["changedFrom"] = this.changedFrom;
        data["changedTo"] = this.changedTo;
        data["fieldName"] = this.fieldName;
        return data;
    }
}

/** Details of names changed in the record event. */
export interface IChangedValueBean {
    /** The value of the field before the change. */
    changedFrom?: string;
    /** The value of the field after the change. */
    changedTo?: string;
    /** The name of the field changed. */
    fieldName?: string;
}

/** Details of a changed worklog. */
export class ChangedWorklog implements IChangedWorklog {
    /** Details of properties associated with the change. */
    readonly properties?: EntityProperty[];
    /** The datetime of the change. */
    readonly updatedTime?: number;
    /** The ID of the worklog. */
    readonly worklogId?: number;

    constructor(data?: IChangedWorklog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["properties"])) {
                (<any>this).properties = [] as any;
                for (let item of _data["properties"])
                    (<any>this).properties!.push(EntityProperty.fromJS(item));
            }
            (<any>this).updatedTime = _data["updatedTime"];
            (<any>this).worklogId = _data["worklogId"];
        }
    }

    static fromJS(data: any): ChangedWorklog {
        data = typeof data === 'object' ? data : {};
        let result = new ChangedWorklog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        data["updatedTime"] = this.updatedTime;
        data["worklogId"] = this.worklogId;
        return data;
    }
}

/** Details of a changed worklog. */
export interface IChangedWorklog {
    /** Details of properties associated with the change. */
    properties?: EntityProperty[];
    /** The datetime of the change. */
    updatedTime?: number;
    /** The ID of the worklog. */
    worklogId?: number;
}

/** List of changed worklogs. */
export class ChangedWorklogs implements IChangedWorklogs {
    lastPage?: boolean;
    /** The URL of the next list of changed worklogs. */
    readonly nextPage?: string;
    /** The URL of this changed worklogs list. */
    readonly self?: string;
    /** The datetime of the first worklog item in the list. */
    readonly since?: number;
    /** The datetime of the last worklog item in the list. */
    readonly until?: number;
    /** Changed worklog list. */
    readonly values?: ChangedWorklog[];

    constructor(data?: IChangedWorklogs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lastPage = _data["lastPage"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).since = _data["since"];
            (<any>this).until = _data["until"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(ChangedWorklog.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChangedWorklogs {
        data = typeof data === 'object' ? data : {};
        let result = new ChangedWorklogs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastPage"] = this.lastPage;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["since"] = this.since;
        data["until"] = this.until;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** List of changed worklogs. */
export interface IChangedWorklogs {
    lastPage?: boolean;
    /** The URL of the next list of changed worklogs. */
    nextPage?: string;
    /** The URL of this changed worklogs list. */
    self?: string;
    /** The datetime of the first worklog item in the list. */
    since?: number;
    /** The datetime of the last worklog item in the list. */
    until?: number;
    /** Changed worklog list. */
    values?: ChangedWorklog[];
}

/** A log of changes made to issue fields. Changelogs related to workflow associations are currently being deprecated. */
export class Changelog implements IChangelog {
    /** The user who made the change. */
    readonly author?: UserDetails;
    /** The date on which the change took place. */
    readonly created?: Date;
    /** The history metadata associated with the changed. */
    readonly historyMetadata?: HistoryMetadata;
    /** The ID of the changelog. */
    readonly id?: string;
    /** The list of items changed. */
    readonly items?: ChangeDetails[];

    constructor(data?: IChangelog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).author = _data["author"] ? UserDetails.fromJS(_data["author"]) : <any>undefined;
            (<any>this).created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            (<any>this).historyMetadata = _data["historyMetadata"] ? HistoryMetadata.fromJS(_data["historyMetadata"]) : <any>undefined;
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["items"])) {
                (<any>this).items = [] as any;
                for (let item of _data["items"])
                    (<any>this).items!.push(ChangeDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Changelog {
        data = typeof data === 'object' ? data : {};
        let result = new Changelog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["historyMetadata"] = this.historyMetadata ? this.historyMetadata.toJSON() : <any>undefined;
        data["id"] = this.id;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

/** A log of changes made to issue fields. Changelogs related to workflow associations are currently being deprecated. */
export interface IChangelog {
    /** The user who made the change. */
    author?: UserDetails;
    /** The date on which the change took place. */
    created?: Date;
    /** The history metadata associated with the changed. */
    historyMetadata?: HistoryMetadata;
    /** The ID of the changelog. */
    id?: string;
    /** The list of items changed. */
    items?: ChangeDetails[];
}

/** Details of an issue navigator column item. */
export class ColumnItem implements IColumnItem {
    /** The issue navigator column label. */
    label?: string;
    /** The issue navigator column value. */
    value?: string;

    constructor(data?: IColumnItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ColumnItem {
        data = typeof data === 'object' ? data : {};
        let result = new ColumnItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data;
    }
}

/** Details of an issue navigator column item. */
export interface IColumnItem {
    /** The issue navigator column label. */
    label?: string;
    /** The issue navigator column value. */
    value?: string;
}

export class ColumnRequestBody implements IColumnRequestBody {
    columns?: string[];

    constructor(data?: IColumnRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(item);
            }
        }
    }

    static fromJS(data: any): ColumnRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new ColumnRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item);
        }
        return data;
    }
}

export interface IColumnRequestBody {
    columns?: string[];
}

/** A comment. */
export class Comment implements IComment {
    /** The ID of the user who created the comment. */
    readonly author?: UserDetails;
    /** The comment text in [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure/). */
    body?: any;
    /** The date and time at which the comment was created. */
    readonly created?: Date;
    /** The ID of the comment. */
    readonly id?: string;
    /** Whether the comment was added from an email sent by a person who is not part of the issue. See [Allow external emails to be added as comments on issues](https://support.atlassian.com/jira-service-management-cloud/docs/allow-external-emails-to-be-added-as-comments-on-issues/)for information on setting up this feature. */
    readonly jsdAuthorCanSeeRequest?: boolean;
    /** Whether the comment is visible in Jira Service Desk. Defaults to true when comments are created in the Jira Cloud Platform. This includes when the site doesn't use Jira Service Desk or the project isn't a Jira Service Desk project and, therefore, there is no Jira Service Desk for the issue to be visible on. To create a comment with its visibility in Jira Service Desk set to false, use the Jira Service Desk REST API [Create request comment](https://developer.atlassian.com/cloud/jira/service-desk/rest/#api-rest-servicedeskapi-request-issueIdOrKey-comment-post) operation. */
    readonly jsdPublic?: boolean;
    /** A list of comment properties. Optional on create and update. */
    properties?: EntityProperty[];
    /** The rendered version of the comment. */
    readonly renderedBody?: string;
    /** The URL of the comment. */
    readonly self?: string;
    /** The ID of the user who updated the comment last. */
    readonly updateAuthor?: UserDetails;
    /** The date and time at which the comment was updated last. */
    readonly updated?: Date;
    /** The group or role to which this comment is visible. Optional on create and update. */
    visibility?: Visibility;

    [key: string]: any;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).author = _data["author"] ? UserDetails.fromJS(_data["author"]) : <any>undefined;
            this.body = _data["body"];
            (<any>this).created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            (<any>this).id = _data["id"];
            (<any>this).jsdAuthorCanSeeRequest = _data["jsdAuthorCanSeeRequest"];
            (<any>this).jsdPublic = _data["jsdPublic"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(EntityProperty.fromJS(item));
            }
            (<any>this).renderedBody = _data["renderedBody"];
            (<any>this).self = _data["self"];
            (<any>this).updateAuthor = _data["updateAuthor"] ? UserDetails.fromJS(_data["updateAuthor"]) : <any>undefined;
            (<any>this).updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
            this.visibility = _data["visibility"] ? Visibility.fromJS(_data["visibility"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["jsdAuthorCanSeeRequest"] = this.jsdAuthorCanSeeRequest;
        data["jsdPublic"] = this.jsdPublic;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        data["renderedBody"] = this.renderedBody;
        data["self"] = this.self;
        data["updateAuthor"] = this.updateAuthor ? this.updateAuthor.toJSON() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["visibility"] = this.visibility ? this.visibility.toJSON() : <any>undefined;
        return data;
    }
}

/** A comment. */
export interface IComment {
    /** The ID of the user who created the comment. */
    author?: UserDetails;
    /** The comment text in [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure/). */
    body?: any;
    /** The date and time at which the comment was created. */
    created?: Date;
    /** The ID of the comment. */
    id?: string;
    /** Whether the comment was added from an email sent by a person who is not part of the issue. See [Allow external emails to be added as comments on issues](https://support.atlassian.com/jira-service-management-cloud/docs/allow-external-emails-to-be-added-as-comments-on-issues/)for information on setting up this feature. */
    jsdAuthorCanSeeRequest?: boolean;
    /** Whether the comment is visible in Jira Service Desk. Defaults to true when comments are created in the Jira Cloud Platform. This includes when the site doesn't use Jira Service Desk or the project isn't a Jira Service Desk project and, therefore, there is no Jira Service Desk for the issue to be visible on. To create a comment with its visibility in Jira Service Desk set to false, use the Jira Service Desk REST API [Create request comment](https://developer.atlassian.com/cloud/jira/service-desk/rest/#api-rest-servicedeskapi-request-issueIdOrKey-comment-post) operation. */
    jsdPublic?: boolean;
    /** A list of comment properties. Optional on create and update. */
    properties?: EntityProperty[];
    /** The rendered version of the comment. */
    renderedBody?: string;
    /** The URL of the comment. */
    self?: string;
    /** The ID of the user who updated the comment last. */
    updateAuthor?: UserDetails;
    /** The date and time at which the comment was updated last. */
    updated?: Date;
    /** The group or role to which this comment is visible. Optional on create and update. */
    visibility?: Visibility;

    [key: string]: any;
}

/** Count of issues assigned to a component. */
export class ComponentIssuesCount implements IComponentIssuesCount {
    /** The count of issues assigned to a component. */
    readonly issueCount?: number;
    /** The URL for this count of issues for a component. */
    readonly self?: string;

    constructor(data?: IComponentIssuesCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).issueCount = _data["issueCount"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): ComponentIssuesCount {
        data = typeof data === 'object' ? data : {};
        let result = new ComponentIssuesCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueCount"] = this.issueCount;
        data["self"] = this.self;
        return data;
    }
}

/** Count of issues assigned to a component. */
export interface IComponentIssuesCount {
    /** The count of issues assigned to a component. */
    issueCount?: number;
    /** The URL for this count of issues for a component. */
    self?: string;
}

export class ComponentJsonBean implements IComponentJsonBean {
    ari?: string;
    description?: string;
    id?: string;
    metadata?: { [key: string]: string; };
    name?: string;
    self?: string;

    [key: string]: any;

    constructor(data?: IComponentJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.ari = _data["ari"];
            this.description = _data["description"];
            this.id = _data["id"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
            this.name = _data["name"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): ComponentJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new ComponentJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["ari"] = this.ari;
        data["description"] = this.description;
        data["id"] = this.id;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

export interface IComponentJsonBean {
    ari?: string;
    description?: string;
    id?: string;
    metadata?: { [key: string]: string; };
    name?: string;
    self?: string;

    [key: string]: any;
}

/** Details about a component with a count of the issues it contains. */
export class ComponentWithIssueCount implements IComponentWithIssueCount {
    /** The details of the user associated with `assigneeType`, if any. See `realAssignee` for details of the user assigned to issues created with this component. */
    assignee?: User;
    /** The nominal user type used to determine the assignee for issues created with this component. See `realAssigneeType` for details on how the type of the user, and hence the user, assigned to issues is determined. Takes the following values:

 *  `PROJECT_LEAD` the assignee to any issues created with this component is nominally the lead for the project the component is in.
 *  `COMPONENT_LEAD` the assignee to any issues created with this component is nominally the lead for the component.
 *  `UNASSIGNED` an assignee is not set for issues created with this component.
 *  `PROJECT_DEFAULT` the assignee to any issues created with this component is nominally the default assignee for the project that the component is in. */
    readonly assigneeType?: ComponentWithIssueCountAssigneeType;
    /** The description for the component. */
    readonly description?: string;
    /** The unique identifier for the component. */
    readonly id?: string;
    /** Whether a user is associated with `assigneeType`. For example, if the `assigneeType` is set to `COMPONENT_LEAD` but the component lead is not set, then `false` is returned. */
    readonly isAssigneeTypeValid?: boolean;
    /** Count of issues for the component. */
    readonly issueCount?: number;
    /** The user details for the component's lead user. */
    lead?: User;
    /** The name for the component. */
    readonly name?: string;
    /** The key of the project to which the component is assigned. */
    readonly project?: string;
    /** Not used. */
    readonly projectId?: number;
    /** The user assigned to issues created with this component, when `assigneeType` does not identify a valid assignee. */
    realAssignee?: User;
    /** The type of the assignee that is assigned to issues created with this component, when an assignee cannot be set from the `assigneeType`. For example, `assigneeType` is set to `COMPONENT_LEAD` but no component lead is set. This property is set to one of the following values:

 *  `PROJECT_LEAD` when `assigneeType` is `PROJECT_LEAD` and the project lead has permission to be assigned issues in the project that the component is in.
 *  `COMPONENT_LEAD` when `assignee`Type is `COMPONENT_LEAD` and the component lead has permission to be assigned issues in the project that the component is in.
 *  `UNASSIGNED` when `assigneeType` is `UNASSIGNED` and Jira is configured to allow unassigned issues.
 *  `PROJECT_DEFAULT` when none of the preceding cases are true. */
    readonly realAssigneeType?: ComponentWithIssueCountRealAssigneeType;
    /** The URL for this count of the issues contained in the component. */
    readonly self?: string;

    constructor(data?: IComponentWithIssueCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assignee = _data["assignee"] ? User.fromJS(_data["assignee"]) : <any>undefined;
            (<any>this).assigneeType = _data["assigneeType"];
            (<any>this).description = _data["description"];
            (<any>this).id = _data["id"];
            (<any>this).isAssigneeTypeValid = _data["isAssigneeTypeValid"];
            (<any>this).issueCount = _data["issueCount"];
            this.lead = _data["lead"] ? User.fromJS(_data["lead"]) : <any>undefined;
            (<any>this).name = _data["name"];
            (<any>this).project = _data["project"];
            (<any>this).projectId = _data["projectId"];
            this.realAssignee = _data["realAssignee"] ? User.fromJS(_data["realAssignee"]) : <any>undefined;
            (<any>this).realAssigneeType = _data["realAssigneeType"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): ComponentWithIssueCount {
        data = typeof data === 'object' ? data : {};
        let result = new ComponentWithIssueCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assignee"] = this.assignee ? this.assignee.toJSON() : <any>undefined;
        data["assigneeType"] = this.assigneeType;
        data["description"] = this.description;
        data["id"] = this.id;
        data["isAssigneeTypeValid"] = this.isAssigneeTypeValid;
        data["issueCount"] = this.issueCount;
        data["lead"] = this.lead ? this.lead.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["project"] = this.project;
        data["projectId"] = this.projectId;
        data["realAssignee"] = this.realAssignee ? this.realAssignee.toJSON() : <any>undefined;
        data["realAssigneeType"] = this.realAssigneeType;
        data["self"] = this.self;
        return data;
    }
}

/** Details about a component with a count of the issues it contains. */
export interface IComponentWithIssueCount {
    /** The details of the user associated with `assigneeType`, if any. See `realAssignee` for details of the user assigned to issues created with this component. */
    assignee?: User;
    /** The nominal user type used to determine the assignee for issues created with this component. See `realAssigneeType` for details on how the type of the user, and hence the user, assigned to issues is determined. Takes the following values:

 *  `PROJECT_LEAD` the assignee to any issues created with this component is nominally the lead for the project the component is in.
 *  `COMPONENT_LEAD` the assignee to any issues created with this component is nominally the lead for the component.
 *  `UNASSIGNED` an assignee is not set for issues created with this component.
 *  `PROJECT_DEFAULT` the assignee to any issues created with this component is nominally the default assignee for the project that the component is in. */
    assigneeType?: ComponentWithIssueCountAssigneeType;
    /** The description for the component. */
    description?: string;
    /** The unique identifier for the component. */
    id?: string;
    /** Whether a user is associated with `assigneeType`. For example, if the `assigneeType` is set to `COMPONENT_LEAD` but the component lead is not set, then `false` is returned. */
    isAssigneeTypeValid?: boolean;
    /** Count of issues for the component. */
    issueCount?: number;
    /** The user details for the component's lead user. */
    lead?: User;
    /** The name for the component. */
    name?: string;
    /** The key of the project to which the component is assigned. */
    project?: string;
    /** Not used. */
    projectId?: number;
    /** The user assigned to issues created with this component, when `assigneeType` does not identify a valid assignee. */
    realAssignee?: User;
    /** The type of the assignee that is assigned to issues created with this component, when an assignee cannot be set from the `assigneeType`. For example, `assigneeType` is set to `COMPONENT_LEAD` but no component lead is set. This property is set to one of the following values:

 *  `PROJECT_LEAD` when `assigneeType` is `PROJECT_LEAD` and the project lead has permission to be assigned issues in the project that the component is in.
 *  `COMPONENT_LEAD` when `assignee`Type is `COMPONENT_LEAD` and the component lead has permission to be assigned issues in the project that the component is in.
 *  `UNASSIGNED` when `assigneeType` is `UNASSIGNED` and Jira is configured to allow unassigned issues.
 *  `PROJECT_DEFAULT` when none of the preceding cases are true. */
    realAssigneeType?: ComponentWithIssueCountRealAssigneeType;
    /** The URL for this count of the issues contained in the component. */
    self?: string;
}

/** A JQL query clause that consists of nested clauses. For example, `(labels in (urgent, blocker) OR lastCommentedBy = currentUser()). Note that, where nesting is not defined, the parser nests JQL clauses based on the operator precedence. For example, "A OR B AND C" is parsed as "(A OR B) AND C". See Setting the precedence of operators for more information about precedence in JQL queries.` */
export class CompoundClause implements ICompoundClause {
    /** The list of nested clauses. */
    clauses!: JqlQueryClause[];
    /** The operator between the clauses. */
    operator!: CompoundClauseOperator;

    [key: string]: any;

    constructor(data?: ICompoundClause) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.clauses = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["clauses"])) {
                this.clauses = [] as any;
                for (let item of _data["clauses"])
                    this.clauses!.push(JqlQueryClause.fromJS(item));
            }
            this.operator = _data["operator"];
        }
    }

    static fromJS(data: any): CompoundClause {
        data = typeof data === 'object' ? data : {};
        let result = new CompoundClause();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.clauses)) {
            data["clauses"] = [];
            for (let item of this.clauses)
                data["clauses"].push(item.toJSON());
        }
        data["operator"] = this.operator;
        return data;
    }
}

/** A JQL query clause that consists of nested clauses. For example, `(labels in (urgent, blocker) OR lastCommentedBy = currentUser()). Note that, where nesting is not defined, the parser nests JQL clauses based on the operator precedence. For example, "A OR B AND C" is parsed as "(A OR B) AND C". See Setting the precedence of operators for more information about precedence in JQL queries.` */
export interface ICompoundClause {
    /** The list of nested clauses. */
    clauses: JqlQueryClause[];
    /** The operator between the clauses. */
    operator: CompoundClauseOperator;

    [key: string]: any;
}

/** The conditions group associated with the transition. */
export class ConditionGroupConfiguration implements IConditionGroupConfiguration {
    /** The nested conditions of the condition group. */
    conditionGroups?: (ConditionGroupConfiguration | undefined)[];
    /** The rules for this condition. */
    conditions?: (WorkflowRuleConfiguration | undefined)[];
    /** Determines how the conditions in the group are evaluated. Accepts either `ANY` or `ALL`. If `ANY` is used, at least one condition in the group must be true for the group to evaluate to true. If `ALL` is used, all conditions in the group must be true for the group to evaluate to true. */
    operation?: ConditionGroupConfigurationOperation;

    constructor(data?: IConditionGroupConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["conditionGroups"])) {
                this.conditionGroups = [] as any;
                for (let item of _data["conditionGroups"])
                    this.conditionGroups!.push(ConditionGroupConfiguration.fromJS(item));
            }
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(WorkflowRuleConfiguration.fromJS(item));
            }
            this.operation = _data["operation"];
        }
    }

    static fromJS(data: any): ConditionGroupConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionGroupConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.conditionGroups)) {
            data["conditionGroups"] = [];
            for (let item of this.conditionGroups)
                data["conditionGroups"].push(item.toJSON());
        }
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["operation"] = this.operation;
        return data;
    }
}

/** The conditions group associated with the transition. */
export interface IConditionGroupConfiguration {
    /** The nested conditions of the condition group. */
    conditionGroups?: (ConditionGroupConfiguration | undefined)[];
    /** The rules for this condition. */
    conditions?: (WorkflowRuleConfiguration | undefined)[];
    /** Determines how the conditions in the group are evaluated. Accepts either `ANY` or `ALL`. If `ANY` is used, at least one condition in the group must be true for the group to evaluate to true. If `ALL` is used, all conditions in the group must be true for the group to evaluate to true. */
    operation?: ConditionGroupConfigurationOperation;
}

/** The payload for creating a condition group in a workflow */
export class ConditionGroupPayload implements IConditionGroupPayload {
    /** The nested conditions of the condition group. */
    conditionGroup?: ConditionGroupPayload[];
    /** The rules for this condition. */
    conditions?: RulePayload[];
    /** Determines how the conditions in the group are evaluated. Accepts either `ANY` or `ALL`. If `ANY` is used, at least one condition in the group must be true for the group to evaluate to true. If `ALL` is used, all conditions in the group must be true for the group to evaluate to true. */
    operation?: ConditionGroupPayloadOperation;

    constructor(data?: IConditionGroupPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["conditionGroup"])) {
                this.conditionGroup = [] as any;
                for (let item of _data["conditionGroup"])
                    this.conditionGroup!.push(ConditionGroupPayload.fromJS(item));
            }
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(RulePayload.fromJS(item));
            }
            this.operation = _data["operation"];
        }
    }

    static fromJS(data: any): ConditionGroupPayload {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionGroupPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.conditionGroup)) {
            data["conditionGroup"] = [];
            for (let item of this.conditionGroup)
                data["conditionGroup"].push(item.toJSON());
        }
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["operation"] = this.operation;
        return data;
    }
}

/** The payload for creating a condition group in a workflow */
export interface IConditionGroupPayload {
    /** The nested conditions of the condition group. */
    conditionGroup?: ConditionGroupPayload[];
    /** The rules for this condition. */
    conditions?: RulePayload[];
    /** Determines how the conditions in the group are evaluated. Accepts either `ANY` or `ALL`. If `ANY` is used, at least one condition in the group must be true for the group to evaluate to true. If `ALL` is used, all conditions in the group must be true for the group to evaluate to true. */
    operation?: ConditionGroupPayloadOperation;
}

/** The conditions group associated with the transition. */
export class ConditionGroupUpdate implements IConditionGroupUpdate {
    /** The nested conditions of the condition group. */
    conditionGroups?: (ConditionGroupUpdate | undefined)[];
    /** The rules for this condition. */
    conditions?: (WorkflowRuleConfiguration | undefined)[];
    /** Determines how the conditions in the group are evaluated. Accepts either `ANY` or `ALL`. If `ANY` is used, at least one condition in the group must be true for the group to evaluate to true. If `ALL` is used, all conditions in the group must be true for the group to evaluate to true. */
    operation!: ConditionGroupUpdateOperation;

    constructor(data?: IConditionGroupUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["conditionGroups"])) {
                this.conditionGroups = [] as any;
                for (let item of _data["conditionGroups"])
                    this.conditionGroups!.push(ConditionGroupUpdate.fromJS(item));
            }
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(WorkflowRuleConfiguration.fromJS(item));
            }
            this.operation = _data["operation"];
        }
    }

    static fromJS(data: any): ConditionGroupUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionGroupUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.conditionGroups)) {
            data["conditionGroups"] = [];
            for (let item of this.conditionGroups)
                data["conditionGroups"].push(item.toJSON());
        }
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["operation"] = this.operation;
        return data;
    }
}

/** The conditions group associated with the transition. */
export interface IConditionGroupUpdate {
    /** The nested conditions of the condition group. */
    conditionGroups?: (ConditionGroupUpdate | undefined)[];
    /** The rules for this condition. */
    conditions?: (WorkflowRuleConfiguration | undefined)[];
    /** Determines how the conditions in the group are evaluated. Accepts either `ANY` or `ALL`. If `ANY` is used, at least one condition in the group must be true for the group to evaluate to true. If `ALL` is used, all conditions in the group must be true for the group to evaluate to true. */
    operation: ConditionGroupUpdateOperation;
}

/** Details about the configuration of Jira. */
export class Configuration implements IConfiguration {
    /** Whether the ability to add attachments to issues is enabled. */
    readonly attachmentsEnabled?: boolean;
    /** Whether the ability to link issues is enabled. */
    readonly issueLinkingEnabled?: boolean;
    /** Whether the ability to create subtasks for issues is enabled. */
    readonly subTasksEnabled?: boolean;
    /** The configuration of time tracking. */
    readonly timeTrackingConfiguration?: TimeTrackingConfiguration;
    /** Whether the ability to track time is enabled. This property is deprecated. */
    readonly timeTrackingEnabled?: boolean;
    /** Whether the ability to create unassigned issues is enabled. See [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM) for details. */
    readonly unassignedIssuesAllowed?: boolean;
    /** Whether the ability for users to vote on issues is enabled. See [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM) for details. */
    readonly votingEnabled?: boolean;
    /** Whether the ability for users to watch issues is enabled. See [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM) for details. */
    readonly watchingEnabled?: boolean;

    constructor(data?: IConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).attachmentsEnabled = _data["attachmentsEnabled"];
            (<any>this).issueLinkingEnabled = _data["issueLinkingEnabled"];
            (<any>this).subTasksEnabled = _data["subTasksEnabled"];
            (<any>this).timeTrackingConfiguration = _data["timeTrackingConfiguration"] ? TimeTrackingConfiguration.fromJS(_data["timeTrackingConfiguration"]) : <any>undefined;
            (<any>this).timeTrackingEnabled = _data["timeTrackingEnabled"];
            (<any>this).unassignedIssuesAllowed = _data["unassignedIssuesAllowed"];
            (<any>this).votingEnabled = _data["votingEnabled"];
            (<any>this).watchingEnabled = _data["watchingEnabled"];
        }
    }

    static fromJS(data: any): Configuration {
        data = typeof data === 'object' ? data : {};
        let result = new Configuration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attachmentsEnabled"] = this.attachmentsEnabled;
        data["issueLinkingEnabled"] = this.issueLinkingEnabled;
        data["subTasksEnabled"] = this.subTasksEnabled;
        data["timeTrackingConfiguration"] = this.timeTrackingConfiguration ? this.timeTrackingConfiguration.toJSON() : <any>undefined;
        data["timeTrackingEnabled"] = this.timeTrackingEnabled;
        data["unassignedIssuesAllowed"] = this.unassignedIssuesAllowed;
        data["votingEnabled"] = this.votingEnabled;
        data["watchingEnabled"] = this.watchingEnabled;
        return data;
    }
}

/** Details about the configuration of Jira. */
export interface IConfiguration {
    /** Whether the ability to add attachments to issues is enabled. */
    attachmentsEnabled?: boolean;
    /** Whether the ability to link issues is enabled. */
    issueLinkingEnabled?: boolean;
    /** Whether the ability to create subtasks for issues is enabled. */
    subTasksEnabled?: boolean;
    /** The configuration of time tracking. */
    timeTrackingConfiguration?: TimeTrackingConfiguration;
    /** Whether the ability to track time is enabled. This property is deprecated. */
    timeTrackingEnabled?: boolean;
    /** Whether the ability to create unassigned issues is enabled. See [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM) for details. */
    unassignedIssuesAllowed?: boolean;
    /** Whether the ability for users to vote on issues is enabled. See [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM) for details. */
    votingEnabled?: boolean;
    /** Whether the ability for users to watch issues is enabled. See [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM) for details. */
    watchingEnabled?: boolean;
}

/** List of custom fields identifiers which will be used to filter configurations */
export class ConfigurationsListParameters implements IConfigurationsListParameters {
    /** List of IDs or keys of the custom fields. It can be a mix of IDs and keys in the same query. */
    fieldIdsOrKeys!: string[];

    constructor(data?: IConfigurationsListParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fieldIdsOrKeys = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fieldIdsOrKeys"])) {
                this.fieldIdsOrKeys = [] as any;
                for (let item of _data["fieldIdsOrKeys"])
                    this.fieldIdsOrKeys!.push(item);
            }
        }
    }

    static fromJS(data: any): ConfigurationsListParameters {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationsListParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fieldIdsOrKeys)) {
            data["fieldIdsOrKeys"] = [];
            for (let item of this.fieldIdsOrKeys)
                data["fieldIdsOrKeys"].push(item);
        }
        return data;
    }
}

/** List of custom fields identifiers which will be used to filter configurations */
export interface IConfigurationsListParameters {
    /** List of IDs or keys of the custom fields. It can be a mix of IDs and keys in the same query. */
    fieldIdsOrKeys: string[];
}

/** A list of custom field details. */
export class ConnectCustomFieldValue implements IConnectCustomFieldValue {
    /** The type of custom field. */
    _type!: ConnectCustomFieldValue_type;
    /** The custom field ID. */
    fieldID!: number;
    /** The issue ID. */
    issueID!: number;
    /** The value of number type custom field when `_type` is `NumberIssueField`. */
    number?: number;
    /** The value of single select and multiselect custom field type when `_type` is `SingleSelectIssueField` or `MultiSelectIssueField`. */
    optionID?: string;
    /** The value of richText type custom field when `_type` is `RichTextIssueField`. */
    richText?: string;
    /** The value of string type custom field when `_type` is `StringIssueField`. */
    string?: string;
    /** The value of of text custom field type when `_type` is `TextIssueField`. */
    text?: string;

    [key: string]: any;

    constructor(data?: IConnectCustomFieldValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this._type = _data["_type"];
            this.fieldID = _data["fieldID"];
            this.issueID = _data["issueID"];
            this.number = _data["number"];
            this.optionID = _data["optionID"];
            this.richText = _data["richText"];
            this.string = _data["string"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): ConnectCustomFieldValue {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectCustomFieldValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["_type"] = this._type;
        data["fieldID"] = this.fieldID;
        data["issueID"] = this.issueID;
        data["number"] = this.number;
        data["optionID"] = this.optionID;
        data["richText"] = this.richText;
        data["string"] = this.string;
        data["text"] = this.text;
        return data;
    }
}

/** A list of custom field details. */
export interface IConnectCustomFieldValue {
    /** The type of custom field. */
    _type: ConnectCustomFieldValue_type;
    /** The custom field ID. */
    fieldID: number;
    /** The issue ID. */
    issueID: number;
    /** The value of number type custom field when `_type` is `NumberIssueField`. */
    number?: number;
    /** The value of single select and multiselect custom field type when `_type` is `SingleSelectIssueField` or `MultiSelectIssueField`. */
    optionID?: string;
    /** The value of richText type custom field when `_type` is `RichTextIssueField`. */
    richText?: string;
    /** The value of string type custom field when `_type` is `StringIssueField`. */
    string?: string;
    /** The value of of text custom field type when `_type` is `TextIssueField`. */
    text?: string;

    [key: string]: any;
}

/** Details of updates for a custom field. */
export class ConnectCustomFieldValues implements IConnectCustomFieldValues {
    /** The list of custom field update details. */
    updateValueList?: ConnectCustomFieldValue[];

    constructor(data?: IConnectCustomFieldValues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["updateValueList"])) {
                this.updateValueList = [] as any;
                for (let item of _data["updateValueList"])
                    this.updateValueList!.push(ConnectCustomFieldValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConnectCustomFieldValues {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectCustomFieldValues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.updateValueList)) {
            data["updateValueList"] = [];
            for (let item of this.updateValueList)
                data["updateValueList"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of updates for a custom field. */
export interface IConnectCustomFieldValues {
    /** The list of custom field update details. */
    updateValueList?: ConnectCustomFieldValue[];
}

/** A [Connect module](https://developer.atlassian.com/cloud/jira/platform/about-jira-modules/) in the same format as in the [app descriptor](https://developer.atlassian.com/cloud/jira/platform/app-descriptor/). */
export class ConnectModule implements IConnectModule {

    [key: string]: any;

    constructor(data?: IConnectModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): ConnectModule {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectModule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

/** A [Connect module](https://developer.atlassian.com/cloud/jira/platform/about-jira-modules/) in the same format as in the [app descriptor](https://developer.atlassian.com/cloud/jira/platform/app-descriptor/). */
export interface IConnectModule {

    [key: string]: any;
}

export class ConnectModules implements IConnectModules {
    /** A list of app modules in the same format as the `modules` property in the
[app descriptor](https://developer.atlassian.com/cloud/jira/platform/app-descriptor/). */
    modules!: ConnectModule[];

    [key: string]: any;

    constructor(data?: IConnectModules) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.modules = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["modules"])) {
                this.modules = [] as any;
                for (let item of _data["modules"])
                    this.modules!.push(ConnectModule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConnectModules {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectModules();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        return data;
    }
}

export interface IConnectModules {
    /** A list of app modules in the same format as the `modules` property in the
[app descriptor](https://developer.atlassian.com/cloud/jira/platform/app-descriptor/). */
    modules: ConnectModule[];

    [key: string]: any;
}

/** A workflow transition rule. */
export class ConnectWorkflowTransitionRule implements IConnectWorkflowTransitionRule {
    configuration!: RuleConfiguration;
    /** The ID of the transition rule. */
    id!: string;
    /** The key of the rule, as defined in the Connect app descriptor. */
    key!: string;
    transition?: WorkflowTransition;

    [key: string]: any;

    constructor(data?: IConnectWorkflowTransitionRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.configuration = new RuleConfiguration();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.configuration = _data["configuration"] ? RuleConfiguration.fromJS(_data["configuration"]) : new RuleConfiguration();
            this.id = _data["id"];
            this.key = _data["key"];
            this.transition = _data["transition"] ? WorkflowTransition.fromJS(_data["transition"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConnectWorkflowTransitionRule {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectWorkflowTransitionRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["configuration"] = this.configuration ? this.configuration.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["key"] = this.key;
        data["transition"] = this.transition ? this.transition.toJSON() : <any>undefined;
        return data;
    }
}

/** A workflow transition rule. */
export interface IConnectWorkflowTransitionRule {
    configuration: RuleConfiguration;
    /** The ID of the transition rule. */
    id: string;
    /** The key of the rule, as defined in the Connect app descriptor. */
    key: string;
    transition?: WorkflowTransition;

    [key: string]: any;
}

/** The list of features on a project. */
export class ContainerForProjectFeatures implements IContainerForProjectFeatures {
    /** The project features. */
    features?: ProjectFeature[];

    constructor(data?: IContainerForProjectFeatures) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(ProjectFeature.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContainerForProjectFeatures {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerForProjectFeatures();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

/** The list of features on a project. */
export interface IContainerForProjectFeatures {
    /** The project features. */
    features?: ProjectFeature[];
}

/** Container for a list of registered webhooks. Webhook details are returned in the same order as the request. */
export class ContainerForRegisteredWebhooks implements IContainerForRegisteredWebhooks {
    /** A list of registered webhooks. */
    webhookRegistrationResult?: RegisteredWebhook[];

    constructor(data?: IContainerForRegisteredWebhooks) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["webhookRegistrationResult"])) {
                this.webhookRegistrationResult = [] as any;
                for (let item of _data["webhookRegistrationResult"])
                    this.webhookRegistrationResult!.push(RegisteredWebhook.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContainerForRegisteredWebhooks {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerForRegisteredWebhooks();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.webhookRegistrationResult)) {
            data["webhookRegistrationResult"] = [];
            for (let item of this.webhookRegistrationResult)
                data["webhookRegistrationResult"].push(item.toJSON());
        }
        return data;
    }
}

/** Container for a list of registered webhooks. Webhook details are returned in the same order as the request. */
export interface IContainerForRegisteredWebhooks {
    /** A list of registered webhooks. */
    webhookRegistrationResult?: RegisteredWebhook[];
}

/** Container for a list of webhook IDs. */
export class ContainerForWebhookIDs implements IContainerForWebhookIDs {
    /** A list of webhook IDs. */
    webhookIds!: number[];

    constructor(data?: IContainerForWebhookIDs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.webhookIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["webhookIds"])) {
                this.webhookIds = [] as any;
                for (let item of _data["webhookIds"])
                    this.webhookIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ContainerForWebhookIDs {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerForWebhookIDs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.webhookIds)) {
            data["webhookIds"] = [];
            for (let item of this.webhookIds)
                data["webhookIds"].push(item);
        }
        return data;
    }
}

/** Container for a list of webhook IDs. */
export interface IContainerForWebhookIDs {
    /** A list of webhook IDs. */
    webhookIds: number[];
}

/** A container for a list of workflow schemes together with the projects they are associated with. */
export class ContainerOfWorkflowSchemeAssociations implements IContainerOfWorkflowSchemeAssociations {
    /** A list of workflow schemes together with projects they are associated with. */
    values!: WorkflowSchemeAssociations[];

    constructor(data?: IContainerOfWorkflowSchemeAssociations) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.values = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(WorkflowSchemeAssociations.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContainerOfWorkflowSchemeAssociations {
        data = typeof data === 'object' ? data : {};
        let result = new ContainerOfWorkflowSchemeAssociations();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A container for a list of workflow schemes together with the projects they are associated with. */
export interface IContainerOfWorkflowSchemeAssociations {
    /** A list of workflow schemes together with projects they are associated with. */
    values: WorkflowSchemeAssociations[];
}

/** A context. */
export class Context implements IContext {
    /** The ID of the context. */
    readonly id?: number;
    /** The name of the context. */
    readonly name?: string;
    /** The scope of the context. */
    scope?: Scope;

    constructor(data?: IContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            this.scope = _data["scope"] ? Scope.fromJS(_data["scope"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Context {
        data = typeof data === 'object' ? data : {};
        let result = new Context();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        return data;
    }
}

/** A context. */
export interface IContext {
    /** The ID of the context. */
    id?: number;
    /** The name of the context. */
    name?: string;
    /** The scope of the context. */
    scope?: Scope;
}

/** The project and issue type mapping with a matching custom field context. */
export class ContextForProjectAndIssueType implements IContextForProjectAndIssueType {
    /** The ID of the custom field context. */
    contextId!: string;
    /** The ID of the issue type. */
    issueTypeId!: string;
    /** The ID of the project. */
    projectId!: string;

    constructor(data?: IContextForProjectAndIssueType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contextId = _data["contextId"];
            this.issueTypeId = _data["issueTypeId"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): ContextForProjectAndIssueType {
        data = typeof data === 'object' ? data : {};
        let result = new ContextForProjectAndIssueType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contextId"] = this.contextId;
        data["issueTypeId"] = this.issueTypeId;
        data["projectId"] = this.projectId;
        return data;
    }
}

/** The project and issue type mapping with a matching custom field context. */
export interface IContextForProjectAndIssueType {
    /** The ID of the custom field context. */
    contextId: string;
    /** The ID of the issue type. */
    issueTypeId: string;
    /** The ID of the project. */
    projectId: string;
}

/** Details of the contextual configuration for a custom field. */
export class ContextualConfiguration implements IContextualConfiguration {
    /** The field configuration. */
    configuration?: any;
    /** The ID of the field context the configuration is associated with. */
    readonly fieldContextId!: string;
    /** The ID of the configuration. */
    id!: string;
    /** The field value schema. */
    schema?: any;

    constructor(data?: IContextualConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.configuration = _data["configuration"];
            (<any>this).fieldContextId = _data["fieldContextId"];
            this.id = _data["id"];
            this.schema = _data["schema"];
        }
    }

    static fromJS(data: any): ContextualConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new ContextualConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["configuration"] = this.configuration;
        data["fieldContextId"] = this.fieldContextId;
        data["id"] = this.id;
        data["schema"] = this.schema;
        return data;
    }
}

/** Details of the contextual configuration for a custom field. */
export interface IContextualConfiguration {
    /** The field configuration. */
    configuration?: any;
    /** The ID of the field context the configuration is associated with. */
    fieldContextId: string;
    /** The ID of the configuration. */
    id: string;
    /** The field value schema. */
    schema?: any;
}

/** The converted JQL queries. */
export class ConvertedJQLQueries implements IConvertedJQLQueries {
    /** List of queries containing user information that could not be mapped to an existing user */
    queriesWithUnknownUsers?: JQLQueryWithUnknownUsers[];
    /** The list of converted query strings with account IDs in place of user identifiers. */
    queryStrings?: string[];

    constructor(data?: IConvertedJQLQueries) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["queriesWithUnknownUsers"])) {
                this.queriesWithUnknownUsers = [] as any;
                for (let item of _data["queriesWithUnknownUsers"])
                    this.queriesWithUnknownUsers!.push(JQLQueryWithUnknownUsers.fromJS(item));
            }
            if (Array.isArray(_data["queryStrings"])) {
                this.queryStrings = [] as any;
                for (let item of _data["queryStrings"])
                    this.queryStrings!.push(item);
            }
        }
    }

    static fromJS(data: any): ConvertedJQLQueries {
        data = typeof data === 'object' ? data : {};
        let result = new ConvertedJQLQueries();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queriesWithUnknownUsers)) {
            data["queriesWithUnknownUsers"] = [];
            for (let item of this.queriesWithUnknownUsers)
                data["queriesWithUnknownUsers"].push(item.toJSON());
        }
        if (Array.isArray(this.queryStrings)) {
            data["queryStrings"] = [];
            for (let item of this.queryStrings)
                data["queryStrings"].push(item);
        }
        return data;
    }
}

/** The converted JQL queries. */
export interface IConvertedJQLQueries {
    /** List of queries containing user information that could not be mapped to an existing user */
    queriesWithUnknownUsers?: JQLQueryWithUnknownUsers[];
    /** The list of converted query strings with account IDs in place of user identifiers. */
    queryStrings?: string[];
}

export class CreateCrossProjectReleaseRequest implements ICreateCrossProjectReleaseRequest {
    /** The cross-project release name. */
    name!: string;
    /** The IDs of the releases to include in the cross-project release. */
    releaseIds?: number[];

    constructor(data?: ICreateCrossProjectReleaseRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["releaseIds"])) {
                this.releaseIds = [] as any;
                for (let item of _data["releaseIds"])
                    this.releaseIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateCrossProjectReleaseRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCrossProjectReleaseRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.releaseIds)) {
            data["releaseIds"] = [];
            for (let item of this.releaseIds)
                data["releaseIds"].push(item);
        }
        return data;
    }
}

export interface ICreateCrossProjectReleaseRequest {
    /** The cross-project release name. */
    name: string;
    /** The IDs of the releases to include in the cross-project release. */
    releaseIds?: number[];
}

/** The details of a created custom field context. */
export class CreateCustomFieldContext implements ICreateCustomFieldContext {
    /** The description of the context. */
    description?: string;
    /** The ID of the context. */
    readonly id?: string;
    /** The list of issue types IDs for the context. If the list is empty, the context refers to all issue types. */
    issueTypeIds?: string[];
    /** The name of the context. */
    name!: string;
    /** The list of project IDs associated with the context. If the list is empty, the context is global. */
    projectIds?: string[];

    constructor(data?: ICreateCustomFieldContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["issueTypeIds"])) {
                this.issueTypeIds = [] as any;
                for (let item of _data["issueTypeIds"])
                    this.issueTypeIds!.push(item);
            }
            this.name = _data["name"];
            if (Array.isArray(_data["projectIds"])) {
                this.projectIds = [] as any;
                for (let item of _data["projectIds"])
                    this.projectIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateCustomFieldContext {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomFieldContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        if (Array.isArray(this.issueTypeIds)) {
            data["issueTypeIds"] = [];
            for (let item of this.issueTypeIds)
                data["issueTypeIds"].push(item);
        }
        data["name"] = this.name;
        if (Array.isArray(this.projectIds)) {
            data["projectIds"] = [];
            for (let item of this.projectIds)
                data["projectIds"].push(item);
        }
        return data;
    }
}

/** The details of a created custom field context. */
export interface ICreateCustomFieldContext {
    /** The description of the context. */
    description?: string;
    /** The ID of the context. */
    id?: string;
    /** The list of issue types IDs for the context. If the list is empty, the context refers to all issue types. */
    issueTypeIds?: string[];
    /** The name of the context. */
    name: string;
    /** The list of project IDs associated with the context. If the list is empty, the context is global. */
    projectIds?: string[];
}

export class CreateCustomFieldRequest implements ICreateCustomFieldRequest {
    /** The custom field ID. */
    customFieldId!: number;
    /** Allows filtering issues based on their values for the custom field. */
    filter?: boolean;

    constructor(data?: ICreateCustomFieldRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customFieldId = _data["customFieldId"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): CreateCustomFieldRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomFieldRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customFieldId"] = this.customFieldId;
        data["filter"] = this.filter;
        return data;
    }
}

export interface ICreateCustomFieldRequest {
    /** The custom field ID. */
    customFieldId: number;
    /** Allows filtering issues based on their values for the custom field. */
    filter?: boolean;
}

export class CreateDateFieldRequest implements ICreateDateFieldRequest {
    /** A date custom field ID. This is required if the type is "DateCustomField". */
    dateCustomFieldId?: number;
    /** The date field type. This must be "DueDate", "TargetStartDate", "TargetEndDate" or "DateCustomField". */
    type!: CreateDateFieldRequestType;

    constructor(data?: ICreateDateFieldRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateCustomFieldId = _data["dateCustomFieldId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateDateFieldRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDateFieldRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateCustomFieldId"] = this.dateCustomFieldId;
        data["type"] = this.type;
        return data;
    }
}

export interface ICreateDateFieldRequest {
    /** A date custom field ID. This is required if the type is "DateCustomField". */
    dateCustomFieldId?: number;
    /** The date field type. This must be "DueDate", "TargetStartDate", "TargetEndDate" or "DateCustomField". */
    type: CreateDateFieldRequestType;
}

export class CreateExclusionRulesRequest implements ICreateExclusionRulesRequest {
    /** The IDs of the issues to exclude from the plan. */
    issueIds?: number[];
    /** The IDs of the issue types to exclude from the plan. */
    issueTypeIds?: number[];
    /** Issues completed this number of days ago will be excluded from the plan. */
    numberOfDaysToShowCompletedIssues?: number;
    /** The IDs of the releases to exclude from the plan. */
    releaseIds?: number[];
    /** The IDs of the work status categories to exclude from the plan. */
    workStatusCategoryIds?: number[];
    /** The IDs of the work statuses to exclude from the plan. */
    workStatusIds?: number[];

    constructor(data?: ICreateExclusionRulesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueIds"])) {
                this.issueIds = [] as any;
                for (let item of _data["issueIds"])
                    this.issueIds!.push(item);
            }
            if (Array.isArray(_data["issueTypeIds"])) {
                this.issueTypeIds = [] as any;
                for (let item of _data["issueTypeIds"])
                    this.issueTypeIds!.push(item);
            }
            this.numberOfDaysToShowCompletedIssues = _data["numberOfDaysToShowCompletedIssues"];
            if (Array.isArray(_data["releaseIds"])) {
                this.releaseIds = [] as any;
                for (let item of _data["releaseIds"])
                    this.releaseIds!.push(item);
            }
            if (Array.isArray(_data["workStatusCategoryIds"])) {
                this.workStatusCategoryIds = [] as any;
                for (let item of _data["workStatusCategoryIds"])
                    this.workStatusCategoryIds!.push(item);
            }
            if (Array.isArray(_data["workStatusIds"])) {
                this.workStatusIds = [] as any;
                for (let item of _data["workStatusIds"])
                    this.workStatusIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateExclusionRulesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExclusionRulesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueIds)) {
            data["issueIds"] = [];
            for (let item of this.issueIds)
                data["issueIds"].push(item);
        }
        if (Array.isArray(this.issueTypeIds)) {
            data["issueTypeIds"] = [];
            for (let item of this.issueTypeIds)
                data["issueTypeIds"].push(item);
        }
        data["numberOfDaysToShowCompletedIssues"] = this.numberOfDaysToShowCompletedIssues;
        if (Array.isArray(this.releaseIds)) {
            data["releaseIds"] = [];
            for (let item of this.releaseIds)
                data["releaseIds"].push(item);
        }
        if (Array.isArray(this.workStatusCategoryIds)) {
            data["workStatusCategoryIds"] = [];
            for (let item of this.workStatusCategoryIds)
                data["workStatusCategoryIds"].push(item);
        }
        if (Array.isArray(this.workStatusIds)) {
            data["workStatusIds"] = [];
            for (let item of this.workStatusIds)
                data["workStatusIds"].push(item);
        }
        return data;
    }
}

export interface ICreateExclusionRulesRequest {
    /** The IDs of the issues to exclude from the plan. */
    issueIds?: number[];
    /** The IDs of the issue types to exclude from the plan. */
    issueTypeIds?: number[];
    /** Issues completed this number of days ago will be excluded from the plan. */
    numberOfDaysToShowCompletedIssues?: number;
    /** The IDs of the releases to exclude from the plan. */
    releaseIds?: number[];
    /** The IDs of the work status categories to exclude from the plan. */
    workStatusCategoryIds?: number[];
    /** The IDs of the work statuses to exclude from the plan. */
    workStatusIds?: number[];
}

/** Issue security scheme and it's details */
export class CreateIssueSecuritySchemeDetails implements ICreateIssueSecuritySchemeDetails {
    /** The description of the issue security scheme. */
    description?: string;
    /** The list of scheme levels which should be added to the security scheme. */
    levels?: SecuritySchemeLevelBean[];
    /** The name of the issue security scheme. Must be unique (case-insensitive). */
    name!: string;

    [key: string]: any;

    constructor(data?: ICreateIssueSecuritySchemeDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            if (Array.isArray(_data["levels"])) {
                this.levels = [] as any;
                for (let item of _data["levels"])
                    this.levels!.push(SecuritySchemeLevelBean.fromJS(item));
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateIssueSecuritySchemeDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CreateIssueSecuritySchemeDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        if (Array.isArray(this.levels)) {
            data["levels"] = [];
            for (let item of this.levels)
                data["levels"].push(item.toJSON());
        }
        data["name"] = this.name;
        return data;
    }
}

/** Issue security scheme and it's details */
export interface ICreateIssueSecuritySchemeDetails {
    /** The description of the issue security scheme. */
    description?: string;
    /** The list of scheme levels which should be added to the security scheme. */
    levels?: SecuritySchemeLevelBean[];
    /** The name of the issue security scheme. Must be unique (case-insensitive). */
    name: string;

    [key: string]: any;
}

export class CreateIssueSourceRequest implements ICreateIssueSourceRequest {
    /** The issue source type. This must be "Board", "Project" or "Filter". */
    type!: CreateIssueSourceRequestType;
    /** The issue source value. This must be a board ID if the type is "Board", a project ID if the type is "Project" or a filter ID if the type is "Filter". */
    value!: number;

    constructor(data?: ICreateIssueSourceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CreateIssueSourceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateIssueSourceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

export interface ICreateIssueSourceRequest {
    /** The issue source type. This must be "Board", "Project" or "Filter". */
    type: CreateIssueSourceRequestType;
    /** The issue source value. This must be a board ID if the type is "Board", a project ID if the type is "Project" or a filter ID if the type is "Filter". */
    value: number;
}

/** Details of an notification scheme. */
export class CreateNotificationSchemeDetails implements ICreateNotificationSchemeDetails {
    /** The description of the notification scheme. */
    description?: string;
    /** The name of the notification scheme. Must be unique (case-insensitive). */
    name!: string;
    /** The list of notifications which should be added to the notification scheme. */
    notificationSchemeEvents?: NotificationSchemeEventDetails[];

    [key: string]: any;

    constructor(data?: ICreateNotificationSchemeDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.name = _data["name"];
            if (Array.isArray(_data["notificationSchemeEvents"])) {
                this.notificationSchemeEvents = [] as any;
                for (let item of _data["notificationSchemeEvents"])
                    this.notificationSchemeEvents!.push(NotificationSchemeEventDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateNotificationSchemeDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CreateNotificationSchemeDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["name"] = this.name;
        if (Array.isArray(this.notificationSchemeEvents)) {
            data["notificationSchemeEvents"] = [];
            for (let item of this.notificationSchemeEvents)
                data["notificationSchemeEvents"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of an notification scheme. */
export interface ICreateNotificationSchemeDetails {
    /** The description of the notification scheme. */
    description?: string;
    /** The name of the notification scheme. Must be unique (case-insensitive). */
    name: string;
    /** The list of notifications which should be added to the notification scheme. */
    notificationSchemeEvents?: NotificationSchemeEventDetails[];

    [key: string]: any;
}

export class CreatePermissionHolderRequest implements ICreatePermissionHolderRequest {
    /** The permission holder type. This must be "Group" or "AccountId". */
    type!: CreatePermissionHolderRequestType;
    /** The permission holder value. This must be a group name if the type is "Group" or an account ID if the type is "AccountId". */
    value!: string;

    constructor(data?: ICreatePermissionHolderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CreatePermissionHolderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePermissionHolderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

export interface ICreatePermissionHolderRequest {
    /** The permission holder type. This must be "Group" or "AccountId". */
    type: CreatePermissionHolderRequestType;
    /** The permission holder value. This must be a group name if the type is "Group" or an account ID if the type is "AccountId". */
    value: string;
}

export class CreatePermissionRequest implements ICreatePermissionRequest {
    /** The permission holder. */
    holder!: CreatePermissionHolderRequest;
    /** The permission type. This must be "View" or "Edit". */
    type!: CreatePermissionRequestType;

    constructor(data?: ICreatePermissionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.holder = new CreatePermissionHolderRequest();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.holder = _data["holder"] ? CreatePermissionHolderRequest.fromJS(_data["holder"]) : new CreatePermissionHolderRequest();
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreatePermissionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePermissionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holder"] = this.holder ? this.holder.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

export interface ICreatePermissionRequest {
    /** The permission holder. */
    holder: CreatePermissionHolderRequest;
    /** The permission type. This must be "View" or "Edit". */
    type: CreatePermissionRequestType;
}

export class CreatePlanOnlyTeamRequest implements ICreatePlanOnlyTeamRequest {
    /** The capacity for the plan-only team. */
    capacity?: number;
    /** The ID of the issue source for the plan-only team. */
    issueSourceId?: number;
    /** The account IDs of the plan-only team members. */
    memberAccountIds?: string[];
    /** The plan-only team name. */
    name!: string;
    /** The planning style for the plan-only team. This must be "Scrum" or "Kanban". */
    planningStyle!: CreatePlanOnlyTeamRequestPlanningStyle;
    /** The sprint length for the plan-only team. */
    sprintLength?: number;

    constructor(data?: ICreatePlanOnlyTeamRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.capacity = _data["capacity"];
            this.issueSourceId = _data["issueSourceId"];
            if (Array.isArray(_data["memberAccountIds"])) {
                this.memberAccountIds = [] as any;
                for (let item of _data["memberAccountIds"])
                    this.memberAccountIds!.push(item);
            }
            this.name = _data["name"];
            this.planningStyle = _data["planningStyle"];
            this.sprintLength = _data["sprintLength"];
        }
    }

    static fromJS(data: any): CreatePlanOnlyTeamRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePlanOnlyTeamRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["capacity"] = this.capacity;
        data["issueSourceId"] = this.issueSourceId;
        if (Array.isArray(this.memberAccountIds)) {
            data["memberAccountIds"] = [];
            for (let item of this.memberAccountIds)
                data["memberAccountIds"].push(item);
        }
        data["name"] = this.name;
        data["planningStyle"] = this.planningStyle;
        data["sprintLength"] = this.sprintLength;
        return data;
    }
}

export interface ICreatePlanOnlyTeamRequest {
    /** The capacity for the plan-only team. */
    capacity?: number;
    /** The ID of the issue source for the plan-only team. */
    issueSourceId?: number;
    /** The account IDs of the plan-only team members. */
    memberAccountIds?: string[];
    /** The plan-only team name. */
    name: string;
    /** The planning style for the plan-only team. This must be "Scrum" or "Kanban". */
    planningStyle: CreatePlanOnlyTeamRequestPlanningStyle;
    /** The sprint length for the plan-only team. */
    sprintLength?: number;
}

export class CreatePlanRequest implements ICreatePlanRequest {
    /** The cross-project releases to include in the plan. */
    crossProjectReleases?: CreateCrossProjectReleaseRequest[];
    /** The custom fields for the plan. */
    customFields?: CreateCustomFieldRequest[];
    /** The exclusion rules for the plan. */
    exclusionRules?: CreateExclusionRulesRequest;
    /** The issue sources to include in the plan. */
    issueSources!: CreateIssueSourceRequest[];
    /** The account ID of the plan lead. */
    leadAccountId?: string;
    /** The plan name. */
    name!: string;
    /** The permissions for the plan. */
    permissions?: CreatePermissionRequest[];
    /** The scheduling settings for the plan. */
    scheduling!: CreateSchedulingRequest;

    constructor(data?: ICreatePlanRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueSources = [];
            this.scheduling = new CreateSchedulingRequest();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["crossProjectReleases"])) {
                this.crossProjectReleases = [] as any;
                for (let item of _data["crossProjectReleases"])
                    this.crossProjectReleases!.push(CreateCrossProjectReleaseRequest.fromJS(item));
            }
            if (Array.isArray(_data["customFields"])) {
                this.customFields = [] as any;
                for (let item of _data["customFields"])
                    this.customFields!.push(CreateCustomFieldRequest.fromJS(item));
            }
            this.exclusionRules = _data["exclusionRules"] ? CreateExclusionRulesRequest.fromJS(_data["exclusionRules"]) : <any>undefined;
            if (Array.isArray(_data["issueSources"])) {
                this.issueSources = [] as any;
                for (let item of _data["issueSources"])
                    this.issueSources!.push(CreateIssueSourceRequest.fromJS(item));
            }
            this.leadAccountId = _data["leadAccountId"];
            this.name = _data["name"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(CreatePermissionRequest.fromJS(item));
            }
            this.scheduling = _data["scheduling"] ? CreateSchedulingRequest.fromJS(_data["scheduling"]) : new CreateSchedulingRequest();
        }
    }

    static fromJS(data: any): CreatePlanRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePlanRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.crossProjectReleases)) {
            data["crossProjectReleases"] = [];
            for (let item of this.crossProjectReleases)
                data["crossProjectReleases"].push(item.toJSON());
        }
        if (Array.isArray(this.customFields)) {
            data["customFields"] = [];
            for (let item of this.customFields)
                data["customFields"].push(item.toJSON());
        }
        data["exclusionRules"] = this.exclusionRules ? this.exclusionRules.toJSON() : <any>undefined;
        if (Array.isArray(this.issueSources)) {
            data["issueSources"] = [];
            for (let item of this.issueSources)
                data["issueSources"].push(item.toJSON());
        }
        data["leadAccountId"] = this.leadAccountId;
        data["name"] = this.name;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        data["scheduling"] = this.scheduling ? this.scheduling.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreatePlanRequest {
    /** The cross-project releases to include in the plan. */
    crossProjectReleases?: CreateCrossProjectReleaseRequest[];
    /** The custom fields for the plan. */
    customFields?: CreateCustomFieldRequest[];
    /** The exclusion rules for the plan. */
    exclusionRules?: CreateExclusionRulesRequest;
    /** The issue sources to include in the plan. */
    issueSources: CreateIssueSourceRequest[];
    /** The account ID of the plan lead. */
    leadAccountId?: string;
    /** The plan name. */
    name: string;
    /** The permissions for the plan. */
    permissions?: CreatePermissionRequest[];
    /** The scheduling settings for the plan. */
    scheduling: CreateSchedulingRequest;
}

/** Details of an issue priority. */
export class CreatePriorityDetails implements ICreatePriorityDetails {
    /** The ID for the avatar for the priority. Either the iconUrl or avatarId must be defined, but not both. This parameter is nullable and will become mandatory once the iconUrl parameter is deprecated. */
    avatarId?: number;
    /** The description of the priority. */
    description?: string | undefined;
    /** The URL of an icon for the priority. Accepted protocols are HTTP and HTTPS. Built in icons can also be used. Either the iconUrl or avatarId must be defined, but not both. */
    iconUrl?: CreatePriorityDetailsIconUrl | undefined;
    /** The name of the priority. Must be unique. */
    name!: string;
    /** The status color of the priority in 3-digit or 6-digit hexadecimal format. */
    statusColor!: string;

    [key: string]: any;

    constructor(data?: ICreatePriorityDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.avatarId = _data["avatarId"];
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
            this.name = _data["name"];
            this.statusColor = _data["statusColor"];
        }
    }

    static fromJS(data: any): CreatePriorityDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePriorityDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["avatarId"] = this.avatarId;
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        data["name"] = this.name;
        data["statusColor"] = this.statusColor;
        return data;
    }
}

/** Details of an issue priority. */
export interface ICreatePriorityDetails {
    /** The ID for the avatar for the priority. Either the iconUrl or avatarId must be defined, but not both. This parameter is nullable and will become mandatory once the iconUrl parameter is deprecated. */
    avatarId?: number;
    /** The description of the priority. */
    description?: string | undefined;
    /** The URL of an icon for the priority. Accepted protocols are HTTP and HTTPS. Built in icons can also be used. Either the iconUrl or avatarId must be defined, but not both. */
    iconUrl?: CreatePriorityDetailsIconUrl | undefined;
    /** The name of the priority. Must be unique. */
    name: string;
    /** The status color of the priority in 3-digit or 6-digit hexadecimal format. */
    statusColor: string;

    [key: string]: any;
}

/** Details of a new priority scheme */
export class CreatePrioritySchemeDetails implements ICreatePrioritySchemeDetails {
    /** The ID of the default priority for the priority scheme. */
    defaultPriorityId!: number;
    /** The description of the priority scheme. */
    description?: string;
    /** Instructions to migrate the priorities of issues.

`in` mappings are used to migrate the priorities of issues to priorities used within the priority scheme.

`out` mappings are used to migrate the priorities of issues to priorities not used within the priority scheme.

 *  When **priorities** are **added** to the new priority scheme, no mapping needs to be provided as the new priorities are not used by any issues.
 *  When **priorities** are **removed** from the new priority scheme, no mapping needs to be provided as the removed priorities are not used by any issues.
 *  When **projects** are **added** to the priority scheme, the priorities of issues in those projects might need to be migrated to new priorities used by the priority scheme. This can occur when the current scheme does not use all the priorities in the project(s)' priority scheme(s).
    
     *  An `in` mapping must be provided for each of these priorities.
 *  When **projects** are **removed** from the priority scheme, no mapping needs to be provided as the removed projects are not using the priorities of the new priority scheme.

For more information on `in` and `out` mappings, see the child properties documentation for the `PriorityMapping` object below. */
    mappings?: PriorityMapping;
    /** The name of the priority scheme. Must be unique. */
    name!: string;
    /** The IDs of priorities in the scheme. */
    priorityIds!: number[];
    /** The IDs of projects that will use the priority scheme. */
    projectIds?: number[];

    constructor(data?: ICreatePrioritySchemeDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.priorityIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultPriorityId = _data["defaultPriorityId"];
            this.description = _data["description"];
            this.mappings = _data["mappings"] ? PriorityMapping.fromJS(_data["mappings"]) : <any>undefined;
            this.name = _data["name"];
            if (Array.isArray(_data["priorityIds"])) {
                this.priorityIds = [] as any;
                for (let item of _data["priorityIds"])
                    this.priorityIds!.push(item);
            }
            if (Array.isArray(_data["projectIds"])) {
                this.projectIds = [] as any;
                for (let item of _data["projectIds"])
                    this.projectIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreatePrioritySchemeDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePrioritySchemeDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultPriorityId"] = this.defaultPriorityId;
        data["description"] = this.description;
        data["mappings"] = this.mappings ? this.mappings.toJSON() : <any>undefined;
        data["name"] = this.name;
        if (Array.isArray(this.priorityIds)) {
            data["priorityIds"] = [];
            for (let item of this.priorityIds)
                data["priorityIds"].push(item);
        }
        if (Array.isArray(this.projectIds)) {
            data["projectIds"] = [];
            for (let item of this.projectIds)
                data["projectIds"].push(item);
        }
        return data;
    }
}

/** Details of a new priority scheme */
export interface ICreatePrioritySchemeDetails {
    /** The ID of the default priority for the priority scheme. */
    defaultPriorityId: number;
    /** The description of the priority scheme. */
    description?: string;
    /** Instructions to migrate the priorities of issues.

`in` mappings are used to migrate the priorities of issues to priorities used within the priority scheme.

`out` mappings are used to migrate the priorities of issues to priorities not used within the priority scheme.

 *  When **priorities** are **added** to the new priority scheme, no mapping needs to be provided as the new priorities are not used by any issues.
 *  When **priorities** are **removed** from the new priority scheme, no mapping needs to be provided as the removed priorities are not used by any issues.
 *  When **projects** are **added** to the priority scheme, the priorities of issues in those projects might need to be migrated to new priorities used by the priority scheme. This can occur when the current scheme does not use all the priorities in the project(s)' priority scheme(s).
    
     *  An `in` mapping must be provided for each of these priorities.
 *  When **projects** are **removed** from the priority scheme, no mapping needs to be provided as the removed projects are not using the priorities of the new priority scheme.

For more information on `in` and `out` mappings, see the child properties documentation for the `PriorityMapping` object below. */
    mappings?: PriorityMapping;
    /** The name of the priority scheme. Must be unique. */
    name: string;
    /** The IDs of priorities in the scheme. */
    priorityIds: number[];
    /** The IDs of projects that will use the priority scheme. */
    projectIds?: number[];
}

/** Details about the project. */
export class CreateProjectDetails implements ICreateProjectDetails {
    /** The default assignee when creating issues for this project. */
    assigneeType?: CreateProjectDetailsAssigneeType;
    /** An integer value for the project's avatar. */
    avatarId?: number;
    /** The ID of the project's category. A complete list of category IDs is found using the [Get all project categories](#api-rest-api-3-projectCategory-get) operation. */
    categoryId?: number;
    /** A brief description of the project. */
    description?: string;
    /** The ID of the field configuration scheme for the project. Use the [Get all field configuration schemes](#api-rest-api-3-fieldconfigurationscheme-get) operation to get a list of field configuration scheme IDs. If you specify the field configuration scheme you cannot specify the project template key. */
    fieldConfigurationScheme?: number;
    /** The ID of the issue security scheme for the project, which enables you to control who can and cannot view issues. Use the [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get) resource to get all issue security scheme IDs. */
    issueSecurityScheme?: number;
    /** The ID of the issue type scheme for the project. Use the [Get all issue type schemes](#api-rest-api-3-issuetypescheme-get) operation to get a list of issue type scheme IDs. If you specify the issue type scheme you cannot specify the project template key. */
    issueTypeScheme?: number;
    /** The ID of the issue type screen scheme for the project. Use the [Get all issue type screen schemes](#api-rest-api-3-issuetypescreenscheme-get) operation to get a list of issue type screen scheme IDs. If you specify the issue type screen scheme you cannot specify the project template key. */
    issueTypeScreenScheme?: number;
    /** Project keys must be unique and start with an uppercase letter followed by one or more uppercase alphanumeric characters. The maximum length is 10 characters. */
    key!: string;
    /** This parameter is deprecated because of privacy changes. Use `leadAccountId` instead. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. The user name of the project lead. Either `lead` or `leadAccountId` must be set when creating a project. Cannot be provided with `leadAccountId`. */
    lead?: string;
    /** The account ID of the project lead. Either `lead` or `leadAccountId` must be set when creating a project. Cannot be provided with `lead`. */
    leadAccountId?: string;
    /** The name of the project. */
    name!: string;
    /** The ID of the notification scheme for the project. Use the [Get notification schemes](#api-rest-api-3-notificationscheme-get) resource to get a list of notification scheme IDs. */
    notificationScheme?: number;
    /** The ID of the permission scheme for the project. Use the [Get all permission schemes](#api-rest-api-3-permissionscheme-get) resource to see a list of all permission scheme IDs. */
    permissionScheme?: number;
    /** A predefined configuration for a project. The type of the `projectTemplateKey` must match with the type of the `projectTypeKey`. */
    projectTemplateKey?: CreateProjectDetailsProjectTemplateKey;
    /** The [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes), which defines the application-specific feature set. If you don't specify the project template you have to specify the project type. */
    projectTypeKey?: CreateProjectDetailsProjectTypeKey;
    /** A link to information about this project, such as project documentation */
    url?: string;
    /** The ID of the workflow scheme for the project. Use the [Get all workflow schemes](#api-rest-api-3-workflowscheme-get) operation to get a list of workflow scheme IDs. If you specify the workflow scheme you cannot specify the project template key. */
    workflowScheme?: number;

    constructor(data?: ICreateProjectDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assigneeType = _data["assigneeType"];
            this.avatarId = _data["avatarId"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            this.fieldConfigurationScheme = _data["fieldConfigurationScheme"];
            this.issueSecurityScheme = _data["issueSecurityScheme"];
            this.issueTypeScheme = _data["issueTypeScheme"];
            this.issueTypeScreenScheme = _data["issueTypeScreenScheme"];
            this.key = _data["key"];
            this.lead = _data["lead"];
            this.leadAccountId = _data["leadAccountId"];
            this.name = _data["name"];
            this.notificationScheme = _data["notificationScheme"];
            this.permissionScheme = _data["permissionScheme"];
            this.projectTemplateKey = _data["projectTemplateKey"];
            this.projectTypeKey = _data["projectTypeKey"];
            this.url = _data["url"];
            this.workflowScheme = _data["workflowScheme"];
        }
    }

    static fromJS(data: any): CreateProjectDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assigneeType"] = this.assigneeType;
        data["avatarId"] = this.avatarId;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        data["fieldConfigurationScheme"] = this.fieldConfigurationScheme;
        data["issueSecurityScheme"] = this.issueSecurityScheme;
        data["issueTypeScheme"] = this.issueTypeScheme;
        data["issueTypeScreenScheme"] = this.issueTypeScreenScheme;
        data["key"] = this.key;
        data["lead"] = this.lead;
        data["leadAccountId"] = this.leadAccountId;
        data["name"] = this.name;
        data["notificationScheme"] = this.notificationScheme;
        data["permissionScheme"] = this.permissionScheme;
        data["projectTemplateKey"] = this.projectTemplateKey;
        data["projectTypeKey"] = this.projectTypeKey;
        data["url"] = this.url;
        data["workflowScheme"] = this.workflowScheme;
        return data;
    }
}

/** Details about the project. */
export interface ICreateProjectDetails {
    /** The default assignee when creating issues for this project. */
    assigneeType?: CreateProjectDetailsAssigneeType;
    /** An integer value for the project's avatar. */
    avatarId?: number;
    /** The ID of the project's category. A complete list of category IDs is found using the [Get all project categories](#api-rest-api-3-projectCategory-get) operation. */
    categoryId?: number;
    /** A brief description of the project. */
    description?: string;
    /** The ID of the field configuration scheme for the project. Use the [Get all field configuration schemes](#api-rest-api-3-fieldconfigurationscheme-get) operation to get a list of field configuration scheme IDs. If you specify the field configuration scheme you cannot specify the project template key. */
    fieldConfigurationScheme?: number;
    /** The ID of the issue security scheme for the project, which enables you to control who can and cannot view issues. Use the [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get) resource to get all issue security scheme IDs. */
    issueSecurityScheme?: number;
    /** The ID of the issue type scheme for the project. Use the [Get all issue type schemes](#api-rest-api-3-issuetypescheme-get) operation to get a list of issue type scheme IDs. If you specify the issue type scheme you cannot specify the project template key. */
    issueTypeScheme?: number;
    /** The ID of the issue type screen scheme for the project. Use the [Get all issue type screen schemes](#api-rest-api-3-issuetypescreenscheme-get) operation to get a list of issue type screen scheme IDs. If you specify the issue type screen scheme you cannot specify the project template key. */
    issueTypeScreenScheme?: number;
    /** Project keys must be unique and start with an uppercase letter followed by one or more uppercase alphanumeric characters. The maximum length is 10 characters. */
    key: string;
    /** This parameter is deprecated because of privacy changes. Use `leadAccountId` instead. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. The user name of the project lead. Either `lead` or `leadAccountId` must be set when creating a project. Cannot be provided with `leadAccountId`. */
    lead?: string;
    /** The account ID of the project lead. Either `lead` or `leadAccountId` must be set when creating a project. Cannot be provided with `lead`. */
    leadAccountId?: string;
    /** The name of the project. */
    name: string;
    /** The ID of the notification scheme for the project. Use the [Get notification schemes](#api-rest-api-3-notificationscheme-get) resource to get a list of notification scheme IDs. */
    notificationScheme?: number;
    /** The ID of the permission scheme for the project. Use the [Get all permission schemes](#api-rest-api-3-permissionscheme-get) resource to see a list of all permission scheme IDs. */
    permissionScheme?: number;
    /** A predefined configuration for a project. The type of the `projectTemplateKey` must match with the type of the `projectTypeKey`. */
    projectTemplateKey?: CreateProjectDetailsProjectTemplateKey;
    /** The [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes), which defines the application-specific feature set. If you don't specify the project template you have to specify the project type. */
    projectTypeKey?: CreateProjectDetailsProjectTypeKey;
    /** A link to information about this project, such as project documentation */
    url?: string;
    /** The ID of the workflow scheme for the project. Use the [Get all workflow schemes](#api-rest-api-3-workflowscheme-get) operation to get a list of workflow scheme IDs. If you specify the workflow scheme you cannot specify the project template key. */
    workflowScheme?: number;
}

/** Details of an issue resolution. */
export class CreateResolutionDetails implements ICreateResolutionDetails {
    /** The description of the resolution. */
    description?: string;
    /** The name of the resolution. Must be unique (case-insensitive). */
    name!: string;

    [key: string]: any;

    constructor(data?: ICreateResolutionDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateResolutionDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CreateResolutionDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

/** Details of an issue resolution. */
export interface ICreateResolutionDetails {
    /** The description of the resolution. */
    description?: string;
    /** The name of the resolution. Must be unique (case-insensitive). */
    name: string;

    [key: string]: any;
}

export class CreateSchedulingRequest implements ICreateSchedulingRequest {
    /** The dependencies for the plan. This must be "Sequential" or "Concurrent". */
    dependencies?: CreateSchedulingRequestDependencies;
    /** The end date field for the plan. */
    endDate?: CreateDateFieldRequest;
    /** The estimation unit for the plan. This must be "StoryPoints", "Days" or "Hours". */
    estimation!: CreateSchedulingRequestEstimation;
    /** The inferred dates for the plan. This must be "None", "SprintDates" or "ReleaseDates". */
    inferredDates?: CreateSchedulingRequestInferredDates;
    /** The start date field for the plan. */
    startDate?: CreateDateFieldRequest;

    constructor(data?: ICreateSchedulingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dependencies = _data["dependencies"];
            this.endDate = _data["endDate"] ? CreateDateFieldRequest.fromJS(_data["endDate"]) : <any>undefined;
            this.estimation = _data["estimation"];
            this.inferredDates = _data["inferredDates"];
            this.startDate = _data["startDate"] ? CreateDateFieldRequest.fromJS(_data["startDate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateSchedulingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSchedulingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dependencies"] = this.dependencies;
        data["endDate"] = this.endDate ? this.endDate.toJSON() : <any>undefined;
        data["estimation"] = this.estimation;
        data["inferredDates"] = this.inferredDates;
        data["startDate"] = this.startDate ? this.startDate.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateSchedulingRequest {
    /** The dependencies for the plan. This must be "Sequential" or "Concurrent". */
    dependencies?: CreateSchedulingRequestDependencies;
    /** The end date field for the plan. */
    endDate?: CreateDateFieldRequest;
    /** The estimation unit for the plan. This must be "StoryPoints", "Days" or "Hours". */
    estimation: CreateSchedulingRequestEstimation;
    /** The inferred dates for the plan. This must be "None", "SprintDates" or "ReleaseDates". */
    inferredDates?: CreateSchedulingRequestInferredDates;
    /** The start date field for the plan. */
    startDate?: CreateDateFieldRequest;
}

/** The details of a UI modification. */
export class CreateUiModificationDetails implements ICreateUiModificationDetails {
    /** List of contexts of the UI modification. The maximum number of contexts is 1000. */
    contexts?: UiModificationContextDetails[];
    /** The data of the UI modification. The maximum size of the data is 50000 characters. */
    data?: string;
    /** The description of the UI modification. The maximum length is 255 characters. */
    description?: string;
    /** The name of the UI modification. The maximum length is 255 characters. */
    name!: string;

    constructor(data?: ICreateUiModificationDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contexts"])) {
                this.contexts = [] as any;
                for (let item of _data["contexts"])
                    this.contexts!.push(UiModificationContextDetails.fromJS(item));
            }
            this.data = _data["data"];
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateUiModificationDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUiModificationDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contexts)) {
            data["contexts"] = [];
            for (let item of this.contexts)
                data["contexts"].push(item.toJSON());
        }
        data["data"] = this.data;
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

/** The details of a UI modification. */
export interface ICreateUiModificationDetails {
    /** List of contexts of the UI modification. The maximum number of contexts is 1000. */
    contexts?: UiModificationContextDetails[];
    /** The data of the UI modification. The maximum size of the data is 50000 characters. */
    data?: string;
    /** The description of the UI modification. The maximum length is 255 characters. */
    description?: string;
    /** The name of the UI modification. The maximum length is 255 characters. */
    name: string;
}

export class CreateUpdateRoleRequestBean implements ICreateUpdateRoleRequestBean {
    /** A description of the project role. Required when fully updating a project role. Optional when creating or partially updating a project role. */
    description?: string;
    /** The name of the project role. Must be unique. Cannot begin or end with whitespace. The maximum length is 255 characters. Required when creating a project role. Optional when partially updating a project role. */
    name?: string;

    constructor(data?: ICreateUpdateRoleRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateUpdateRoleRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateRoleRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateUpdateRoleRequestBean {
    /** A description of the project role. Required when fully updating a project role. Optional when creating or partially updating a project role. */
    description?: string;
    /** The name of the project role. Must be unique. Cannot begin or end with whitespace. The maximum length is 255 characters. Required when creating a project role. Optional when partially updating a project role. */
    name?: string;
}

/** A workflow transition condition. */
export class CreateWorkflowCondition implements ICreateWorkflowCondition {
    /** The list of workflow conditions. */
    conditions?: CreateWorkflowCondition[];
    /** EXPERIMENTAL. The configuration of the transition rule. */
    configuration?: { [key: string]: any; };
    /** The compound condition operator. */
    operator?: CreateWorkflowConditionOperator;
    /** The type of the transition rule. */
    type?: string;

    constructor(data?: ICreateWorkflowCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(CreateWorkflowCondition.fromJS(item));
            }
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
            this.operator = _data["operator"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateWorkflowCondition {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkflowCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        data["operator"] = this.operator;
        data["type"] = this.type;
        return data;
    }
}

/** A workflow transition condition. */
export interface ICreateWorkflowCondition {
    /** The list of workflow conditions. */
    conditions?: CreateWorkflowCondition[];
    /** EXPERIMENTAL. The configuration of the transition rule. */
    configuration?: { [key: string]: any; };
    /** The compound condition operator. */
    operator?: CreateWorkflowConditionOperator;
    /** The type of the transition rule. */
    type?: string;
}

/** The details of a workflow. */
export class CreateWorkflowDetails implements ICreateWorkflowDetails {
    /** The description of the workflow. The maximum length is 1000 characters. */
    description?: string;
    /** The name of the workflow. The name must be unique. The maximum length is 255 characters. Characters can be separated by a whitespace but the name cannot start or end with a whitespace. */
    name!: string;
    /** The statuses of the workflow. Any status that does not include a transition is added to the workflow without a transition. */
    statuses!: CreateWorkflowStatusDetails[];
    /** The transitions of the workflow. For the request to be valid, these transitions must:

 *  include one *initial* transition.
 *  not use the same name for a *global* and *directed* transition.
 *  have a unique name for each *global* transition.
 *  have a unique 'to' status for each *global* transition.
 *  have unique names for each transition from a status.
 *  not have a 'from' status on *initial* and *global* transitions.
 *  have a 'from' status on *directed* transitions.

All the transition statuses must be included in `statuses`. */
    transitions!: CreateWorkflowTransitionDetails[];

    constructor(data?: ICreateWorkflowDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.statuses = [];
            this.transitions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(CreateWorkflowStatusDetails.fromJS(item));
            }
            if (Array.isArray(_data["transitions"])) {
                this.transitions = [] as any;
                for (let item of _data["transitions"])
                    this.transitions!.push(CreateWorkflowTransitionDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateWorkflowDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkflowDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        if (Array.isArray(this.transitions)) {
            data["transitions"] = [];
            for (let item of this.transitions)
                data["transitions"].push(item.toJSON());
        }
        return data;
    }
}

/** The details of a workflow. */
export interface ICreateWorkflowDetails {
    /** The description of the workflow. The maximum length is 1000 characters. */
    description?: string;
    /** The name of the workflow. The name must be unique. The maximum length is 255 characters. Characters can be separated by a whitespace but the name cannot start or end with a whitespace. */
    name: string;
    /** The statuses of the workflow. Any status that does not include a transition is added to the workflow without a transition. */
    statuses: CreateWorkflowStatusDetails[];
    /** The transitions of the workflow. For the request to be valid, these transitions must:

 *  include one *initial* transition.
 *  not use the same name for a *global* and *directed* transition.
 *  have a unique name for each *global* transition.
 *  have a unique 'to' status for each *global* transition.
 *  have unique names for each transition from a status.
 *  not have a 'from' status on *initial* and *global* transitions.
 *  have a 'from' status on *directed* transitions.

All the transition statuses must be included in `statuses`. */
    transitions: CreateWorkflowTransitionDetails[];
}

/** The details of a transition status. */
export class CreateWorkflowStatusDetails implements ICreateWorkflowStatusDetails {
    /** The ID of the status. */
    id!: string;
    /** The properties of the status. */
    properties?: { [key: string]: string; };

    constructor(data?: ICreateWorkflowStatusDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CreateWorkflowStatusDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkflowStatusDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

/** The details of a transition status. */
export interface ICreateWorkflowStatusDetails {
    /** The ID of the status. */
    id: string;
    /** The properties of the status. */
    properties?: { [key: string]: string; };
}

/** The details of a workflow transition. */
export class CreateWorkflowTransitionDetails implements ICreateWorkflowTransitionDetails {
    /** The description of the transition. The maximum length is 1000 characters. */
    description?: string;
    /** The statuses the transition can start from. */
    from?: string[];
    /** The name of the transition. The maximum length is 60 characters. */
    name!: string;
    /** The properties of the transition. */
    properties?: { [key: string]: string; };
    /** The rules of the transition. */
    rules?: CreateWorkflowTransitionRulesDetails;
    /** The screen of the transition. */
    screen?: CreateWorkflowTransitionScreenDetails;
    /** The status the transition goes to. */
    to!: string;
    /** The type of the transition. */
    type!: CreateWorkflowTransitionDetailsType;

    constructor(data?: ICreateWorkflowTransitionDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            if (Array.isArray(_data["from"])) {
                this.from = [] as any;
                for (let item of _data["from"])
                    this.from!.push(item);
            }
            this.name = _data["name"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.rules = _data["rules"] ? CreateWorkflowTransitionRulesDetails.fromJS(_data["rules"]) : <any>undefined;
            this.screen = _data["screen"] ? CreateWorkflowTransitionScreenDetails.fromJS(_data["screen"]) : <any>undefined;
            this.to = _data["to"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateWorkflowTransitionDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkflowTransitionDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        if (Array.isArray(this.from)) {
            data["from"] = [];
            for (let item of this.from)
                data["from"].push(item);
        }
        data["name"] = this.name;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["rules"] = this.rules ? this.rules.toJSON() : <any>undefined;
        data["screen"] = this.screen ? this.screen.toJSON() : <any>undefined;
        data["to"] = this.to;
        data["type"] = this.type;
        return data;
    }
}

/** The details of a workflow transition. */
export interface ICreateWorkflowTransitionDetails {
    /** The description of the transition. The maximum length is 1000 characters. */
    description?: string;
    /** The statuses the transition can start from. */
    from?: string[];
    /** The name of the transition. The maximum length is 60 characters. */
    name: string;
    /** The properties of the transition. */
    properties?: { [key: string]: string; };
    /** The rules of the transition. */
    rules?: CreateWorkflowTransitionRulesDetails;
    /** The screen of the transition. */
    screen?: CreateWorkflowTransitionScreenDetails;
    /** The status the transition goes to. */
    to: string;
    /** The type of the transition. */
    type: CreateWorkflowTransitionDetailsType;
}

/** A workflow transition rule. */
export class CreateWorkflowTransitionRule implements ICreateWorkflowTransitionRule {
    /** EXPERIMENTAL. The configuration of the transition rule. */
    configuration?: { [key: string]: any; };
    /** The type of the transition rule. */
    type!: string;

    constructor(data?: ICreateWorkflowTransitionRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["configuration"]) {
                this.configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>this.configuration)![key] = _data["configuration"][key];
                }
            }
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateWorkflowTransitionRule {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkflowTransitionRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        data["type"] = this.type;
        return data;
    }
}

/** A workflow transition rule. */
export interface ICreateWorkflowTransitionRule {
    /** EXPERIMENTAL. The configuration of the transition rule. */
    configuration?: { [key: string]: any; };
    /** The type of the transition rule. */
    type: string;
}

/** The details of a workflow transition rules. */
export class CreateWorkflowTransitionRulesDetails implements ICreateWorkflowTransitionRulesDetails {
    /** The workflow conditions. */
    conditions?: CreateWorkflowCondition;
    /** The workflow post functions.

**Note:** The default post functions are always added to the *initial* transition, as in:

    "postFunctions": [
        {
            "type": "IssueCreateFunction"
        },
        {
            "type": "IssueReindexFunction"
        },
        {
            "type": "FireIssueEventFunction",
            "configuration": {
                "event": {
                    "id": "1",
                    "name": "issue_created"
                }
            }
        }
    ]

**Note:** The default post functions are always added to the *global* and *directed* transitions, as in:

    "postFunctions": [
        {
            "type": "UpdateIssueStatusFunction"
        },
        {
            "type": "CreateCommentFunction"
        },
        {
            "type": "GenerateChangeHistoryFunction"
        },
        {
            "type": "IssueReindexFunction"
        },
        {
            "type": "FireIssueEventFunction",
            "configuration": {
                "event": {
                    "id": "13",
                    "name": "issue_generic"
                }
            }
        }
    ] */
    postFunctions?: CreateWorkflowTransitionRule[];
    /** The workflow validators.

**Note:** The default permission validator is always added to the *initial* transition, as in:

    "validators": [
        {
            "type": "PermissionValidator",
            "configuration": {
                "permissionKey": "CREATE_ISSUES"
            }
        }
    ] */
    validators?: CreateWorkflowTransitionRule[];

    constructor(data?: ICreateWorkflowTransitionRulesDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conditions = _data["conditions"] ? CreateWorkflowCondition.fromJS(_data["conditions"]) : <any>undefined;
            if (Array.isArray(_data["postFunctions"])) {
                this.postFunctions = [] as any;
                for (let item of _data["postFunctions"])
                    this.postFunctions!.push(CreateWorkflowTransitionRule.fromJS(item));
            }
            if (Array.isArray(_data["validators"])) {
                this.validators = [] as any;
                for (let item of _data["validators"])
                    this.validators!.push(CreateWorkflowTransitionRule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateWorkflowTransitionRulesDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkflowTransitionRulesDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conditions"] = this.conditions ? this.conditions.toJSON() : <any>undefined;
        if (Array.isArray(this.postFunctions)) {
            data["postFunctions"] = [];
            for (let item of this.postFunctions)
                data["postFunctions"].push(item.toJSON());
        }
        if (Array.isArray(this.validators)) {
            data["validators"] = [];
            for (let item of this.validators)
                data["validators"].push(item.toJSON());
        }
        return data;
    }
}

/** The details of a workflow transition rules. */
export interface ICreateWorkflowTransitionRulesDetails {
    /** The workflow conditions. */
    conditions?: CreateWorkflowCondition;
    /** The workflow post functions.

**Note:** The default post functions are always added to the *initial* transition, as in:

    "postFunctions": [
        {
            "type": "IssueCreateFunction"
        },
        {
            "type": "IssueReindexFunction"
        },
        {
            "type": "FireIssueEventFunction",
            "configuration": {
                "event": {
                    "id": "1",
                    "name": "issue_created"
                }
            }
        }
    ]

**Note:** The default post functions are always added to the *global* and *directed* transitions, as in:

    "postFunctions": [
        {
            "type": "UpdateIssueStatusFunction"
        },
        {
            "type": "CreateCommentFunction"
        },
        {
            "type": "GenerateChangeHistoryFunction"
        },
        {
            "type": "IssueReindexFunction"
        },
        {
            "type": "FireIssueEventFunction",
            "configuration": {
                "event": {
                    "id": "13",
                    "name": "issue_generic"
                }
            }
        }
    ] */
    postFunctions?: CreateWorkflowTransitionRule[];
    /** The workflow validators.

**Note:** The default permission validator is always added to the *initial* transition, as in:

    "validators": [
        {
            "type": "PermissionValidator",
            "configuration": {
                "permissionKey": "CREATE_ISSUES"
            }
        }
    ] */
    validators?: CreateWorkflowTransitionRule[];
}

/** The details of a transition screen. */
export class CreateWorkflowTransitionScreenDetails implements ICreateWorkflowTransitionScreenDetails {
    /** The ID of the screen. */
    id!: string;

    constructor(data?: ICreateWorkflowTransitionScreenDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateWorkflowTransitionScreenDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWorkflowTransitionScreenDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** The details of a transition screen. */
export interface ICreateWorkflowTransitionScreenDetails {
    /** The ID of the screen. */
    id: string;
}

/** Details about a created issue or subtask. */
export class CreatedIssue implements ICreatedIssue {
    /** The ID of the created issue or subtask. */
    readonly id?: string;
    /** The key of the created issue or subtask. */
    readonly key?: string;
    /** The URL of the created issue or subtask. */
    readonly self?: string;
    /** The response code and messages related to any requested transition. */
    readonly transition?: NestedResponse;
    /** The response code and messages related to any requested watchers. */
    readonly watchers?: NestedResponse;

    constructor(data?: ICreatedIssue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).key = _data["key"];
            (<any>this).self = _data["self"];
            (<any>this).transition = _data["transition"] ? NestedResponse.fromJS(_data["transition"]) : <any>undefined;
            (<any>this).watchers = _data["watchers"] ? NestedResponse.fromJS(_data["watchers"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreatedIssue {
        data = typeof data === 'object' ? data : {};
        let result = new CreatedIssue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["self"] = this.self;
        data["transition"] = this.transition ? this.transition.toJSON() : <any>undefined;
        data["watchers"] = this.watchers ? this.watchers.toJSON() : <any>undefined;
        return data;
    }
}

/** Details about a created issue or subtask. */
export interface ICreatedIssue {
    /** The ID of the created issue or subtask. */
    id?: string;
    /** The key of the created issue or subtask. */
    key?: string;
    /** The URL of the created issue or subtask. */
    self?: string;
    /** The response code and messages related to any requested transition. */
    transition?: NestedResponse;
    /** The response code and messages related to any requested watchers. */
    watchers?: NestedResponse;
}

/** Details about the issues created and the errors for requests that failed. */
export class CreatedIssues implements ICreatedIssues {
    /** Error details for failed issue creation requests. */
    readonly errors?: BulkOperationErrorResult[];
    /** Details of the issues created. */
    readonly issues?: CreatedIssue[];

    constructor(data?: ICreatedIssues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(BulkOperationErrorResult.fromJS(item));
            }
            if (Array.isArray(_data["issues"])) {
                (<any>this).issues = [] as any;
                for (let item of _data["issues"])
                    (<any>this).issues!.push(CreatedIssue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreatedIssues {
        data = typeof data === 'object' ? data : {};
        let result = new CreatedIssues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item.toJSON());
        }
        return data;
    }
}

/** Details about the issues created and the errors for requests that failed. */
export interface ICreatedIssues {
    /** Error details for failed issue creation requests. */
    errors?: BulkOperationErrorResult[];
    /** Details of the issues created. */
    issues?: CreatedIssue[];
}

/** A [user](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#user) specified as an Atlassian account ID. */
export class CustomContextVariable implements ICustomContextVariable {
    /** Type of custom context variable. */
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomContextVariable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "user";
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomContextVariable {
        data = typeof data === 'object' ? data : {};
        let result = new CustomContextVariable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        return data;
    }
}

/** A [user](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#user) specified as an Atlassian account ID. */
export interface ICustomContextVariable {
    /** Type of custom context variable. */
    type: string;

    [key: string]: any;
}

/** Details of configurations for a custom field. */
export class CustomFieldConfigurations implements ICustomFieldConfigurations {
    /** The list of custom field configuration details. */
    configurations!: ContextualConfiguration[];

    constructor(data?: ICustomFieldConfigurations) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.configurations = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["configurations"])) {
                this.configurations = [] as any;
                for (let item of _data["configurations"])
                    this.configurations!.push(ContextualConfiguration.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomFieldConfigurations {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldConfigurations();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.configurations)) {
            data["configurations"] = [];
            for (let item of this.configurations)
                data["configurations"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of configurations for a custom field. */
export interface ICustomFieldConfigurations {
    /** The list of custom field configuration details. */
    configurations: ContextualConfiguration[];
}

/** The details of a custom field context. */
export class CustomFieldContext implements ICustomFieldContext {
    /** The description of the context. */
    description!: string;
    /** The ID of the context. */
    id!: string;
    /** Whether the context apply to all issue types. */
    isAnyIssueType!: boolean;
    /** Whether the context is global. */
    isGlobalContext!: boolean;
    /** The name of the context. */
    name!: string;

    constructor(data?: ICustomFieldContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.id = _data["id"];
            this.isAnyIssueType = _data["isAnyIssueType"];
            this.isGlobalContext = _data["isGlobalContext"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CustomFieldContext {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["isAnyIssueType"] = this.isAnyIssueType;
        data["isGlobalContext"] = this.isGlobalContext;
        data["name"] = this.name;
        return data;
    }
}

/** The details of a custom field context. */
export interface ICustomFieldContext {
    /** The description of the context. */
    description: string;
    /** The ID of the context. */
    id: string;
    /** Whether the context apply to all issue types. */
    isAnyIssueType: boolean;
    /** Whether the context is global. */
    isGlobalContext: boolean;
    /** The name of the context. */
    name: string;
}

/** The default value for a cascading select custom field. */
export class CustomFieldContextDefaultValue implements ICustomFieldContextDefaultValue {

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "option.cascading";
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValue {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

/** The default value for a cascading select custom field. */
export interface ICustomFieldContextDefaultValue {

    [key: string]: any;
}

/** The default value for a Date custom field. */
export class CustomFieldContextDefaultValueDate implements ICustomFieldContextDefaultValueDate {
    /** The default date in ISO format. Ignored if `useCurrent` is true. */
    date?: string;
    type!: string;
    /** Whether to use the current date. */
    useCurrent?: boolean;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueDate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.useCurrent = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.date = _data["date"];
            this.type = _data["type"];
            this.useCurrent = _data["useCurrent"] !== undefined ? _data["useCurrent"] : false;
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueDate {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueDate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["date"] = this.date;
        data["type"] = this.type;
        data["useCurrent"] = this.useCurrent;
        return data;
    }
}

/** The default value for a Date custom field. */
export interface ICustomFieldContextDefaultValueDate {
    /** The default date in ISO format. Ignored if `useCurrent` is true. */
    date?: string;
    type: string;
    /** Whether to use the current date. */
    useCurrent?: boolean;

    [key: string]: any;
}

/** The default value for a date time custom field. */
export class CustomFieldContextDefaultValueDateTime implements ICustomFieldContextDefaultValueDateTime {
    /** The default date-time in ISO format. Ignored if `useCurrent` is true. */
    dateTime?: string;
    type!: string;
    /** Whether to use the current date. */
    useCurrent?: boolean;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueDateTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.useCurrent = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.dateTime = _data["dateTime"];
            this.type = _data["type"];
            this.useCurrent = _data["useCurrent"] !== undefined ? _data["useCurrent"] : false;
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueDateTime {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueDateTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["dateTime"] = this.dateTime;
        data["type"] = this.type;
        data["useCurrent"] = this.useCurrent;
        return data;
    }
}

/** The default value for a date time custom field. */
export interface ICustomFieldContextDefaultValueDateTime {
    /** The default date-time in ISO format. Ignored if `useCurrent` is true. */
    dateTime?: string;
    type: string;
    /** Whether to use the current date. */
    useCurrent?: boolean;

    [key: string]: any;
}

/** Default value for a float (number) custom field. */
export class CustomFieldContextDefaultValueFloat implements ICustomFieldContextDefaultValueFloat {
    /** The default floating-point number. */
    number!: number;
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueFloat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.number = _data["number"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueFloat {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueFloat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["number"] = this.number;
        data["type"] = this.type;
        return data;
    }
}

/** Default value for a float (number) custom field. */
export interface ICustomFieldContextDefaultValueFloat {
    /** The default floating-point number. */
    number: number;
    type: string;

    [key: string]: any;
}

/** The default value for a Forge date time custom field. */
export class CustomFieldContextDefaultValueForgeDateTimeField implements ICustomFieldContextDefaultValueForgeDateTimeField {
    /** The ID of the context. */
    contextId!: string;
    /** The default date-time in ISO format. Ignored if `useCurrent` is true. */
    dateTime?: string;
    type!: string;
    /** Whether to use the current date. */
    useCurrent?: boolean;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueForgeDateTimeField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.useCurrent = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contextId = _data["contextId"];
            this.dateTime = _data["dateTime"];
            this.type = _data["type"];
            this.useCurrent = _data["useCurrent"] !== undefined ? _data["useCurrent"] : false;
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueForgeDateTimeField {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueForgeDateTimeField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contextId"] = this.contextId;
        data["dateTime"] = this.dateTime;
        data["type"] = this.type;
        data["useCurrent"] = this.useCurrent;
        return data;
    }
}

/** The default value for a Forge date time custom field. */
export interface ICustomFieldContextDefaultValueForgeDateTimeField {
    /** The ID of the context. */
    contextId: string;
    /** The default date-time in ISO format. Ignored if `useCurrent` is true. */
    dateTime?: string;
    type: string;
    /** Whether to use the current date. */
    useCurrent?: boolean;

    [key: string]: any;
}

/** The default value for a Forge group custom field. */
export class CustomFieldContextDefaultValueForgeGroupField implements ICustomFieldContextDefaultValueForgeGroupField {
    /** The ID of the context. */
    contextId!: string;
    /** The ID of the the default group. */
    groupId!: string;
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueForgeGroupField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contextId = _data["contextId"];
            this.groupId = _data["groupId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueForgeGroupField {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueForgeGroupField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contextId"] = this.contextId;
        data["groupId"] = this.groupId;
        data["type"] = this.type;
        return data;
    }
}

/** The default value for a Forge group custom field. */
export interface ICustomFieldContextDefaultValueForgeGroupField {
    /** The ID of the context. */
    contextId: string;
    /** The ID of the the default group. */
    groupId: string;
    type: string;

    [key: string]: any;
}

/** The default value for a Forge collection of groups custom field. */
export class CustomFieldContextDefaultValueForgeMultiGroupField implements ICustomFieldContextDefaultValueForgeMultiGroupField {
    /** The ID of the context. */
    contextId!: string;
    /** The IDs of the default groups. */
    groupIds!: string[];
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueForgeMultiGroupField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.groupIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contextId = _data["contextId"];
            if (Array.isArray(_data["groupIds"])) {
                this.groupIds = [] as any;
                for (let item of _data["groupIds"])
                    this.groupIds!.push(item);
            }
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueForgeMultiGroupField {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueForgeMultiGroupField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contextId"] = this.contextId;
        if (Array.isArray(this.groupIds)) {
            data["groupIds"] = [];
            for (let item of this.groupIds)
                data["groupIds"].push(item);
        }
        data["type"] = this.type;
        return data;
    }
}

/** The default value for a Forge collection of groups custom field. */
export interface ICustomFieldContextDefaultValueForgeMultiGroupField {
    /** The ID of the context. */
    contextId: string;
    /** The IDs of the default groups. */
    groupIds: string[];
    type: string;

    [key: string]: any;
}

/** The default text for a Forge collection of strings custom field. */
export class CustomFieldContextDefaultValueForgeMultiStringField implements ICustomFieldContextDefaultValueForgeMultiStringField {
    type!: string;
    /** List of string values. The maximum length for a value is 254 characters. */
    values?: string[];

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueForgeMultiStringField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueForgeMultiStringField {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueForgeMultiStringField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data;
    }
}

/** The default text for a Forge collection of strings custom field. */
export interface ICustomFieldContextDefaultValueForgeMultiStringField {
    type: string;
    /** List of string values. The maximum length for a value is 254 characters. */
    values?: string[];

    [key: string]: any;
}

/** Defaults for a Forge collection of users custom field. */
export class CustomFieldContextDefaultValueForgeMultiUserField implements ICustomFieldContextDefaultValueForgeMultiUserField {
    /** The IDs of the default users. */
    accountIds!: string[];
    /** The ID of the context. */
    contextId!: string;
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueForgeMultiUserField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.accountIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["accountIds"])) {
                this.accountIds = [] as any;
                for (let item of _data["accountIds"])
                    this.accountIds!.push(item);
            }
            this.contextId = _data["contextId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueForgeMultiUserField {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueForgeMultiUserField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.accountIds)) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        data["contextId"] = this.contextId;
        data["type"] = this.type;
        return data;
    }
}

/** Defaults for a Forge collection of users custom field. */
export interface ICustomFieldContextDefaultValueForgeMultiUserField {
    /** The IDs of the default users. */
    accountIds: string[];
    /** The ID of the context. */
    contextId: string;
    type: string;

    [key: string]: any;
}

/** Default value for a Forge number custom field. */
export class CustomFieldContextDefaultValueForgeNumberField implements ICustomFieldContextDefaultValueForgeNumberField {
    /** The ID of the context. */
    contextId!: string;
    /** The default floating-point number. */
    number!: number;
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueForgeNumberField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contextId = _data["contextId"];
            this.number = _data["number"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueForgeNumberField {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueForgeNumberField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contextId"] = this.contextId;
        data["number"] = this.number;
        data["type"] = this.type;
        return data;
    }
}

/** Default value for a Forge number custom field. */
export interface ICustomFieldContextDefaultValueForgeNumberField {
    /** The ID of the context. */
    contextId: string;
    /** The default floating-point number. */
    number: number;
    type: string;

    [key: string]: any;
}

/** The default value for a Forge object custom field. */
export class CustomFieldContextDefaultValueForgeObjectField implements ICustomFieldContextDefaultValueForgeObjectField {
    /** The default JSON object. */
    object?: any;
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueForgeObjectField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.object = _data["object"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueForgeObjectField {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueForgeObjectField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["object"] = this.object;
        data["type"] = this.type;
        return data;
    }
}

/** The default value for a Forge object custom field. */
export interface ICustomFieldContextDefaultValueForgeObjectField {
    /** The default JSON object. */
    object?: any;
    type: string;

    [key: string]: any;
}

/** The default text for a Forge string custom field. */
export class CustomFieldContextDefaultValueForgeStringField implements ICustomFieldContextDefaultValueForgeStringField {
    /** The ID of the context. */
    contextId!: string;
    /** The default text. The maximum length is 254 characters. */
    text?: string;
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueForgeStringField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contextId = _data["contextId"];
            this.text = _data["text"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueForgeStringField {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueForgeStringField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contextId"] = this.contextId;
        data["text"] = this.text;
        data["type"] = this.type;
        return data;
    }
}

/** The default text for a Forge string custom field. */
export interface ICustomFieldContextDefaultValueForgeStringField {
    /** The ID of the context. */
    contextId: string;
    /** The default text. The maximum length is 254 characters. */
    text?: string;
    type: string;

    [key: string]: any;
}

/** Defaults for a Forge user custom field. */
export class CustomFieldContextDefaultValueForgeUserField implements ICustomFieldContextDefaultValueForgeUserField {
    /** The ID of the default user. */
    accountId!: string;
    /** The ID of the context. */
    contextId!: string;
    type!: string;
    userFilter!: UserFilter;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueForgeUserField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userFilter = new UserFilter();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accountId = _data["accountId"];
            this.contextId = _data["contextId"];
            this.type = _data["type"];
            this.userFilter = _data["userFilter"] ? UserFilter.fromJS(_data["userFilter"]) : new UserFilter();
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueForgeUserField {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueForgeUserField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accountId"] = this.accountId;
        data["contextId"] = this.contextId;
        data["type"] = this.type;
        data["userFilter"] = this.userFilter ? this.userFilter.toJSON() : <any>undefined;
        return data;
    }
}

/** Defaults for a Forge user custom field. */
export interface ICustomFieldContextDefaultValueForgeUserField {
    /** The ID of the default user. */
    accountId: string;
    /** The ID of the context. */
    contextId: string;
    type: string;
    userFilter: UserFilter;

    [key: string]: any;
}

/** Default value for a labels custom field. */
export class CustomFieldContextDefaultValueLabels implements ICustomFieldContextDefaultValueLabels {
    /** The default labels value. */
    labels!: string[];
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueLabels) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.labels = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(item);
            }
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueLabels {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueLabels();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        data["type"] = this.type;
        return data;
    }
}

/** Default value for a labels custom field. */
export interface ICustomFieldContextDefaultValueLabels {
    /** The default labels value. */
    labels: string[];
    type: string;

    [key: string]: any;
}

/** The default value for a User Picker (multiple) custom field. */
export class CustomFieldContextDefaultValueMultiUserPicker implements ICustomFieldContextDefaultValueMultiUserPicker {
    /** The IDs of the default users. */
    accountIds!: string[];
    /** The ID of the context. */
    contextId!: string;
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueMultiUserPicker) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.accountIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["accountIds"])) {
                this.accountIds = [] as any;
                for (let item of _data["accountIds"])
                    this.accountIds!.push(item);
            }
            this.contextId = _data["contextId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueMultiUserPicker {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueMultiUserPicker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.accountIds)) {
            data["accountIds"] = [];
            for (let item of this.accountIds)
                data["accountIds"].push(item);
        }
        data["contextId"] = this.contextId;
        data["type"] = this.type;
        return data;
    }
}

/** The default value for a User Picker (multiple) custom field. */
export interface ICustomFieldContextDefaultValueMultiUserPicker {
    /** The IDs of the default users. */
    accountIds: string[];
    /** The ID of the context. */
    contextId: string;
    type: string;

    [key: string]: any;
}

/** The default value for a multiple group picker custom field. */
export class CustomFieldContextDefaultValueMultipleGroupPicker implements ICustomFieldContextDefaultValueMultipleGroupPicker {
    /** The ID of the context. */
    contextId!: string;
    /** The IDs of the default groups. */
    groupIds!: string[];
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueMultipleGroupPicker) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.groupIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contextId = _data["contextId"];
            if (Array.isArray(_data["groupIds"])) {
                this.groupIds = [] as any;
                for (let item of _data["groupIds"])
                    this.groupIds!.push(item);
            }
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueMultipleGroupPicker {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueMultipleGroupPicker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contextId"] = this.contextId;
        if (Array.isArray(this.groupIds)) {
            data["groupIds"] = [];
            for (let item of this.groupIds)
                data["groupIds"].push(item);
        }
        data["type"] = this.type;
        return data;
    }
}

/** The default value for a multiple group picker custom field. */
export interface ICustomFieldContextDefaultValueMultipleGroupPicker {
    /** The ID of the context. */
    contextId: string;
    /** The IDs of the default groups. */
    groupIds: string[];
    type: string;

    [key: string]: any;
}

/** The default value for a multi-select custom field. */
export class CustomFieldContextDefaultValueMultipleOption implements ICustomFieldContextDefaultValueMultipleOption {
    /** The ID of the context. */
    contextId!: string;
    /** The list of IDs of the default options. */
    optionIds!: string[];
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueMultipleOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.optionIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contextId = _data["contextId"];
            if (Array.isArray(_data["optionIds"])) {
                this.optionIds = [] as any;
                for (let item of _data["optionIds"])
                    this.optionIds!.push(item);
            }
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueMultipleOption {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueMultipleOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contextId"] = this.contextId;
        if (Array.isArray(this.optionIds)) {
            data["optionIds"] = [];
            for (let item of this.optionIds)
                data["optionIds"].push(item);
        }
        data["type"] = this.type;
        return data;
    }
}

/** The default value for a multi-select custom field. */
export interface ICustomFieldContextDefaultValueMultipleOption {
    /** The ID of the context. */
    contextId: string;
    /** The list of IDs of the default options. */
    optionIds: string[];
    type: string;

    [key: string]: any;
}

/** The default value for a multiple version picker custom field. */
export class CustomFieldContextDefaultValueMultipleVersionPicker implements ICustomFieldContextDefaultValueMultipleVersionPicker {
    type!: string;
    /** The IDs of the default versions. */
    versionIds!: string[];
    /** The order the pickable versions are displayed in. If not provided, the released-first order is used. Available version orders are `"releasedFirst"` and `"unreleasedFirst"`. */
    versionOrder?: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueMultipleVersionPicker) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.versionIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            if (Array.isArray(_data["versionIds"])) {
                this.versionIds = [] as any;
                for (let item of _data["versionIds"])
                    this.versionIds!.push(item);
            }
            this.versionOrder = _data["versionOrder"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueMultipleVersionPicker {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueMultipleVersionPicker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        if (Array.isArray(this.versionIds)) {
            data["versionIds"] = [];
            for (let item of this.versionIds)
                data["versionIds"].push(item);
        }
        data["versionOrder"] = this.versionOrder;
        return data;
    }
}

/** The default value for a multiple version picker custom field. */
export interface ICustomFieldContextDefaultValueMultipleVersionPicker {
    type: string;
    /** The IDs of the default versions. */
    versionIds: string[];
    /** The order the pickable versions are displayed in. If not provided, the released-first order is used. Available version orders are `"releasedFirst"` and `"unreleasedFirst"`. */
    versionOrder?: string;

    [key: string]: any;
}

/** The default value for a project custom field. */
export class CustomFieldContextDefaultValueProject implements ICustomFieldContextDefaultValueProject {
    /** The ID of the context. */
    contextId!: string;
    /** The ID of the default project. */
    projectId!: string;
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contextId = _data["contextId"];
            this.projectId = _data["projectId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueProject {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueProject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contextId"] = this.contextId;
        data["projectId"] = this.projectId;
        data["type"] = this.type;
        return data;
    }
}

/** The default value for a project custom field. */
export interface ICustomFieldContextDefaultValueProject {
    /** The ID of the context. */
    contextId: string;
    /** The ID of the default project. */
    projectId: string;
    type: string;

    [key: string]: any;
}

/** The default text for a read only custom field. */
export class CustomFieldContextDefaultValueReadOnly implements ICustomFieldContextDefaultValueReadOnly {
    /** The default text. The maximum length is 255 characters. */
    text?: string;
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueReadOnly) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.text = _data["text"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueReadOnly {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueReadOnly();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["text"] = this.text;
        data["type"] = this.type;
        return data;
    }
}

/** The default text for a read only custom field. */
export interface ICustomFieldContextDefaultValueReadOnly {
    /** The default text. The maximum length is 255 characters. */
    text?: string;
    type: string;

    [key: string]: any;
}

/** The default value for a group picker custom field. */
export class CustomFieldContextDefaultValueSingleGroupPicker implements ICustomFieldContextDefaultValueSingleGroupPicker {
    /** The ID of the context. */
    contextId!: string;
    /** The ID of the the default group. */
    groupId!: string;
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueSingleGroupPicker) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contextId = _data["contextId"];
            this.groupId = _data["groupId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueSingleGroupPicker {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueSingleGroupPicker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contextId"] = this.contextId;
        data["groupId"] = this.groupId;
        data["type"] = this.type;
        return data;
    }
}

/** The default value for a group picker custom field. */
export interface ICustomFieldContextDefaultValueSingleGroupPicker {
    /** The ID of the context. */
    contextId: string;
    /** The ID of the the default group. */
    groupId: string;
    type: string;

    [key: string]: any;
}

/** The default value for a single select custom field. */
export class CustomFieldContextDefaultValueSingleOption implements ICustomFieldContextDefaultValueSingleOption {
    /** The ID of the context. */
    contextId!: string;
    /** The ID of the default option. */
    optionId!: string;
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueSingleOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contextId = _data["contextId"];
            this.optionId = _data["optionId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueSingleOption {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueSingleOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contextId"] = this.contextId;
        data["optionId"] = this.optionId;
        data["type"] = this.type;
        return data;
    }
}

/** The default value for a single select custom field. */
export interface ICustomFieldContextDefaultValueSingleOption {
    /** The ID of the context. */
    contextId: string;
    /** The ID of the default option. */
    optionId: string;
    type: string;

    [key: string]: any;
}

/** The default value for a version picker custom field. */
export class CustomFieldContextDefaultValueSingleVersionPicker implements ICustomFieldContextDefaultValueSingleVersionPicker {
    type!: string;
    /** The ID of the default version. */
    versionId!: string;
    /** The order the pickable versions are displayed in. If not provided, the released-first order is used. Available version orders are `"releasedFirst"` and `"unreleasedFirst"`. */
    versionOrder?: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueSingleVersionPicker) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.versionId = _data["versionId"];
            this.versionOrder = _data["versionOrder"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueSingleVersionPicker {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueSingleVersionPicker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["versionId"] = this.versionId;
        data["versionOrder"] = this.versionOrder;
        return data;
    }
}

/** The default value for a version picker custom field. */
export interface ICustomFieldContextDefaultValueSingleVersionPicker {
    type: string;
    /** The ID of the default version. */
    versionId: string;
    /** The order the pickable versions are displayed in. If not provided, the released-first order is used. Available version orders are `"releasedFirst"` and `"unreleasedFirst"`. */
    versionOrder?: string;

    [key: string]: any;
}

/** The default text for a text area custom field. */
export class CustomFieldContextDefaultValueTextArea implements ICustomFieldContextDefaultValueTextArea {
    /** The default text. The maximum length is 32767 characters. */
    text?: string;
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueTextArea) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.text = _data["text"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueTextArea {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueTextArea();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["text"] = this.text;
        data["type"] = this.type;
        return data;
    }
}

/** The default text for a text area custom field. */
export interface ICustomFieldContextDefaultValueTextArea {
    /** The default text. The maximum length is 32767 characters. */
    text?: string;
    type: string;

    [key: string]: any;
}

/** The default text for a text custom field. */
export class CustomFieldContextDefaultValueTextField implements ICustomFieldContextDefaultValueTextField {
    /** The default text. The maximum length is 254 characters. */
    text?: string;
    type!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueTextField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.text = _data["text"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueTextField {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueTextField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["text"] = this.text;
        data["type"] = this.type;
        return data;
    }
}

/** The default text for a text custom field. */
export interface ICustomFieldContextDefaultValueTextField {
    /** The default text. The maximum length is 254 characters. */
    text?: string;
    type: string;

    [key: string]: any;
}

/** The default value for a URL custom field. */
export class CustomFieldContextDefaultValueURL implements ICustomFieldContextDefaultValueURL {
    /** The ID of the context. */
    contextId!: string;
    type!: string;
    /** The default URL. */
    url!: string;

    [key: string]: any;

    constructor(data?: ICustomFieldContextDefaultValueURL) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.contextId = _data["contextId"];
            this.type = _data["type"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueURL {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueURL();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["contextId"] = this.contextId;
        data["type"] = this.type;
        data["url"] = this.url;
        return data;
    }
}

/** The default value for a URL custom field. */
export interface ICustomFieldContextDefaultValueURL {
    /** The ID of the context. */
    contextId: string;
    type: string;
    /** The default URL. */
    url: string;

    [key: string]: any;
}

/** Default values to update. */
export class CustomFieldContextDefaultValueUpdate implements ICustomFieldContextDefaultValueUpdate {
    defaultValues?: DefaultValues[];

    constructor(data?: ICustomFieldContextDefaultValueUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["defaultValues"])) {
                this.defaultValues = [] as any;
                for (let item of _data["defaultValues"])
                    this.defaultValues!.push(DefaultValues.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomFieldContextDefaultValueUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextDefaultValueUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.defaultValues)) {
            data["defaultValues"] = [];
            for (let item of this.defaultValues)
                data["defaultValues"].push(item.toJSON());
        }
        return data;
    }
}

/** Default values to update. */
export interface ICustomFieldContextDefaultValueUpdate {
    defaultValues?: DefaultValues[];
}

/** Details of the custom field options for a context. */
export class CustomFieldContextOption implements ICustomFieldContextOption {
    /** Whether the option is disabled. */
    disabled!: boolean;
    /** The ID of the custom field option. */
    id!: string;
    /** For cascading options, the ID of the custom field option containing the cascading option. */
    optionId?: string;
    /** The value of the custom field option. */
    value!: string;

    constructor(data?: ICustomFieldContextOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.id = _data["id"];
            this.optionId = _data["optionId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CustomFieldContextOption {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["id"] = this.id;
        data["optionId"] = this.optionId;
        data["value"] = this.value;
        return data;
    }
}

/** Details of the custom field options for a context. */
export interface ICustomFieldContextOption {
    /** Whether the option is disabled. */
    disabled: boolean;
    /** The ID of the custom field option. */
    id: string;
    /** For cascading options, the ID of the custom field option containing the cascading option. */
    optionId?: string;
    /** The value of the custom field option. */
    value: string;
}

/** Details of a context to project association. */
export class CustomFieldContextProjectMapping implements ICustomFieldContextProjectMapping {
    /** The ID of the context. */
    readonly contextId!: string;
    /** Whether context is global. */
    readonly isGlobalContext?: boolean;
    /** The ID of the project. */
    readonly projectId?: string;

    constructor(data?: ICustomFieldContextProjectMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).contextId = _data["contextId"];
            (<any>this).isGlobalContext = _data["isGlobalContext"];
            (<any>this).projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): CustomFieldContextProjectMapping {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextProjectMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contextId"] = this.contextId;
        data["isGlobalContext"] = this.isGlobalContext;
        data["projectId"] = this.projectId;
        return data;
    }
}

/** Details of a context to project association. */
export interface ICustomFieldContextProjectMapping {
    /** The ID of the context. */
    contextId: string;
    /** Whether context is global. */
    isGlobalContext?: boolean;
    /** The ID of the project. */
    projectId?: string;
}

/** Defaults for a User Picker (single) custom field. */
export class CustomFieldContextSingleUserPickerDefaults implements ICustomFieldContextSingleUserPickerDefaults {
    /** The ID of the default user. */
    accountId!: string;
    /** The ID of the context. */
    contextId!: string;
    type!: string;
    userFilter!: UserFilter;

    [key: string]: any;

    constructor(data?: ICustomFieldContextSingleUserPickerDefaults) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userFilter = new UserFilter();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accountId = _data["accountId"];
            this.contextId = _data["contextId"];
            this.type = _data["type"];
            this.userFilter = _data["userFilter"] ? UserFilter.fromJS(_data["userFilter"]) : new UserFilter();
        }
    }

    static fromJS(data: any): CustomFieldContextSingleUserPickerDefaults {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextSingleUserPickerDefaults();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accountId"] = this.accountId;
        data["contextId"] = this.contextId;
        data["type"] = this.type;
        data["userFilter"] = this.userFilter ? this.userFilter.toJSON() : <any>undefined;
        return data;
    }
}

/** Defaults for a User Picker (single) custom field. */
export interface ICustomFieldContextSingleUserPickerDefaults {
    /** The ID of the default user. */
    accountId: string;
    /** The ID of the context. */
    contextId: string;
    type: string;
    userFilter: UserFilter;

    [key: string]: any;
}

/** Details of a custom field context. */
export class CustomFieldContextUpdateDetails implements ICustomFieldContextUpdateDetails {
    /** The description of the custom field context. The maximum length is 255 characters. */
    description?: string;
    /** The name of the custom field context. The name must be unique. The maximum length is 255 characters. */
    name?: string;

    constructor(data?: ICustomFieldContextUpdateDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CustomFieldContextUpdateDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldContextUpdateDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

/** Details of a custom field context. */
export interface ICustomFieldContextUpdateDetails {
    /** The description of the custom field context. The maximum length is 255 characters. */
    description?: string;
    /** The name of the custom field context. The name must be unique. The maximum length is 255 characters. */
    name?: string;
}

/** A list of custom field options for a context. */
export class CustomFieldCreatedContextOptionsList implements ICustomFieldCreatedContextOptionsList {
    /** The created custom field options. */
    options?: CustomFieldContextOption[];

    constructor(data?: ICustomFieldCreatedContextOptionsList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(CustomFieldContextOption.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomFieldCreatedContextOptionsList {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldCreatedContextOptionsList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data;
    }
}

/** A list of custom field options for a context. */
export interface ICustomFieldCreatedContextOptionsList {
    /** The created custom field options. */
    options?: CustomFieldContextOption[];
}

export class CustomFieldDefinitionJsonBean implements ICustomFieldDefinitionJsonBean {
    /** The description of the custom field, which is displayed in Jira. */
    description?: string;
    /** The name of the custom field, which is displayed in Jira. This is not the unique identifier. */
    name!: string;
    /** The searcher defines the way the field is searched in Jira. For example, *com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher*.  
The search UI (basic search and JQL search) will display different operations and values for the field, based on the field searcher. You must specify a searcher that is valid for the field type, as listed below (abbreviated values shown):

 *  `cascadingselect`: `cascadingselectsearcher`
 *  `datepicker`: `daterange`
 *  `datetime`: `datetimerange`
 *  `float`: `exactnumber` or `numberrange`
 *  `grouppicker`: `grouppickersearcher`
 *  `importid`: `exactnumber` or `numberrange`
 *  `labels`: `labelsearcher`
 *  `multicheckboxes`: `multiselectsearcher`
 *  `multigrouppicker`: `multiselectsearcher`
 *  `multiselect`: `multiselectsearcher`
 *  `multiuserpicker`: `userpickergroupsearcher`
 *  `multiversion`: `versionsearcher`
 *  `project`: `projectsearcher`
 *  `radiobuttons`: `multiselectsearcher`
 *  `readonlyfield`: `textsearcher`
 *  `select`: `multiselectsearcher`
 *  `textarea`: `textsearcher`
 *  `textfield`: `textsearcher`
 *  `url`: `exacttextsearcher`
 *  `userpicker`: `userpickergroupsearcher`
 *  `version`: `versionsearcher`

If no searcher is provided, the field isn't searchable. However, [Forge custom fields](https://developer.atlassian.com/platform/forge/manifest-reference/modules/#jira-custom-field-type--beta-) have a searcher set automatically, so are always searchable. */
    searcherKey?: CustomFieldDefinitionJsonBeanSearcherKey;
    /** The type of the custom field. These built-in custom field types are available:

 *  `cascadingselect`: Enables values to be selected from two levels of select lists (value: `com.atlassian.jira.plugin.system.customfieldtypes:cascadingselect`)
 *  `datepicker`: Stores a date using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:datepicker`)
 *  `datetime`: Stores a date with a time component (value: `com.atlassian.jira.plugin.system.customfieldtypes:datetime`)
 *  `float`: Stores and validates a numeric (floating point) input (value: `com.atlassian.jira.plugin.system.customfieldtypes:float`)
 *  `grouppicker`: Stores a user group using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:grouppicker`)
 *  `importid`: A read-only field that stores the ID the issue had in the system it was imported from (value: `com.atlassian.jira.plugin.system.customfieldtypes:importid`)
 *  `labels`: Stores labels (value: `com.atlassian.jira.plugin.system.customfieldtypes:labels`)
 *  `multicheckboxes`: Stores multiple values using checkboxes (value: ``)
 *  `multigrouppicker`: Stores multiple user groups using a picker control (value: ``)
 *  `multiselect`: Stores multiple values using a select list (value: `com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes`)
 *  `multiuserpicker`: Stores multiple users using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:multigrouppicker`)
 *  `multiversion`: Stores multiple versions from the versions available in a project using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:multiversion`)
 *  `project`: Stores a project from a list of projects that the user is permitted to view (value: `com.atlassian.jira.plugin.system.customfieldtypes:project`)
 *  `radiobuttons`: Stores a value using radio buttons (value: `com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons`)
 *  `readonlyfield`: Stores a read-only text value, which can only be populated via the API (value: `com.atlassian.jira.plugin.system.customfieldtypes:readonlyfield`)
 *  `select`: Stores a value from a configurable list of options (value: `com.atlassian.jira.plugin.system.customfieldtypes:select`)
 *  `textarea`: Stores a long text string using a multiline text area (value: `com.atlassian.jira.plugin.system.customfieldtypes:textarea`)
 *  `textfield`: Stores a text string using a single-line text box (value: `com.atlassian.jira.plugin.system.customfieldtypes:textfield`)
 *  `url`: Stores a URL (value: `com.atlassian.jira.plugin.system.customfieldtypes:url`)
 *  `userpicker`: Stores a user using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:userpicker`)
 *  `version`: Stores a version using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:version`)

To create a field based on a [Forge custom field type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/#jira-custom-field-type--beta-), use the ID of the Forge custom field type as the value. For example, `ari:cloud:ecosystem::extension/e62f20a2-4b61-4dbe-bfb9-9a88b5e3ac84/548c5df1-24aa-4f7c-bbbb-3038d947cb05/static/my-cf-type-key`. */
    type!: string;

    constructor(data?: ICustomFieldDefinitionJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
            this.searcherKey = _data["searcherKey"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CustomFieldDefinitionJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldDefinitionJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        data["searcherKey"] = this.searcherKey;
        data["type"] = this.type;
        return data;
    }
}

export interface ICustomFieldDefinitionJsonBean {
    /** The description of the custom field, which is displayed in Jira. */
    description?: string;
    /** The name of the custom field, which is displayed in Jira. This is not the unique identifier. */
    name: string;
    /** The searcher defines the way the field is searched in Jira. For example, *com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher*.  
The search UI (basic search and JQL search) will display different operations and values for the field, based on the field searcher. You must specify a searcher that is valid for the field type, as listed below (abbreviated values shown):

 *  `cascadingselect`: `cascadingselectsearcher`
 *  `datepicker`: `daterange`
 *  `datetime`: `datetimerange`
 *  `float`: `exactnumber` or `numberrange`
 *  `grouppicker`: `grouppickersearcher`
 *  `importid`: `exactnumber` or `numberrange`
 *  `labels`: `labelsearcher`
 *  `multicheckboxes`: `multiselectsearcher`
 *  `multigrouppicker`: `multiselectsearcher`
 *  `multiselect`: `multiselectsearcher`
 *  `multiuserpicker`: `userpickergroupsearcher`
 *  `multiversion`: `versionsearcher`
 *  `project`: `projectsearcher`
 *  `radiobuttons`: `multiselectsearcher`
 *  `readonlyfield`: `textsearcher`
 *  `select`: `multiselectsearcher`
 *  `textarea`: `textsearcher`
 *  `textfield`: `textsearcher`
 *  `url`: `exacttextsearcher`
 *  `userpicker`: `userpickergroupsearcher`
 *  `version`: `versionsearcher`

If no searcher is provided, the field isn't searchable. However, [Forge custom fields](https://developer.atlassian.com/platform/forge/manifest-reference/modules/#jira-custom-field-type--beta-) have a searcher set automatically, so are always searchable. */
    searcherKey?: CustomFieldDefinitionJsonBeanSearcherKey;
    /** The type of the custom field. These built-in custom field types are available:

 *  `cascadingselect`: Enables values to be selected from two levels of select lists (value: `com.atlassian.jira.plugin.system.customfieldtypes:cascadingselect`)
 *  `datepicker`: Stores a date using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:datepicker`)
 *  `datetime`: Stores a date with a time component (value: `com.atlassian.jira.plugin.system.customfieldtypes:datetime`)
 *  `float`: Stores and validates a numeric (floating point) input (value: `com.atlassian.jira.plugin.system.customfieldtypes:float`)
 *  `grouppicker`: Stores a user group using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:grouppicker`)
 *  `importid`: A read-only field that stores the ID the issue had in the system it was imported from (value: `com.atlassian.jira.plugin.system.customfieldtypes:importid`)
 *  `labels`: Stores labels (value: `com.atlassian.jira.plugin.system.customfieldtypes:labels`)
 *  `multicheckboxes`: Stores multiple values using checkboxes (value: ``)
 *  `multigrouppicker`: Stores multiple user groups using a picker control (value: ``)
 *  `multiselect`: Stores multiple values using a select list (value: `com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes`)
 *  `multiuserpicker`: Stores multiple users using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:multigrouppicker`)
 *  `multiversion`: Stores multiple versions from the versions available in a project using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:multiversion`)
 *  `project`: Stores a project from a list of projects that the user is permitted to view (value: `com.atlassian.jira.plugin.system.customfieldtypes:project`)
 *  `radiobuttons`: Stores a value using radio buttons (value: `com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons`)
 *  `readonlyfield`: Stores a read-only text value, which can only be populated via the API (value: `com.atlassian.jira.plugin.system.customfieldtypes:readonlyfield`)
 *  `select`: Stores a value from a configurable list of options (value: `com.atlassian.jira.plugin.system.customfieldtypes:select`)
 *  `textarea`: Stores a long text string using a multiline text area (value: `com.atlassian.jira.plugin.system.customfieldtypes:textarea`)
 *  `textfield`: Stores a text string using a single-line text box (value: `com.atlassian.jira.plugin.system.customfieldtypes:textfield`)
 *  `url`: Stores a URL (value: `com.atlassian.jira.plugin.system.customfieldtypes:url`)
 *  `userpicker`: Stores a user using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:userpicker`)
 *  `version`: Stores a version using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:version`)

To create a field based on a [Forge custom field type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/#jira-custom-field-type--beta-), use the ID of the Forge custom field type as the value. For example, `ari:cloud:ecosystem::extension/e62f20a2-4b61-4dbe-bfb9-9a88b5e3ac84/548c5df1-24aa-4f7c-bbbb-3038d947cb05/static/my-cf-type-key`. */
    type: string;
}

/** Details of a custom option for a field. */
export class CustomFieldOption implements ICustomFieldOption {
    /** The URL of these custom field option details. */
    readonly self?: string;
    /** The value of the custom field option. */
    readonly value?: string;

    constructor(data?: ICustomFieldOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).self = _data["self"];
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): CustomFieldOption {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["self"] = this.self;
        data["value"] = this.value;
        return data;
    }
}

/** Details of a custom option for a field. */
export interface ICustomFieldOption {
    /** The URL of these custom field option details. */
    self?: string;
    /** The value of the custom field option. */
    value?: string;
}

/** Details of a custom field option to create. */
export class CustomFieldOptionCreate implements ICustomFieldOptionCreate {
    /** Whether the option is disabled. */
    disabled?: boolean;
    /** For cascading options, the ID of a parent option. */
    optionId?: string;
    /** The value of the custom field option. */
    value!: string;

    constructor(data?: ICustomFieldOptionCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.optionId = _data["optionId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CustomFieldOptionCreate {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldOptionCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["optionId"] = this.optionId;
        data["value"] = this.value;
        return data;
    }
}

/** Details of a custom field option to create. */
export interface ICustomFieldOptionCreate {
    /** Whether the option is disabled. */
    disabled?: boolean;
    /** For cascading options, the ID of a parent option. */
    optionId?: string;
    /** The value of the custom field option. */
    value: string;
}

/** Details of a custom field option for a context. */
export class CustomFieldOptionUpdate implements ICustomFieldOptionUpdate {
    /** Whether the option is disabled. */
    disabled?: boolean;
    /** The ID of the custom field option. */
    id!: string;
    /** The value of the custom field option. */
    value?: string;

    constructor(data?: ICustomFieldOptionUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"];
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CustomFieldOptionUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldOptionUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["id"] = this.id;
        data["value"] = this.value;
        return data;
    }
}

/** Details of a custom field option for a context. */
export interface ICustomFieldOptionUpdate {
    /** Whether the option is disabled. */
    disabled?: boolean;
    /** The ID of the custom field option. */
    id: string;
    /** The value of the custom field option. */
    value?: string;
}

/** Defines the payload for the custom field definitions. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-fields/\#api-rest-api-3-field-post */
export class CustomFieldPayload implements ICustomFieldPayload {
    /** The type of the custom field */
    cfType?: string;
    /** The description of the custom field */
    description?: string;
    /** The name of the custom field */
    name?: string;
    /** The strategy to use when there is a conflict with an existing custom field. FAIL - Fail execution, this always needs to be unique; USE - Use the existing entity and ignore new entity parameters */
    onConflict?: CustomFieldPayloadOnConflict;
    pcri?: ProjectCreateResourceIdentifier;
    /** The searcher key of the custom field */
    searcherKey?: string;

    constructor(data?: ICustomFieldPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cfType = _data["cfType"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.onConflict = _data["onConflict"];
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
            this.searcherKey = _data["searcherKey"];
        }
    }

    static fromJS(data: any): CustomFieldPayload {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cfType"] = this.cfType;
        data["description"] = this.description;
        data["name"] = this.name;
        data["onConflict"] = this.onConflict;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        data["searcherKey"] = this.searcherKey;
        return data;
    }
}

/** Defines the payload for the custom field definitions. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-fields/\#api-rest-api-3-field-post */
export interface ICustomFieldPayload {
    /** The type of the custom field */
    cfType?: string;
    /** The description of the custom field */
    description?: string;
    /** The name of the custom field */
    name?: string;
    /** The strategy to use when there is a conflict with an existing custom field. FAIL - Fail execution, this always needs to be unique; USE - Use the existing entity and ignore new entity parameters */
    onConflict?: CustomFieldPayloadOnConflict;
    pcri?: ProjectCreateResourceIdentifier;
    /** The searcher key of the custom field */
    searcherKey?: string;
}

/** Details about the replacement for a deleted version. */
export class CustomFieldReplacement implements ICustomFieldReplacement {
    /** The ID of the custom field in which to replace the version number. */
    customFieldId?: number;
    /** The version number to use as a replacement for the deleted version. */
    moveTo?: number;

    constructor(data?: ICustomFieldReplacement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customFieldId = _data["customFieldId"];
            this.moveTo = _data["moveTo"];
        }
    }

    static fromJS(data: any): CustomFieldReplacement {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldReplacement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customFieldId"] = this.customFieldId;
        data["moveTo"] = this.moveTo;
        return data;
    }
}

/** Details about the replacement for a deleted version. */
export interface ICustomFieldReplacement {
    /** The ID of the custom field in which to replace the version number. */
    customFieldId?: number;
    /** The version number to use as a replacement for the deleted version. */
    moveTo?: number;
}

/** A list of custom field options for a context. */
export class CustomFieldUpdatedContextOptionsList implements ICustomFieldUpdatedContextOptionsList {
    /** The updated custom field options. */
    options?: CustomFieldOptionUpdate[];

    constructor(data?: ICustomFieldUpdatedContextOptionsList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(CustomFieldOptionUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomFieldUpdatedContextOptionsList {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldUpdatedContextOptionsList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data;
    }
}

/** A list of custom field options for a context. */
export interface ICustomFieldUpdatedContextOptionsList {
    /** The updated custom field options. */
    options?: CustomFieldOptionUpdate[];
}

/** A list of issue IDs and the value to update a custom field to. */
export class CustomFieldValueUpdate implements ICustomFieldValueUpdate {
    /** The list of issue IDs. */
    issueIds!: number[];
    /** The value for the custom field. The value must be compatible with the [custom field type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#data-types) as follows:

 *  `string` the value must be a string.
 *  `number` the value must be a number.
 *  `datetime` the value must be a string that represents a date in the ISO format or the simplified extended ISO format. For example, `"2023-01-18T12:00:00-03:00"` or `"2023-01-18T12:00:00.000Z"`. However, the milliseconds part is ignored.
 *  `user` the value must be an object that contains the `accountId` field.
 *  `group` the value must be an object that contains the group `name` or `groupId` field. Because group names can change, we recommend using `groupId`.

A list of appropriate values must be provided if the field is of the `list` [collection type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#collection-types). */
    value!: any;

    constructor(data?: ICustomFieldValueUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueIds"])) {
                this.issueIds = [] as any;
                for (let item of _data["issueIds"])
                    this.issueIds!.push(item);
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CustomFieldValueUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldValueUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueIds)) {
            data["issueIds"] = [];
            for (let item of this.issueIds)
                data["issueIds"].push(item);
        }
        data["value"] = this.value;
        return data;
    }
}

/** A list of issue IDs and the value to update a custom field to. */
export interface ICustomFieldValueUpdate {
    /** The list of issue IDs. */
    issueIds: number[];
    /** The value for the custom field. The value must be compatible with the [custom field type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#data-types) as follows:

 *  `string` the value must be a string.
 *  `number` the value must be a number.
 *  `datetime` the value must be a string that represents a date in the ISO format or the simplified extended ISO format. For example, `"2023-01-18T12:00:00-03:00"` or `"2023-01-18T12:00:00.000Z"`. However, the milliseconds part is ignored.
 *  `user` the value must be an object that contains the `accountId` field.
 *  `group` the value must be an object that contains the group `name` or `groupId` field. Because group names can change, we recommend using `groupId`.

A list of appropriate values must be provided if the field is of the `list` [collection type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#collection-types). */
    value: any;
}

/** Details of updates for a custom field. */
export class CustomFieldValueUpdateDetails implements ICustomFieldValueUpdateDetails {
    /** The list of custom field update details. */
    updates?: CustomFieldValueUpdate[];

    constructor(data?: ICustomFieldValueUpdateDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["updates"])) {
                this.updates = [] as any;
                for (let item of _data["updates"])
                    this.updates!.push(CustomFieldValueUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomFieldValueUpdateDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CustomFieldValueUpdateDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.updates)) {
            data["updates"] = [];
            for (let item of this.updates)
                data["updates"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of updates for a custom field. */
export interface ICustomFieldValueUpdateDetails {
    /** The list of custom field update details. */
    updates?: CustomFieldValueUpdate[];
}

/** The specific request object for creating a project with template. */
export class CustomTemplateRequestDTO implements ICustomTemplateRequestDTO {
    boards?: BoardsPayload | undefined;
    field?: FieldCapabilityPayload | undefined;
    issueType?: IssueTypeProjectCreatePayload | undefined;
    notification?: NotificationSchemePayload | undefined;
    permissionScheme?: PermissionPayloadDTO | undefined;
    project?: ProjectPayload;
    role?: RolesCapabilityPayload | undefined;
    scope?: ScopePayload | undefined;
    security?: SecuritySchemePayload | undefined;
    workflow?: WorkflowCapabilityPayload | undefined;

    constructor(data?: ICustomTemplateRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.boards = _data["boards"] ? BoardsPayload.fromJS(_data["boards"]) : <any>undefined;
            this.field = _data["field"] ? FieldCapabilityPayload.fromJS(_data["field"]) : <any>undefined;
            this.issueType = _data["issueType"] ? IssueTypeProjectCreatePayload.fromJS(_data["issueType"]) : <any>undefined;
            this.notification = _data["notification"] ? NotificationSchemePayload.fromJS(_data["notification"]) : <any>undefined;
            this.permissionScheme = _data["permissionScheme"] ? PermissionPayloadDTO.fromJS(_data["permissionScheme"]) : <any>undefined;
            this.project = _data["project"] ? ProjectPayload.fromJS(_data["project"]) : <any>undefined;
            this.role = _data["role"] ? RolesCapabilityPayload.fromJS(_data["role"]) : <any>undefined;
            this.scope = _data["scope"] ? ScopePayload.fromJS(_data["scope"]) : <any>undefined;
            this.security = _data["security"] ? SecuritySchemePayload.fromJS(_data["security"]) : <any>undefined;
            this.workflow = _data["workflow"] ? WorkflowCapabilityPayload.fromJS(_data["workflow"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomTemplateRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CustomTemplateRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["boards"] = this.boards ? this.boards.toJSON() : <any>undefined;
        data["field"] = this.field ? this.field.toJSON() : <any>undefined;
        data["issueType"] = this.issueType ? this.issueType.toJSON() : <any>undefined;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["permissionScheme"] = this.permissionScheme ? this.permissionScheme.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["workflow"] = this.workflow ? this.workflow.toJSON() : <any>undefined;
        return data;
    }
}

/** The specific request object for creating a project with template. */
export interface ICustomTemplateRequestDTO {
    boards?: BoardsPayload | undefined;
    field?: FieldCapabilityPayload | undefined;
    issueType?: IssueTypeProjectCreatePayload | undefined;
    notification?: NotificationSchemePayload | undefined;
    permissionScheme?: PermissionPayloadDTO | undefined;
    project?: ProjectPayload;
    role?: RolesCapabilityPayload | undefined;
    scope?: ScopePayload | undefined;
    security?: SecuritySchemePayload | undefined;
    workflow?: WorkflowCapabilityPayload | undefined;
}

/** Project Details */
export class CustomTemplatesProjectDetails implements ICustomTemplatesProjectDetails {
    /** The access level of the project. Only used by team-managed project */
    accessLevel?: CustomTemplatesProjectDetailsAccessLevel;
    /** Additional properties of the project */
    additionalProperties?: { [key: string]: string; };
    /** The default assignee when creating issues in the project */
    assigneeType?: CustomTemplatesProjectDetailsAssigneeType;
    /** The ID of the project's avatar. Use the \[Get project avatars\](\#api-rest-api-3-project-projectIdOrKey-avatar-get) operation to list the available avatars in a project. */
    avatarId?: number;
    /** The ID of the project's category. A complete list of category IDs is found using the [Get all project categories](#api-rest-api-3-projectCategory-get) operation. */
    categoryId?: number;
    /** Brief description of the project */
    description?: string;
    /** Whether components are enabled for the project. Only used by company-managed project */
    enableComponents?: boolean;
    /** Project keys must be unique and start with an uppercase letter followed by one or more uppercase alphanumeric characters. The maximum length is 10 characters. */
    key?: string;
    /** The default language for the project */
    language?: string;
    /** The account ID of the project lead. Either `lead` or `leadAccountId` must be set when creating a project. Cannot be provided with `lead`. */
    leadAccountId?: string;
    /** Name of the project */
    name?: string;
    /** A link to information about this project, such as project documentation */
    url?: string;

    constructor(data?: ICustomTemplatesProjectDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.enableComponents = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessLevel = _data["accessLevel"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
            this.assigneeType = _data["assigneeType"];
            this.avatarId = _data["avatarId"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            this.enableComponents = _data["enableComponents"] !== undefined ? _data["enableComponents"] : false;
            this.key = _data["key"];
            this.language = _data["language"];
            this.leadAccountId = _data["leadAccountId"];
            this.name = _data["name"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): CustomTemplatesProjectDetails {
        data = typeof data === 'object' ? data : {};
        let result = new CustomTemplatesProjectDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessLevel"] = this.accessLevel;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = (<any>this.additionalProperties)[key];
            }
        }
        data["assigneeType"] = this.assigneeType;
        data["avatarId"] = this.avatarId;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        data["enableComponents"] = this.enableComponents;
        data["key"] = this.key;
        data["language"] = this.language;
        data["leadAccountId"] = this.leadAccountId;
        data["name"] = this.name;
        data["url"] = this.url;
        return data;
    }
}

/** Project Details */
export interface ICustomTemplatesProjectDetails {
    /** The access level of the project. Only used by team-managed project */
    accessLevel?: CustomTemplatesProjectDetailsAccessLevel;
    /** Additional properties of the project */
    additionalProperties?: { [key: string]: string; };
    /** The default assignee when creating issues in the project */
    assigneeType?: CustomTemplatesProjectDetailsAssigneeType;
    /** The ID of the project's avatar. Use the \[Get project avatars\](\#api-rest-api-3-project-projectIdOrKey-avatar-get) operation to list the available avatars in a project. */
    avatarId?: number;
    /** The ID of the project's category. A complete list of category IDs is found using the [Get all project categories](#api-rest-api-3-projectCategory-get) operation. */
    categoryId?: number;
    /** Brief description of the project */
    description?: string;
    /** Whether components are enabled for the project. Only used by company-managed project */
    enableComponents?: boolean;
    /** Project keys must be unique and start with an uppercase letter followed by one or more uppercase alphanumeric characters. The maximum length is 10 characters. */
    key?: string;
    /** The default language for the project */
    language?: string;
    /** The account ID of the project lead. Either `lead` or `leadAccountId` must be set when creating a project. Cannot be provided with `lead`. */
    leadAccountId?: string;
    /** Name of the project */
    name?: string;
    /** A link to information about this project, such as project documentation */
    url?: string;
}

/** Details of a dashboard. */
export class Dashboard implements IDashboard {
    /** The automatic refresh interval for the dashboard in milliseconds. */
    readonly automaticRefreshMs?: number;
    description?: string;
    /** The details of any edit share permissions for the dashboard. */
    readonly editPermissions?: SharePermission[];
    /** The ID of the dashboard. */
    readonly id?: string;
    /** Whether the dashboard is selected as a favorite by the user. */
    readonly isFavourite?: boolean;
    /** Whether the current user has permission to edit the dashboard. */
    readonly isWritable?: boolean;
    /** The name of the dashboard. */
    readonly name?: string;
    /** The owner of the dashboard. */
    readonly owner?: UserBean;
    /** The number of users who have this dashboard as a favorite. */
    readonly popularity?: number;
    /** The rank of this dashboard. */
    readonly rank?: number;
    /** The URL of these dashboard details. */
    readonly self?: string;
    /** The details of any view share permissions for the dashboard. */
    readonly sharePermissions?: SharePermission[];
    /** Whether the current dashboard is system dashboard. */
    readonly systemDashboard?: boolean;
    /** The URL of the dashboard. */
    readonly view?: string;

    constructor(data?: IDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).automaticRefreshMs = _data["automaticRefreshMs"];
            this.description = _data["description"];
            if (Array.isArray(_data["editPermissions"])) {
                (<any>this).editPermissions = [] as any;
                for (let item of _data["editPermissions"])
                    (<any>this).editPermissions!.push(SharePermission.fromJS(item));
            }
            (<any>this).id = _data["id"];
            (<any>this).isFavourite = _data["isFavourite"];
            (<any>this).isWritable = _data["isWritable"];
            (<any>this).name = _data["name"];
            (<any>this).owner = _data["owner"] ? UserBean.fromJS(_data["owner"]) : <any>undefined;
            (<any>this).popularity = _data["popularity"];
            (<any>this).rank = _data["rank"];
            (<any>this).self = _data["self"];
            if (Array.isArray(_data["sharePermissions"])) {
                (<any>this).sharePermissions = [] as any;
                for (let item of _data["sharePermissions"])
                    (<any>this).sharePermissions!.push(SharePermission.fromJS(item));
            }
            (<any>this).systemDashboard = _data["systemDashboard"];
            (<any>this).view = _data["view"];
        }
    }

    static fromJS(data: any): Dashboard {
        data = typeof data === 'object' ? data : {};
        let result = new Dashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["automaticRefreshMs"] = this.automaticRefreshMs;
        data["description"] = this.description;
        if (Array.isArray(this.editPermissions)) {
            data["editPermissions"] = [];
            for (let item of this.editPermissions)
                data["editPermissions"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["isFavourite"] = this.isFavourite;
        data["isWritable"] = this.isWritable;
        data["name"] = this.name;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["popularity"] = this.popularity;
        data["rank"] = this.rank;
        data["self"] = this.self;
        if (Array.isArray(this.sharePermissions)) {
            data["sharePermissions"] = [];
            for (let item of this.sharePermissions)
                data["sharePermissions"].push(item.toJSON());
        }
        data["systemDashboard"] = this.systemDashboard;
        data["view"] = this.view;
        return data;
    }
}

/** Details of a dashboard. */
export interface IDashboard {
    /** The automatic refresh interval for the dashboard in milliseconds. */
    automaticRefreshMs?: number;
    description?: string;
    /** The details of any edit share permissions for the dashboard. */
    editPermissions?: SharePermission[];
    /** The ID of the dashboard. */
    id?: string;
    /** Whether the dashboard is selected as a favorite by the user. */
    isFavourite?: boolean;
    /** Whether the current user has permission to edit the dashboard. */
    isWritable?: boolean;
    /** The name of the dashboard. */
    name?: string;
    /** The owner of the dashboard. */
    owner?: UserBean;
    /** The number of users who have this dashboard as a favorite. */
    popularity?: number;
    /** The rank of this dashboard. */
    rank?: number;
    /** The URL of these dashboard details. */
    self?: string;
    /** The details of any view share permissions for the dashboard. */
    sharePermissions?: SharePermission[];
    /** Whether the current dashboard is system dashboard. */
    systemDashboard?: boolean;
    /** The URL of the dashboard. */
    view?: string;
}

/** Details of a dashboard. */
export class DashboardDetails implements IDashboardDetails {
    /** The description of the dashboard. */
    description?: string;
    /** The edit permissions for the dashboard. */
    editPermissions!: SharePermission[];
    /** The name of the dashboard. */
    name!: string;
    /** The share permissions for the dashboard. */
    sharePermissions!: SharePermission[];

    constructor(data?: IDashboardDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.editPermissions = [];
            this.sharePermissions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            if (Array.isArray(_data["editPermissions"])) {
                this.editPermissions = [] as any;
                for (let item of _data["editPermissions"])
                    this.editPermissions!.push(SharePermission.fromJS(item));
            }
            this.name = _data["name"];
            if (Array.isArray(_data["sharePermissions"])) {
                this.sharePermissions = [] as any;
                for (let item of _data["sharePermissions"])
                    this.sharePermissions!.push(SharePermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardDetails {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        if (Array.isArray(this.editPermissions)) {
            data["editPermissions"] = [];
            for (let item of this.editPermissions)
                data["editPermissions"].push(item.toJSON());
        }
        data["name"] = this.name;
        if (Array.isArray(this.sharePermissions)) {
            data["sharePermissions"] = [];
            for (let item of this.sharePermissions)
                data["sharePermissions"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of a dashboard. */
export interface IDashboardDetails {
    /** The description of the dashboard. */
    description?: string;
    /** The edit permissions for the dashboard. */
    editPermissions: SharePermission[];
    /** The name of the dashboard. */
    name: string;
    /** The share permissions for the dashboard. */
    sharePermissions: SharePermission[];
}

/** Details of a gadget. */
export class DashboardGadget implements IDashboardGadget {
    /** The color of the gadget. Should be one of `blue`, `red`, `yellow`, `green`, `cyan`, `purple`, `gray`, or `white`. */
    readonly color!: DashboardGadgetColor;
    /** The ID of the gadget instance. */
    readonly id!: number;
    /** The module key of the gadget type. */
    readonly moduleKey?: string;
    /** The position of the gadget. */
    readonly position!: DashboardGadgetPosition;
    /** The title of the gadget. */
    readonly title!: string;
    /** The URI of the gadget type. */
    readonly uri?: string;

    constructor(data?: IDashboardGadget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.position = new DashboardGadgetPosition();
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).color = _data["color"];
            (<any>this).id = _data["id"];
            (<any>this).moduleKey = _data["moduleKey"];
            (<any>this).position = _data["position"] ? DashboardGadgetPosition.fromJS(_data["position"]) : new DashboardGadgetPosition();
            (<any>this).title = _data["title"];
            (<any>this).uri = _data["uri"];
        }
    }

    static fromJS(data: any): DashboardGadget {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardGadget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["color"] = this.color;
        data["id"] = this.id;
        data["moduleKey"] = this.moduleKey;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["uri"] = this.uri;
        return data;
    }
}

/** Details of a gadget. */
export interface IDashboardGadget {
    /** The color of the gadget. Should be one of `blue`, `red`, `yellow`, `green`, `cyan`, `purple`, `gray`, or `white`. */
    color: DashboardGadgetColor;
    /** The ID of the gadget instance. */
    id: number;
    /** The module key of the gadget type. */
    moduleKey?: string;
    /** The position of the gadget. */
    position: DashboardGadgetPosition;
    /** The title of the gadget. */
    title: string;
    /** The URI of the gadget type. */
    uri?: string;
}

/** Details of a gadget position. */
export class DashboardGadgetPosition implements IDashboardGadgetPosition {
    the_column_position_of_the_gadget!: number;
    the_row_position_of_the_gadget!: number;

    constructor(data?: IDashboardGadgetPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.the_column_position_of_the_gadget = _data["The column position of the gadget."];
            this.the_row_position_of_the_gadget = _data["The row position of the gadget."];
        }
    }

    static fromJS(data: any): DashboardGadgetPosition {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardGadgetPosition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["The column position of the gadget."] = this.the_column_position_of_the_gadget;
        data["The row position of the gadget."] = this.the_row_position_of_the_gadget;
        return data;
    }
}

/** Details of a gadget position. */
export interface IDashboardGadgetPosition {
    the_column_position_of_the_gadget: number;
    the_row_position_of_the_gadget: number;
}

/** The list of gadgets on the dashboard. */
export class DashboardGadgetResponse implements IDashboardGadgetResponse {
    /** The list of gadgets. */
    readonly gadgets!: DashboardGadget[];

    constructor(data?: IDashboardGadgetResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.gadgets = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["gadgets"])) {
                (<any>this).gadgets = [] as any;
                for (let item of _data["gadgets"])
                    (<any>this).gadgets!.push(DashboardGadget.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardGadgetResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardGadgetResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.gadgets)) {
            data["gadgets"] = [];
            for (let item of this.gadgets)
                data["gadgets"].push(item.toJSON());
        }
        return data;
    }
}

/** The list of gadgets on the dashboard. */
export interface IDashboardGadgetResponse {
    /** The list of gadgets. */
    gadgets: DashboardGadget[];
}

/** Details of the settings for a dashboard gadget. */
export class DashboardGadgetSettings implements IDashboardGadgetSettings {
    /** The color of the gadget. Should be one of `blue`, `red`, `yellow`, `green`, `cyan`, `purple`, `gray`, or `white`. */
    color?: string;
    /** Whether to ignore the validation of module key and URI. For example, when a gadget is created that is a part of an application that isn't installed. */
    ignoreUriAndModuleKeyValidation?: boolean;
    /** The module key of the gadget type. Can't be provided with `uri`. */
    moduleKey?: string;
    /** The position of the gadget. When the gadget is placed into the position, other gadgets in the same column are moved down to accommodate it. */
    position?: DashboardGadgetPosition;
    /** The title of the gadget. */
    title?: string;
    /** The URI of the gadget type. Can't be provided with `moduleKey`. */
    uri?: string;

    constructor(data?: IDashboardGadgetSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.color = _data["color"];
            this.ignoreUriAndModuleKeyValidation = _data["ignoreUriAndModuleKeyValidation"];
            this.moduleKey = _data["moduleKey"];
            this.position = _data["position"] ? DashboardGadgetPosition.fromJS(_data["position"]) : <any>undefined;
            this.title = _data["title"];
            this.uri = _data["uri"];
        }
    }

    static fromJS(data: any): DashboardGadgetSettings {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardGadgetSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["color"] = this.color;
        data["ignoreUriAndModuleKeyValidation"] = this.ignoreUriAndModuleKeyValidation;
        data["moduleKey"] = this.moduleKey;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["uri"] = this.uri;
        return data;
    }
}

/** Details of the settings for a dashboard gadget. */
export interface IDashboardGadgetSettings {
    /** The color of the gadget. Should be one of `blue`, `red`, `yellow`, `green`, `cyan`, `purple`, `gray`, or `white`. */
    color?: string;
    /** Whether to ignore the validation of module key and URI. For example, when a gadget is created that is a part of an application that isn't installed. */
    ignoreUriAndModuleKeyValidation?: boolean;
    /** The module key of the gadget type. Can't be provided with `uri`. */
    moduleKey?: string;
    /** The position of the gadget. When the gadget is placed into the position, other gadgets in the same column are moved down to accommodate it. */
    position?: DashboardGadgetPosition;
    /** The title of the gadget. */
    title?: string;
    /** The URI of the gadget type. Can't be provided with `moduleKey`. */
    uri?: string;
}

/** The details of the gadget to update. */
export class DashboardGadgetUpdateRequest implements IDashboardGadgetUpdateRequest {
    /** The color of the gadget. Should be one of `blue`, `red`, `yellow`, `green`, `cyan`, `purple`, `gray`, or `white`. */
    color?: string;
    /** The position of the gadget. */
    position?: DashboardGadgetPosition;
    /** The title of the gadget. */
    title?: string;

    constructor(data?: IDashboardGadgetUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.color = _data["color"];
            this.position = _data["position"] ? DashboardGadgetPosition.fromJS(_data["position"]) : <any>undefined;
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): DashboardGadgetUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardGadgetUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["color"] = this.color;
        data["position"] = this.position ? this.position.toJSON() : <any>undefined;
        data["title"] = this.title;
        return data;
    }
}

/** The details of the gadget to update. */
export interface IDashboardGadgetUpdateRequest {
    /** The color of the gadget. Should be one of `blue`, `red`, `yellow`, `green`, `cyan`, `purple`, `gray`, or `white`. */
    color?: string;
    /** The position of the gadget. */
    position?: DashboardGadgetPosition;
    /** The title of the gadget. */
    title?: string;
}

/** The data classification. */
export class DataClassificationLevelsBean implements IDataClassificationLevelsBean {
    /** The data classifications. */
    classifications?: DataClassificationTagBean[];

    constructor(data?: IDataClassificationLevelsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["classifications"])) {
                this.classifications = [] as any;
                for (let item of _data["classifications"])
                    this.classifications!.push(DataClassificationTagBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataClassificationLevelsBean {
        data = typeof data === 'object' ? data : {};
        let result = new DataClassificationLevelsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.classifications)) {
            data["classifications"] = [];
            for (let item of this.classifications)
                data["classifications"].push(item.toJSON());
        }
        return data;
    }
}

/** The data classification. */
export interface IDataClassificationLevelsBean {
    /** The data classifications. */
    classifications?: DataClassificationTagBean[];
}

/** The data classification. */
export class DataClassificationTagBean implements IDataClassificationTagBean {
    /** The color of the data classification object. */
    color?: string;
    /** The description of the data classification object. */
    description?: string;
    /** The guideline of the data classification object. */
    guideline?: string;
    /** The ID of the data classification object. */
    id!: string;
    /** The name of the data classification object. */
    name?: string;
    /** The rank of the data classification object. */
    rank?: number;
    /** The status of the data classification object. */
    status!: string;

    constructor(data?: IDataClassificationTagBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.color = _data["color"];
            this.description = _data["description"];
            this.guideline = _data["guideline"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.rank = _data["rank"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): DataClassificationTagBean {
        data = typeof data === 'object' ? data : {};
        let result = new DataClassificationTagBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["color"] = this.color;
        data["description"] = this.description;
        data["guideline"] = this.guideline;
        data["id"] = this.id;
        data["name"] = this.name;
        data["rank"] = this.rank;
        data["status"] = this.status;
        return data;
    }
}

/** The data classification. */
export interface IDataClassificationTagBean {
    /** The color of the data classification object. */
    color?: string;
    /** The description of the data classification object. */
    description?: string;
    /** The guideline of the data classification object. */
    guideline?: string;
    /** The ID of the data classification object. */
    id: string;
    /** The name of the data classification object. */
    name?: string;
    /** The rank of the data classification object. */
    rank?: number;
    /** The status of the data classification object. */
    status: string;
}

/** List issues archived within a specified date range. */
export class DateRangeFilterRequest implements IDateRangeFilterRequest {
    /** List issues archived after a specified date, passed in the YYYY-MM-DD format. */
    dateAfter!: string;
    /** List issues archived before a specified date provided in the YYYY-MM-DD format. */
    dateBefore!: string;

    constructor(data?: IDateRangeFilterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateAfter = _data["dateAfter"];
            this.dateBefore = _data["dateBefore"];
        }
    }

    static fromJS(data: any): DateRangeFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeFilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateAfter"] = this.dateAfter;
        data["dateBefore"] = this.dateBefore;
        return data;
    }
}

/** List issues archived within a specified date range. */
export interface IDateRangeFilterRequest {
    /** List issues archived after a specified date, passed in the YYYY-MM-DD format. */
    dateAfter: string;
    /** List issues archived before a specified date provided in the YYYY-MM-DD format. */
    dateBefore: string;
}

/** Details of scheme and new default level. */
export class DefaultLevelValue implements IDefaultLevelValue {
    /** The ID of the issue security level to set as default for the specified scheme. Providing null will reset the default level. */
    defaultLevelId!: string;
    /** The ID of the issue security scheme to set default level for. */
    issueSecuritySchemeId!: string;

    [key: string]: any;

    constructor(data?: IDefaultLevelValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.defaultLevelId = _data["defaultLevelId"];
            this.issueSecuritySchemeId = _data["issueSecuritySchemeId"];
        }
    }

    static fromJS(data: any): DefaultLevelValue {
        data = typeof data === 'object' ? data : {};
        let result = new DefaultLevelValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["defaultLevelId"] = this.defaultLevelId;
        data["issueSecuritySchemeId"] = this.issueSecuritySchemeId;
        return data;
    }
}

/** Details of scheme and new default level. */
export interface IDefaultLevelValue {
    /** The ID of the issue security level to set as default for the specified scheme. Providing null will reset the default level. */
    defaultLevelId: string;
    /** The ID of the issue security scheme to set default level for. */
    issueSecuritySchemeId: string;

    [key: string]: any;
}

/** Details of the scope of the default sharing for new filters and dashboards. */
export class DefaultShareScope implements IDefaultShareScope {
    /** The scope of the default sharing for new filters and dashboards:

 *  `AUTHENTICATED` Shared with all logged-in users.
 *  `GLOBAL` Shared with all logged-in users. This shows as `AUTHENTICATED` in the response.
 *  `PRIVATE` Not shared with any users. */
    scope!: DefaultShareScopeScope;

    constructor(data?: IDefaultShareScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scope = _data["scope"];
        }
    }

    static fromJS(data: any): DefaultShareScope {
        data = typeof data === 'object' ? data : {};
        let result = new DefaultShareScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scope"] = this.scope;
        return data;
    }
}

/** Details of the scope of the default sharing for new filters and dashboards. */
export interface IDefaultShareScope {
    /** The scope of the default sharing for new filters and dashboards:

 *  `AUTHENTICATED` Shared with all logged-in users.
 *  `GLOBAL` Shared with all logged-in users. This shows as `AUTHENTICATED` in the response.
 *  `PRIVATE` Not shared with any users. */
    scope: DefaultShareScopeScope;
}

/** Details about the default workflow. */
export class DefaultWorkflow implements IDefaultWorkflow {
    /** Whether a draft workflow scheme is created or updated when updating an active workflow scheme. The draft is updated with the new default workflow. Defaults to `false`. */
    updateDraftIfNeeded?: boolean;
    /** The name of the workflow to set as the default workflow. */
    workflow!: string;

    constructor(data?: IDefaultWorkflow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.updateDraftIfNeeded = _data["updateDraftIfNeeded"];
            this.workflow = _data["workflow"];
        }
    }

    static fromJS(data: any): DefaultWorkflow {
        data = typeof data === 'object' ? data : {};
        let result = new DefaultWorkflow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updateDraftIfNeeded"] = this.updateDraftIfNeeded;
        data["workflow"] = this.workflow;
        return data;
    }
}

/** Details about the default workflow. */
export interface IDefaultWorkflow {
    /** Whether a draft workflow scheme is created or updated when updating an active workflow scheme. The draft is updated with the new default workflow. Defaults to `false`. */
    updateDraftIfNeeded?: boolean;
    /** The name of the workflow to set as the default workflow. */
    workflow: string;
}

export class DeleteAndReplaceVersionBean implements IDeleteAndReplaceVersionBean {
    /** An array of custom field IDs (`customFieldId`) and version IDs (`moveTo`) to update when the fields contain the deleted version. */
    customFieldReplacementList?: CustomFieldReplacement[];
    /** The ID of the version to update `affectedVersion` to when the field contains the deleted version. */
    moveAffectedIssuesTo?: number;
    /** The ID of the version to update `fixVersion` to when the field contains the deleted version. */
    moveFixIssuesTo?: number;

    constructor(data?: IDeleteAndReplaceVersionBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["customFieldReplacementList"])) {
                this.customFieldReplacementList = [] as any;
                for (let item of _data["customFieldReplacementList"])
                    this.customFieldReplacementList!.push(CustomFieldReplacement.fromJS(item));
            }
            this.moveAffectedIssuesTo = _data["moveAffectedIssuesTo"];
            this.moveFixIssuesTo = _data["moveFixIssuesTo"];
        }
    }

    static fromJS(data: any): DeleteAndReplaceVersionBean {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteAndReplaceVersionBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customFieldReplacementList)) {
            data["customFieldReplacementList"] = [];
            for (let item of this.customFieldReplacementList)
                data["customFieldReplacementList"].push(item.toJSON());
        }
        data["moveAffectedIssuesTo"] = this.moveAffectedIssuesTo;
        data["moveFixIssuesTo"] = this.moveFixIssuesTo;
        return data;
    }
}

export interface IDeleteAndReplaceVersionBean {
    /** An array of custom field IDs (`customFieldId`) and version IDs (`moveTo`) to update when the fields contain the deleted version. */
    customFieldReplacementList?: CustomFieldReplacement[];
    /** The ID of the version to update `affectedVersion` to when the field contains the deleted version. */
    moveAffectedIssuesTo?: number;
    /** The ID of the version to update `fixVersion` to when the field contains the deleted version. */
    moveFixIssuesTo?: number;
}

/** Details about a workflow. */
export class DeprecatedWorkflow implements IDeprecatedWorkflow {
    default?: boolean;
    /** The description of the workflow. */
    readonly description?: string;
    /** The datetime the workflow was last modified. */
    readonly lastModifiedDate?: string;
    /** This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    readonly lastModifiedUser?: string;
    /** The account ID of the user that last modified the workflow. */
    readonly lastModifiedUserAccountId?: string;
    /** The name of the workflow. */
    readonly name?: string;
    /** The scope where this workflow applies */
    readonly scope?: Scope;
    /** The number of steps included in the workflow. */
    readonly steps?: number;

    constructor(data?: IDeprecatedWorkflow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.default = _data["default"];
            (<any>this).description = _data["description"];
            (<any>this).lastModifiedDate = _data["lastModifiedDate"];
            (<any>this).lastModifiedUser = _data["lastModifiedUser"];
            (<any>this).lastModifiedUserAccountId = _data["lastModifiedUserAccountId"];
            (<any>this).name = _data["name"];
            (<any>this).scope = _data["scope"] ? Scope.fromJS(_data["scope"]) : <any>undefined;
            (<any>this).steps = _data["steps"];
        }
    }

    static fromJS(data: any): DeprecatedWorkflow {
        data = typeof data === 'object' ? data : {};
        let result = new DeprecatedWorkflow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["default"] = this.default;
        data["description"] = this.description;
        data["lastModifiedDate"] = this.lastModifiedDate;
        data["lastModifiedUser"] = this.lastModifiedUser;
        data["lastModifiedUserAccountId"] = this.lastModifiedUserAccountId;
        data["name"] = this.name;
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        data["steps"] = this.steps;
        return data;
    }
}

/** Details about a workflow. */
export interface IDeprecatedWorkflow {
    default?: boolean;
    /** The description of the workflow. */
    description?: string;
    /** The datetime the workflow was last modified. */
    lastModifiedDate?: string;
    /** This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    lastModifiedUser?: string;
    /** The account ID of the user that last modified the workflow. */
    lastModifiedUserAccountId?: string;
    /** The name of the workflow. */
    name?: string;
    /** The scope where this workflow applies */
    scope?: Scope;
    /** The number of steps included in the workflow. */
    steps?: number;
}

export class DetailedErrorCollection implements IDetailedErrorCollection {
    /** Map of objects representing additional details for an error */
    details?: { [key: string]: any; };
    /** The list of error messages produced by this operation. For example, "input parameter 'key' must be provided" */
    errorMessages?: string[];
    /** The list of errors by parameter returned by the operation. For example,"projectKey": "Project keys must start with an uppercase letter, followed by one or more uppercase alphanumeric characters." */
    errors?: { [key: string]: string; };

    constructor(data?: IDetailedErrorCollection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["details"]) {
                this.details = {} as any;
                for (let key in _data["details"]) {
                    if (_data["details"].hasOwnProperty(key))
                        (<any>this.details)![key] = _data["details"][key];
                }
            }
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages!.push(item);
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key];
                }
            }
        }
    }

    static fromJS(data: any): DetailedErrorCollection {
        data = typeof data === 'object' ? data : {};
        let result = new DetailedErrorCollection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.details) {
            data["details"] = {};
            for (let key in this.details) {
                if (this.details.hasOwnProperty(key))
                    (<any>data["details"])[key] = (<any>this.details)[key];
            }
        }
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        return data;
    }
}

export interface IDetailedErrorCollection {
    /** Map of objects representing additional details for an error */
    details?: { [key: string]: any; };
    /** The list of error messages produced by this operation. For example, "input parameter 'key' must be provided" */
    errorMessages?: string[];
    /** The list of errors by parameter returned by the operation. For example,"projectKey": "Project keys must start with an uppercase letter, followed by one or more uppercase alphanumeric characters." */
    errors?: { [key: string]: string; };
}

/** The current version details of this workflow scheme. */
export class DocumentVersion implements IDocumentVersion {
    /** The version UUID. */
    id?: string;
    /** The version number. */
    versionNumber?: number;

    constructor(data?: IDocumentVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.versionNumber = _data["versionNumber"];
        }
    }

    static fromJS(data: any): DocumentVersion {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["versionNumber"] = this.versionNumber;
        return data;
    }
}

/** The current version details of this workflow scheme. */
export interface IDocumentVersion {
    /** The version UUID. */
    id?: string;
    /** The version number. */
    versionNumber?: number;
}

export class DuplicatePlanRequest implements IDuplicatePlanRequest {
    /** The plan name. */
    name!: string;

    constructor(data?: IDuplicatePlanRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DuplicatePlanRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicatePlanRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IDuplicatePlanRequest {
    /** The plan name. */
    name: string;
}

/** An entity property, for more information see [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/). */
export class EntityProperty implements IEntityProperty {
    /** The key of the property. Required on create and update. */
    key?: string;
    /** The value of the property. Required on create and update. */
    value?: any;

    constructor(data?: IEntityProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): EntityProperty {
        data = typeof data === 'object' ? data : {};
        let result = new EntityProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

/** An entity property, for more information see [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/). */
export interface IEntityProperty {
    /** The key of the property. Required on create and update. */
    key?: string;
    /** The value of the property. Required on create and update. */
    value?: any;
}

export class EntityPropertyDetails implements IEntityPropertyDetails {
    /** The entity property ID. */
    entityId!: number;
    /** The entity property key. */
    key!: string;
    /** The new value of the entity property. */
    value!: string;

    [key: string]: any;

    constructor(data?: IEntityPropertyDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entityId = _data["entityId"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): EntityPropertyDetails {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entityId"] = this.entityId;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IEntityPropertyDetails {
    /** The entity property ID. */
    entityId: number;
    /** The entity property key. */
    key: string;
    /** The new value of the entity property. */
    value: string;

    [key: string]: any;
}

export class ErrorDto implements IErrorDto {
    count?: number;
    issueIdsOrKeys?: string[];
    message?: string;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["issueIdsOrKeys"])) {
                this.issueIdsOrKeys = [] as any;
                for (let item of _data["issueIdsOrKeys"])
                    this.issueIdsOrKeys!.push(item);
            }
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.issueIdsOrKeys)) {
            data["issueIdsOrKeys"] = [];
            for (let item of this.issueIdsOrKeys)
                data["issueIdsOrKeys"].push(item);
        }
        data["message"] = this.message;
        return data;
    }
}

export interface IErrorDto {
    count?: number;
    issueIdsOrKeys?: string[];
    message?: string;
}

/** Error messages from an operation. */
export class ErrorCollection implements IErrorCollection {
    /** The list of error messages produced by this operation. For example, "input parameter 'key' must be provided" */
    errorMessages?: string[];
    /** The list of errors by parameter returned by the operation. For example,"projectKey": "Project keys must start with an uppercase letter, followed by one or more uppercase alphanumeric characters." */
    errors?: { [key: string]: string; };
    status?: number;

    constructor(data?: IErrorCollection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages!.push(item);
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key];
                }
            }
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ErrorCollection {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorCollection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        data["status"] = this.status;
        return data;
    }
}

/** Error messages from an operation. */
export interface IErrorCollection {
    /** The list of error messages produced by this operation. For example, "input parameter 'key' must be provided" */
    errorMessages?: string[];
    /** The list of errors by parameter returned by the operation. For example,"projectKey": "Project keys must start with an uppercase letter, followed by one or more uppercase alphanumeric characters." */
    errors?: { [key: string]: string; };
    status?: number;
}

export class ErrorCollections implements IErrorCollections {

    constructor(data?: IErrorCollections) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ErrorCollections {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorCollections();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IErrorCollections {
}

export class ErrorMessage implements IErrorMessage {
    message?: string;

    constructor(data?: IErrorMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): ErrorMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data;
    }
}

export interface IErrorMessage {
    message?: string;
}

export class Errors implements IErrors {
    issueIsSubtask?: ErrorDto;
    issuesInArchivedProjects?: ErrorDto;
    issuesInUnlicensedProjects?: ErrorDto;
    issuesNotFound?: ErrorDto;
    userDoesNotHavePermission?: ErrorDto;

    constructor(data?: IErrors) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueIsSubtask = _data["issueIsSubtask"] ? ErrorDto.fromJS(_data["issueIsSubtask"]) : <any>undefined;
            this.issuesInArchivedProjects = _data["issuesInArchivedProjects"] ? ErrorDto.fromJS(_data["issuesInArchivedProjects"]) : <any>undefined;
            this.issuesInUnlicensedProjects = _data["issuesInUnlicensedProjects"] ? ErrorDto.fromJS(_data["issuesInUnlicensedProjects"]) : <any>undefined;
            this.issuesNotFound = _data["issuesNotFound"] ? ErrorDto.fromJS(_data["issuesNotFound"]) : <any>undefined;
            this.userDoesNotHavePermission = _data["userDoesNotHavePermission"] ? ErrorDto.fromJS(_data["userDoesNotHavePermission"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Errors {
        data = typeof data === 'object' ? data : {};
        let result = new Errors();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueIsSubtask"] = this.issueIsSubtask ? this.issueIsSubtask.toJSON() : <any>undefined;
        data["issuesInArchivedProjects"] = this.issuesInArchivedProjects ? this.issuesInArchivedProjects.toJSON() : <any>undefined;
        data["issuesInUnlicensedProjects"] = this.issuesInUnlicensedProjects ? this.issuesInUnlicensedProjects.toJSON() : <any>undefined;
        data["issuesNotFound"] = this.issuesNotFound ? this.issuesNotFound.toJSON() : <any>undefined;
        data["userDoesNotHavePermission"] = this.userDoesNotHavePermission ? this.userDoesNotHavePermission.toJSON() : <any>undefined;
        return data;
    }
}

export interface IErrors {
    issueIsSubtask?: ErrorDto;
    issuesInArchivedProjects?: ErrorDto;
    issuesInUnlicensedProjects?: ErrorDto;
    issuesNotFound?: ErrorDto;
    userDoesNotHavePermission?: ErrorDto;
}

/** Details about a notification associated with an event. */
export class EventNotification implements IEventNotification {
    /** The email address. */
    emailAddress?: string;
    /** Expand options that include additional event notification details in the response. */
    expand?: string;
    /** The custom user or group field. */
    field?: FieldDetails;
    /** The specified group. */
    group?: GroupName;
    /** The ID of the notification. */
    id?: number;
    /** Identifies the recipients of the notification. */
    notificationType?: EventNotificationNotificationType;
    /** As a group's name can change, use of `recipient` is recommended. The identifier associated with the `notificationType` value that defines the receiver of the notification, where the receiver isn't implied by `notificationType` value. So, when `notificationType` is:

 *  `User` The `parameter` is the user account ID.
 *  `Group` The `parameter` is the group name.
 *  `ProjectRole` The `parameter` is the project role ID.
 *  `UserCustomField` The `parameter` is the ID of the custom field.
 *  `GroupCustomField` The `parameter` is the ID of the custom field. */
    parameter?: string;
    /** The specified project role. */
    projectRole?: ProjectRole;
    /** The identifier associated with the `notificationType` value that defines the receiver of the notification, where the receiver isn't implied by the `notificationType` value. So, when `notificationType` is:

 *  `User`, `recipient` is the user account ID.
 *  `Group`, `recipient` is the group ID.
 *  `ProjectRole`, `recipient` is the project role ID.
 *  `UserCustomField`, `recipient` is the ID of the custom field.
 *  `GroupCustomField`, `recipient` is the ID of the custom field. */
    recipient?: string;
    /** The specified user. */
    user?: UserDetails;

    constructor(data?: IEventNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.expand = _data["expand"];
            this.field = _data["field"] ? FieldDetails.fromJS(_data["field"]) : <any>undefined;
            this.group = _data["group"] ? GroupName.fromJS(_data["group"]) : <any>undefined;
            this.id = _data["id"];
            this.notificationType = _data["notificationType"];
            this.parameter = _data["parameter"];
            this.projectRole = _data["projectRole"] ? ProjectRole.fromJS(_data["projectRole"]) : <any>undefined;
            this.recipient = _data["recipient"];
            this.user = _data["user"] ? UserDetails.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EventNotification {
        data = typeof data === 'object' ? data : {};
        let result = new EventNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["expand"] = this.expand;
        data["field"] = this.field ? this.field.toJSON() : <any>undefined;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["notificationType"] = this.notificationType;
        data["parameter"] = this.parameter;
        data["projectRole"] = this.projectRole ? this.projectRole.toJSON() : <any>undefined;
        data["recipient"] = this.recipient;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

/** Details about a notification associated with an event. */
export interface IEventNotification {
    /** The email address. */
    emailAddress?: string;
    /** Expand options that include additional event notification details in the response. */
    expand?: string;
    /** The custom user or group field. */
    field?: FieldDetails;
    /** The specified group. */
    group?: GroupName;
    /** The ID of the notification. */
    id?: number;
    /** Identifies the recipients of the notification. */
    notificationType?: EventNotificationNotificationType;
    /** As a group's name can change, use of `recipient` is recommended. The identifier associated with the `notificationType` value that defines the receiver of the notification, where the receiver isn't implied by `notificationType` value. So, when `notificationType` is:

 *  `User` The `parameter` is the user account ID.
 *  `Group` The `parameter` is the group name.
 *  `ProjectRole` The `parameter` is the project role ID.
 *  `UserCustomField` The `parameter` is the ID of the custom field.
 *  `GroupCustomField` The `parameter` is the ID of the custom field. */
    parameter?: string;
    /** The specified project role. */
    projectRole?: ProjectRole;
    /** The identifier associated with the `notificationType` value that defines the receiver of the notification, where the receiver isn't implied by the `notificationType` value. So, when `notificationType` is:

 *  `User`, `recipient` is the user account ID.
 *  `Group`, `recipient` is the group ID.
 *  `ProjectRole`, `recipient` is the project role ID.
 *  `UserCustomField`, `recipient` is the ID of the custom field.
 *  `GroupCustomField`, `recipient` is the ID of the custom field. */
    recipient?: string;
    /** The specified user. */
    user?: UserDetails;
}

/** A priority scheme with less fields to be used in for an API expand response. */
export class ExpandPrioritySchemeBean implements IExpandPrioritySchemeBean {
    /** The ID of the priority scheme. */
    readonly id?: string;
    /** The name of the priority scheme. */
    readonly name?: string;
    /** The URL of the priority scheme. */
    readonly self?: string;

    constructor(data?: IExpandPrioritySchemeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): ExpandPrioritySchemeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandPrioritySchemeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

/** A priority scheme with less fields to be used in for an API expand response. */
export interface IExpandPrioritySchemeBean {
    /** The ID of the priority scheme. */
    id?: string;
    /** The name of the priority scheme. */
    name?: string;
    /** The URL of the priority scheme. */
    self?: string;
}

export class ExpandPrioritySchemePage implements IExpandPrioritySchemePage {
    maxResults?: number;
    startAt?: number;
    total?: number;

    [key: string]: any;

    constructor(data?: IExpandPrioritySchemePage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.maxResults = _data["maxResults"];
            this.startAt = _data["startAt"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): ExpandPrioritySchemePage {
        data = typeof data === 'object' ? data : {};
        let result = new ExpandPrioritySchemePage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["maxResults"] = this.maxResults;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        return data;
    }
}

export interface IExpandPrioritySchemePage {
    maxResults?: number;
    startAt?: number;
    total?: number;

    [key: string]: any;
}

/** The response for status request for a running/completed export task. */
export class ExportArchivedIssuesTaskProgressResponse implements IExportArchivedIssuesTaskProgressResponse {
    fileUrl?: string;
    payload?: string;
    progress?: number;
    status?: string;
    submittedTime?: Date;
    taskId?: string;

    constructor(data?: IExportArchivedIssuesTaskProgressResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileUrl = _data["fileUrl"];
            this.payload = _data["payload"];
            this.progress = _data["progress"];
            this.status = _data["status"];
            this.submittedTime = _data["submittedTime"] ? new Date(_data["submittedTime"].toString()) : <any>undefined;
            this.taskId = _data["taskId"];
        }
    }

    static fromJS(data: any): ExportArchivedIssuesTaskProgressResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ExportArchivedIssuesTaskProgressResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileUrl"] = this.fileUrl;
        data["payload"] = this.payload;
        data["progress"] = this.progress;
        data["status"] = this.status;
        data["submittedTime"] = this.submittedTime ? this.submittedTime.toISOString() : <any>undefined;
        data["taskId"] = this.taskId;
        return data;
    }
}

/** The response for status request for a running/completed export task. */
export interface IExportArchivedIssuesTaskProgressResponse {
    fileUrl?: string;
    payload?: string;
    progress?: number;
    status?: string;
    submittedTime?: Date;
    taskId?: string;
}

/** Details about a failed webhook. */
export class FailedWebhook implements IFailedWebhook {
    /** The webhook body. */
    body?: string;
    /** The time the webhook was added to the list of failed webhooks (that is, the time of the last failed retry). */
    failureTime!: number;
    /** The webhook ID, as sent in the `X-Atlassian-Webhook-Identifier` header with the webhook. */
    id!: string;
    /** The original webhook destination. */
    url!: string;

    constructor(data?: IFailedWebhook) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.body = _data["body"];
            this.failureTime = _data["failureTime"];
            this.id = _data["id"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): FailedWebhook {
        data = typeof data === 'object' ? data : {};
        let result = new FailedWebhook();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        data["failureTime"] = this.failureTime;
        data["id"] = this.id;
        data["url"] = this.url;
        return data;
    }
}

/** Details about a failed webhook. */
export interface IFailedWebhook {
    /** The webhook body. */
    body?: string;
    /** The time the webhook was added to the list of failed webhooks (that is, the time of the last failed retry). */
    failureTime: number;
    /** The webhook ID, as sent in the `X-Atlassian-Webhook-Identifier` header with the webhook. */
    id: string;
    /** The original webhook destination. */
    url: string;
}

/** A page of failed webhooks. */
export class FailedWebhooks implements IFailedWebhooks {
    /** The maximum number of items on the page. If the list of values is shorter than this number, then there are no more pages. */
    maxResults!: number;
    /** The URL to the next page of results. Present only if the request returned at least one result.The next page may be empty at the time of receiving the response, but new failed webhooks may appear in time. You can save the URL to the next page and query for new results periodically (for example, every hour). */
    next?: string;
    /** The list of webhooks. */
    values!: FailedWebhook[];

    constructor(data?: IFailedWebhooks) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.values = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResults = _data["maxResults"];
            this.next = _data["next"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(FailedWebhook.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FailedWebhooks {
        data = typeof data === 'object' ? data : {};
        let result = new FailedWebhooks();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResults"] = this.maxResults;
        data["next"] = this.next;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of failed webhooks. */
export interface IFailedWebhooks {
    /** The maximum number of items on the page. If the list of values is shorter than this number, then there are no more pages. */
    maxResults: number;
    /** The URL to the next page of results. Present only if the request returned at least one result.The next page may be empty at the time of receiving the response, but new failed webhooks may appear in time. You can save the URL to the next page and query for new results periodically (for example, every hour). */
    next?: string;
    /** The list of webhooks. */
    values: FailedWebhook[];
}

/** Details of a field. */
export class Field implements IField {
    /** Number of contexts where the field is used. */
    contextsCount?: number;
    /** The description of the field. */
    description?: string;
    /** The ID of the field. */
    id!: string;
    /** Whether the field is locked. */
    isLocked?: boolean;
    /** Whether the field is shown on screen or not. */
    isUnscreenable?: boolean;
    /** The key of the field. */
    key?: string;
    lastUsed?: FieldLastUsed;
    /** The name of the field. */
    name!: string;
    /** Number of projects where the field is used. */
    projectsCount?: number;
    schema!: JsonTypeBean;
    /** Number of screens where the field is used. */
    screensCount?: number;
    /** The searcher key of the field. Returned for custom fields. */
    searcherKey?: string;
    /** The stable ID of the field. */
    stableId?: string;

    constructor(data?: IField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.schema = new JsonTypeBean();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contextsCount = _data["contextsCount"];
            this.description = _data["description"];
            this.id = _data["id"];
            this.isLocked = _data["isLocked"];
            this.isUnscreenable = _data["isUnscreenable"];
            this.key = _data["key"];
            this.lastUsed = _data["lastUsed"] ? FieldLastUsed.fromJS(_data["lastUsed"]) : <any>undefined;
            this.name = _data["name"];
            this.projectsCount = _data["projectsCount"];
            this.schema = _data["schema"] ? JsonTypeBean.fromJS(_data["schema"]) : new JsonTypeBean();
            this.screensCount = _data["screensCount"];
            this.searcherKey = _data["searcherKey"];
            this.stableId = _data["stableId"];
        }
    }

    static fromJS(data: any): Field {
        data = typeof data === 'object' ? data : {};
        let result = new Field();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contextsCount"] = this.contextsCount;
        data["description"] = this.description;
        data["id"] = this.id;
        data["isLocked"] = this.isLocked;
        data["isUnscreenable"] = this.isUnscreenable;
        data["key"] = this.key;
        data["lastUsed"] = this.lastUsed ? this.lastUsed.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["projectsCount"] = this.projectsCount;
        data["schema"] = this.schema ? this.schema.toJSON() : <any>undefined;
        data["screensCount"] = this.screensCount;
        data["searcherKey"] = this.searcherKey;
        data["stableId"] = this.stableId;
        return data;
    }
}

/** Details of a field. */
export interface IField {
    /** Number of contexts where the field is used. */
    contextsCount?: number;
    /** The description of the field. */
    description?: string;
    /** The ID of the field. */
    id: string;
    /** Whether the field is locked. */
    isLocked?: boolean;
    /** Whether the field is shown on screen or not. */
    isUnscreenable?: boolean;
    /** The key of the field. */
    key?: string;
    lastUsed?: FieldLastUsed;
    /** The name of the field. */
    name: string;
    /** Number of projects where the field is used. */
    projectsCount?: number;
    schema: JsonTypeBean;
    /** Number of screens where the field is used. */
    screensCount?: number;
    /** The searcher key of the field. Returned for custom fields. */
    searcherKey?: string;
    /** The stable ID of the field. */
    stableId?: string;
}

/** Details of field associations with projects. */
export class FieldAssociationsRequest implements IFieldAssociationsRequest {
    /** Contexts to associate/unassociate the fields with. */
    associationContexts!: AssociationContextObject[];
    /** Fields to associate/unassociate with projects. */
    fields!: FieldIdentifierObject[];

    constructor(data?: IFieldAssociationsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.associationContexts = [];
            this.fields = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["associationContexts"])) {
                this.associationContexts = [] as any;
                for (let item of _data["associationContexts"])
                    this.associationContexts!.push(AssociationContextObject.fromJS(item));
            }
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(FieldIdentifierObject.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FieldAssociationsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new FieldAssociationsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.associationContexts)) {
            data["associationContexts"] = [];
            for (let item of this.associationContexts)
                data["associationContexts"].push(item.toJSON());
        }
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of field associations with projects. */
export interface IFieldAssociationsRequest {
    /** Contexts to associate/unassociate the fields with. */
    associationContexts: AssociationContextObject[];
    /** Fields to associate/unassociate with projects. */
    fields: FieldIdentifierObject[];
}

/** Defines the payload for the fields, screens, screen schemes, issue type screen schemes, field layouts, and field layout schemes */
export class FieldCapabilityPayload implements IFieldCapabilityPayload {
    /** The custom field definitions. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-fields/\#api-rest-api-3-field-post */
    customFieldDefinitions?: (CustomFieldPayload | undefined)[] | undefined;
    fieldLayoutScheme?: FieldLayoutSchemePayload | undefined;
    /** The field layouts configuration. */
    fieldLayouts?: (FieldLayoutPayload | undefined)[] | undefined;
    /** The issue layouts configuration */
    issueLayouts?: (IssueLayoutPayload | undefined)[] | undefined;
    issueTypeScreenScheme?: IssueTypeScreenSchemePayload | undefined;
    /** The screen schemes See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-screen-schemes/\#api-rest-api-3-screenscheme-post */
    screenScheme?: (ScreenSchemePayload | undefined)[] | undefined;
    /** The screens. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-screens/\#api-rest-api-3-screens-post */
    screens?: (ScreenPayload | undefined)[] | undefined;

    constructor(data?: IFieldCapabilityPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["customFieldDefinitions"])) {
                this.customFieldDefinitions = [] as any;
                for (let item of _data["customFieldDefinitions"])
                    this.customFieldDefinitions!.push(CustomFieldPayload.fromJS(item));
            }
            this.fieldLayoutScheme = _data["fieldLayoutScheme"] ? FieldLayoutSchemePayload.fromJS(_data["fieldLayoutScheme"]) : <any>undefined;
            if (Array.isArray(_data["fieldLayouts"])) {
                this.fieldLayouts = [] as any;
                for (let item of _data["fieldLayouts"])
                    this.fieldLayouts!.push(FieldLayoutPayload.fromJS(item));
            }
            if (Array.isArray(_data["issueLayouts"])) {
                this.issueLayouts = [] as any;
                for (let item of _data["issueLayouts"])
                    this.issueLayouts!.push(IssueLayoutPayload.fromJS(item));
            }
            this.issueTypeScreenScheme = _data["issueTypeScreenScheme"] ? IssueTypeScreenSchemePayload.fromJS(_data["issueTypeScreenScheme"]) : <any>undefined;
            if (Array.isArray(_data["screenScheme"])) {
                this.screenScheme = [] as any;
                for (let item of _data["screenScheme"])
                    this.screenScheme!.push(ScreenSchemePayload.fromJS(item));
            }
            if (Array.isArray(_data["screens"])) {
                this.screens = [] as any;
                for (let item of _data["screens"])
                    this.screens!.push(ScreenPayload.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FieldCapabilityPayload {
        data = typeof data === 'object' ? data : {};
        let result = new FieldCapabilityPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customFieldDefinitions)) {
            data["customFieldDefinitions"] = [];
            for (let item of this.customFieldDefinitions)
                data["customFieldDefinitions"].push(item.toJSON());
        }
        data["fieldLayoutScheme"] = this.fieldLayoutScheme ? this.fieldLayoutScheme.toJSON() : <any>undefined;
        if (Array.isArray(this.fieldLayouts)) {
            data["fieldLayouts"] = [];
            for (let item of this.fieldLayouts)
                data["fieldLayouts"].push(item.toJSON());
        }
        if (Array.isArray(this.issueLayouts)) {
            data["issueLayouts"] = [];
            for (let item of this.issueLayouts)
                data["issueLayouts"].push(item.toJSON());
        }
        data["issueTypeScreenScheme"] = this.issueTypeScreenScheme ? this.issueTypeScreenScheme.toJSON() : <any>undefined;
        if (Array.isArray(this.screenScheme)) {
            data["screenScheme"] = [];
            for (let item of this.screenScheme)
                data["screenScheme"].push(item.toJSON());
        }
        if (Array.isArray(this.screens)) {
            data["screens"] = [];
            for (let item of this.screens)
                data["screens"].push(item.toJSON());
        }
        return data;
    }
}

/** Defines the payload for the fields, screens, screen schemes, issue type screen schemes, field layouts, and field layout schemes */
export interface IFieldCapabilityPayload {
    /** The custom field definitions. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-fields/\#api-rest-api-3-field-post */
    customFieldDefinitions?: (CustomFieldPayload | undefined)[] | undefined;
    fieldLayoutScheme?: FieldLayoutSchemePayload | undefined;
    /** The field layouts configuration. */
    fieldLayouts?: (FieldLayoutPayload | undefined)[] | undefined;
    /** The issue layouts configuration */
    issueLayouts?: (IssueLayoutPayload | undefined)[] | undefined;
    issueTypeScreenScheme?: IssueTypeScreenSchemePayload | undefined;
    /** The screen schemes See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-screen-schemes/\#api-rest-api-3-screenscheme-post */
    screenScheme?: (ScreenSchemePayload | undefined)[] | undefined;
    /** The screens. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-screens/\#api-rest-api-3-screens-post */
    screens?: (ScreenPayload | undefined)[] | undefined;
}

/** A clause that asserts whether a field was changed. For example, `status CHANGED AFTER startOfMonth(-1M)`.See [CHANGED](https://confluence.atlassian.com/x/dgiiLQ#Advancedsearching-operatorsreference-CHANGEDCHANGED) for more information about the CHANGED operator. */
export class FieldChangedClause implements IFieldChangedClause {
    field!: JqlQueryField;
    /** The operator applied to the field. */
    operator!: FieldChangedClauseOperator;
    /** The list of time predicates. */
    predicates!: JqlQueryClauseTimePredicate[];

    [key: string]: any;

    constructor(data?: IFieldChangedClause) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.field = new JqlQueryField();
            this.predicates = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.field = _data["field"] ? JqlQueryField.fromJS(_data["field"]) : new JqlQueryField();
            this.operator = _data["operator"];
            if (Array.isArray(_data["predicates"])) {
                this.predicates = [] as any;
                for (let item of _data["predicates"])
                    this.predicates!.push(JqlQueryClauseTimePredicate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FieldChangedClause {
        data = typeof data === 'object' ? data : {};
        let result = new FieldChangedClause();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["field"] = this.field ? this.field.toJSON() : <any>undefined;
        data["operator"] = this.operator;
        if (Array.isArray(this.predicates)) {
            data["predicates"] = [];
            for (let item of this.predicates)
                data["predicates"].push(item.toJSON());
        }
        return data;
    }
}

/** A clause that asserts whether a field was changed. For example, `status CHANGED AFTER startOfMonth(-1M)`.See [CHANGED](https://confluence.atlassian.com/x/dgiiLQ#Advancedsearching-operatorsreference-CHANGEDCHANGED) for more information about the CHANGED operator. */
export interface IFieldChangedClause {
    field: JqlQueryField;
    /** The operator applied to the field. */
    operator: FieldChangedClauseOperator;
    /** The list of time predicates. */
    predicates: JqlQueryClauseTimePredicate[];

    [key: string]: any;
}

/** Details of a field configuration. */
export class FieldConfiguration implements IFieldConfiguration {
    /** The description of the field configuration. */
    description!: string;
    /** The ID of the field configuration. */
    id!: number;
    /** Whether the field configuration is the default. */
    isDefault?: boolean;
    /** The name of the field configuration. */
    name!: string;

    constructor(data?: IFieldConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.id = _data["id"];
            this.isDefault = _data["isDefault"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FieldConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new FieldConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["isDefault"] = this.isDefault;
        data["name"] = this.name;
        return data;
    }
}

/** Details of a field configuration. */
export interface IFieldConfiguration {
    /** The description of the field configuration. */
    description: string;
    /** The ID of the field configuration. */
    id: number;
    /** Whether the field configuration is the default. */
    isDefault?: boolean;
    /** The name of the field configuration. */
    name: string;
}

/** Details of a field configuration. */
export class FieldConfigurationDetails implements IFieldConfigurationDetails {
    /** The description of the field configuration. */
    description?: string;
    /** The name of the field configuration. Must be unique. */
    name!: string;

    constructor(data?: IFieldConfigurationDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FieldConfigurationDetails {
        data = typeof data === 'object' ? data : {};
        let result = new FieldConfigurationDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

/** Details of a field configuration. */
export interface IFieldConfigurationDetails {
    /** The description of the field configuration. */
    description?: string;
    /** The name of the field configuration. Must be unique. */
    name: string;
}

/** The field configuration for an issue type. */
export class FieldConfigurationIssueTypeItem implements IFieldConfigurationIssueTypeItem {
    /** The ID of the field configuration. */
    fieldConfigurationId!: string;
    /** The ID of the field configuration scheme. */
    fieldConfigurationSchemeId!: string;
    /** The ID of the issue type or *default*. When set to *default* this field configuration issue type item applies to all issue types without a field configuration. */
    issueTypeId!: string;

    constructor(data?: IFieldConfigurationIssueTypeItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldConfigurationId = _data["fieldConfigurationId"];
            this.fieldConfigurationSchemeId = _data["fieldConfigurationSchemeId"];
            this.issueTypeId = _data["issueTypeId"];
        }
    }

    static fromJS(data: any): FieldConfigurationIssueTypeItem {
        data = typeof data === 'object' ? data : {};
        let result = new FieldConfigurationIssueTypeItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldConfigurationId"] = this.fieldConfigurationId;
        data["fieldConfigurationSchemeId"] = this.fieldConfigurationSchemeId;
        data["issueTypeId"] = this.issueTypeId;
        return data;
    }
}

/** The field configuration for an issue type. */
export interface IFieldConfigurationIssueTypeItem {
    /** The ID of the field configuration. */
    fieldConfigurationId: string;
    /** The ID of the field configuration scheme. */
    fieldConfigurationSchemeId: string;
    /** The ID of the issue type or *default*. When set to *default* this field configuration issue type item applies to all issue types without a field configuration. */
    issueTypeId: string;
}

/** A field within a field configuration. */
export class FieldConfigurationItem implements IFieldConfigurationItem {
    /** The description of the field within the field configuration. */
    description?: string;
    /** The ID of the field within the field configuration. */
    id!: string;
    /** Whether the field is hidden in the field configuration. */
    isHidden?: boolean;
    /** Whether the field is required in the field configuration. */
    isRequired?: boolean;
    /** The renderer type for the field within the field configuration. */
    renderer?: string;

    constructor(data?: IFieldConfigurationItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.id = _data["id"];
            this.isHidden = _data["isHidden"];
            this.isRequired = _data["isRequired"];
            this.renderer = _data["renderer"];
        }
    }

    static fromJS(data: any): FieldConfigurationItem {
        data = typeof data === 'object' ? data : {};
        let result = new FieldConfigurationItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["isHidden"] = this.isHidden;
        data["isRequired"] = this.isRequired;
        data["renderer"] = this.renderer;
        return data;
    }
}

/** A field within a field configuration. */
export interface IFieldConfigurationItem {
    /** The description of the field within the field configuration. */
    description?: string;
    /** The ID of the field within the field configuration. */
    id: string;
    /** Whether the field is hidden in the field configuration. */
    isHidden?: boolean;
    /** Whether the field is required in the field configuration. */
    isRequired?: boolean;
    /** The renderer type for the field within the field configuration. */
    renderer?: string;
}

/** Details of field configuration items. */
export class FieldConfigurationItemsDetails implements IFieldConfigurationItemsDetails {
    /** Details of fields in a field configuration. */
    fieldConfigurationItems!: FieldConfigurationItem[];

    constructor(data?: IFieldConfigurationItemsDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fieldConfigurationItems = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fieldConfigurationItems"])) {
                this.fieldConfigurationItems = [] as any;
                for (let item of _data["fieldConfigurationItems"])
                    this.fieldConfigurationItems!.push(FieldConfigurationItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FieldConfigurationItemsDetails {
        data = typeof data === 'object' ? data : {};
        let result = new FieldConfigurationItemsDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fieldConfigurationItems)) {
            data["fieldConfigurationItems"] = [];
            for (let item of this.fieldConfigurationItems)
                data["fieldConfigurationItems"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of field configuration items. */
export interface IFieldConfigurationItemsDetails {
    /** Details of fields in a field configuration. */
    fieldConfigurationItems: FieldConfigurationItem[];
}

/** Details of a field configuration scheme. */
export class FieldConfigurationScheme implements IFieldConfigurationScheme {
    /** The description of the field configuration scheme. */
    description?: string;
    /** The ID of the field configuration scheme. */
    id!: string;
    /** The name of the field configuration scheme. */
    name!: string;

    constructor(data?: IFieldConfigurationScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FieldConfigurationScheme {
        data = typeof data === 'object' ? data : {};
        let result = new FieldConfigurationScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** Details of a field configuration scheme. */
export interface IFieldConfigurationScheme {
    /** The description of the field configuration scheme. */
    description?: string;
    /** The ID of the field configuration scheme. */
    id: string;
    /** The name of the field configuration scheme. */
    name: string;
}

/** Associated field configuration scheme and project. */
export class FieldConfigurationSchemeProjectAssociation implements IFieldConfigurationSchemeProjectAssociation {
    /** The ID of the field configuration scheme. If the field configuration scheme ID is `null`, the operation assigns the default field configuration scheme. */
    fieldConfigurationSchemeId?: string;
    /** The ID of the project. */
    projectId!: string;

    constructor(data?: IFieldConfigurationSchemeProjectAssociation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldConfigurationSchemeId = _data["fieldConfigurationSchemeId"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): FieldConfigurationSchemeProjectAssociation {
        data = typeof data === 'object' ? data : {};
        let result = new FieldConfigurationSchemeProjectAssociation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldConfigurationSchemeId"] = this.fieldConfigurationSchemeId;
        data["projectId"] = this.projectId;
        return data;
    }
}

/** Associated field configuration scheme and project. */
export interface IFieldConfigurationSchemeProjectAssociation {
    /** The ID of the field configuration scheme. If the field configuration scheme ID is `null`, the operation assigns the default field configuration scheme. */
    fieldConfigurationSchemeId?: string;
    /** The ID of the project. */
    projectId: string;
}

/** Project list with assigned field configuration schema. */
export class FieldConfigurationSchemeProjects implements IFieldConfigurationSchemeProjects {
    fieldConfigurationScheme?: FieldConfigurationScheme;
    /** The IDs of projects using the field configuration scheme. */
    projectIds!: string[];

    constructor(data?: IFieldConfigurationSchemeProjects) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.projectIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldConfigurationScheme = _data["fieldConfigurationScheme"] ? FieldConfigurationScheme.fromJS(_data["fieldConfigurationScheme"]) : <any>undefined;
            if (Array.isArray(_data["projectIds"])) {
                this.projectIds = [] as any;
                for (let item of _data["projectIds"])
                    this.projectIds!.push(item);
            }
        }
    }

    static fromJS(data: any): FieldConfigurationSchemeProjects {
        data = typeof data === 'object' ? data : {};
        let result = new FieldConfigurationSchemeProjects();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldConfigurationScheme"] = this.fieldConfigurationScheme ? this.fieldConfigurationScheme.toJSON() : <any>undefined;
        if (Array.isArray(this.projectIds)) {
            data["projectIds"] = [];
            for (let item of this.projectIds)
                data["projectIds"].push(item);
        }
        return data;
    }
}

/** Project list with assigned field configuration schema. */
export interface IFieldConfigurationSchemeProjects {
    fieldConfigurationScheme?: FieldConfigurationScheme;
    /** The IDs of projects using the field configuration scheme. */
    projectIds: string[];
}

/** The field configuration to issue type mapping. */
export class FieldConfigurationToIssueTypeMapping implements IFieldConfigurationToIssueTypeMapping {
    /** The ID of the field configuration. */
    fieldConfigurationId!: string;
    /** The ID of the issue type or *default*. When set to *default* this field configuration issue type item applies to all issue types without a field configuration. An issue type can be included only once in a request. */
    issueTypeId!: string;

    constructor(data?: IFieldConfigurationToIssueTypeMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldConfigurationId = _data["fieldConfigurationId"];
            this.issueTypeId = _data["issueTypeId"];
        }
    }

    static fromJS(data: any): FieldConfigurationToIssueTypeMapping {
        data = typeof data === 'object' ? data : {};
        let result = new FieldConfigurationToIssueTypeMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldConfigurationId"] = this.fieldConfigurationId;
        data["issueTypeId"] = this.issueTypeId;
        return data;
    }
}

/** The field configuration to issue type mapping. */
export interface IFieldConfigurationToIssueTypeMapping {
    /** The ID of the field configuration. */
    fieldConfigurationId: string;
    /** The ID of the issue type or *default*. When set to *default* this field configuration issue type item applies to all issue types without a field configuration. An issue type can be included only once in a request. */
    issueTypeId: string;
}

/** The metadata describing an issue field for createmeta. */
export class FieldCreateMetadata implements IFieldCreateMetadata {
    /** The list of values allowed in the field. */
    readonly allowedValues?: any[];
    /** The URL that can be used to automatically complete the field. */
    readonly autoCompleteUrl?: string;
    /** The configuration properties. */
    readonly configuration?: { [key: string]: any; };
    /** The default value of the field. */
    readonly defaultValue?: any;
    /** The field id. */
    readonly fieldId!: string;
    /** Whether the field has a default value. */
    readonly hasDefaultValue?: boolean;
    /** The key of the field. */
    readonly key!: string;
    /** The name of the field. */
    readonly name!: string;
    /** The list of operations that can be performed on the field. */
    readonly operations!: string[];
    /** Whether the field is required. */
    readonly required!: boolean;
    /** The data type of the field. */
    readonly schema!: JsonTypeBean;

    constructor(data?: IFieldCreateMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.operations = [];
            this.schema = new JsonTypeBean();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["allowedValues"])) {
                (<any>this).allowedValues = [] as any;
                for (let item of _data["allowedValues"])
                    (<any>this).allowedValues!.push(item);
            }
            (<any>this).autoCompleteUrl = _data["autoCompleteUrl"];
            if (_data["configuration"]) {
                (<any>this).configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>(<any>this).configuration)![key] = _data["configuration"][key];
                }
            }
            (<any>this).defaultValue = _data["defaultValue"];
            (<any>this).fieldId = _data["fieldId"];
            (<any>this).hasDefaultValue = _data["hasDefaultValue"];
            (<any>this).key = _data["key"];
            (<any>this).name = _data["name"];
            if (Array.isArray(_data["operations"])) {
                (<any>this).operations = [] as any;
                for (let item of _data["operations"])
                    (<any>this).operations!.push(item);
            }
            (<any>this).required = _data["required"];
            (<any>this).schema = _data["schema"] ? JsonTypeBean.fromJS(_data["schema"]) : new JsonTypeBean();
        }
    }

    static fromJS(data: any): FieldCreateMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new FieldCreateMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allowedValues)) {
            data["allowedValues"] = [];
            for (let item of this.allowedValues)
                data["allowedValues"].push(item);
        }
        data["autoCompleteUrl"] = this.autoCompleteUrl;
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        data["defaultValue"] = this.defaultValue;
        data["fieldId"] = this.fieldId;
        data["hasDefaultValue"] = this.hasDefaultValue;
        data["key"] = this.key;
        data["name"] = this.name;
        if (Array.isArray(this.operations)) {
            data["operations"] = [];
            for (let item of this.operations)
                data["operations"].push(item);
        }
        data["required"] = this.required;
        data["schema"] = this.schema ? this.schema.toJSON() : <any>undefined;
        return data;
    }
}

/** The metadata describing an issue field for createmeta. */
export interface IFieldCreateMetadata {
    /** The list of values allowed in the field. */
    allowedValues?: any[];
    /** The URL that can be used to automatically complete the field. */
    autoCompleteUrl?: string;
    /** The configuration properties. */
    configuration?: { [key: string]: any; };
    /** The default value of the field. */
    defaultValue?: any;
    /** The field id. */
    fieldId: string;
    /** Whether the field has a default value. */
    hasDefaultValue?: boolean;
    /** The key of the field. */
    key: string;
    /** The name of the field. */
    name: string;
    /** The list of operations that can be performed on the field. */
    operations: string[];
    /** Whether the field is required. */
    required: boolean;
    /** The data type of the field. */
    schema: JsonTypeBean;
}

/** Details about a field. */
export class FieldDetails implements IFieldDetails {
    /** The names that can be used to reference the field in an advanced search. For more information, see [Advanced searching - fields reference](https://confluence.atlassian.com/x/gwORLQ). */
    clauseNames?: string[];
    /** Whether the field is a custom field. */
    custom?: boolean;
    /** The ID of the field. */
    id?: string;
    /** The key of the field. */
    key?: string;
    /** The name of the field. */
    name?: string;
    /** Whether the field can be used as a column on the issue navigator. */
    navigable?: boolean;
    /** Whether the content of the field can be used to order lists. */
    orderable?: boolean;
    /** The data schema for the field. */
    schema?: JsonTypeBean;
    /** The scope of the field. */
    scope?: Scope;
    /** Whether the content of the field can be searched. */
    searchable?: boolean;

    constructor(data?: IFieldDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["clauseNames"])) {
                this.clauseNames = [] as any;
                for (let item of _data["clauseNames"])
                    this.clauseNames!.push(item);
            }
            this.custom = _data["custom"];
            this.id = _data["id"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.navigable = _data["navigable"];
            this.orderable = _data["orderable"];
            this.schema = _data["schema"] ? JsonTypeBean.fromJS(_data["schema"]) : <any>undefined;
            this.scope = _data["scope"] ? Scope.fromJS(_data["scope"]) : <any>undefined;
            this.searchable = _data["searchable"];
        }
    }

    static fromJS(data: any): FieldDetails {
        data = typeof data === 'object' ? data : {};
        let result = new FieldDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.clauseNames)) {
            data["clauseNames"] = [];
            for (let item of this.clauseNames)
                data["clauseNames"].push(item);
        }
        data["custom"] = this.custom;
        data["id"] = this.id;
        data["key"] = this.key;
        data["name"] = this.name;
        data["navigable"] = this.navigable;
        data["orderable"] = this.orderable;
        data["schema"] = this.schema ? this.schema.toJSON() : <any>undefined;
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        data["searchable"] = this.searchable;
        return data;
    }
}

/** Details about a field. */
export interface IFieldDetails {
    /** The names that can be used to reference the field in an advanced search. For more information, see [Advanced searching - fields reference](https://confluence.atlassian.com/x/gwORLQ). */
    clauseNames?: string[];
    /** Whether the field is a custom field. */
    custom?: boolean;
    /** The ID of the field. */
    id?: string;
    /** The key of the field. */
    key?: string;
    /** The name of the field. */
    name?: string;
    /** Whether the field can be used as a column on the issue navigator. */
    navigable?: boolean;
    /** Whether the content of the field can be used to order lists. */
    orderable?: boolean;
    /** The data schema for the field. */
    schema?: JsonTypeBean;
    /** The scope of the field. */
    scope?: Scope;
    /** Whether the content of the field can be searched. */
    searchable?: boolean;
}

/** Identifier for a field for example FIELD\_ID. */
export class FieldIdentifierObject implements IFieldIdentifierObject {
    identifier?: any;

    protected _discriminator: string;

    constructor(data?: IFieldIdentifierObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "FieldIdentifierObject";
    }

    init(_data?: any) {
        if (_data) {
            this.identifier = _data["identifier"];
        }
    }

    static fromJS(data: any): FieldIdentifierObject {
        data = typeof data === 'object' ? data : {};
        if (data["type"] === "FieldIdIdentifier") {
            let result = new FieldIdIdentifier();
            result.init(data);
            return result;
        }
        let result = new FieldIdentifierObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this._discriminator;
        data["identifier"] = this.identifier;
        return data;
    }
}

/** Identifier for a field for example FIELD\_ID. */
export interface IFieldIdentifierObject {
    identifier?: any;
}

export class FieldIdIdentifier extends FieldIdentifierObject implements IFieldIdIdentifier {
    identifier?: string;

    [key: string]: any;

    constructor(data?: IFieldIdIdentifier) {
        super(data);
        this._discriminator = "FieldIdIdentifier";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.identifier = _data["identifier"];
        }
    }

    static fromJS(data: any): FieldIdIdentifier {
        data = typeof data === 'object' ? data : {};
        let result = new FieldIdIdentifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["identifier"] = this.identifier;
        super.toJSON(data);
        return data;
    }
}

export interface IFieldIdIdentifier extends IFieldIdentifierObject {
    identifier?: string;

    [key: string]: any;
}

/** Information about the most recent use of a field. */
export class FieldLastUsed implements IFieldLastUsed {
    /** Last used value type:

 *  *TRACKED*: field is tracked and a last used date is available.
 *  *NOT\_TRACKED*: field is not tracked, last used date is not available.
 *  *NO\_INFORMATION*: field is tracked, but no last used date is available. */
    type?: FieldLastUsedType;
    /** The date when the value of the field last changed. */
    value?: Date;

    constructor(data?: IFieldLastUsed) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"] ? new Date(_data["value"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FieldLastUsed {
        data = typeof data === 'object' ? data : {};
        let result = new FieldLastUsed();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value ? this.value.toISOString() : <any>undefined;
        return data;
    }
}

/** Information about the most recent use of a field. */
export interface IFieldLastUsed {
    /** Last used value type:

 *  *TRACKED*: field is tracked and a last used date is available.
 *  *NOT\_TRACKED*: field is not tracked, last used date is not available.
 *  *NO\_INFORMATION*: field is tracked, but no last used date is available. */
    type?: FieldLastUsedType;
    /** The date when the value of the field last changed. */
    value?: Date;
}

/** Defines the payload for the field layout configuration. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-field-configurations/\#api-rest-api-3-fieldconfiguration-post */
export class FieldLayoutConfiguration implements IFieldLayoutConfiguration {
    /** Whether to show the field */
    field?: boolean;
    pcri?: ProjectCreateResourceIdentifier;
    /** Whether the field is required */
    required?: boolean;

    constructor(data?: IFieldLayoutConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
            this.required = _data["required"];
        }
    }

    static fromJS(data: any): FieldLayoutConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new FieldLayoutConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        data["required"] = this.required;
        return data;
    }
}

/** Defines the payload for the field layout configuration. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-field-configurations/\#api-rest-api-3-fieldconfiguration-post */
export interface IFieldLayoutConfiguration {
    /** Whether to show the field */
    field?: boolean;
    pcri?: ProjectCreateResourceIdentifier;
    /** Whether the field is required */
    required?: boolean;
}

/** Defines the payload for the field layouts. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-field-configurations/\#api-group-issue-field-configurations" + fieldlayout is what users would see as "Field Configuration" in Jira's UI - https://support.atlassian.com/jira-cloud-administration/docs/manage-issue-field-configurations/ */
export class FieldLayoutPayload implements IFieldLayoutPayload {
    /** The field layout configuration. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-field-configurations/\#api-rest-api-3-fieldconfiguration-post */
    configuration?: FieldLayoutConfiguration[];
    /** The description of the field layout */
    description?: string;
    /** The name of the field layout */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;

    constructor(data?: IFieldLayoutPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["configuration"])) {
                this.configuration = [] as any;
                for (let item of _data["configuration"])
                    this.configuration!.push(FieldLayoutConfiguration.fromJS(item));
            }
            this.description = _data["description"];
            this.name = _data["name"];
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FieldLayoutPayload {
        data = typeof data === 'object' ? data : {};
        let result = new FieldLayoutPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.configuration)) {
            data["configuration"] = [];
            for (let item of this.configuration)
                data["configuration"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["name"] = this.name;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        return data;
    }
}

/** Defines the payload for the field layouts. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-field-configurations/\#api-group-issue-field-configurations" + fieldlayout is what users would see as "Field Configuration" in Jira's UI - https://support.atlassian.com/jira-cloud-administration/docs/manage-issue-field-configurations/ */
export interface IFieldLayoutPayload {
    /** The field layout configuration. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-field-configurations/\#api-rest-api-3-fieldconfiguration-post */
    configuration?: FieldLayoutConfiguration[];
    /** The description of the field layout */
    description?: string;
    /** The name of the field layout */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;
}

/** Defines the payload for the field layout schemes. See "Field Configuration Scheme" - https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-field-configurations/\#api-rest-api-3-fieldconfigurationscheme-post https://support.atlassian.com/jira-cloud-administration/docs/configure-a-field-configuration-scheme/ */
export class FieldLayoutSchemePayload implements IFieldLayoutSchemePayload {
    defaultFieldLayout?: ProjectCreateResourceIdentifier;
    /** The description of the field layout scheme */
    description?: string;
    /** There is a default configuration "fieldlayout" that is applied to all issue types using this scheme that don't have an explicit mapping users can create (or re-use existing) configurations for other issue types and map them to this scheme */
    explicitMappings?: { [key: string]: ProjectCreateResourceIdentifier; };
    /** The name of the field layout scheme */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;

    constructor(data?: IFieldLayoutSchemePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultFieldLayout = _data["defaultFieldLayout"] ? ProjectCreateResourceIdentifier.fromJS(_data["defaultFieldLayout"]) : <any>undefined;
            this.description = _data["description"];
            if (_data["explicitMappings"]) {
                this.explicitMappings = {} as any;
                for (let key in _data["explicitMappings"]) {
                    if (_data["explicitMappings"].hasOwnProperty(key))
                        (<any>this.explicitMappings)![key] = _data["explicitMappings"][key] ? ProjectCreateResourceIdentifier.fromJS(_data["explicitMappings"][key]) : new ProjectCreateResourceIdentifier();
                }
            }
            this.name = _data["name"];
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FieldLayoutSchemePayload {
        data = typeof data === 'object' ? data : {};
        let result = new FieldLayoutSchemePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFieldLayout"] = this.defaultFieldLayout ? this.defaultFieldLayout.toJSON() : <any>undefined;
        data["description"] = this.description;
        if (this.explicitMappings) {
            data["explicitMappings"] = {};
            for (let key in this.explicitMappings) {
                if (this.explicitMappings.hasOwnProperty(key))
                    (<any>data["explicitMappings"])[key] = this.explicitMappings[key] ? this.explicitMappings[key].toJSON() : <any>undefined;
            }
        }
        data["name"] = this.name;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        return data;
    }
}

/** Defines the payload for the field layout schemes. See "Field Configuration Scheme" - https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-field-configurations/\#api-rest-api-3-fieldconfigurationscheme-post https://support.atlassian.com/jira-cloud-administration/docs/configure-a-field-configuration-scheme/ */
export interface IFieldLayoutSchemePayload {
    defaultFieldLayout?: ProjectCreateResourceIdentifier;
    /** The description of the field layout scheme */
    description?: string;
    /** There is a default configuration "fieldlayout" that is applied to all issue types using this scheme that don't have an explicit mapping users can create (or re-use existing) configurations for other issue types and map them to this scheme */
    explicitMappings?: { [key: string]: ProjectCreateResourceIdentifier; };
    /** The name of the field layout scheme */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;
}

/** The metadata describing an issue field. */
export class FieldMetadata implements IFieldMetadata {
    /** The list of values allowed in the field. */
    readonly allowedValues?: any[];
    /** The URL that can be used to automatically complete the field. */
    readonly autoCompleteUrl?: string;
    /** The configuration properties. */
    readonly configuration?: { [key: string]: any; };
    /** The default value of the field. */
    readonly defaultValue?: any;
    /** Whether the field has a default value. */
    readonly hasDefaultValue?: boolean;
    /** The key of the field. */
    readonly key!: string;
    /** The name of the field. */
    readonly name!: string;
    /** The list of operations that can be performed on the field. */
    readonly operations!: string[];
    /** Whether the field is required. */
    readonly required!: boolean;
    /** The data type of the field. */
    readonly schema!: JsonTypeBean;

    constructor(data?: IFieldMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.operations = [];
            this.schema = new JsonTypeBean();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["allowedValues"])) {
                (<any>this).allowedValues = [] as any;
                for (let item of _data["allowedValues"])
                    (<any>this).allowedValues!.push(item);
            }
            (<any>this).autoCompleteUrl = _data["autoCompleteUrl"];
            if (_data["configuration"]) {
                (<any>this).configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>(<any>this).configuration)![key] = _data["configuration"][key];
                }
            }
            (<any>this).defaultValue = _data["defaultValue"];
            (<any>this).hasDefaultValue = _data["hasDefaultValue"];
            (<any>this).key = _data["key"];
            (<any>this).name = _data["name"];
            if (Array.isArray(_data["operations"])) {
                (<any>this).operations = [] as any;
                for (let item of _data["operations"])
                    (<any>this).operations!.push(item);
            }
            (<any>this).required = _data["required"];
            (<any>this).schema = _data["schema"] ? JsonTypeBean.fromJS(_data["schema"]) : new JsonTypeBean();
        }
    }

    static fromJS(data: any): FieldMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new FieldMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allowedValues)) {
            data["allowedValues"] = [];
            for (let item of this.allowedValues)
                data["allowedValues"].push(item);
        }
        data["autoCompleteUrl"] = this.autoCompleteUrl;
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        data["defaultValue"] = this.defaultValue;
        data["hasDefaultValue"] = this.hasDefaultValue;
        data["key"] = this.key;
        data["name"] = this.name;
        if (Array.isArray(this.operations)) {
            data["operations"] = [];
            for (let item of this.operations)
                data["operations"].push(item);
        }
        data["required"] = this.required;
        data["schema"] = this.schema ? this.schema.toJSON() : <any>undefined;
        return data;
    }
}

/** The metadata describing an issue field. */
export interface IFieldMetadata {
    /** The list of values allowed in the field. */
    allowedValues?: any[];
    /** The URL that can be used to automatically complete the field. */
    autoCompleteUrl?: string;
    /** The configuration properties. */
    configuration?: { [key: string]: any; };
    /** The default value of the field. */
    defaultValue?: any;
    /** Whether the field has a default value. */
    hasDefaultValue?: boolean;
    /** The key of the field. */
    key: string;
    /** The name of the field. */
    name: string;
    /** The list of operations that can be performed on the field. */
    operations: string[];
    /** Whether the field is required. */
    required: boolean;
    /** The data type of the field. */
    schema: JsonTypeBean;
}

/** Details of a field that can be used in advanced searches. */
export class FieldReferenceData implements IFieldReferenceData {
    /** Whether the field provide auto-complete suggestions. */
    auto?: FieldReferenceDataAuto;
    /** If the item is a custom field, the ID of the custom field. */
    cfid?: string;
    /** Whether this field has been deprecated. */
    deprecated?: FieldReferenceDataDeprecated;
    /** The searcher key of the field, only passed when the field is deprecated. */
    deprecatedSearcherKey?: string;
    /** The display name contains the following:

 *  for system fields, the field name. For example, `Summary`.
 *  for collapsed custom fields, the field name followed by a hyphen and then the field name and field type. For example, `Component - Component[Dropdown]`.
 *  for other custom fields, the field name followed by a hyphen and then the custom field ID. For example, `Component - cf[10061]`. */
    displayName?: string;
    /** The valid search operators for the field. */
    operators?: string[];
    /** Whether the field can be used in a query's `ORDER BY` clause. */
    orderable?: FieldReferenceDataOrderable;
    /** Whether the content of this field can be searched. */
    searchable?: FieldReferenceDataSearchable;
    /** The data types of items in the field. */
    types?: string[];
    /** The field identifier. */
    value?: string;

    constructor(data?: IFieldReferenceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.auto = _data["auto"];
            this.cfid = _data["cfid"];
            this.deprecated = _data["deprecated"];
            this.deprecatedSearcherKey = _data["deprecatedSearcherKey"];
            this.displayName = _data["displayName"];
            if (Array.isArray(_data["operators"])) {
                this.operators = [] as any;
                for (let item of _data["operators"])
                    this.operators!.push(item);
            }
            this.orderable = _data["orderable"];
            this.searchable = _data["searchable"];
            if (Array.isArray(_data["types"])) {
                this.types = [] as any;
                for (let item of _data["types"])
                    this.types!.push(item);
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): FieldReferenceData {
        data = typeof data === 'object' ? data : {};
        let result = new FieldReferenceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["auto"] = this.auto;
        data["cfid"] = this.cfid;
        data["deprecated"] = this.deprecated;
        data["deprecatedSearcherKey"] = this.deprecatedSearcherKey;
        data["displayName"] = this.displayName;
        if (Array.isArray(this.operators)) {
            data["operators"] = [];
            for (let item of this.operators)
                data["operators"].push(item);
        }
        data["orderable"] = this.orderable;
        data["searchable"] = this.searchable;
        if (Array.isArray(this.types)) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["value"] = this.value;
        return data;
    }
}

/** Details of a field that can be used in advanced searches. */
export interface IFieldReferenceData {
    /** Whether the field provide auto-complete suggestions. */
    auto?: FieldReferenceDataAuto;
    /** If the item is a custom field, the ID of the custom field. */
    cfid?: string;
    /** Whether this field has been deprecated. */
    deprecated?: FieldReferenceDataDeprecated;
    /** The searcher key of the field, only passed when the field is deprecated. */
    deprecatedSearcherKey?: string;
    /** The display name contains the following:

 *  for system fields, the field name. For example, `Summary`.
 *  for collapsed custom fields, the field name followed by a hyphen and then the field name and field type. For example, `Component - Component[Dropdown]`.
 *  for other custom fields, the field name followed by a hyphen and then the custom field ID. For example, `Component - cf[10061]`. */
    displayName?: string;
    /** The valid search operators for the field. */
    operators?: string[];
    /** Whether the field can be used in a query's `ORDER BY` clause. */
    orderable?: FieldReferenceDataOrderable;
    /** Whether the content of this field can be searched. */
    searchable?: FieldReferenceDataSearchable;
    /** The data types of items in the field. */
    types?: string[];
    /** The field identifier. */
    value?: string;
}

/** Details of an operation to perform on a field. */
export class FieldUpdateOperation implements IFieldUpdateOperation {
    /** The value to add to the field. */
    add?: any;
    /** The field value to copy from another issue. */
    copy?: any;
    /** The value to edit in the field. */
    edit?: any;
    /** The value to removed from the field. */
    remove?: any;
    /** The value to set in the field. */
    set?: any;

    constructor(data?: IFieldUpdateOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.add = _data["add"];
            this.copy = _data["copy"];
            this.edit = _data["edit"];
            this.remove = _data["remove"];
            this.set = _data["set"];
        }
    }

    static fromJS(data: any): FieldUpdateOperation {
        data = typeof data === 'object' ? data : {};
        let result = new FieldUpdateOperation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["add"] = this.add;
        data["copy"] = this.copy;
        data["edit"] = this.edit;
        data["remove"] = this.remove;
        data["set"] = this.set;
        return data;
    }
}

/** Details of an operation to perform on a field. */
export interface IFieldUpdateOperation {
    /** The value to add to the field. */
    add?: any;
    /** The field value to copy from another issue. */
    copy?: any;
    /** The value to edit in the field. */
    edit?: any;
    /** The value to removed from the field. */
    remove?: any;
    /** The value to set in the field. */
    set?: any;
}

/** A clause that asserts the current value of a field. For example, `summary ~ test`. */
export class FieldValueClause implements IFieldValueClause {
    field!: JqlQueryField;
    operand!: JqlQueryClauseOperand;
    /** The operator between the field and operand. */
    operator!: FieldValueClauseOperator;

    [key: string]: any;

    constructor(data?: IFieldValueClause) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.field = new JqlQueryField();
            this.operand = new JqlQueryClauseOperand();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.field = _data["field"] ? JqlQueryField.fromJS(_data["field"]) : new JqlQueryField();
            this.operand = _data["operand"] ? JqlQueryClauseOperand.fromJS(_data["operand"]) : new JqlQueryClauseOperand();
            this.operator = _data["operator"];
        }
    }

    static fromJS(data: any): FieldValueClause {
        data = typeof data === 'object' ? data : {};
        let result = new FieldValueClause();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["field"] = this.field ? this.field.toJSON() : <any>undefined;
        data["operand"] = this.operand ? this.operand.toJSON() : <any>undefined;
        data["operator"] = this.operator;
        return data;
    }
}

/** A clause that asserts the current value of a field. For example, `summary ~ test`. */
export interface IFieldValueClause {
    field: JqlQueryField;
    operand: JqlQueryClauseOperand;
    /** The operator between the field and operand. */
    operator: FieldValueClauseOperator;

    [key: string]: any;
}

/** A clause that asserts a previous value of a field. For example, `status WAS "Resolved" BY currentUser() BEFORE "2019/02/02"`. See [WAS](https://confluence.atlassian.com/x/dgiiLQ#Advancedsearching-operatorsreference-WASWAS) for more information about the WAS operator. */
export class FieldWasClause implements IFieldWasClause {
    field!: JqlQueryField;
    operand!: JqlQueryClauseOperand;
    /** The operator between the field and operand. */
    operator!: FieldWasClauseOperator;
    /** The list of time predicates. */
    predicates!: JqlQueryClauseTimePredicate[];

    [key: string]: any;

    constructor(data?: IFieldWasClause) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.field = new JqlQueryField();
            this.operand = new JqlQueryClauseOperand();
            this.predicates = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.field = _data["field"] ? JqlQueryField.fromJS(_data["field"]) : new JqlQueryField();
            this.operand = _data["operand"] ? JqlQueryClauseOperand.fromJS(_data["operand"]) : new JqlQueryClauseOperand();
            this.operator = _data["operator"];
            if (Array.isArray(_data["predicates"])) {
                this.predicates = [] as any;
                for (let item of _data["predicates"])
                    this.predicates!.push(JqlQueryClauseTimePredicate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FieldWasClause {
        data = typeof data === 'object' ? data : {};
        let result = new FieldWasClause();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["field"] = this.field ? this.field.toJSON() : <any>undefined;
        data["operand"] = this.operand ? this.operand.toJSON() : <any>undefined;
        data["operator"] = this.operator;
        if (Array.isArray(this.predicates)) {
            data["predicates"] = [];
            for (let item of this.predicates)
                data["predicates"].push(item.toJSON());
        }
        return data;
    }
}

/** A clause that asserts a previous value of a field. For example, `status WAS "Resolved" BY currentUser() BEFORE "2019/02/02"`. See [WAS](https://confluence.atlassian.com/x/dgiiLQ#Advancedsearching-operatorsreference-WASWAS) for more information about the WAS operator. */
export interface IFieldWasClause {
    field: JqlQueryField;
    operand: JqlQueryClauseOperand;
    /** The operator between the field and operand. */
    operator: FieldWasClauseOperator;
    /** The list of time predicates. */
    predicates: JqlQueryClauseTimePredicate[];

    [key: string]: any;
}

/** Key fields from the linked issue. */
export class Fields implements IFields {
    /** The assignee of the linked issue. */
    readonly assignee?: UserDetails;
    /** The type of the linked issue. */
    readonly issueType?: IssueTypeDetails;
    /** The type of the linked issue. */
    issuetype?: IssueTypeDetails;
    /** The priority of the linked issue. */
    readonly priority?: Priority;
    /** The status of the linked issue. */
    readonly status?: StatusDetails;
    /** The summary description of the linked issue. */
    readonly summary?: string;
    /** The time tracking of the linked issue. */
    readonly timetracking?: TimeTrackingDetails;

    constructor(data?: IFields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).assignee = _data["assignee"] ? UserDetails.fromJS(_data["assignee"]) : <any>undefined;
            (<any>this).issueType = _data["issueType"] ? IssueTypeDetails.fromJS(_data["issueType"]) : <any>undefined;
            this.issuetype = _data["issuetype"] ? IssueTypeDetails.fromJS(_data["issuetype"]) : <any>undefined;
            (<any>this).priority = _data["priority"] ? Priority.fromJS(_data["priority"]) : <any>undefined;
            (<any>this).status = _data["status"] ? StatusDetails.fromJS(_data["status"]) : <any>undefined;
            (<any>this).summary = _data["summary"];
            (<any>this).timetracking = _data["timetracking"] ? TimeTrackingDetails.fromJS(_data["timetracking"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Fields {
        data = typeof data === 'object' ? data : {};
        let result = new Fields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assignee"] = this.assignee ? this.assignee.toJSON() : <any>undefined;
        data["issueType"] = this.issueType ? this.issueType.toJSON() : <any>undefined;
        data["issuetype"] = this.issuetype ? this.issuetype.toJSON() : <any>undefined;
        data["priority"] = this.priority ? this.priority.toJSON() : <any>undefined;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["summary"] = this.summary;
        data["timetracking"] = this.timetracking ? this.timetracking.toJSON() : <any>undefined;
        return data;
    }
}

/** Key fields from the linked issue. */
export interface IFields {
    /** The assignee of the linked issue. */
    assignee?: UserDetails;
    /** The type of the linked issue. */
    issueType?: IssueTypeDetails;
    /** The type of the linked issue. */
    issuetype?: IssueTypeDetails;
    /** The priority of the linked issue. */
    priority?: Priority;
    /** The status of the linked issue. */
    status?: StatusDetails;
    /** The summary description of the linked issue. */
    summary?: string;
    /** The time tracking of the linked issue. */
    timetracking?: TimeTrackingDetails;
}

/** Details about a filter. */
export class Filter implements IFilter {
    /** \[Experimental\] Approximate last used time. Returns the date and time when the filter was last used. Returns `null` if the filter hasn't been used after tracking was enabled. For performance reasons, timestamps aren't updated in real time and therefore may not be exactly accurate. */
    readonly approximateLastUsed?: Date;
    /** A description of the filter. */
    description?: string;
    /** The groups and projects that can edit the filter. */
    editPermissions?: SharePermission[];
    /** Whether the filter is selected as a favorite. */
    favourite?: boolean;
    /** The count of how many users have selected this filter as a favorite, including the filter owner. */
    readonly favouritedCount?: number;
    /** The unique identifier for the filter. */
    readonly id?: string;
    /** The JQL query for the filter. For example, *project = SSP AND issuetype = Bug*. */
    jql?: string;
    /** The name of the filter. Must be unique. */
    name!: string;
    /** The user who owns the filter. This is defaulted to the creator of the filter, however Jira administrators can change the owner of a shared filter in the admin settings. */
    readonly owner?: User;
    /** A URL to view the filter results in Jira, using the [Search for issues using JQL](#api-rest-api-3-filter-search-get) operation with the filter's JQL string to return the filter results. For example, *https://your-domain.atlassian.net/rest/api/3/search?jql=project+%3D+SSP+AND+issuetype+%3D+Bug*. */
    readonly searchUrl?: string;
    /** The URL of the filter. */
    readonly self?: string;
    /** The groups and projects that the filter is shared with. */
    sharePermissions?: SharePermission[];
    /** A paginated list of the users that the filter is shared with. This includes users that are members of the groups or can browse the projects that the filter is shared with. */
    readonly sharedUsers?: UserList;
    /** A paginated list of the users that are subscribed to the filter. */
    readonly subscriptions?: FilterSubscriptionsList;
    /** A URL to view the filter results in Jira, using the ID of the filter. For example, *https://your-domain.atlassian.net/issues/?filter=10100*. */
    readonly viewUrl?: string;

    constructor(data?: IFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).approximateLastUsed = _data["approximateLastUsed"] ? new Date(_data["approximateLastUsed"].toString()) : <any>undefined;
            this.description = _data["description"];
            if (Array.isArray(_data["editPermissions"])) {
                this.editPermissions = [] as any;
                for (let item of _data["editPermissions"])
                    this.editPermissions!.push(SharePermission.fromJS(item));
            }
            this.favourite = _data["favourite"];
            (<any>this).favouritedCount = _data["favouritedCount"];
            (<any>this).id = _data["id"];
            this.jql = _data["jql"];
            this.name = _data["name"];
            (<any>this).owner = _data["owner"] ? User.fromJS(_data["owner"]) : <any>undefined;
            (<any>this).searchUrl = _data["searchUrl"];
            (<any>this).self = _data["self"];
            if (Array.isArray(_data["sharePermissions"])) {
                this.sharePermissions = [] as any;
                for (let item of _data["sharePermissions"])
                    this.sharePermissions!.push(SharePermission.fromJS(item));
            }
            (<any>this).sharedUsers = _data["sharedUsers"] ? UserList.fromJS(_data["sharedUsers"]) : <any>undefined;
            (<any>this).subscriptions = _data["subscriptions"] ? FilterSubscriptionsList.fromJS(_data["subscriptions"]) : <any>undefined;
            (<any>this).viewUrl = _data["viewUrl"];
        }
    }

    static fromJS(data: any): Filter {
        data = typeof data === 'object' ? data : {};
        let result = new Filter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approximateLastUsed"] = this.approximateLastUsed ? this.approximateLastUsed.toISOString() : <any>undefined;
        data["description"] = this.description;
        if (Array.isArray(this.editPermissions)) {
            data["editPermissions"] = [];
            for (let item of this.editPermissions)
                data["editPermissions"].push(item.toJSON());
        }
        data["favourite"] = this.favourite;
        data["favouritedCount"] = this.favouritedCount;
        data["id"] = this.id;
        data["jql"] = this.jql;
        data["name"] = this.name;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["searchUrl"] = this.searchUrl;
        data["self"] = this.self;
        if (Array.isArray(this.sharePermissions)) {
            data["sharePermissions"] = [];
            for (let item of this.sharePermissions)
                data["sharePermissions"].push(item.toJSON());
        }
        data["sharedUsers"] = this.sharedUsers ? this.sharedUsers.toJSON() : <any>undefined;
        data["subscriptions"] = this.subscriptions ? this.subscriptions.toJSON() : <any>undefined;
        data["viewUrl"] = this.viewUrl;
        return data;
    }
}

/** Details about a filter. */
export interface IFilter {
    /** \[Experimental\] Approximate last used time. Returns the date and time when the filter was last used. Returns `null` if the filter hasn't been used after tracking was enabled. For performance reasons, timestamps aren't updated in real time and therefore may not be exactly accurate. */
    approximateLastUsed?: Date;
    /** A description of the filter. */
    description?: string;
    /** The groups and projects that can edit the filter. */
    editPermissions?: SharePermission[];
    /** Whether the filter is selected as a favorite. */
    favourite?: boolean;
    /** The count of how many users have selected this filter as a favorite, including the filter owner. */
    favouritedCount?: number;
    /** The unique identifier for the filter. */
    id?: string;
    /** The JQL query for the filter. For example, *project = SSP AND issuetype = Bug*. */
    jql?: string;
    /** The name of the filter. Must be unique. */
    name: string;
    /** The user who owns the filter. This is defaulted to the creator of the filter, however Jira administrators can change the owner of a shared filter in the admin settings. */
    owner?: User;
    /** A URL to view the filter results in Jira, using the [Search for issues using JQL](#api-rest-api-3-filter-search-get) operation with the filter's JQL string to return the filter results. For example, *https://your-domain.atlassian.net/rest/api/3/search?jql=project+%3D+SSP+AND+issuetype+%3D+Bug*. */
    searchUrl?: string;
    /** The URL of the filter. */
    self?: string;
    /** The groups and projects that the filter is shared with. */
    sharePermissions?: SharePermission[];
    /** A paginated list of the users that the filter is shared with. This includes users that are members of the groups or can browse the projects that the filter is shared with. */
    sharedUsers?: UserList;
    /** A paginated list of the users that are subscribed to the filter. */
    subscriptions?: FilterSubscriptionsList;
    /** A URL to view the filter results in Jira, using the ID of the filter. For example, *https://your-domain.atlassian.net/issues/?filter=10100*. */
    viewUrl?: string;
}

/** Details of a filter. */
export class FilterDetails implements IFilterDetails {
    /** \[Experimental\] Approximate last used time. Returns the date and time when the filter was last used. Returns `null` if the filter hasn't been used after tracking was enabled. For performance reasons, timestamps aren't updated in real time and therefore may not be exactly accurate. */
    readonly approximateLastUsed?: Date;
    /** The description of the filter. */
    description?: string;
    /** The groups and projects that can edit the filter. This can be specified when updating a filter, but not when creating a filter. */
    editPermissions?: SharePermission[];
    /** Expand options that include additional filter details in the response. */
    readonly expand?: string;
    /** Whether the filter is selected as a favorite by any users, not including the filter owner. */
    readonly favourite?: boolean;
    /** The count of how many users have selected this filter as a favorite, including the filter owner. */
    readonly favouritedCount?: number;
    /** The unique identifier for the filter. */
    readonly id?: string;
    /** The JQL query for the filter. For example, *project = SSP AND issuetype = Bug*. */
    readonly jql?: string;
    /** The name of the filter. */
    name!: string;
    /** The user who owns the filter. Defaults to the creator of the filter, however, Jira administrators can change the owner of a shared filter in the admin settings. */
    readonly owner?: User;
    /** A URL to view the filter results in Jira, using the [Search for issues using JQL](#api-rest-api-3-filter-search-get) operation with the filter's JQL string to return the filter results. For example, *https://your-domain.atlassian.net/rest/api/3/search?jql=project+%3D+SSP+AND+issuetype+%3D+Bug*. */
    readonly searchUrl?: string;
    /** The URL of the filter. */
    readonly self?: string;
    /** The groups and projects that the filter is shared with. This can be specified when updating a filter, but not when creating a filter. */
    sharePermissions?: SharePermission[];
    /** The users that are subscribed to the filter. */
    readonly subscriptions?: FilterSubscription[];
    /** A URL to view the filter results in Jira, using the ID of the filter. For example, *https://your-domain.atlassian.net/issues/?filter=10100*. */
    readonly viewUrl?: string;

    constructor(data?: IFilterDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).approximateLastUsed = _data["approximateLastUsed"] ? new Date(_data["approximateLastUsed"].toString()) : <any>undefined;
            this.description = _data["description"];
            if (Array.isArray(_data["editPermissions"])) {
                this.editPermissions = [] as any;
                for (let item of _data["editPermissions"])
                    this.editPermissions!.push(SharePermission.fromJS(item));
            }
            (<any>this).expand = _data["expand"];
            (<any>this).favourite = _data["favourite"];
            (<any>this).favouritedCount = _data["favouritedCount"];
            (<any>this).id = _data["id"];
            (<any>this).jql = _data["jql"];
            this.name = _data["name"];
            (<any>this).owner = _data["owner"] ? User.fromJS(_data["owner"]) : <any>undefined;
            (<any>this).searchUrl = _data["searchUrl"];
            (<any>this).self = _data["self"];
            if (Array.isArray(_data["sharePermissions"])) {
                this.sharePermissions = [] as any;
                for (let item of _data["sharePermissions"])
                    this.sharePermissions!.push(SharePermission.fromJS(item));
            }
            if (Array.isArray(_data["subscriptions"])) {
                (<any>this).subscriptions = [] as any;
                for (let item of _data["subscriptions"])
                    (<any>this).subscriptions!.push(FilterSubscription.fromJS(item));
            }
            (<any>this).viewUrl = _data["viewUrl"];
        }
    }

    static fromJS(data: any): FilterDetails {
        data = typeof data === 'object' ? data : {};
        let result = new FilterDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approximateLastUsed"] = this.approximateLastUsed ? this.approximateLastUsed.toISOString() : <any>undefined;
        data["description"] = this.description;
        if (Array.isArray(this.editPermissions)) {
            data["editPermissions"] = [];
            for (let item of this.editPermissions)
                data["editPermissions"].push(item.toJSON());
        }
        data["expand"] = this.expand;
        data["favourite"] = this.favourite;
        data["favouritedCount"] = this.favouritedCount;
        data["id"] = this.id;
        data["jql"] = this.jql;
        data["name"] = this.name;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["searchUrl"] = this.searchUrl;
        data["self"] = this.self;
        if (Array.isArray(this.sharePermissions)) {
            data["sharePermissions"] = [];
            for (let item of this.sharePermissions)
                data["sharePermissions"].push(item.toJSON());
        }
        if (Array.isArray(this.subscriptions)) {
            data["subscriptions"] = [];
            for (let item of this.subscriptions)
                data["subscriptions"].push(item.toJSON());
        }
        data["viewUrl"] = this.viewUrl;
        return data;
    }
}

/** Details of a filter. */
export interface IFilterDetails {
    /** \[Experimental\] Approximate last used time. Returns the date and time when the filter was last used. Returns `null` if the filter hasn't been used after tracking was enabled. For performance reasons, timestamps aren't updated in real time and therefore may not be exactly accurate. */
    approximateLastUsed?: Date;
    /** The description of the filter. */
    description?: string;
    /** The groups and projects that can edit the filter. This can be specified when updating a filter, but not when creating a filter. */
    editPermissions?: SharePermission[];
    /** Expand options that include additional filter details in the response. */
    expand?: string;
    /** Whether the filter is selected as a favorite by any users, not including the filter owner. */
    favourite?: boolean;
    /** The count of how many users have selected this filter as a favorite, including the filter owner. */
    favouritedCount?: number;
    /** The unique identifier for the filter. */
    id?: string;
    /** The JQL query for the filter. For example, *project = SSP AND issuetype = Bug*. */
    jql?: string;
    /** The name of the filter. */
    name: string;
    /** The user who owns the filter. Defaults to the creator of the filter, however, Jira administrators can change the owner of a shared filter in the admin settings. */
    owner?: User;
    /** A URL to view the filter results in Jira, using the [Search for issues using JQL](#api-rest-api-3-filter-search-get) operation with the filter's JQL string to return the filter results. For example, *https://your-domain.atlassian.net/rest/api/3/search?jql=project+%3D+SSP+AND+issuetype+%3D+Bug*. */
    searchUrl?: string;
    /** The URL of the filter. */
    self?: string;
    /** The groups and projects that the filter is shared with. This can be specified when updating a filter, but not when creating a filter. */
    sharePermissions?: SharePermission[];
    /** The users that are subscribed to the filter. */
    subscriptions?: FilterSubscription[];
    /** A URL to view the filter results in Jira, using the ID of the filter. For example, *https://your-domain.atlassian.net/issues/?filter=10100*. */
    viewUrl?: string;
}

/** Details of a user or group subscribing to a filter. */
export class FilterSubscription implements IFilterSubscription {
    /** The group subscribing to filter. */
    readonly group?: GroupName;
    /** The ID of the filter subscription. */
    readonly id?: number;
    /** The user subscribing to filter. */
    readonly user?: User;

    constructor(data?: IFilterSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).group = _data["group"] ? GroupName.fromJS(_data["group"]) : <any>undefined;
            (<any>this).id = _data["id"];
            (<any>this).user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FilterSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new FilterSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

/** Details of a user or group subscribing to a filter. */
export interface IFilterSubscription {
    /** The group subscribing to filter. */
    group?: GroupName;
    /** The ID of the filter subscription. */
    id?: number;
    /** The user subscribing to filter. */
    user?: User;
}

/** A paginated list of subscriptions to a filter. */
export class FilterSubscriptionsList implements IFilterSubscriptionsList {
    /** The index of the last item returned on the page. */
    readonly endIndex?: number;
    /** The list of items. */
    readonly items?: FilterSubscription[];
    /** The maximum number of results that could be on the page. */
    readonly maxResults?: number;
    /** The number of items on the page. */
    readonly size?: number;
    /** The index of the first item returned on the page. */
    readonly startIndex?: number;

    constructor(data?: IFilterSubscriptionsList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).endIndex = _data["end-index"];
            if (Array.isArray(_data["items"])) {
                (<any>this).items = [] as any;
                for (let item of _data["items"])
                    (<any>this).items!.push(FilterSubscription.fromJS(item));
            }
            (<any>this).maxResults = _data["max-results"];
            (<any>this).size = _data["size"];
            (<any>this).startIndex = _data["start-index"];
        }
    }

    static fromJS(data: any): FilterSubscriptionsList {
        data = typeof data === 'object' ? data : {};
        let result = new FilterSubscriptionsList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["end-index"] = this.endIndex;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["max-results"] = this.maxResults;
        data["size"] = this.size;
        data["start-index"] = this.startIndex;
        return data;
    }
}

/** A paginated list of subscriptions to a filter. */
export interface IFilterSubscriptionsList {
    /** The index of the last item returned on the page. */
    endIndex?: number;
    /** The list of items. */
    items?: FilterSubscription[];
    /** The maximum number of results that could be on the page. */
    maxResults?: number;
    /** The number of items on the page. */
    size?: number;
    /** The index of the first item returned on the page. */
    startIndex?: number;
}

/** A group found in a search. */
export class FoundGroup implements IFoundGroup {
    /** The ID of the group, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*. */
    groupId?: string;
    /** The group name with the matched query string highlighted with the HTML bold tag. */
    html?: string;
    labels?: GroupLabel[];
    /** The name of the group. The name of a group is mutable, to reliably identify a group use ``groupId`.` */
    name?: string;

    constructor(data?: IFoundGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.html = _data["html"];
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(GroupLabel.fromJS(item));
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): FoundGroup {
        data = typeof data === 'object' ? data : {};
        let result = new FoundGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["html"] = this.html;
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        data["name"] = this.name;
        return data;
    }
}

/** A group found in a search. */
export interface IFoundGroup {
    /** The ID of the group, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*. */
    groupId?: string;
    /** The group name with the matched query string highlighted with the HTML bold tag. */
    html?: string;
    labels?: GroupLabel[];
    /** The name of the group. The name of a group is mutable, to reliably identify a group use ``groupId`.` */
    name?: string;
}

/** The list of groups found in a search, including header text (Showing X of Y matching groups) and total of matched groups. */
export class FoundGroups implements IFoundGroups {
    groups?: FoundGroup[];
    /** Header text indicating the number of groups in the response and the total number of groups found in the search. */
    header?: string;
    /** The total number of groups found in the search. */
    total?: number;

    constructor(data?: IFoundGroups) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(FoundGroup.fromJS(item));
            }
            this.header = _data["header"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): FoundGroups {
        data = typeof data === 'object' ? data : {};
        let result = new FoundGroups();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        data["header"] = this.header;
        data["total"] = this.total;
        return data;
    }
}

/** The list of groups found in a search, including header text (Showing X of Y matching groups) and total of matched groups. */
export interface IFoundGroups {
    groups?: FoundGroup[];
    /** Header text indicating the number of groups in the response and the total number of groups found in the search. */
    header?: string;
    /** The total number of groups found in the search. */
    total?: number;
}

/** The list of users found in a search, including header text (Showing X of Y matching users) and total of matched users. */
export class FoundUsers implements IFoundUsers {
    /** Header text indicating the number of users in the response and the total number of users found in the search. */
    header?: string;
    /** The total number of users found in the search. */
    total?: number;
    users?: UserPickerUser[];

    constructor(data?: IFoundUsers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"];
            this.total = _data["total"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserPickerUser.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FoundUsers {
        data = typeof data === 'object' ? data : {};
        let result = new FoundUsers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header;
        data["total"] = this.total;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

/** The list of users found in a search, including header text (Showing X of Y matching users) and total of matched users. */
export interface IFoundUsers {
    /** Header text indicating the number of users in the response and the total number of users found in the search. */
    header?: string;
    /** The total number of users found in the search. */
    total?: number;
    users?: UserPickerUser[];
}

/** List of users and groups found in a search. */
export class FoundUsersAndGroups implements IFoundUsersAndGroups {
    groups?: FoundGroups;
    users?: FoundUsers;

    constructor(data?: IFoundUsersAndGroups) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groups = _data["groups"] ? FoundGroups.fromJS(_data["groups"]) : <any>undefined;
            this.users = _data["users"] ? FoundUsers.fromJS(_data["users"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FoundUsersAndGroups {
        data = typeof data === 'object' ? data : {};
        let result = new FoundUsersAndGroups();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groups"] = this.groups ? this.groups.toJSON() : <any>undefined;
        data["users"] = this.users ? this.users.toJSON() : <any>undefined;
        return data;
    }
}

/** List of users and groups found in a search. */
export interface IFoundUsersAndGroups {
    groups?: FoundGroups;
    users?: FoundUsers;
}

/** The payload for the layout details for the start end of a transition */
export class FromLayoutPayload implements IFromLayoutPayload {
    /** The port that the transition can be made from */
    fromPort?: number;
    status?: ProjectCreateResourceIdentifier;
    /** The port that the transition goes to */
    toPortOverride?: number;

    constructor(data?: IFromLayoutPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fromPort = _data["fromPort"];
            this.status = _data["status"] ? ProjectCreateResourceIdentifier.fromJS(_data["status"]) : <any>undefined;
            this.toPortOverride = _data["toPortOverride"];
        }
    }

    static fromJS(data: any): FromLayoutPayload {
        data = typeof data === 'object' ? data : {};
        let result = new FromLayoutPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromPort"] = this.fromPort;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["toPortOverride"] = this.toPortOverride;
        return data;
    }
}

/** The payload for the layout details for the start end of a transition */
export interface IFromLayoutPayload {
    /** The port that the transition can be made from */
    fromPort?: number;
    status?: ProjectCreateResourceIdentifier;
    /** The port that the transition goes to */
    toPortOverride?: number;
}

/** An operand that is a function. See [Advanced searching - functions reference](https://confluence.atlassian.com/x/dwiiLQ) for more information about JQL functions. */
export class FunctionOperand implements IFunctionOperand {
    /** The list of function arguments. */
    arguments!: string[];
    /** Encoded operand, which can be used directly in a JQL query. */
    encodedOperand?: string;
    /** The name of the function. */
    function!: string;

    [key: string]: any;

    constructor(data?: IFunctionOperand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.arguments = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["arguments"])) {
                this.arguments = [] as any;
                for (let item of _data["arguments"])
                    this.arguments!.push(item);
            }
            this.encodedOperand = _data["encodedOperand"];
            this.function = _data["function"];
        }
    }

    static fromJS(data: any): FunctionOperand {
        data = typeof data === 'object' ? data : {};
        let result = new FunctionOperand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.arguments)) {
            data["arguments"] = [];
            for (let item of this.arguments)
                data["arguments"].push(item);
        }
        data["encodedOperand"] = this.encodedOperand;
        data["function"] = this.function;
        return data;
    }
}

/** An operand that is a function. See [Advanced searching - functions reference](https://confluence.atlassian.com/x/dwiiLQ) for more information about JQL functions. */
export interface IFunctionOperand {
    /** The list of function arguments. */
    arguments: string[];
    /** Encoded operand, which can be used directly in a JQL query. */
    encodedOperand?: string;
    /** The name of the function. */
    function: string;

    [key: string]: any;
}

/** Details of functions that can be used in advanced searches. */
export class FunctionReferenceData implements IFunctionReferenceData {
    /** The display name of the function. */
    displayName?: string;
    /** Whether the function can take a list of arguments. */
    isList?: FunctionReferenceDataIsList;
    /** Whether the function supports both single and list value operators. */
    supportsListAndSingleValueOperators?: FunctionReferenceDataSupportsListAndSingleValueOperators;
    /** The data types returned by the function. */
    types?: string[];
    /** The function identifier. */
    value?: string;

    constructor(data?: IFunctionReferenceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.isList = _data["isList"];
            this.supportsListAndSingleValueOperators = _data["supportsListAndSingleValueOperators"];
            if (Array.isArray(_data["types"])) {
                this.types = [] as any;
                for (let item of _data["types"])
                    this.types!.push(item);
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): FunctionReferenceData {
        data = typeof data === 'object' ? data : {};
        let result = new FunctionReferenceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["isList"] = this.isList;
        data["supportsListAndSingleValueOperators"] = this.supportsListAndSingleValueOperators;
        if (Array.isArray(this.types)) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["value"] = this.value;
        return data;
    }
}

/** Details of functions that can be used in advanced searches. */
export interface IFunctionReferenceData {
    /** The display name of the function. */
    displayName?: string;
    /** Whether the function can take a list of arguments. */
    isList?: FunctionReferenceDataIsList;
    /** Whether the function supports both single and list value operators. */
    supportsListAndSingleValueOperators?: FunctionReferenceDataSupportsListAndSingleValueOperators;
    /** The data types returned by the function. */
    types?: string[];
    /** The function identifier. */
    value?: string;
}

export class GetAtlassianTeamResponse implements IGetAtlassianTeamResponse {
    /** The capacity for the Atlassian team. */
    capacity?: number;
    /** The Atlassian team ID. */
    id!: string;
    /** The ID of the issue source for the Atlassian team. */
    issueSourceId?: number;
    /** The planning style for the Atlassian team. This is "Scrum" or "Kanban". */
    planningStyle!: GetAtlassianTeamResponsePlanningStyle;
    /** The sprint length for the Atlassian team. */
    sprintLength?: number;

    constructor(data?: IGetAtlassianTeamResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.capacity = _data["capacity"];
            this.id = _data["id"];
            this.issueSourceId = _data["issueSourceId"];
            this.planningStyle = _data["planningStyle"];
            this.sprintLength = _data["sprintLength"];
        }
    }

    static fromJS(data: any): GetAtlassianTeamResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetAtlassianTeamResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["capacity"] = this.capacity;
        data["id"] = this.id;
        data["issueSourceId"] = this.issueSourceId;
        data["planningStyle"] = this.planningStyle;
        data["sprintLength"] = this.sprintLength;
        return data;
    }
}

export interface IGetAtlassianTeamResponse {
    /** The capacity for the Atlassian team. */
    capacity?: number;
    /** The Atlassian team ID. */
    id: string;
    /** The ID of the issue source for the Atlassian team. */
    issueSourceId?: number;
    /** The planning style for the Atlassian team. This is "Scrum" or "Kanban". */
    planningStyle: GetAtlassianTeamResponsePlanningStyle;
    /** The sprint length for the Atlassian team. */
    sprintLength?: number;
}

export class GetCrossProjectReleaseResponse implements IGetCrossProjectReleaseResponse {
    /** The cross-project release name. */
    name?: string;
    /** The IDs of the releases included in the cross-project release. */
    releaseIds?: number[];

    constructor(data?: IGetCrossProjectReleaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["releaseIds"])) {
                this.releaseIds = [] as any;
                for (let item of _data["releaseIds"])
                    this.releaseIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GetCrossProjectReleaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetCrossProjectReleaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.releaseIds)) {
            data["releaseIds"] = [];
            for (let item of this.releaseIds)
                data["releaseIds"].push(item);
        }
        return data;
    }
}

export interface IGetCrossProjectReleaseResponse {
    /** The cross-project release name. */
    name?: string;
    /** The IDs of the releases included in the cross-project release. */
    releaseIds?: number[];
}

export class GetCustomFieldResponse implements IGetCustomFieldResponse {
    /** The custom field ID. */
    customFieldId!: number;
    /** Allows filtering issues based on their values for the custom field. */
    filter?: boolean;

    constructor(data?: IGetCustomFieldResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customFieldId = _data["customFieldId"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): GetCustomFieldResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomFieldResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customFieldId"] = this.customFieldId;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IGetCustomFieldResponse {
    /** The custom field ID. */
    customFieldId: number;
    /** Allows filtering issues based on their values for the custom field. */
    filter?: boolean;
}

export class GetDateFieldResponse implements IGetDateFieldResponse {
    /** A date custom field ID. This is returned if the type is "DateCustomField". */
    dateCustomFieldId?: number;
    /** The date field type. This is "DueDate", "TargetStartDate", "TargetEndDate" or "DateCustomField". */
    type!: GetDateFieldResponseType;

    constructor(data?: IGetDateFieldResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateCustomFieldId = _data["dateCustomFieldId"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): GetDateFieldResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetDateFieldResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateCustomFieldId"] = this.dateCustomFieldId;
        data["type"] = this.type;
        return data;
    }
}

export interface IGetDateFieldResponse {
    /** A date custom field ID. This is returned if the type is "DateCustomField". */
    dateCustomFieldId?: number;
    /** The date field type. This is "DueDate", "TargetStartDate", "TargetEndDate" or "DateCustomField". */
    type: GetDateFieldResponseType;
}

export class GetExclusionRulesResponse implements IGetExclusionRulesResponse {
    /** The IDs of the issues excluded from the plan. */
    issueIds?: number[];
    /** The IDs of the issue types excluded from the plan. */
    issueTypeIds?: number[];
    /** Issues completed this number of days ago are excluded from the plan. */
    numberOfDaysToShowCompletedIssues!: number;
    /** The IDs of the releases excluded from the plan. */
    releaseIds?: number[];
    /** The IDs of the work status categories excluded from the plan. */
    workStatusCategoryIds?: number[];
    /** The IDs of the work statuses excluded from the plan. */
    workStatusIds?: number[];

    constructor(data?: IGetExclusionRulesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueIds"])) {
                this.issueIds = [] as any;
                for (let item of _data["issueIds"])
                    this.issueIds!.push(item);
            }
            if (Array.isArray(_data["issueTypeIds"])) {
                this.issueTypeIds = [] as any;
                for (let item of _data["issueTypeIds"])
                    this.issueTypeIds!.push(item);
            }
            this.numberOfDaysToShowCompletedIssues = _data["numberOfDaysToShowCompletedIssues"];
            if (Array.isArray(_data["releaseIds"])) {
                this.releaseIds = [] as any;
                for (let item of _data["releaseIds"])
                    this.releaseIds!.push(item);
            }
            if (Array.isArray(_data["workStatusCategoryIds"])) {
                this.workStatusCategoryIds = [] as any;
                for (let item of _data["workStatusCategoryIds"])
                    this.workStatusCategoryIds!.push(item);
            }
            if (Array.isArray(_data["workStatusIds"])) {
                this.workStatusIds = [] as any;
                for (let item of _data["workStatusIds"])
                    this.workStatusIds!.push(item);
            }
        }
    }

    static fromJS(data: any): GetExclusionRulesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetExclusionRulesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueIds)) {
            data["issueIds"] = [];
            for (let item of this.issueIds)
                data["issueIds"].push(item);
        }
        if (Array.isArray(this.issueTypeIds)) {
            data["issueTypeIds"] = [];
            for (let item of this.issueTypeIds)
                data["issueTypeIds"].push(item);
        }
        data["numberOfDaysToShowCompletedIssues"] = this.numberOfDaysToShowCompletedIssues;
        if (Array.isArray(this.releaseIds)) {
            data["releaseIds"] = [];
            for (let item of this.releaseIds)
                data["releaseIds"].push(item);
        }
        if (Array.isArray(this.workStatusCategoryIds)) {
            data["workStatusCategoryIds"] = [];
            for (let item of this.workStatusCategoryIds)
                data["workStatusCategoryIds"].push(item);
        }
        if (Array.isArray(this.workStatusIds)) {
            data["workStatusIds"] = [];
            for (let item of this.workStatusIds)
                data["workStatusIds"].push(item);
        }
        return data;
    }
}

export interface IGetExclusionRulesResponse {
    /** The IDs of the issues excluded from the plan. */
    issueIds?: number[];
    /** The IDs of the issue types excluded from the plan. */
    issueTypeIds?: number[];
    /** Issues completed this number of days ago are excluded from the plan. */
    numberOfDaysToShowCompletedIssues: number;
    /** The IDs of the releases excluded from the plan. */
    releaseIds?: number[];
    /** The IDs of the work status categories excluded from the plan. */
    workStatusCategoryIds?: number[];
    /** The IDs of the work statuses excluded from the plan. */
    workStatusIds?: number[];
}

export class GetIssueSourceResponse implements IGetIssueSourceResponse {
    /** The issue source type. This is "Board", "Project" or "Filter". */
    type!: GetIssueSourceResponseType;
    /** The issue source value. This is a board ID if the type is "Board", a project ID if the type is "Project" or a filter ID if the type is "Filter". */
    value!: number;

    constructor(data?: IGetIssueSourceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): GetIssueSourceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetIssueSourceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

export interface IGetIssueSourceResponse {
    /** The issue source type. This is "Board", "Project" or "Filter". */
    type: GetIssueSourceResponseType;
    /** The issue source value. This is a board ID if the type is "Board", a project ID if the type is "Project" or a filter ID if the type is "Filter". */
    value: number;
}

export class GetPermissionHolderResponse implements IGetPermissionHolderResponse {
    /** The permission holder type. This is "Group" or "AccountId". */
    type!: GetPermissionHolderResponseType;
    /** The permission holder value. This is a group name if the type is "Group" or an account ID if the type is "AccountId". */
    value!: string;

    constructor(data?: IGetPermissionHolderResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): GetPermissionHolderResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPermissionHolderResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

export interface IGetPermissionHolderResponse {
    /** The permission holder type. This is "Group" or "AccountId". */
    type: GetPermissionHolderResponseType;
    /** The permission holder value. This is a group name if the type is "Group" or an account ID if the type is "AccountId". */
    value: string;
}

export class GetPermissionResponse implements IGetPermissionResponse {
    /** The permission holder. */
    holder!: GetPermissionHolderResponse;
    /** The permission type. This is "View" or "Edit". */
    type!: GetPermissionResponseType;

    constructor(data?: IGetPermissionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.holder = new GetPermissionHolderResponse();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.holder = _data["holder"] ? GetPermissionHolderResponse.fromJS(_data["holder"]) : new GetPermissionHolderResponse();
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): GetPermissionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPermissionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holder"] = this.holder ? this.holder.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

export interface IGetPermissionResponse {
    /** The permission holder. */
    holder: GetPermissionHolderResponse;
    /** The permission type. This is "View" or "Edit". */
    type: GetPermissionResponseType;
}

export class GetPlanOnlyTeamResponse implements IGetPlanOnlyTeamResponse {
    /** The capacity for the plan-only team. */
    capacity?: number;
    /** The plan-only team ID. */
    id!: number;
    /** The ID of the issue source for the plan-only team. */
    issueSourceId?: number;
    /** The account IDs of the plan-only team members. */
    memberAccountIds?: string[];
    /** The plan-only team name. */
    name!: string;
    /** The planning style for the plan-only team. This is "Scrum" or "Kanban". */
    planningStyle!: GetPlanOnlyTeamResponsePlanningStyle;
    /** The sprint length for the plan-only team. */
    sprintLength?: number;

    constructor(data?: IGetPlanOnlyTeamResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.capacity = _data["capacity"];
            this.id = _data["id"];
            this.issueSourceId = _data["issueSourceId"];
            if (Array.isArray(_data["memberAccountIds"])) {
                this.memberAccountIds = [] as any;
                for (let item of _data["memberAccountIds"])
                    this.memberAccountIds!.push(item);
            }
            this.name = _data["name"];
            this.planningStyle = _data["planningStyle"];
            this.sprintLength = _data["sprintLength"];
        }
    }

    static fromJS(data: any): GetPlanOnlyTeamResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPlanOnlyTeamResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["capacity"] = this.capacity;
        data["id"] = this.id;
        data["issueSourceId"] = this.issueSourceId;
        if (Array.isArray(this.memberAccountIds)) {
            data["memberAccountIds"] = [];
            for (let item of this.memberAccountIds)
                data["memberAccountIds"].push(item);
        }
        data["name"] = this.name;
        data["planningStyle"] = this.planningStyle;
        data["sprintLength"] = this.sprintLength;
        return data;
    }
}

export interface IGetPlanOnlyTeamResponse {
    /** The capacity for the plan-only team. */
    capacity?: number;
    /** The plan-only team ID. */
    id: number;
    /** The ID of the issue source for the plan-only team. */
    issueSourceId?: number;
    /** The account IDs of the plan-only team members. */
    memberAccountIds?: string[];
    /** The plan-only team name. */
    name: string;
    /** The planning style for the plan-only team. This is "Scrum" or "Kanban". */
    planningStyle: GetPlanOnlyTeamResponsePlanningStyle;
    /** The sprint length for the plan-only team. */
    sprintLength?: number;
}

export class GetPlanResponse implements IGetPlanResponse {
    /** The cross-project releases included in the plan. */
    crossProjectReleases?: GetCrossProjectReleaseResponse[];
    /** The custom fields for the plan. */
    customFields?: GetCustomFieldResponse[];
    /** The exclusion rules for the plan. */
    exclusionRules?: GetExclusionRulesResponse;
    /** The plan ID. */
    id!: number;
    /** The issue sources included in the plan. */
    issueSources?: GetIssueSourceResponse[];
    /** The date when the plan was last saved in UTC. */
    lastSaved?: string;
    /** The account ID of the plan lead. */
    leadAccountId?: string;
    /** The plan name. */
    name?: string;
    /** The permissions for the plan. */
    permissions?: GetPermissionResponse[];
    /** The scheduling settings for the plan. */
    scheduling!: GetSchedulingResponse;
    /** The plan status. This is "Active", "Trashed" or "Archived". */
    status!: GetPlanResponseStatus;

    constructor(data?: IGetPlanResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.scheduling = new GetSchedulingResponse();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["crossProjectReleases"])) {
                this.crossProjectReleases = [] as any;
                for (let item of _data["crossProjectReleases"])
                    this.crossProjectReleases!.push(GetCrossProjectReleaseResponse.fromJS(item));
            }
            if (Array.isArray(_data["customFields"])) {
                this.customFields = [] as any;
                for (let item of _data["customFields"])
                    this.customFields!.push(GetCustomFieldResponse.fromJS(item));
            }
            this.exclusionRules = _data["exclusionRules"] ? GetExclusionRulesResponse.fromJS(_data["exclusionRules"]) : <any>undefined;
            this.id = _data["id"];
            if (Array.isArray(_data["issueSources"])) {
                this.issueSources = [] as any;
                for (let item of _data["issueSources"])
                    this.issueSources!.push(GetIssueSourceResponse.fromJS(item));
            }
            this.lastSaved = _data["lastSaved"];
            this.leadAccountId = _data["leadAccountId"];
            this.name = _data["name"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(GetPermissionResponse.fromJS(item));
            }
            this.scheduling = _data["scheduling"] ? GetSchedulingResponse.fromJS(_data["scheduling"]) : new GetSchedulingResponse();
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): GetPlanResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPlanResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.crossProjectReleases)) {
            data["crossProjectReleases"] = [];
            for (let item of this.crossProjectReleases)
                data["crossProjectReleases"].push(item.toJSON());
        }
        if (Array.isArray(this.customFields)) {
            data["customFields"] = [];
            for (let item of this.customFields)
                data["customFields"].push(item.toJSON());
        }
        data["exclusionRules"] = this.exclusionRules ? this.exclusionRules.toJSON() : <any>undefined;
        data["id"] = this.id;
        if (Array.isArray(this.issueSources)) {
            data["issueSources"] = [];
            for (let item of this.issueSources)
                data["issueSources"].push(item.toJSON());
        }
        data["lastSaved"] = this.lastSaved;
        data["leadAccountId"] = this.leadAccountId;
        data["name"] = this.name;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        data["scheduling"] = this.scheduling ? this.scheduling.toJSON() : <any>undefined;
        data["status"] = this.status;
        return data;
    }
}

export interface IGetPlanResponse {
    /** The cross-project releases included in the plan. */
    crossProjectReleases?: GetCrossProjectReleaseResponse[];
    /** The custom fields for the plan. */
    customFields?: GetCustomFieldResponse[];
    /** The exclusion rules for the plan. */
    exclusionRules?: GetExclusionRulesResponse;
    /** The plan ID. */
    id: number;
    /** The issue sources included in the plan. */
    issueSources?: GetIssueSourceResponse[];
    /** The date when the plan was last saved in UTC. */
    lastSaved?: string;
    /** The account ID of the plan lead. */
    leadAccountId?: string;
    /** The plan name. */
    name?: string;
    /** The permissions for the plan. */
    permissions?: GetPermissionResponse[];
    /** The scheduling settings for the plan. */
    scheduling: GetSchedulingResponse;
    /** The plan status. This is "Active", "Trashed" or "Archived". */
    status: GetPlanResponseStatus;
}

export class GetPlanResponseForPage implements IGetPlanResponseForPage {
    /** The plan ID. */
    id!: string;
    /** The issue sources included in the plan. */
    issueSources?: GetIssueSourceResponse[];
    /** The plan name. */
    name!: string;
    /** Default scenario ID. */
    scenarioId!: string;
    /** The plan status. This is "Active", "Trashed" or "Archived". */
    status!: GetPlanResponseForPageStatus;

    constructor(data?: IGetPlanResponseForPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["issueSources"])) {
                this.issueSources = [] as any;
                for (let item of _data["issueSources"])
                    this.issueSources!.push(GetIssueSourceResponse.fromJS(item));
            }
            this.name = _data["name"];
            this.scenarioId = _data["scenarioId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): GetPlanResponseForPage {
        data = typeof data === 'object' ? data : {};
        let result = new GetPlanResponseForPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.issueSources)) {
            data["issueSources"] = [];
            for (let item of this.issueSources)
                data["issueSources"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["scenarioId"] = this.scenarioId;
        data["status"] = this.status;
        return data;
    }
}

export interface IGetPlanResponseForPage {
    /** The plan ID. */
    id: string;
    /** The issue sources included in the plan. */
    issueSources?: GetIssueSourceResponse[];
    /** The plan name. */
    name: string;
    /** Default scenario ID. */
    scenarioId: string;
    /** The plan status. This is "Active", "Trashed" or "Archived". */
    status: GetPlanResponseForPageStatus;
}

export class GetSchedulingResponse implements IGetSchedulingResponse {
    /** The dependencies for the plan. This is "Sequential" or "Concurrent". */
    dependencies!: GetSchedulingResponseDependencies;
    /** The end date field for the plan. */
    endDate!: GetDateFieldResponse;
    /** The estimation unit for the plan. This is "StoryPoints", "Days" or "Hours". */
    estimation!: GetSchedulingResponseEstimation;
    /** The inferred dates for the plan. This is "None", "SprintDates" or "ReleaseDates". */
    inferredDates!: GetSchedulingResponseInferredDates;
    /** The start date field for the plan. */
    startDate!: GetDateFieldResponse;

    constructor(data?: IGetSchedulingResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.endDate = new GetDateFieldResponse();
            this.startDate = new GetDateFieldResponse();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dependencies = _data["dependencies"];
            this.endDate = _data["endDate"] ? GetDateFieldResponse.fromJS(_data["endDate"]) : new GetDateFieldResponse();
            this.estimation = _data["estimation"];
            this.inferredDates = _data["inferredDates"];
            this.startDate = _data["startDate"] ? GetDateFieldResponse.fromJS(_data["startDate"]) : new GetDateFieldResponse();
        }
    }

    static fromJS(data: any): GetSchedulingResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetSchedulingResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dependencies"] = this.dependencies;
        data["endDate"] = this.endDate ? this.endDate.toJSON() : <any>undefined;
        data["estimation"] = this.estimation;
        data["inferredDates"] = this.inferredDates;
        data["startDate"] = this.startDate ? this.startDate.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetSchedulingResponse {
    /** The dependencies for the plan. This is "Sequential" or "Concurrent". */
    dependencies: GetSchedulingResponseDependencies;
    /** The end date field for the plan. */
    endDate: GetDateFieldResponse;
    /** The estimation unit for the plan. This is "StoryPoints", "Days" or "Hours". */
    estimation: GetSchedulingResponseEstimation;
    /** The inferred dates for the plan. This is "None", "SprintDates" or "ReleaseDates". */
    inferredDates: GetSchedulingResponseInferredDates;
    /** The start date field for the plan. */
    startDate: GetDateFieldResponse;
}

export class GetTeamResponseForPage implements IGetTeamResponseForPage {
    /** The team ID. */
    id!: string;
    /** The team name. This is returned if the type is "PlanOnly". */
    name?: string;
    /** The team type. This is "PlanOnly" or "Atlassian". */
    type!: GetTeamResponseForPageType;

    constructor(data?: IGetTeamResponseForPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): GetTeamResponseForPage {
        data = typeof data === 'object' ? data : {};
        let result = new GetTeamResponseForPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

export interface IGetTeamResponseForPage {
    /** The team ID. */
    id: string;
    /** The team name. This is returned if the type is "PlanOnly". */
    name?: string;
    /** The team type. This is "PlanOnly" or "Atlassian". */
    type: GetTeamResponseForPageType;
}

export class GlobalScopeBean implements IGlobalScopeBean {
    /** Defines the behavior of the option in the global context.If notSelectable is set, the option cannot be set as the field's value. This is useful for archiving an option that has previously been selected but shouldn't be used anymore.If defaultValue is set, the option is selected by default. */
    attributes?: Attributes[];

    constructor(data?: IGlobalScopeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(item);
            }
        }
    }

    static fromJS(data: any): GlobalScopeBean {
        data = typeof data === 'object' ? data : {};
        let result = new GlobalScopeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item);
        }
        return data;
    }
}

export interface IGlobalScopeBean {
    /** Defines the behavior of the option in the global context.If notSelectable is set, the option cannot be set as the field's value. This is useful for archiving an option that has previously been selected but shouldn't be used anymore.If defaultValue is set, the option is selected by default. */
    attributes?: Attributes[];
}

export class Group implements IGroup {
    /** Expand options that include additional group details in the response. */
    readonly expand?: string;
    /** The ID of the group, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*. */
    groupId?: string | undefined;
    /** The name of group. */
    name?: string;
    /** The URL for these group details. */
    readonly self?: string;
    /** A paginated list of the users that are members of the group. A maximum of 50 users is returned in the list, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 50 users, use`?expand=users[51:100]`. */
    readonly users?: PagedListUserDetailsApplicationUser;

    constructor(data?: IGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).expand = _data["expand"];
            this.groupId = _data["groupId"];
            this.name = _data["name"];
            (<any>this).self = _data["self"];
            (<any>this).users = _data["users"] ? PagedListUserDetailsApplicationUser.fromJS(_data["users"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Group {
        data = typeof data === 'object' ? data : {};
        let result = new Group();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expand"] = this.expand;
        data["groupId"] = this.groupId;
        data["name"] = this.name;
        data["self"] = this.self;
        data["users"] = this.users ? this.users.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGroup {
    /** Expand options that include additional group details in the response. */
    expand?: string;
    /** The ID of the group, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*. */
    groupId?: string | undefined;
    /** The name of group. */
    name?: string;
    /** The URL for these group details. */
    self?: string;
    /** A paginated list of the users that are members of the group. A maximum of 50 users is returned in the list, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 50 users, use`?expand=users[51:100]`. */
    users?: PagedListUserDetailsApplicationUser;
}

/** Details about a group. */
export class GroupDetails implements IGroupDetails {
    /** The ID of the group, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*. */
    groupId?: string | undefined;
    /** The name of the group. */
    name?: string;

    constructor(data?: IGroupDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GroupDetails {
        data = typeof data === 'object' ? data : {};
        let result = new GroupDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["name"] = this.name;
        return data;
    }
}

/** Details about a group. */
export interface IGroupDetails {
    /** The ID of the group, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*. */
    groupId?: string | undefined;
    /** The name of the group. */
    name?: string;
}

/** A group label. */
export class GroupLabel implements IGroupLabel {
    /** The group label name. */
    text?: string;
    /** The title of the group label. */
    title?: string;
    /** The type of the group label. */
    type?: GroupLabelType;

    constructor(data?: IGroupLabel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.title = _data["title"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): GroupLabel {
        data = typeof data === 'object' ? data : {};
        let result = new GroupLabel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["title"] = this.title;
        data["type"] = this.type;
        return data;
    }
}

/** A group label. */
export interface IGroupLabel {
    /** The group label name. */
    text?: string;
    /** The title of the group label. */
    title?: string;
    /** The type of the group label. */
    type?: GroupLabelType;
}

/** Details about a group. */
export class GroupName implements IGroupName {
    /** The ID of the group, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*. */
    groupId?: string | undefined;
    /** The name of group. */
    name?: string;
    /** The URL for these group details. */
    readonly self?: string;

    constructor(data?: IGroupName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupId = _data["groupId"];
            this.name = _data["name"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): GroupName {
        data = typeof data === 'object' ? data : {};
        let result = new GroupName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

/** Details about a group. */
export interface IGroupName {
    /** The ID of the group, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*. */
    groupId?: string | undefined;
    /** The name of group. */
    name?: string;
    /** The URL for these group details. */
    self?: string;
}

/** Jira instance health check results. Deprecated and no longer returned. */
export class HealthCheckResult implements IHealthCheckResult {
    /** The description of the Jira health check item. */
    description?: string;
    /** The name of the Jira health check item. */
    name?: string;
    /** Whether the Jira health check item passed or failed. */
    passed?: boolean;

    constructor(data?: IHealthCheckResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
            this.passed = _data["passed"];
        }
    }

    static fromJS(data: any): HealthCheckResult {
        data = typeof data === 'object' ? data : {};
        let result = new HealthCheckResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        data["passed"] = this.passed;
        return data;
    }
}

/** Jira instance health check results. Deprecated and no longer returned. */
export interface IHealthCheckResult {
    /** The description of the Jira health check item. */
    description?: string;
    /** The name of the Jira health check item. */
    name?: string;
    /** Whether the Jira health check item passed or failed. */
    passed?: boolean;
}

/** The project issue type hierarchy. */
export class Hierarchy implements IHierarchy {
    /** The ID of the base level. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/). */
    baseLevelId?: number;
    /** Details about the hierarchy level. */
    readonly levels?: SimplifiedHierarchyLevel[];

    constructor(data?: IHierarchy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseLevelId = _data["baseLevelId"];
            if (Array.isArray(_data["levels"])) {
                (<any>this).levels = [] as any;
                for (let item of _data["levels"])
                    (<any>this).levels!.push(SimplifiedHierarchyLevel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Hierarchy {
        data = typeof data === 'object' ? data : {};
        let result = new Hierarchy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseLevelId"] = this.baseLevelId;
        if (Array.isArray(this.levels)) {
            data["levels"] = [];
            for (let item of this.levels)
                data["levels"].push(item.toJSON());
        }
        return data;
    }
}

/** The project issue type hierarchy. */
export interface IHierarchy {
    /** The ID of the base level. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/). */
    baseLevelId?: number;
    /** Details about the hierarchy level. */
    levels?: SimplifiedHierarchyLevel[];
}

/** Details of issue history metadata. */
export class HistoryMetadata implements IHistoryMetadata {
    /** The activity described in the history record. */
    activityDescription?: string;
    /** The key of the activity described in the history record. */
    activityDescriptionKey?: string;
    /** Details of the user whose action created the history record. */
    actor?: HistoryMetadataParticipant;
    /** Details of the cause that triggered the creation the history record. */
    cause?: HistoryMetadataParticipant;
    /** The description of the history record. */
    description?: string;
    /** The description key of the history record. */
    descriptionKey?: string;
    /** The description of the email address associated the history record. */
    emailDescription?: string;
    /** The description key of the email address associated the history record. */
    emailDescriptionKey?: string;
    /** Additional arbitrary information about the history record. */
    extraData?: { [key: string]: string; };
    /** Details of the system that generated the history record. */
    generator?: HistoryMetadataParticipant;
    /** The type of the history record. */
    type?: string;

    [key: string]: any;

    constructor(data?: IHistoryMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.activityDescription = _data["activityDescription"];
            this.activityDescriptionKey = _data["activityDescriptionKey"];
            this.actor = _data["actor"] ? HistoryMetadataParticipant.fromJS(_data["actor"]) : <any>undefined;
            this.cause = _data["cause"] ? HistoryMetadataParticipant.fromJS(_data["cause"]) : <any>undefined;
            this.description = _data["description"];
            this.descriptionKey = _data["descriptionKey"];
            this.emailDescription = _data["emailDescription"];
            this.emailDescriptionKey = _data["emailDescriptionKey"];
            if (_data["extraData"]) {
                this.extraData = {} as any;
                for (let key in _data["extraData"]) {
                    if (_data["extraData"].hasOwnProperty(key))
                        (<any>this.extraData)![key] = _data["extraData"][key];
                }
            }
            this.generator = _data["generator"] ? HistoryMetadataParticipant.fromJS(_data["generator"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): HistoryMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new HistoryMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["activityDescription"] = this.activityDescription;
        data["activityDescriptionKey"] = this.activityDescriptionKey;
        data["actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        data["cause"] = this.cause ? this.cause.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["descriptionKey"] = this.descriptionKey;
        data["emailDescription"] = this.emailDescription;
        data["emailDescriptionKey"] = this.emailDescriptionKey;
        if (this.extraData) {
            data["extraData"] = {};
            for (let key in this.extraData) {
                if (this.extraData.hasOwnProperty(key))
                    (<any>data["extraData"])[key] = (<any>this.extraData)[key];
            }
        }
        data["generator"] = this.generator ? this.generator.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

/** Details of issue history metadata. */
export interface IHistoryMetadata {
    /** The activity described in the history record. */
    activityDescription?: string;
    /** The key of the activity described in the history record. */
    activityDescriptionKey?: string;
    /** Details of the user whose action created the history record. */
    actor?: HistoryMetadataParticipant;
    /** Details of the cause that triggered the creation the history record. */
    cause?: HistoryMetadataParticipant;
    /** The description of the history record. */
    description?: string;
    /** The description key of the history record. */
    descriptionKey?: string;
    /** The description of the email address associated the history record. */
    emailDescription?: string;
    /** The description key of the email address associated the history record. */
    emailDescriptionKey?: string;
    /** Additional arbitrary information about the history record. */
    extraData?: { [key: string]: string; };
    /** Details of the system that generated the history record. */
    generator?: HistoryMetadataParticipant;
    /** The type of the history record. */
    type?: string;

    [key: string]: any;
}

/** Details of user or system associated with a issue history metadata item. */
export class HistoryMetadataParticipant implements IHistoryMetadataParticipant {
    /** The URL to an avatar for the user or system associated with a history record. */
    avatarUrl?: string;
    /** The display name of the user or system associated with a history record. */
    displayName?: string;
    /** The key of the display name of the user or system associated with a history record. */
    displayNameKey?: string;
    /** The ID of the user or system associated with a history record. */
    id?: string;
    /** The type of the user or system associated with a history record. */
    type?: string;
    /** The URL of the user or system associated with a history record. */
    url?: string;

    [key: string]: any;

    constructor(data?: IHistoryMetadataParticipant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.avatarUrl = _data["avatarUrl"];
            this.displayName = _data["displayName"];
            this.displayNameKey = _data["displayNameKey"];
            this.id = _data["id"];
            this.type = _data["type"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): HistoryMetadataParticipant {
        data = typeof data === 'object' ? data : {};
        let result = new HistoryMetadataParticipant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["avatarUrl"] = this.avatarUrl;
        data["displayName"] = this.displayName;
        data["displayNameKey"] = this.displayNameKey;
        data["id"] = this.id;
        data["type"] = this.type;
        data["url"] = this.url;
        return data;
    }
}

/** Details of user or system associated with a issue history metadata item. */
export interface IHistoryMetadataParticipant {
    /** The URL to an avatar for the user or system associated with a history record. */
    avatarUrl?: string;
    /** The display name of the user or system associated with a history record. */
    displayName?: string;
    /** The key of the display name of the user or system associated with a history record. */
    displayNameKey?: string;
    /** The ID of the user or system associated with a history record. */
    id?: string;
    /** The type of the user or system associated with a history record. */
    type?: string;
    /** The URL of the user or system associated with a history record. */
    url?: string;

    [key: string]: any;
}

/** An icon. If no icon is defined: *  for a status icon, no status icon displays in Jira. *  for the remote object icon, the default link icon displays in Jira. */
export class Icon implements IIcon {
    /** The URL of the tooltip, used only for a status icon. If not set, the status icon in Jira is not clickable. */
    link?: string;
    /** The title of the icon. This is used as follows:

 *  For a status icon it is used as a tooltip on the icon. If not set, the status icon doesn't display a tooltip in Jira.
 *  For the remote object icon it is used in conjunction with the application name to display a tooltip for the link's icon. The tooltip takes the format "\[application name\] icon title". Blank itemsare excluded from the tooltip title. If both items are blank, the icon tooltop displays as "Web Link". */
    title?: string;
    /** The URL of an icon that displays at 16x16 pixel in Jira. */
    url16x16?: string;

    [key: string]: any;

    constructor(data?: IIcon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.link = _data["link"];
            this.title = _data["title"];
            this.url16x16 = _data["url16x16"];
        }
    }

    static fromJS(data: any): Icon {
        data = typeof data === 'object' ? data : {};
        let result = new Icon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["link"] = this.link;
        data["title"] = this.title;
        data["url16x16"] = this.url16x16;
        return data;
    }
}

/** An icon. If no icon is defined: *  for a status icon, no status icon displays in Jira. *  for the remote object icon, the default link icon displays in Jira. */
export interface IIcon {
    /** The URL of the tooltip, used only for a status icon. If not set, the status icon in Jira is not clickable. */
    link?: string;
    /** The title of the icon. This is used as follows:

 *  For a status icon it is used as a tooltip on the icon. If not set, the status icon doesn't display a tooltip in Jira.
 *  For the remote object icon it is used in conjunction with the application name to display a tooltip for the link's icon. The tooltip takes the format "\[application name\] icon title". Blank itemsare excluded from the tooltip title. If both items are blank, the icon tooltop displays as "Web Link". */
    title?: string;
    /** The URL of an icon that displays at 16x16 pixel in Jira. */
    url16x16?: string;

    [key: string]: any;
}

/** An icon. */
export class IconBean implements IIconBean {
    /** The URL of the tooltip, used only for a status icon. */
    link?: string;
    /** The title of the icon, for use as a tooltip on the icon. */
    title?: string;
    /** The URL of a 16x16 pixel icon. */
    url16x16?: string;

    constructor(data?: IIconBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.link = _data["link"];
            this.title = _data["title"];
            this.url16x16 = _data["url16x16"];
        }
    }

    static fromJS(data: any): IconBean {
        data = typeof data === 'object' ? data : {};
        let result = new IconBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["link"] = this.link;
        data["title"] = this.title;
        data["url16x16"] = this.url16x16;
        return data;
    }
}

/** An icon. */
export interface IIconBean {
    /** The URL of the tooltip, used only for a status icon. */
    link?: string;
    /** The title of the icon, for use as a tooltip on the icon. */
    title?: string;
    /** The URL of a 16x16 pixel icon. */
    url16x16?: string;
}

export class IdBean implements IIdBean {
    /** The ID of the permission scheme to associate with the project. Use the [Get all permission schemes](#api-rest-api-3-permissionscheme-get) resource to get a list of permission scheme IDs. */
    id!: number;

    constructor(data?: IIdBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IdBean {
        data = typeof data === 'object' ? data : {};
        let result = new IdBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IIdBean {
    /** The ID of the permission scheme to associate with the project. Use the [Get all permission schemes](#api-rest-api-3-permissionscheme-get) resource to get a list of permission scheme IDs. */
    id: number;
}

export class IdOrKeyBean implements IIdOrKeyBean {
    /** The ID of the referenced item. */
    id?: number;
    /** The key of the referenced item. */
    key?: string;

    constructor(data?: IIdOrKeyBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): IdOrKeyBean {
        data = typeof data === 'object' ? data : {};
        let result = new IdOrKeyBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        return data;
    }
}

export interface IIdOrKeyBean {
    /** The ID of the referenced item. */
    id?: number;
    /** The key of the referenced item. */
    key?: string;
}

export class IdSearchRequestBean implements IIdSearchRequestBean {
    /** A [JQL](https://confluence.atlassian.com/x/egORLQ) expression. Order by clauses are not allowed. */
    jql?: string;
    /** The maximum number of items to return per page. */
    maxResults?: number;
    /** The continuation token to fetch the next page. This token is provided by the response of this endpoint. */
    nextPageToken?: string;

    constructor(data?: IIdSearchRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.maxResults = 1000;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jql = _data["jql"];
            this.maxResults = _data["maxResults"] !== undefined ? _data["maxResults"] : 1000;
            this.nextPageToken = _data["nextPageToken"];
        }
    }

    static fromJS(data: any): IdSearchRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new IdSearchRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jql"] = this.jql;
        data["maxResults"] = this.maxResults;
        data["nextPageToken"] = this.nextPageToken;
        return data;
    }
}

export interface IIdSearchRequestBean {
    /** A [JQL](https://confluence.atlassian.com/x/egORLQ) expression. Order by clauses are not allowed. */
    jql?: string;
    /** The maximum number of items to return per page. */
    maxResults?: number;
    /** The continuation token to fetch the next page. This token is provided by the response of this endpoint. */
    nextPageToken?: string;
}

/** Result of your JQL search. Returns a list of issue IDs and a token to fetch the next page if one exists. */
export class IdSearchResults implements IIdSearchResults {
    /** The list of issue IDs found by the search. */
    readonly issueIds?: number[];
    /** Continuation token to fetch the next page. If this result represents the last or the only page this token will be null. */
    readonly nextPageToken?: string;

    constructor(data?: IIdSearchResults) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueIds"])) {
                (<any>this).issueIds = [] as any;
                for (let item of _data["issueIds"])
                    (<any>this).issueIds!.push(item);
            }
            (<any>this).nextPageToken = _data["nextPageToken"];
        }
    }

    static fromJS(data: any): IdSearchResults {
        data = typeof data === 'object' ? data : {};
        let result = new IdSearchResults();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueIds)) {
            data["issueIds"] = [];
            for (let item of this.issueIds)
                data["issueIds"].push(item);
        }
        data["nextPageToken"] = this.nextPageToken;
        return data;
    }
}

/** Result of your JQL search. Returns a list of issue IDs and a token to fetch the next page if one exists. */
export interface IIdSearchResults {
    /** The list of issue IDs found by the search. */
    issueIds?: number[];
    /** Continuation token to fetch the next page. If this result represents the last or the only page this token will be null. */
    nextPageToken?: string;
}

export class IncludedFields implements IIncludedFields {
    actuallyIncluded?: string[];
    excluded?: string[];
    included?: string[];

    constructor(data?: IIncludedFields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["actuallyIncluded"])) {
                this.actuallyIncluded = [] as any;
                for (let item of _data["actuallyIncluded"])
                    this.actuallyIncluded!.push(item);
            }
            if (Array.isArray(_data["excluded"])) {
                this.excluded = [] as any;
                for (let item of _data["excluded"])
                    this.excluded!.push(item);
            }
            if (Array.isArray(_data["included"])) {
                this.included = [] as any;
                for (let item of _data["included"])
                    this.included!.push(item);
            }
        }
    }

    static fromJS(data: any): IncludedFields {
        data = typeof data === 'object' ? data : {};
        let result = new IncludedFields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.actuallyIncluded)) {
            data["actuallyIncluded"] = [];
            for (let item of this.actuallyIncluded)
                data["actuallyIncluded"].push(item);
        }
        if (Array.isArray(this.excluded)) {
            data["excluded"] = [];
            for (let item of this.excluded)
                data["excluded"].push(item);
        }
        if (Array.isArray(this.included)) {
            data["included"] = [];
            for (let item of this.included)
                data["included"].push(item);
        }
        return data;
    }
}

export interface IIncludedFields {
    actuallyIncluded?: string[];
    excluded?: string[];
    included?: string[];
}

export class InputStreamSource implements IInputStreamSource {
    inputStream?: any;

    constructor(data?: IInputStreamSource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inputStream = _data["inputStream"];
        }
    }

    static fromJS(data: any): InputStreamSource {
        data = typeof data === 'object' ? data : {};
        let result = new InputStreamSource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inputStream"] = this.inputStream;
        return data;
    }
}

export interface IInputStreamSource {
    inputStream?: any;
}

/** List of Issue Ids Or Keys that are to be archived or unarchived */
export class IssueArchivalSyncRequest implements IIssueArchivalSyncRequest {
    issueIdsOrKeys?: string[];

    constructor(data?: IIssueArchivalSyncRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueIdsOrKeys"])) {
                this.issueIdsOrKeys = [] as any;
                for (let item of _data["issueIdsOrKeys"])
                    this.issueIdsOrKeys!.push(item);
            }
        }
    }

    static fromJS(data: any): IssueArchivalSyncRequest {
        data = typeof data === 'object' ? data : {};
        let result = new IssueArchivalSyncRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueIdsOrKeys)) {
            data["issueIdsOrKeys"] = [];
            for (let item of this.issueIdsOrKeys)
                data["issueIdsOrKeys"].push(item);
        }
        return data;
    }
}

/** List of Issue Ids Or Keys that are to be archived or unarchived */
export interface IIssueArchivalSyncRequest {
    issueIdsOrKeys?: string[];
}

/** Number of archived/unarchived issues and list of errors that occurred during the action, if any. */
export class IssueArchivalSyncResponse implements IIssueArchivalSyncResponse {
    errors?: Errors;
    numberOfIssuesUpdated?: number;

    constructor(data?: IIssueArchivalSyncResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errors = _data["errors"] ? Errors.fromJS(_data["errors"]) : <any>undefined;
            this.numberOfIssuesUpdated = _data["numberOfIssuesUpdated"];
        }
    }

    static fromJS(data: any): IssueArchivalSyncResponse {
        data = typeof data === 'object' ? data : {};
        let result = new IssueArchivalSyncResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errors"] = this.errors ? this.errors.toJSON() : <any>undefined;
        data["numberOfIssuesUpdated"] = this.numberOfIssuesUpdated;
        return data;
    }
}

/** Number of archived/unarchived issues and list of errors that occurred during the action, if any. */
export interface IIssueArchivalSyncResponse {
    errors?: Errors;
    numberOfIssuesUpdated?: number;
}

/** Details about an issue. */
export class IssueBean implements IIssueBean {
    /** Details of changelogs associated with the issue. */
    readonly changelog?: PageOfChangelogs;
    /** The metadata for the fields on the issue that can be amended. */
    readonly editmeta?: IssueUpdateMetadata;
    /** Expand options that include additional issue details in the response. */
    readonly expand?: string;
    fields?: { [key: string]: any; };
    fieldsToInclude?: IncludedFields;
    /** The ID of the issue. */
    readonly id?: string;
    /** The key of the issue. */
    readonly key?: string;
    /** The ID and name of each field present on the issue. */
    readonly names?: { [key: string]: string; };
    /** The operations that can be performed on the issue. */
    readonly operations?: Operations;
    /** Details of the issue properties identified in the request. */
    readonly properties?: { [key: string]: any; };
    /** The rendered value of each field present on the issue. */
    readonly renderedFields?: { [key: string]: any; };
    /** The schema describing each field present on the issue. */
    readonly schema?: { [key: string]: JsonTypeBean; };
    /** The URL of the issue details. */
    readonly self?: string;
    /** The transitions that can be performed on the issue. */
    readonly transitions?: IssueTransition[];
    /** The versions of each field on the issue. */
    readonly versionedRepresentations?: { [key: string]: { [key: string]: any; }; };

    constructor(data?: IIssueBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).changelog = _data["changelog"] ? PageOfChangelogs.fromJS(_data["changelog"]) : <any>undefined;
            (<any>this).editmeta = _data["editmeta"] ? IssueUpdateMetadata.fromJS(_data["editmeta"]) : <any>undefined;
            (<any>this).expand = _data["expand"];
            if (_data["fields"]) {
                this.fields = {} as any;
                for (let key in _data["fields"]) {
                    if (_data["fields"].hasOwnProperty(key))
                        (<any>this.fields)![key] = _data["fields"][key];
                }
            }
            this.fieldsToInclude = _data["fieldsToInclude"] ? IncludedFields.fromJS(_data["fieldsToInclude"]) : <any>undefined;
            (<any>this).id = _data["id"];
            (<any>this).key = _data["key"];
            if (_data["names"]) {
                (<any>this).names = {} as any;
                for (let key in _data["names"]) {
                    if (_data["names"].hasOwnProperty(key))
                        (<any>(<any>this).names)![key] = _data["names"][key];
                }
            }
            (<any>this).operations = _data["operations"] ? Operations.fromJS(_data["operations"]) : <any>undefined;
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key];
                }
            }
            if (_data["renderedFields"]) {
                (<any>this).renderedFields = {} as any;
                for (let key in _data["renderedFields"]) {
                    if (_data["renderedFields"].hasOwnProperty(key))
                        (<any>(<any>this).renderedFields)![key] = _data["renderedFields"][key];
                }
            }
            if (_data["schema"]) {
                (<any>this).schema = {} as any;
                for (let key in _data["schema"]) {
                    if (_data["schema"].hasOwnProperty(key))
                        (<any>(<any>this).schema)![key] = _data["schema"][key] ? JsonTypeBean.fromJS(_data["schema"][key]) : new JsonTypeBean();
                }
            }
            (<any>this).self = _data["self"];
            if (Array.isArray(_data["transitions"])) {
                (<any>this).transitions = [] as any;
                for (let item of _data["transitions"])
                    (<any>this).transitions!.push(IssueTransition.fromJS(item));
            }
            if (_data["versionedRepresentations"]) {
                (<any>this).versionedRepresentations = {} as any;
                for (let key in _data["versionedRepresentations"]) {
                    if (_data["versionedRepresentations"].hasOwnProperty(key))
                        (<any>(<any>this).versionedRepresentations)![key] = _data["versionedRepresentations"][key] !== undefined ? _data["versionedRepresentations"][key] : {};
                }
            }
        }
    }

    static fromJS(data: any): IssueBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["changelog"] = this.changelog ? this.changelog.toJSON() : <any>undefined;
        data["editmeta"] = this.editmeta ? this.editmeta.toJSON() : <any>undefined;
        data["expand"] = this.expand;
        if (this.fields) {
            data["fields"] = {};
            for (let key in this.fields) {
                if (this.fields.hasOwnProperty(key))
                    (<any>data["fields"])[key] = (<any>this.fields)[key];
            }
        }
        data["fieldsToInclude"] = this.fieldsToInclude ? this.fieldsToInclude.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["key"] = this.key;
        if (this.names) {
            data["names"] = {};
            for (let key in this.names) {
                if (this.names.hasOwnProperty(key))
                    (<any>data["names"])[key] = (<any>this.names)[key];
            }
        }
        data["operations"] = this.operations ? this.operations.toJSON() : <any>undefined;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        if (this.renderedFields) {
            data["renderedFields"] = {};
            for (let key in this.renderedFields) {
                if (this.renderedFields.hasOwnProperty(key))
                    (<any>data["renderedFields"])[key] = (<any>this.renderedFields)[key];
            }
        }
        if (this.schema) {
            data["schema"] = {};
            for (let key in this.schema) {
                if (this.schema.hasOwnProperty(key))
                    (<any>data["schema"])[key] = this.schema[key] ? this.schema[key].toJSON() : <any>undefined;
            }
        }
        data["self"] = this.self;
        if (Array.isArray(this.transitions)) {
            data["transitions"] = [];
            for (let item of this.transitions)
                data["transitions"].push(item.toJSON());
        }
        if (this.versionedRepresentations) {
            data["versionedRepresentations"] = {};
            for (let key in this.versionedRepresentations) {
                if (this.versionedRepresentations.hasOwnProperty(key))
                    (<any>data["versionedRepresentations"])[key] = (<any>this.versionedRepresentations)[key];
            }
        }
        return data;
    }
}

/** Details about an issue. */
export interface IIssueBean {
    /** Details of changelogs associated with the issue. */
    changelog?: PageOfChangelogs;
    /** The metadata for the fields on the issue that can be amended. */
    editmeta?: IssueUpdateMetadata;
    /** Expand options that include additional issue details in the response. */
    expand?: string;
    fields?: { [key: string]: any; };
    fieldsToInclude?: IncludedFields;
    /** The ID of the issue. */
    id?: string;
    /** The key of the issue. */
    key?: string;
    /** The ID and name of each field present on the issue. */
    names?: { [key: string]: string; };
    /** The operations that can be performed on the issue. */
    operations?: Operations;
    /** Details of the issue properties identified in the request. */
    properties?: { [key: string]: any; };
    /** The rendered value of each field present on the issue. */
    renderedFields?: { [key: string]: any; };
    /** The schema describing each field present on the issue. */
    schema?: { [key: string]: JsonTypeBean; };
    /** The URL of the issue details. */
    self?: string;
    /** The transitions that can be performed on the issue. */
    transitions?: IssueTransition[];
    /** The versions of each field on the issue. */
    versionedRepresentations?: { [key: string]: { [key: string]: any; }; };
}

/** Issue Bulk Delete Payload */
export class IssueBulkDeletePayload implements IIssueBulkDeletePayload {
    /** List of issue IDs or keys which are to be bulk deleted. These IDs or keys can be from different projects and issue types. */
    selectedIssueIdsOrKeys!: string[];
    /** A boolean value that indicates whether to send a bulk change notification when the issues are being deleted.

If `true`, dispatches a bulk notification email to users about the updates. */
    sendBulkNotification?: boolean | undefined;

    constructor(data?: IIssueBulkDeletePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.selectedIssueIdsOrKeys = [];
            this.sendBulkNotification = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["selectedIssueIdsOrKeys"])) {
                this.selectedIssueIdsOrKeys = [] as any;
                for (let item of _data["selectedIssueIdsOrKeys"])
                    this.selectedIssueIdsOrKeys!.push(item);
            }
            this.sendBulkNotification = _data["sendBulkNotification"] !== undefined ? _data["sendBulkNotification"] : true;
        }
    }

    static fromJS(data: any): IssueBulkDeletePayload {
        data = typeof data === 'object' ? data : {};
        let result = new IssueBulkDeletePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.selectedIssueIdsOrKeys)) {
            data["selectedIssueIdsOrKeys"] = [];
            for (let item of this.selectedIssueIdsOrKeys)
                data["selectedIssueIdsOrKeys"].push(item);
        }
        data["sendBulkNotification"] = this.sendBulkNotification;
        return data;
    }
}

/** Issue Bulk Delete Payload */
export interface IIssueBulkDeletePayload {
    /** List of issue IDs or keys which are to be bulk deleted. These IDs or keys can be from different projects and issue types. */
    selectedIssueIdsOrKeys: string[];
    /** A boolean value that indicates whether to send a bulk change notification when the issues are being deleted.

If `true`, dispatches a bulk notification email to users about the updates. */
    sendBulkNotification?: boolean | undefined;
}

export class IssueBulkEditField implements IIssueBulkEditField {
    /** Description of the field. */
    description?: string;
    /** A list of options related to the field, applicable in contexts where multiple selections are allowed. */
    fieldOptions?: IssueBulkOperationsFieldOption[];
    /** The unique ID of the field. */
    id?: string;
    /** Indicates whether the field is mandatory for the operation. */
    isRequired?: boolean;
    /** Specifies supported actions (like add, replace, remove) on multi-select fields via an enum. */
    multiSelectFieldOptions?: MultiSelectFieldOptions[];
    /** The display name of the field. */
    name?: string;
    /** A URL to fetch additional data for the field */
    searchUrl?: string;
    /** The type of the field. */
    type?: string;
    /** A message indicating why the field is unavailable for editing. */
    unavailableMessage?: string;

    constructor(data?: IIssueBulkEditField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            if (Array.isArray(_data["fieldOptions"])) {
                this.fieldOptions = [] as any;
                for (let item of _data["fieldOptions"])
                    this.fieldOptions!.push(IssueBulkOperationsFieldOption.fromJS(item));
            }
            this.id = _data["id"];
            this.isRequired = _data["isRequired"];
            if (Array.isArray(_data["multiSelectFieldOptions"])) {
                this.multiSelectFieldOptions = [] as any;
                for (let item of _data["multiSelectFieldOptions"])
                    this.multiSelectFieldOptions!.push(item);
            }
            this.name = _data["name"];
            this.searchUrl = _data["searchUrl"];
            this.type = _data["type"];
            this.unavailableMessage = _data["unavailableMessage"];
        }
    }

    static fromJS(data: any): IssueBulkEditField {
        data = typeof data === 'object' ? data : {};
        let result = new IssueBulkEditField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        if (Array.isArray(this.fieldOptions)) {
            data["fieldOptions"] = [];
            for (let item of this.fieldOptions)
                data["fieldOptions"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["isRequired"] = this.isRequired;
        if (Array.isArray(this.multiSelectFieldOptions)) {
            data["multiSelectFieldOptions"] = [];
            for (let item of this.multiSelectFieldOptions)
                data["multiSelectFieldOptions"].push(item);
        }
        data["name"] = this.name;
        data["searchUrl"] = this.searchUrl;
        data["type"] = this.type;
        data["unavailableMessage"] = this.unavailableMessage;
        return data;
    }
}

export interface IIssueBulkEditField {
    /** Description of the field. */
    description?: string;
    /** A list of options related to the field, applicable in contexts where multiple selections are allowed. */
    fieldOptions?: IssueBulkOperationsFieldOption[];
    /** The unique ID of the field. */
    id?: string;
    /** Indicates whether the field is mandatory for the operation. */
    isRequired?: boolean;
    /** Specifies supported actions (like add, replace, remove) on multi-select fields via an enum. */
    multiSelectFieldOptions?: MultiSelectFieldOptions[];
    /** The display name of the field. */
    name?: string;
    /** A URL to fetch additional data for the field */
    searchUrl?: string;
    /** The type of the field. */
    type?: string;
    /** A message indicating why the field is unavailable for editing. */
    unavailableMessage?: string;
}

/** Issue Bulk Edit Payload */
export class IssueBulkEditPayload implements IIssueBulkEditPayload {
    /** An object that defines the values to be updated in specified fields of an issue. The structure and content of this parameter vary depending on the type of field being edited. Although the order is not significant, ensure that field IDs align with those in selectedActions. */
    editedFieldsInput!: JiraIssueFields;
    /** List of all the field IDs that are to be bulk edited. Each field ID in this list corresponds to a specific attribute of an issue that is set to be modified in the bulk edit operation. The relevant field ID can be obtained by calling the Bulk Edit Get Fields REST API (documentation available on this page itself). */
    selectedActions!: string[];
    /** List of issue IDs or keys which are to be bulk edited. These IDs or keys can be from different projects and issue types. */
    selectedIssueIdsOrKeys!: string[];
    /** A boolean value that indicates whether to send a bulk change notification when the issues are being edited.

If `true`, dispatches a bulk notification email to users about the updates. */
    sendBulkNotification?: boolean | undefined;

    constructor(data?: IIssueBulkEditPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.editedFieldsInput = new JiraIssueFields();
            this.selectedActions = [];
            this.selectedIssueIdsOrKeys = [];
            this.sendBulkNotification = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.editedFieldsInput = _data["editedFieldsInput"] ? JiraIssueFields.fromJS(_data["editedFieldsInput"]) : new JiraIssueFields();
            if (Array.isArray(_data["selectedActions"])) {
                this.selectedActions = [] as any;
                for (let item of _data["selectedActions"])
                    this.selectedActions!.push(item);
            }
            if (Array.isArray(_data["selectedIssueIdsOrKeys"])) {
                this.selectedIssueIdsOrKeys = [] as any;
                for (let item of _data["selectedIssueIdsOrKeys"])
                    this.selectedIssueIdsOrKeys!.push(item);
            }
            this.sendBulkNotification = _data["sendBulkNotification"] !== undefined ? _data["sendBulkNotification"] : true;
        }
    }

    static fromJS(data: any): IssueBulkEditPayload {
        data = typeof data === 'object' ? data : {};
        let result = new IssueBulkEditPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editedFieldsInput"] = this.editedFieldsInput ? this.editedFieldsInput.toJSON() : <any>undefined;
        if (Array.isArray(this.selectedActions)) {
            data["selectedActions"] = [];
            for (let item of this.selectedActions)
                data["selectedActions"].push(item);
        }
        if (Array.isArray(this.selectedIssueIdsOrKeys)) {
            data["selectedIssueIdsOrKeys"] = [];
            for (let item of this.selectedIssueIdsOrKeys)
                data["selectedIssueIdsOrKeys"].push(item);
        }
        data["sendBulkNotification"] = this.sendBulkNotification;
        return data;
    }
}

/** Issue Bulk Edit Payload */
export interface IIssueBulkEditPayload {
    /** An object that defines the values to be updated in specified fields of an issue. The structure and content of this parameter vary depending on the type of field being edited. Although the order is not significant, ensure that field IDs align with those in selectedActions. */
    editedFieldsInput: JiraIssueFields;
    /** List of all the field IDs that are to be bulk edited. Each field ID in this list corresponds to a specific attribute of an issue that is set to be modified in the bulk edit operation. The relevant field ID can be obtained by calling the Bulk Edit Get Fields REST API (documentation available on this page itself). */
    selectedActions: string[];
    /** List of issue IDs or keys which are to be bulk edited. These IDs or keys can be from different projects and issue types. */
    selectedIssueIdsOrKeys: string[];
    /** A boolean value that indicates whether to send a bulk change notification when the issues are being edited.

If `true`, dispatches a bulk notification email to users about the updates. */
    sendBulkNotification?: boolean | undefined;
}

/** Issue Bulk Move Payload */
export class IssueBulkMovePayload implements IIssueBulkMovePayload {
    /** A boolean value that indicates whether to send a bulk change notification when the issues are being moved.

If `true`, dispatches a bulk notification email to users about the updates. */
    sendBulkNotification?: boolean | undefined;
    /** An object representing the mapping of issues and data related to destination entities, like fields and statuses, that are required during a bulk move.

The key is a string that is created by concatenating the following three entities in order, separated by commas. The format is `<project ID or key>,<issueType ID>,<parent ID or key>`. It should be unique across mappings provided in the payload. If you provide multiple mappings for the same key, only one will be processed. However, the operation won't fail, so the error may be hard to track down.

 *  ***Destination project*** (Required): ID or key of the project to which the issues are being moved.
 *  ***Destination issueType*** (Required): ID of the issueType to which the issues are being moved.
 *  ***Destination parent ID or key*** (Optional): ID or key of the issue which will become the parent of the issues being moved. Only required when the destination issueType is a subtask. */
    targetToSourcesMapping?: { [key: string]: TargetToSourcesMapping; };

    constructor(data?: IIssueBulkMovePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sendBulkNotification = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sendBulkNotification = _data["sendBulkNotification"] !== undefined ? _data["sendBulkNotification"] : true;
            if (_data["targetToSourcesMapping"]) {
                this.targetToSourcesMapping = {} as any;
                for (let key in _data["targetToSourcesMapping"]) {
                    if (_data["targetToSourcesMapping"].hasOwnProperty(key))
                        (<any>this.targetToSourcesMapping)![key] = _data["targetToSourcesMapping"][key] ? TargetToSourcesMapping.fromJS(_data["targetToSourcesMapping"][key]) : new TargetToSourcesMapping();
                }
            }
        }
    }

    static fromJS(data: any): IssueBulkMovePayload {
        data = typeof data === 'object' ? data : {};
        let result = new IssueBulkMovePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sendBulkNotification"] = this.sendBulkNotification;
        if (this.targetToSourcesMapping) {
            data["targetToSourcesMapping"] = {};
            for (let key in this.targetToSourcesMapping) {
                if (this.targetToSourcesMapping.hasOwnProperty(key))
                    (<any>data["targetToSourcesMapping"])[key] = this.targetToSourcesMapping[key] ? this.targetToSourcesMapping[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Issue Bulk Move Payload */
export interface IIssueBulkMovePayload {
    /** A boolean value that indicates whether to send a bulk change notification when the issues are being moved.

If `true`, dispatches a bulk notification email to users about the updates. */
    sendBulkNotification?: boolean | undefined;
    /** An object representing the mapping of issues and data related to destination entities, like fields and statuses, that are required during a bulk move.

The key is a string that is created by concatenating the following three entities in order, separated by commas. The format is `<project ID or key>,<issueType ID>,<parent ID or key>`. It should be unique across mappings provided in the payload. If you provide multiple mappings for the same key, only one will be processed. However, the operation won't fail, so the error may be hard to track down.

 *  ***Destination project*** (Required): ID or key of the project to which the issues are being moved.
 *  ***Destination issueType*** (Required): ID of the issueType to which the issues are being moved.
 *  ***Destination parent ID or key*** (Optional): ID or key of the issue which will become the parent of the issues being moved. Only required when the destination issueType is a subtask. */
    targetToSourcesMapping?: { [key: string]: TargetToSourcesMapping; };
}

export class IssueBulkOperationsFieldOption implements IIssueBulkOperationsFieldOption {

    constructor(data?: IIssueBulkOperationsFieldOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IssueBulkOperationsFieldOption {
        data = typeof data === 'object' ? data : {};
        let result = new IssueBulkOperationsFieldOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIssueBulkOperationsFieldOption {
}

export class IssueBulkTransitionForWorkflow implements IIssueBulkTransitionForWorkflow {
    /** Indicates whether all the transitions of this workflow are available in the transitions list or not. */
    readonly isTransitionsFiltered?: boolean;
    /** List of issue keys from the request which are associated with this workflow. */
    readonly issues?: string[];
    /** List of transitions available for issues from the request which are associated with this workflow.

 **This list includes only those transitions that are common across the issues in this workflow and do not involve any additional field updates.**  */
    readonly transitions?: SimplifiedIssueTransition[];

    constructor(data?: IIssueBulkTransitionForWorkflow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isTransitionsFiltered = _data["isTransitionsFiltered"];
            if (Array.isArray(_data["issues"])) {
                (<any>this).issues = [] as any;
                for (let item of _data["issues"])
                    (<any>this).issues!.push(item);
            }
            if (Array.isArray(_data["transitions"])) {
                (<any>this).transitions = [] as any;
                for (let item of _data["transitions"])
                    (<any>this).transitions!.push(SimplifiedIssueTransition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IssueBulkTransitionForWorkflow {
        data = typeof data === 'object' ? data : {};
        let result = new IssueBulkTransitionForWorkflow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isTransitionsFiltered"] = this.isTransitionsFiltered;
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item);
        }
        if (Array.isArray(this.transitions)) {
            data["transitions"] = [];
            for (let item of this.transitions)
                data["transitions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIssueBulkTransitionForWorkflow {
    /** Indicates whether all the transitions of this workflow are available in the transitions list or not. */
    isTransitionsFiltered?: boolean;
    /** List of issue keys from the request which are associated with this workflow. */
    issues?: string[];
    /** List of transitions available for issues from the request which are associated with this workflow.

 **This list includes only those transitions that are common across the issues in this workflow and do not involve any additional field updates.**  */
    transitions?: SimplifiedIssueTransition[];
}

/** Issue Bulk Transition Payload */
export class IssueBulkTransitionPayload implements IIssueBulkTransitionPayload {
    /** List of objects and each object has two properties:

 *  Issues that will be bulk transitioned.
 *  TransitionId that corresponds to a specific transition of issues that share the same workflow. */
    bulkTransitionInputs!: BulkTransitionSubmitInput[];
    /** A boolean value that indicates whether to send a bulk change notification when the issues are being transitioned.

If `true`, dispatches a bulk notification email to users about the updates. */
    sendBulkNotification?: boolean | undefined;

    constructor(data?: IIssueBulkTransitionPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulkTransitionInputs = [];
            this.sendBulkNotification = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulkTransitionInputs"])) {
                this.bulkTransitionInputs = [] as any;
                for (let item of _data["bulkTransitionInputs"])
                    this.bulkTransitionInputs!.push(BulkTransitionSubmitInput.fromJS(item));
            }
            this.sendBulkNotification = _data["sendBulkNotification"] !== undefined ? _data["sendBulkNotification"] : true;
        }
    }

    static fromJS(data: any): IssueBulkTransitionPayload {
        data = typeof data === 'object' ? data : {};
        let result = new IssueBulkTransitionPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulkTransitionInputs)) {
            data["bulkTransitionInputs"] = [];
            for (let item of this.bulkTransitionInputs)
                data["bulkTransitionInputs"].push(item.toJSON());
        }
        data["sendBulkNotification"] = this.sendBulkNotification;
        return data;
    }
}

/** Issue Bulk Transition Payload */
export interface IIssueBulkTransitionPayload {
    /** List of objects and each object has two properties:

 *  Issues that will be bulk transitioned.
 *  TransitionId that corresponds to a specific transition of issues that share the same workflow. */
    bulkTransitionInputs: BulkTransitionSubmitInput[];
    /** A boolean value that indicates whether to send a bulk change notification when the issues are being transitioned.

If `true`, dispatches a bulk notification email to users about the updates. */
    sendBulkNotification?: boolean | undefined;
}

/** Issue Bulk Watch Or Unwatch Payload */
export class IssueBulkWatchOrUnwatchPayload implements IIssueBulkWatchOrUnwatchPayload {
    /** List of issue IDs or keys which are to be bulk watched or unwatched. These IDs or keys can be from different projects and issue types. */
    selectedIssueIdsOrKeys!: string[];

    constructor(data?: IIssueBulkWatchOrUnwatchPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.selectedIssueIdsOrKeys = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["selectedIssueIdsOrKeys"])) {
                this.selectedIssueIdsOrKeys = [] as any;
                for (let item of _data["selectedIssueIdsOrKeys"])
                    this.selectedIssueIdsOrKeys!.push(item);
            }
        }
    }

    static fromJS(data: any): IssueBulkWatchOrUnwatchPayload {
        data = typeof data === 'object' ? data : {};
        let result = new IssueBulkWatchOrUnwatchPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.selectedIssueIdsOrKeys)) {
            data["selectedIssueIdsOrKeys"] = [];
            for (let item of this.selectedIssueIdsOrKeys)
                data["selectedIssueIdsOrKeys"].push(item);
        }
        return data;
    }
}

/** Issue Bulk Watch Or Unwatch Payload */
export interface IIssueBulkWatchOrUnwatchPayload {
    /** List of issue IDs or keys which are to be bulk watched or unwatched. These IDs or keys can be from different projects and issue types. */
    selectedIssueIdsOrKeys: string[];
}

/** List of changelogs that belong to single issue */
export class IssueChangeLog implements IIssueChangeLog {
    /** List of changelogs that belongs to given issueId. */
    readonly changeHistories?: Changelog[];
    /** The ID of the issue. */
    readonly issueId?: string;

    constructor(data?: IIssueChangeLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["changeHistories"])) {
                (<any>this).changeHistories = [] as any;
                for (let item of _data["changeHistories"])
                    (<any>this).changeHistories!.push(Changelog.fromJS(item));
            }
            (<any>this).issueId = _data["issueId"];
        }
    }

    static fromJS(data: any): IssueChangeLog {
        data = typeof data === 'object' ? data : {};
        let result = new IssueChangeLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.changeHistories)) {
            data["changeHistories"] = [];
            for (let item of this.changeHistories)
                data["changeHistories"].push(item.toJSON());
        }
        data["issueId"] = this.issueId;
        return data;
    }
}

/** List of changelogs that belong to single issue */
export interface IIssueChangeLog {
    /** List of changelogs that belongs to given issueId. */
    changeHistories?: Changelog[];
    /** The ID of the issue. */
    issueId?: string;
}

/** A list of changelog IDs. */
export class IssueChangelogIds implements IIssueChangelogIds {
    /** The list of changelog IDs. */
    changelogIds!: number[];

    constructor(data?: IIssueChangelogIds) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.changelogIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["changelogIds"])) {
                this.changelogIds = [] as any;
                for (let item of _data["changelogIds"])
                    this.changelogIds!.push(item);
            }
        }
    }

    static fromJS(data: any): IssueChangelogIds {
        data = typeof data === 'object' ? data : {};
        let result = new IssueChangelogIds();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.changelogIds)) {
            data["changelogIds"] = [];
            for (let item of this.changelogIds)
                data["changelogIds"].push(item);
        }
        return data;
    }
}

/** A list of changelog IDs. */
export interface IIssueChangelogIds {
    /** The list of changelog IDs. */
    changelogIds: number[];
}

export class IssueCommentListRequestBean implements IIssueCommentListRequestBean {
    /** The list of comment IDs. A maximum of 1000 IDs can be specified. */
    ids!: number[];

    constructor(data?: IIssueCommentListRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): IssueCommentListRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueCommentListRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }
}

export interface IIssueCommentListRequestBean {
    /** The list of comment IDs. A maximum of 1000 IDs can be specified. */
    ids: number[];
}

/** An [issue](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#issue) specified by ID or key. All the fields of the issue object are available in the Jira expression. */
export class IssueContextVariable implements IIssueContextVariable {
    /** The issue ID. */
    id?: number;
    /** The issue key. */
    key?: string;
    /** Type of custom context variable. */
    type!: string;

    [key: string]: any;

    constructor(data?: IIssueContextVariable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.key = _data["key"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): IssueContextVariable {
        data = typeof data === 'object' ? data : {};
        let result = new IssueContextVariable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["key"] = this.key;
        data["type"] = this.type;
        return data;
    }
}

/** An [issue](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#issue) specified by ID or key. All the fields of the issue object are available in the Jira expression. */
export interface IIssueContextVariable {
    /** The issue ID. */
    id?: number;
    /** The issue key. */
    key?: string;
    /** Type of custom context variable. */
    type: string;

    [key: string]: any;
}

/** The wrapper for the issue creation metadata for a list of projects. */
export class IssueCreateMetadata implements IIssueCreateMetadata {
    /** Expand options that include additional project details in the response. */
    readonly expand?: string;
    /** List of projects and their issue creation metadata. */
    readonly projects?: ProjectIssueCreateMetadata[];

    constructor(data?: IIssueCreateMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).expand = _data["expand"];
            if (Array.isArray(_data["projects"])) {
                (<any>this).projects = [] as any;
                for (let item of _data["projects"])
                    (<any>this).projects!.push(ProjectIssueCreateMetadata.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IssueCreateMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new IssueCreateMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expand"] = this.expand;
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item.toJSON());
        }
        return data;
    }
}

/** The wrapper for the issue creation metadata for a list of projects. */
export interface IIssueCreateMetadata {
    /** Expand options that include additional project details in the response. */
    expand?: string;
    /** List of projects and their issue creation metadata. */
    projects?: ProjectIssueCreateMetadata[];
}

/** Lists of issues and entity properties. See [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/) for more information. */
export class IssueEntityProperties implements IIssueEntityProperties {
    /** A list of entity property IDs. */
    entitiesIds?: number[];
    /** A list of entity property keys and values. */
    properties?: { [key: string]: JsonNode; };

    constructor(data?: IIssueEntityProperties) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entitiesIds"])) {
                this.entitiesIds = [] as any;
                for (let item of _data["entitiesIds"])
                    this.entitiesIds!.push(item);
            }
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? JsonNode.fromJS(_data["properties"][key]) : new JsonNode();
                }
            }
        }
    }

    static fromJS(data: any): IssueEntityProperties {
        data = typeof data === 'object' ? data : {};
        let result = new IssueEntityProperties();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entitiesIds)) {
            data["entitiesIds"] = [];
            for (let item of this.entitiesIds)
                data["entitiesIds"].push(item);
        }
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Lists of issues and entity properties. See [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/) for more information. */
export interface IIssueEntityProperties {
    /** A list of entity property IDs. */
    entitiesIds?: number[];
    /** A list of entity property keys and values. */
    properties?: { [key: string]: JsonNode; };
}

/** An issue ID with entity property values. See [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/) for more information. */
export class IssueEntityPropertiesForMultiUpdate implements IIssueEntityPropertiesForMultiUpdate {
    /** The ID of the issue. */
    issueID?: number;
    /** Entity properties to set on the issue. The maximum length of an issue property value is 32768 characters. */
    properties?: { [key: string]: JsonNode; };

    constructor(data?: IIssueEntityPropertiesForMultiUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueID = _data["issueID"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key] ? JsonNode.fromJS(_data["properties"][key]) : new JsonNode();
                }
            }
        }
    }

    static fromJS(data: any): IssueEntityPropertiesForMultiUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new IssueEntityPropertiesForMultiUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueID"] = this.issueID;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** An issue ID with entity property values. See [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/) for more information. */
export interface IIssueEntityPropertiesForMultiUpdate {
    /** The ID of the issue. */
    issueID?: number;
    /** Entity properties to set on the issue. The maximum length of an issue property value is 32768 characters. */
    properties?: { [key: string]: JsonNode; };
}

/** Describes the error that occurred when retrieving data for a particular issue. */
export class IssueError implements IIssueError {
    /** The error that occurred when fetching this issue. */
    readonly errorMessage?: string;
    /** The ID of the issue. */
    readonly id?: string;

    constructor(data?: IIssueError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).errorMessage = _data["errorMessage"];
            (<any>this).id = _data["id"];
        }
    }

    static fromJS(data: any): IssueError {
        data = typeof data === 'object' ? data : {};
        let result = new IssueError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["id"] = this.id;
        return data;
    }
}

/** Describes the error that occurred when retrieving data for a particular issue. */
export interface IIssueError {
    /** The error that occurred when fetching this issue. */
    errorMessage?: string;
    /** The ID of the issue. */
    id?: string;
}

/** Details about an issue event. */
export class IssueEvent implements IIssueEvent {
    /** The ID of the event. */
    readonly id?: number;
    /** The name of the event. */
    readonly name?: string;

    constructor(data?: IIssueEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): IssueEvent {
        data = typeof data === 'object' ? data : {};
        let result = new IssueEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** Details about an issue event. */
export interface IIssueEvent {
    /** The ID of the event. */
    id?: number;
    /** The name of the event. */
    name?: string;
}

/** Details of the options for a select list issue field. */
export class IssueFieldOption implements IIssueFieldOption {
    config?: IssueFieldOptionConfiguration;
    /** The unique identifier for the option. This is only unique within the select field's set of options. */
    id!: number;
    /** The properties of the object, as arbitrary key-value pairs. These properties can be searched using JQL, if the extractions (see [Issue Field Option Property Index](https://developer.atlassian.com/cloud/jira/platform/modules/issue-field-option-property-index/)) are defined in the descriptor for the issue field module. */
    properties?: { [key: string]: any; };
    /** The option's name, which is displayed in Jira. */
    value!: string;

    constructor(data?: IIssueFieldOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.config = _data["config"] ? IssueFieldOptionConfiguration.fromJS(_data["config"]) : <any>undefined;
            this.id = _data["id"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): IssueFieldOption {
        data = typeof data === 'object' ? data : {};
        let result = new IssueFieldOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["config"] = this.config ? this.config.toJSON() : <any>undefined;
        data["id"] = this.id;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["value"] = this.value;
        return data;
    }
}

/** Details of the options for a select list issue field. */
export interface IIssueFieldOption {
    config?: IssueFieldOptionConfiguration;
    /** The unique identifier for the option. This is only unique within the select field's set of options. */
    id: number;
    /** The properties of the object, as arbitrary key-value pairs. These properties can be searched using JQL, if the extractions (see [Issue Field Option Property Index](https://developer.atlassian.com/cloud/jira/platform/modules/issue-field-option-property-index/)) are defined in the descriptor for the issue field module. */
    properties?: { [key: string]: any; };
    /** The option's name, which is displayed in Jira. */
    value: string;
}

/** Details of the projects the option is available in. */
export class IssueFieldOptionConfiguration implements IIssueFieldOptionConfiguration {
    /** DEPRECATED */
    attributes?: attributes[];
    /** Defines the projects that the option is available in. If the scope is not defined, then the option is available in all projects. */
    scope?: IssueFieldOptionScopeBean;

    constructor(data?: IIssueFieldOptionConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(item);
            }
            this.scope = _data["scope"] ? IssueFieldOptionScopeBean.fromJS(_data["scope"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IssueFieldOptionConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new IssueFieldOptionConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item);
        }
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        return data;
    }
}

/** Details of the projects the option is available in. */
export interface IIssueFieldOptionConfiguration {
    /** DEPRECATED */
    attributes?: attributes[];
    /** Defines the projects that the option is available in. If the scope is not defined, then the option is available in all projects. */
    scope?: IssueFieldOptionScopeBean;
}

export class IssueFieldOptionCreateBean implements IIssueFieldOptionCreateBean {
    config?: IssueFieldOptionConfiguration;
    /** The properties of the option as arbitrary key-value pairs. These properties can be searched using JQL, if the extractions (see https://developer.atlassian.com/cloud/jira/platform/modules/issue-field-option-property-index/) are defined in the descriptor for the issue field module. */
    properties?: { [key: string]: any; };
    /** The option's name, which is displayed in Jira. */
    value!: string;

    [key: string]: any;

    constructor(data?: IIssueFieldOptionCreateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.config = _data["config"] ? IssueFieldOptionConfiguration.fromJS(_data["config"]) : <any>undefined;
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): IssueFieldOptionCreateBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueFieldOptionCreateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["config"] = this.config ? this.config.toJSON() : <any>undefined;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["value"] = this.value;
        return data;
    }
}

export interface IIssueFieldOptionCreateBean {
    config?: IssueFieldOptionConfiguration;
    /** The properties of the option as arbitrary key-value pairs. These properties can be searched using JQL, if the extractions (see https://developer.atlassian.com/cloud/jira/platform/modules/issue-field-option-property-index/) are defined in the descriptor for the issue field module. */
    properties?: { [key: string]: any; };
    /** The option's name, which is displayed in Jira. */
    value: string;

    [key: string]: any;
}

export class IssueFieldOptionScopeBean implements IIssueFieldOptionScopeBean {
    /** Defines the behavior of the option within the global context. If this property is set, even if set to an empty object, then the option is available in all projects. */
    global?: GlobalScopeBean;
    /** DEPRECATED */
    projects?: number[];
    /** Defines the projects in which the option is available and the behavior of the option within each project. Specify one object per project. The behavior of the option in a project context overrides the behavior in the global context. */
    projects2?: ProjectScopeBean[];

    constructor(data?: IIssueFieldOptionScopeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.global = _data["global"] ? GlobalScopeBean.fromJS(_data["global"]) : <any>undefined;
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects!.push(item);
            }
            if (Array.isArray(_data["projects2"])) {
                this.projects2 = [] as any;
                for (let item of _data["projects2"])
                    this.projects2!.push(ProjectScopeBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IssueFieldOptionScopeBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueFieldOptionScopeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["global"] = this.global ? this.global.toJSON() : <any>undefined;
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item);
        }
        if (Array.isArray(this.projects2)) {
            data["projects2"] = [];
            for (let item of this.projects2)
                data["projects2"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIssueFieldOptionScopeBean {
    /** Defines the behavior of the option within the global context. If this property is set, even if set to an empty object, then the option is available in all projects. */
    global?: GlobalScopeBean;
    /** DEPRECATED */
    projects?: number[];
    /** Defines the projects in which the option is available and the behavior of the option within each project. Specify one object per project. The behavior of the option in a project context overrides the behavior in the global context. */
    projects2?: ProjectScopeBean[];
}

/** Bulk operation filter details. */
export class IssueFilterForBulkPropertyDelete implements IIssueFilterForBulkPropertyDelete {
    /** The value of properties to perform the bulk operation on. */
    currentValue?: any;
    /** List of issues to perform the bulk delete operation on. */
    entityIds?: number[];

    constructor(data?: IIssueFilterForBulkPropertyDelete) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentValue = _data["currentValue"];
            if (Array.isArray(_data["entityIds"])) {
                this.entityIds = [] as any;
                for (let item of _data["entityIds"])
                    this.entityIds!.push(item);
            }
        }
    }

    static fromJS(data: any): IssueFilterForBulkPropertyDelete {
        data = typeof data === 'object' ? data : {};
        let result = new IssueFilterForBulkPropertyDelete();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentValue"] = this.currentValue;
        if (Array.isArray(this.entityIds)) {
            data["entityIds"] = [];
            for (let item of this.entityIds)
                data["entityIds"].push(item);
        }
        return data;
    }
}

/** Bulk operation filter details. */
export interface IIssueFilterForBulkPropertyDelete {
    /** The value of properties to perform the bulk operation on. */
    currentValue?: any;
    /** List of issues to perform the bulk delete operation on. */
    entityIds?: number[];
}

/** Bulk operation filter details. */
export class IssueFilterForBulkPropertySet implements IIssueFilterForBulkPropertySet {
    /** The value of properties to perform the bulk operation on. */
    currentValue?: any;
    /** List of issues to perform the bulk operation on. */
    entityIds?: number[];
    /** Whether the bulk operation occurs only when the property is present on or absent from an issue. */
    hasProperty?: boolean;

    constructor(data?: IIssueFilterForBulkPropertySet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentValue = _data["currentValue"];
            if (Array.isArray(_data["entityIds"])) {
                this.entityIds = [] as any;
                for (let item of _data["entityIds"])
                    this.entityIds!.push(item);
            }
            this.hasProperty = _data["hasProperty"];
        }
    }

    static fromJS(data: any): IssueFilterForBulkPropertySet {
        data = typeof data === 'object' ? data : {};
        let result = new IssueFilterForBulkPropertySet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentValue"] = this.currentValue;
        if (Array.isArray(this.entityIds)) {
            data["entityIds"] = [];
            for (let item of this.entityIds)
                data["entityIds"].push(item);
        }
        data["hasProperty"] = this.hasProperty;
        return data;
    }
}

/** Bulk operation filter details. */
export interface IIssueFilterForBulkPropertySet {
    /** The value of properties to perform the bulk operation on. */
    currentValue?: any;
    /** List of issues to perform the bulk operation on. */
    entityIds?: number[];
    /** Whether the bulk operation occurs only when the property is present on or absent from an issue. */
    hasProperty?: boolean;
}

/** Defines the payload to configure the issue layout item for a project. */
export class IssueLayouItemtPayload implements IIssueLayouItemtPayload {
    itemKey?: ProjectCreateResourceIdentifier;
    /** The item section type */
    sectionType?: IssueLayouItemtPayloadSectionType;
    /** The item type. Currently only support FIELD */
    type?: IssueLayouItemtPayloadType;

    constructor(data?: IIssueLayouItemtPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemKey = _data["itemKey"] ? ProjectCreateResourceIdentifier.fromJS(_data["itemKey"]) : <any>undefined;
            this.sectionType = _data["sectionType"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): IssueLayouItemtPayload {
        data = typeof data === 'object' ? data : {};
        let result = new IssueLayouItemtPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemKey"] = this.itemKey ? this.itemKey.toJSON() : <any>undefined;
        data["sectionType"] = this.sectionType;
        data["type"] = this.type;
        return data;
    }
}

/** Defines the payload to configure the issue layout item for a project. */
export interface IIssueLayouItemtPayload {
    itemKey?: ProjectCreateResourceIdentifier;
    /** The item section type */
    sectionType?: IssueLayouItemtPayloadSectionType;
    /** The item type. Currently only support FIELD */
    type?: IssueLayouItemtPayloadType;
}

/** Defines the payload to configure the issue layouts for a project. */
export class IssueLayoutPayload implements IIssueLayoutPayload {
    containerId?: ProjectCreateResourceIdentifier;
    /** The issue layout type */
    issueLayoutType?: IssueLayoutPayloadIssueLayoutType;
    /** The configuration of items in the issue layout */
    items?: IssueLayouItemtPayload[];
    pcri?: ProjectCreateResourceIdentifier;

    constructor(data?: IIssueLayoutPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.containerId = _data["containerId"] ? ProjectCreateResourceIdentifier.fromJS(_data["containerId"]) : <any>undefined;
            this.issueLayoutType = _data["issueLayoutType"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IssueLayouItemtPayload.fromJS(item));
            }
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IssueLayoutPayload {
        data = typeof data === 'object' ? data : {};
        let result = new IssueLayoutPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["containerId"] = this.containerId ? this.containerId.toJSON() : <any>undefined;
        data["issueLayoutType"] = this.issueLayoutType;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        return data;
    }
}

/** Defines the payload to configure the issue layouts for a project. */
export interface IIssueLayoutPayload {
    containerId?: ProjectCreateResourceIdentifier;
    /** The issue layout type */
    issueLayoutType?: IssueLayoutPayloadIssueLayoutType;
    /** The configuration of items in the issue layout */
    items?: IssueLayouItemtPayload[];
    pcri?: ProjectCreateResourceIdentifier;
}

export class IssueLimitReportResponseBean implements IIssueLimitReportResponseBean {
    /** A list of ids of issues approaching the limit and their field count */
    issuesApproachingLimit?: { [key: string]: { [key: string]: number; }; };
    /** A list of ids of issues breaching the limit and their field count */
    issuesBreachingLimit?: { [key: string]: { [key: string]: number; }; };
    /** The fields and their defined limits */
    limits?: { [key: string]: number; };

    constructor(data?: IIssueLimitReportResponseBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["issuesApproachingLimit"]) {
                this.issuesApproachingLimit = {} as any;
                for (let key in _data["issuesApproachingLimit"]) {
                    if (_data["issuesApproachingLimit"].hasOwnProperty(key))
                        (<any>this.issuesApproachingLimit)![key] = _data["issuesApproachingLimit"][key] !== undefined ? _data["issuesApproachingLimit"][key] : {};
                }
            }
            if (_data["issuesBreachingLimit"]) {
                this.issuesBreachingLimit = {} as any;
                for (let key in _data["issuesBreachingLimit"]) {
                    if (_data["issuesBreachingLimit"].hasOwnProperty(key))
                        (<any>this.issuesBreachingLimit)![key] = _data["issuesBreachingLimit"][key] !== undefined ? _data["issuesBreachingLimit"][key] : {};
                }
            }
            if (_data["limits"]) {
                this.limits = {} as any;
                for (let key in _data["limits"]) {
                    if (_data["limits"].hasOwnProperty(key))
                        (<any>this.limits)![key] = _data["limits"][key];
                }
            }
        }
    }

    static fromJS(data: any): IssueLimitReportResponseBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueLimitReportResponseBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.issuesApproachingLimit) {
            data["issuesApproachingLimit"] = {};
            for (let key in this.issuesApproachingLimit) {
                if (this.issuesApproachingLimit.hasOwnProperty(key))
                    (<any>data["issuesApproachingLimit"])[key] = (<any>this.issuesApproachingLimit)[key];
            }
        }
        if (this.issuesBreachingLimit) {
            data["issuesBreachingLimit"] = {};
            for (let key in this.issuesBreachingLimit) {
                if (this.issuesBreachingLimit.hasOwnProperty(key))
                    (<any>data["issuesBreachingLimit"])[key] = (<any>this.issuesBreachingLimit)[key];
            }
        }
        if (this.limits) {
            data["limits"] = {};
            for (let key in this.limits) {
                if (this.limits.hasOwnProperty(key))
                    (<any>data["limits"])[key] = (<any>this.limits)[key];
            }
        }
        return data;
    }
}

export interface IIssueLimitReportResponseBean {
    /** A list of ids of issues approaching the limit and their field count */
    issuesApproachingLimit?: { [key: string]: { [key: string]: number; }; };
    /** A list of ids of issues breaching the limit and their field count */
    issuesBreachingLimit?: { [key: string]: { [key: string]: number; }; };
    /** The fields and their defined limits */
    limits?: { [key: string]: number; };
}

/** Details of a link between issues. */
export class IssueLink implements IIssueLink {
    /** The ID of the issue link. */
    readonly id?: string;
    /** Provides details about the linked issue. If presenting this link in a user interface, use the `inward` field of the issue link type to label the link. */
    inwardIssue!: LinkedIssue;
    /** Provides details about the linked issue. If presenting this link in a user interface, use the `outward` field of the issue link type to label the link. */
    outwardIssue!: LinkedIssue;
    /** The URL of the issue link. */
    readonly self?: string;
    /** The type of link between the issues. */
    type!: IssueLinkType;

    constructor(data?: IIssueLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.inwardIssue = new LinkedIssue();
            this.outwardIssue = new LinkedIssue();
            this.type = new IssueLinkType();
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.inwardIssue = _data["inwardIssue"] ? LinkedIssue.fromJS(_data["inwardIssue"]) : new LinkedIssue();
            this.outwardIssue = _data["outwardIssue"] ? LinkedIssue.fromJS(_data["outwardIssue"]) : new LinkedIssue();
            (<any>this).self = _data["self"];
            this.type = _data["type"] ? IssueLinkType.fromJS(_data["type"]) : new IssueLinkType();
        }
    }

    static fromJS(data: any): IssueLink {
        data = typeof data === 'object' ? data : {};
        let result = new IssueLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["inwardIssue"] = this.inwardIssue ? this.inwardIssue.toJSON() : <any>undefined;
        data["outwardIssue"] = this.outwardIssue ? this.outwardIssue.toJSON() : <any>undefined;
        data["self"] = this.self;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        return data;
    }
}

/** Details of a link between issues. */
export interface IIssueLink {
    /** The ID of the issue link. */
    id?: string;
    /** Provides details about the linked issue. If presenting this link in a user interface, use the `inward` field of the issue link type to label the link. */
    inwardIssue: LinkedIssue;
    /** Provides details about the linked issue. If presenting this link in a user interface, use the `outward` field of the issue link type to label the link. */
    outwardIssue: LinkedIssue;
    /** The URL of the issue link. */
    self?: string;
    /** The type of link between the issues. */
    type: IssueLinkType;
}

/** This object is used as follows: *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it defines and reports on the type of link between the issues. Find a list of issue link types with [Get issue link types](#api-rest-api-3-issueLinkType-get). *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it defines and reports on issue link types. */
export class IssueLinkType implements IIssueLinkType {
    /** The ID of the issue link type and is used as follows:

 *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is the type of issue link. Required on create when `name` isn't provided. Otherwise, read only.
 *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it is read only. */
    id?: string;
    /** The description of the issue link type inward link and is used as follows:

 *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is read only.
 *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it is required on create and optional on update. Otherwise, read only. */
    inward?: string;
    /** The name of the issue link type and is used as follows:

 *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is the type of issue link. Required on create when `id` isn't provided. Otherwise, read only.
 *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it is required on create and optional on update. Otherwise, read only. */
    name?: string;
    /** The description of the issue link type outward link and is used as follows:

 *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is read only.
 *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it is required on create and optional on update. Otherwise, read only. */
    outward?: string;
    /** The URL of the issue link type. Read only. */
    readonly self?: string;

    constructor(data?: IIssueLinkType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.inward = _data["inward"];
            this.name = _data["name"];
            this.outward = _data["outward"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): IssueLinkType {
        data = typeof data === 'object' ? data : {};
        let result = new IssueLinkType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["inward"] = this.inward;
        data["name"] = this.name;
        data["outward"] = this.outward;
        data["self"] = this.self;
        return data;
    }
}

/** This object is used as follows: *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it defines and reports on the type of link between the issues. Find a list of issue link types with [Get issue link types](#api-rest-api-3-issueLinkType-get). *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it defines and reports on issue link types. */
export interface IIssueLinkType {
    /** The ID of the issue link type and is used as follows:

 *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is the type of issue link. Required on create when `name` isn't provided. Otherwise, read only.
 *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it is read only. */
    id?: string;
    /** The description of the issue link type inward link and is used as follows:

 *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is read only.
 *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it is required on create and optional on update. Otherwise, read only. */
    inward?: string;
    /** The name of the issue link type and is used as follows:

 *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is the type of issue link. Required on create when `id` isn't provided. Otherwise, read only.
 *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it is required on create and optional on update. Otherwise, read only. */
    name?: string;
    /** The description of the issue link type outward link and is used as follows:

 *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is read only.
 *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it is required on create and optional on update. Otherwise, read only. */
    outward?: string;
    /** The URL of the issue link type. Read only. */
    self?: string;
}

/** A list of issue link type beans. */
export class IssueLinkTypes implements IIssueLinkTypes {
    /** The issue link type bean. */
    readonly issueLinkTypes?: IssueLinkType[];

    constructor(data?: IIssueLinkTypes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueLinkTypes"])) {
                (<any>this).issueLinkTypes = [] as any;
                for (let item of _data["issueLinkTypes"])
                    (<any>this).issueLinkTypes!.push(IssueLinkType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IssueLinkTypes {
        data = typeof data === 'object' ? data : {};
        let result = new IssueLinkTypes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueLinkTypes)) {
            data["issueLinkTypes"] = [];
            for (let item of this.issueLinkTypes)
                data["issueLinkTypes"].push(item.toJSON());
        }
        return data;
    }
}

/** A list of issue link type beans. */
export interface IIssueLinkTypes {
    /** The issue link type bean. */
    issueLinkTypes?: IssueLinkType[];
}

/** A list of issue IDs. */
export class IssueList implements IIssueList {
    /** The list of issue IDs. */
    issueIds!: string[];

    constructor(data?: IIssueList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueIds"])) {
                this.issueIds = [] as any;
                for (let item of _data["issueIds"])
                    this.issueIds!.push(item);
            }
        }
    }

    static fromJS(data: any): IssueList {
        data = typeof data === 'object' ? data : {};
        let result = new IssueList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueIds)) {
            data["issueIds"] = [];
            for (let item of this.issueIds)
                data["issueIds"].push(item);
        }
        return data;
    }
}

/** A list of issue IDs. */
export interface IIssueList {
    /** The list of issue IDs. */
    issueIds: string[];
}

/** A list of matched issues or errors for each JQL query, in the order the JQL queries were passed. */
export class IssueMatches implements IIssueMatches {
    matches!: IssueMatchesForJQL[];

    constructor(data?: IIssueMatches) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.matches = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["matches"])) {
                this.matches = [] as any;
                for (let item of _data["matches"])
                    this.matches!.push(IssueMatchesForJQL.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IssueMatches {
        data = typeof data === 'object' ? data : {};
        let result = new IssueMatches();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.matches)) {
            data["matches"] = [];
            for (let item of this.matches)
                data["matches"].push(item.toJSON());
        }
        return data;
    }
}

/** A list of matched issues or errors for each JQL query, in the order the JQL queries were passed. */
export interface IIssueMatches {
    matches: IssueMatchesForJQL[];
}

/** A list of the issues matched to a JQL query or details of errors encountered during matching. */
export class IssueMatchesForJQL implements IIssueMatchesForJQL {
    /** A list of errors. */
    errors!: string[];
    /** A list of issue IDs. */
    matchedIssues!: number[];

    constructor(data?: IIssueMatchesForJQL) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.errors = [];
            this.matchedIssues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            if (Array.isArray(_data["matchedIssues"])) {
                this.matchedIssues = [] as any;
                for (let item of _data["matchedIssues"])
                    this.matchedIssues!.push(item);
            }
        }
    }

    static fromJS(data: any): IssueMatchesForJQL {
        data = typeof data === 'object' ? data : {};
        let result = new IssueMatchesForJQL();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        if (Array.isArray(this.matchedIssues)) {
            data["matchedIssues"] = [];
            for (let item of this.matchedIssues)
                data["matchedIssues"].push(item);
        }
        return data;
    }
}

/** A list of the issues matched to a JQL query or details of errors encountered during matching. */
export interface IIssueMatchesForJQL {
    /** A list of errors. */
    errors: string[];
    /** A list of issue IDs. */
    matchedIssues: number[];
}

/** A list of issues suggested for use in auto-completion. */
export class IssuePickerSuggestions implements IIssuePickerSuggestions {
    /** A list of issues for an issue type suggested for use in auto-completion. */
    readonly sections?: IssuePickerSuggestionsIssueType[];

    constructor(data?: IIssuePickerSuggestions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sections"])) {
                (<any>this).sections = [] as any;
                for (let item of _data["sections"])
                    (<any>this).sections!.push(IssuePickerSuggestionsIssueType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IssuePickerSuggestions {
        data = typeof data === 'object' ? data : {};
        let result = new IssuePickerSuggestions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        return data;
    }
}

/** A list of issues suggested for use in auto-completion. */
export interface IIssuePickerSuggestions {
    /** A list of issues for an issue type suggested for use in auto-completion. */
    sections?: IssuePickerSuggestionsIssueType[];
}

/** A type of issue suggested for use in auto-completion. */
export class IssuePickerSuggestionsIssueType implements IIssuePickerSuggestionsIssueType {
    /** The ID of the type of issues suggested for use in auto-completion. */
    readonly id?: string;
    /** A list of issues suggested for use in auto-completion. */
    readonly issues?: SuggestedIssue[];
    /** The label of the type of issues suggested for use in auto-completion. */
    readonly label?: string;
    /** If no issue suggestions are found, returns a message indicating no suggestions were found, */
    readonly msg?: string;
    /** If issue suggestions are found, returns a message indicating the number of issues suggestions found and returned. */
    readonly sub?: string;

    constructor(data?: IIssuePickerSuggestionsIssueType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["issues"])) {
                (<any>this).issues = [] as any;
                for (let item of _data["issues"])
                    (<any>this).issues!.push(SuggestedIssue.fromJS(item));
            }
            (<any>this).label = _data["label"];
            (<any>this).msg = _data["msg"];
            (<any>this).sub = _data["sub"];
        }
    }

    static fromJS(data: any): IssuePickerSuggestionsIssueType {
        data = typeof data === 'object' ? data : {};
        let result = new IssuePickerSuggestionsIssueType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item.toJSON());
        }
        data["label"] = this.label;
        data["msg"] = this.msg;
        data["sub"] = this.sub;
        return data;
    }
}

/** A type of issue suggested for use in auto-completion. */
export interface IIssuePickerSuggestionsIssueType {
    /** The ID of the type of issues suggested for use in auto-completion. */
    id?: string;
    /** A list of issues suggested for use in auto-completion. */
    issues?: SuggestedIssue[];
    /** The label of the type of issues suggested for use in auto-completion. */
    label?: string;
    /** If no issue suggestions are found, returns a message indicating no suggestions were found, */
    msg?: string;
    /** If issue suggestions are found, returns a message indicating the number of issues suggestions found and returned. */
    sub?: string;
}

/** Issue security level member. */
export class IssueSecurityLevelMember implements IIssueSecurityLevelMember {
    /** The user or group being granted the permission. It consists of a `type` and a type-dependent `parameter`. See [Holder object](../api-group-permission-schemes/#holder-object) in *Get all permission schemes* for more information. */
    holder!: PermissionHolder;
    /** The ID of the issue security level member. */
    id!: number;
    /** The ID of the issue security level. */
    issueSecurityLevelId!: number;

    constructor(data?: IIssueSecurityLevelMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.holder = new PermissionHolder();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.holder = _data["holder"] ? PermissionHolder.fromJS(_data["holder"]) : new PermissionHolder();
            this.id = _data["id"];
            this.issueSecurityLevelId = _data["issueSecurityLevelId"];
        }
    }

    static fromJS(data: any): IssueSecurityLevelMember {
        data = typeof data === 'object' ? data : {};
        let result = new IssueSecurityLevelMember();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["holder"] = this.holder ? this.holder.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["issueSecurityLevelId"] = this.issueSecurityLevelId;
        return data;
    }
}

/** Issue security level member. */
export interface IIssueSecurityLevelMember {
    /** The user or group being granted the permission. It consists of a `type` and a type-dependent `parameter`. See [Holder object](../api-group-permission-schemes/#holder-object) in *Get all permission schemes* for more information. */
    holder: PermissionHolder;
    /** The ID of the issue security level member. */
    id: number;
    /** The ID of the issue security level. */
    issueSecurityLevelId: number;
}

/** Details about an project using security scheme mapping. */
export class IssueSecuritySchemeToProjectMapping implements IIssueSecuritySchemeToProjectMapping {
    readonly issueSecuritySchemeId?: string;
    readonly projectId?: string;

    [key: string]: any;

    constructor(data?: IIssueSecuritySchemeToProjectMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).issueSecuritySchemeId = _data["issueSecuritySchemeId"];
            (<any>this).projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): IssueSecuritySchemeToProjectMapping {
        data = typeof data === 'object' ? data : {};
        let result = new IssueSecuritySchemeToProjectMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["issueSecuritySchemeId"] = this.issueSecuritySchemeId;
        data["projectId"] = this.projectId;
        return data;
    }
}

/** Details about an project using security scheme mapping. */
export interface IIssueSecuritySchemeToProjectMapping {
    issueSecuritySchemeId?: string;
    projectId?: string;

    [key: string]: any;
}

/** Details of an issue transition. */
export class IssueTransition implements IIssueTransition {
    /** Expand options that include additional transition details in the response. */
    readonly expand?: string;
    /** Details of the fields associated with the issue transition screen. Use this information to populate `fields` and `update` in a transition request. */
    readonly fields?: { [key: string]: FieldMetadata; };
    /** Whether there is a screen associated with the issue transition. */
    readonly hasScreen?: boolean;
    /** The ID of the issue transition. Required when specifying a transition to undertake. */
    id?: string;
    /** Whether the transition is available to be performed. */
    readonly isAvailable?: boolean;
    /** Whether the issue has to meet criteria before the issue transition is applied. */
    readonly isConditional?: boolean;
    /** Whether the issue transition is global, that is, the transition is applied to issues regardless of their status. */
    readonly isGlobal?: boolean;
    /** Whether this is the initial issue transition for the workflow. */
    readonly isInitial?: boolean;
    looped?: boolean;
    /** The name of the issue transition. */
    readonly name?: string;
    /** Details of the issue status after the transition. */
    readonly to?: StatusDetails;

    [key: string]: any;

    constructor(data?: IIssueTransition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).expand = _data["expand"];
            if (_data["fields"]) {
                (<any>this).fields = {} as any;
                for (let key in _data["fields"]) {
                    if (_data["fields"].hasOwnProperty(key))
                        (<any>(<any>this).fields)![key] = _data["fields"][key] ? FieldMetadata.fromJS(_data["fields"][key]) : new FieldMetadata();
                }
            }
            (<any>this).hasScreen = _data["hasScreen"];
            this.id = _data["id"];
            (<any>this).isAvailable = _data["isAvailable"];
            (<any>this).isConditional = _data["isConditional"];
            (<any>this).isGlobal = _data["isGlobal"];
            (<any>this).isInitial = _data["isInitial"];
            this.looped = _data["looped"];
            (<any>this).name = _data["name"];
            (<any>this).to = _data["to"] ? StatusDetails.fromJS(_data["to"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IssueTransition {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTransition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["expand"] = this.expand;
        if (this.fields) {
            data["fields"] = {};
            for (let key in this.fields) {
                if (this.fields.hasOwnProperty(key))
                    (<any>data["fields"])[key] = this.fields[key] ? this.fields[key].toJSON() : <any>undefined;
            }
        }
        data["hasScreen"] = this.hasScreen;
        data["id"] = this.id;
        data["isAvailable"] = this.isAvailable;
        data["isConditional"] = this.isConditional;
        data["isGlobal"] = this.isGlobal;
        data["isInitial"] = this.isInitial;
        data["looped"] = this.looped;
        data["name"] = this.name;
        data["to"] = this.to ? this.to.toJSON() : <any>undefined;
        return data;
    }
}

/** Details of an issue transition. */
export interface IIssueTransition {
    /** Expand options that include additional transition details in the response. */
    expand?: string;
    /** Details of the fields associated with the issue transition screen. Use this information to populate `fields` and `update` in a transition request. */
    fields?: { [key: string]: FieldMetadata; };
    /** Whether there is a screen associated with the issue transition. */
    hasScreen?: boolean;
    /** The ID of the issue transition. Required when specifying a transition to undertake. */
    id?: string;
    /** Whether the transition is available to be performed. */
    isAvailable?: boolean;
    /** Whether the issue has to meet criteria before the issue transition is applied. */
    isConditional?: boolean;
    /** Whether the issue transition is global, that is, the transition is applied to issues regardless of their status. */
    isGlobal?: boolean;
    /** Whether this is the initial issue transition for the workflow. */
    isInitial?: boolean;
    looped?: boolean;
    /** The name of the issue transition. */
    name?: string;
    /** Details of the issue status after the transition. */
    to?: StatusDetails;

    [key: string]: any;
}

export class IssueTransitionStatus implements IIssueTransitionStatus {
    /** The unique ID of the status. */
    readonly statusId?: number;
    /** The name of the status. */
    readonly statusName?: string;

    constructor(data?: IIssueTransitionStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).statusId = _data["statusId"];
            (<any>this).statusName = _data["statusName"];
        }
    }

    static fromJS(data: any): IssueTransitionStatus {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTransitionStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusId"] = this.statusId;
        data["statusName"] = this.statusName;
        return data;
    }
}

export interface IIssueTransitionStatus {
    /** The unique ID of the status. */
    statusId?: number;
    /** The name of the status. */
    statusName?: string;
}

export class IssueTypeCreateBean implements IIssueTypeCreateBean {
    /** The description of the issue type. */
    description?: string;
    /** The hierarchy level of the issue type. Use:

 *  `-1` for Subtask.
 *  `0` for Base.

Defaults to `0`. */
    hierarchyLevel?: number;
    /** The unique name for the issue type. The maximum length is 60 characters. */
    name!: string;
    /** Deprecated. Use `hierarchyLevel` instead. See the [deprecation notice](https://community.developer.atlassian.com/t/deprecation-of-the-epic-link-parent-link-and-other-related-fields-in-rest-apis-and-webhooks/54048) for details.

Whether the issue type is `subtype` or `standard`. Defaults to `standard`. */
    type?: IssueTypeCreateBeanType;

    constructor(data?: IIssueTypeCreateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.hierarchyLevel = _data["hierarchyLevel"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): IssueTypeCreateBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeCreateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["hierarchyLevel"] = this.hierarchyLevel;
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

export interface IIssueTypeCreateBean {
    /** The description of the issue type. */
    description?: string;
    /** The hierarchy level of the issue type. Use:

 *  `-1` for Subtask.
 *  `0` for Base.

Defaults to `0`. */
    hierarchyLevel?: number;
    /** The unique name for the issue type. The maximum length is 60 characters. */
    name: string;
    /** Deprecated. Use `hierarchyLevel` instead. See the [deprecation notice](https://community.developer.atlassian.com/t/deprecation-of-the-epic-link-parent-link-and-other-related-fields-in-rest-apis-and-webhooks/54048) for details.

Whether the issue type is `subtype` or `standard`. Defaults to `standard`. */
    type?: IssueTypeCreateBeanType;
}

/** Details about an issue type. */
export class IssueTypeDetails implements IIssueTypeDetails {
    /** The ID of the issue type's avatar. */
    readonly avatarId?: number;
    /** The description of the issue type. */
    readonly description?: string;
    /** Unique ID for next-gen projects. */
    readonly entityId?: string;
    /** Hierarchy level of the issue type. */
    readonly hierarchyLevel?: number;
    /** The URL of the issue type's avatar. */
    readonly iconUrl?: string;
    /** The ID of the issue type. */
    readonly id?: string;
    /** The name of the issue type. */
    readonly name?: string;
    /** Details of the next-gen projects the issue type is available in. */
    readonly scope?: Scope;
    /** The URL of these issue type details. */
    readonly self?: string;
    /** Whether this issue type is used to create subtasks. */
    readonly subtask?: boolean;

    constructor(data?: IIssueTypeDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).avatarId = _data["avatarId"];
            (<any>this).description = _data["description"];
            (<any>this).entityId = _data["entityId"];
            (<any>this).hierarchyLevel = _data["hierarchyLevel"];
            (<any>this).iconUrl = _data["iconUrl"];
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            (<any>this).scope = _data["scope"] ? Scope.fromJS(_data["scope"]) : <any>undefined;
            (<any>this).self = _data["self"];
            (<any>this).subtask = _data["subtask"];
        }
    }

    static fromJS(data: any): IssueTypeDetails {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatarId"] = this.avatarId;
        data["description"] = this.description;
        data["entityId"] = this.entityId;
        data["hierarchyLevel"] = this.hierarchyLevel;
        data["iconUrl"] = this.iconUrl;
        data["id"] = this.id;
        data["name"] = this.name;
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        data["self"] = this.self;
        data["subtask"] = this.subtask;
        return data;
    }
}

/** Details about an issue type. */
export interface IIssueTypeDetails {
    /** The ID of the issue type's avatar. */
    avatarId?: number;
    /** The description of the issue type. */
    description?: string;
    /** Unique ID for next-gen projects. */
    entityId?: string;
    /** Hierarchy level of the issue type. */
    hierarchyLevel?: number;
    /** The URL of the issue type's avatar. */
    iconUrl?: string;
    /** The ID of the issue type. */
    id?: string;
    /** The name of the issue type. */
    name?: string;
    /** Details of the next-gen projects the issue type is available in. */
    scope?: Scope;
    /** The URL of these issue type details. */
    self?: string;
    /** Whether this issue type is used to create subtasks. */
    subtask?: boolean;
}

/** The payload for creating an issue type hierarchy */
export class IssueTypeHierarchyPayload implements IIssueTypeHierarchyPayload {
    /** The hierarchy level of the issue type. 0, 1, 2, 3 .. n; Negative values for subtasks */
    hierarchyLevel?: number;
    /** The name of the issue type */
    name?: string;
    /** The conflict strategy to use when the issue type already exists. FAIL - Fail execution, this always needs to be unique; USE - Use the existing entity and ignore new entity parameters */
    onConflict?: IssueTypeHierarchyPayloadOnConflict;
    pcri?: ProjectCreateResourceIdentifier;

    constructor(data?: IIssueTypeHierarchyPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hierarchyLevel = _data["hierarchyLevel"];
            this.name = _data["name"];
            this.onConflict = _data["onConflict"];
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IssueTypeHierarchyPayload {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeHierarchyPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hierarchyLevel"] = this.hierarchyLevel;
        data["name"] = this.name;
        data["onConflict"] = this.onConflict;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        return data;
    }
}

/** The payload for creating an issue type hierarchy */
export interface IIssueTypeHierarchyPayload {
    /** The hierarchy level of the issue type. 0, 1, 2, 3 .. n; Negative values for subtasks */
    hierarchyLevel?: number;
    /** The name of the issue type */
    name?: string;
    /** The conflict strategy to use when the issue type already exists. FAIL - Fail execution, this always needs to be unique; USE - Use the existing entity and ignore new entity parameters */
    onConflict?: IssueTypeHierarchyPayloadOnConflict;
    pcri?: ProjectCreateResourceIdentifier;
}

/** The list of issue type IDs. */
export class IssueTypeIds implements IIssueTypeIds {
    /** The list of issue type IDs. */
    issueTypeIds!: string[];

    constructor(data?: IIssueTypeIds) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueTypeIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueTypeIds"])) {
                this.issueTypeIds = [] as any;
                for (let item of _data["issueTypeIds"])
                    this.issueTypeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): IssueTypeIds {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeIds();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueTypeIds)) {
            data["issueTypeIds"] = [];
            for (let item of this.issueTypeIds)
                data["issueTypeIds"].push(item);
        }
        return data;
    }
}

/** The list of issue type IDs. */
export interface IIssueTypeIds {
    /** The list of issue type IDs. */
    issueTypeIds: string[];
}

/** The list of issue type IDs to be removed from the field configuration scheme. */
export class IssueTypeIdsToRemove implements IIssueTypeIdsToRemove {
    /** The list of issue type IDs. Must contain unique values not longer than 255 characters and not be empty. Maximum of 100 IDs. */
    issueTypeIds!: string[];

    constructor(data?: IIssueTypeIdsToRemove) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueTypeIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueTypeIds"])) {
                this.issueTypeIds = [] as any;
                for (let item of _data["issueTypeIds"])
                    this.issueTypeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): IssueTypeIdsToRemove {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeIdsToRemove();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueTypeIds)) {
            data["issueTypeIds"] = [];
            for (let item of this.issueTypeIds)
                data["issueTypeIds"].push(item);
        }
        return data;
    }
}

/** The list of issue type IDs to be removed from the field configuration scheme. */
export interface IIssueTypeIdsToRemove {
    /** The list of issue type IDs. Must contain unique values not longer than 255 characters and not be empty. Maximum of 100 IDs. */
    issueTypeIds: string[];
}

/** Details of an issue type. */
export class IssueTypeInfo implements IIssueTypeInfo {
    /** The avatar of the issue type. */
    readonly avatarId?: number;
    /** The ID of the issue type. */
    readonly id?: number;
    /** The name of the issue type. */
    readonly name?: string;

    constructor(data?: IIssueTypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).avatarId = _data["avatarId"];
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): IssueTypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatarId"] = this.avatarId;
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** Details of an issue type. */
export interface IIssueTypeInfo {
    /** The avatar of the issue type. */
    avatarId?: number;
    /** The ID of the issue type. */
    id?: number;
    /** The name of the issue type. */
    name?: string;
}

/** Details of the issue creation metadata for an issue type. */
export class IssueTypeIssueCreateMetadata implements IIssueTypeIssueCreateMetadata {
    /** The ID of the issue type's avatar. */
    readonly avatarId?: number;
    /** The description of the issue type. */
    readonly description?: string;
    /** Unique ID for next-gen projects. */
    readonly entityId?: string;
    /** Expand options that include additional issue type metadata details in the response. */
    readonly expand?: string;
    /** List of the fields available when creating an issue for the issue type. */
    readonly fields?: { [key: string]: FieldMetadata; };
    /** Hierarchy level of the issue type. */
    readonly hierarchyLevel?: number;
    /** The URL of the issue type's avatar. */
    readonly iconUrl?: string;
    /** The ID of the issue type. */
    readonly id?: string;
    /** The name of the issue type. */
    readonly name?: string;
    /** Details of the next-gen projects the issue type is available in. */
    readonly scope?: Scope;
    /** The URL of these issue type details. */
    readonly self?: string;
    /** Whether this issue type is used to create subtasks. */
    readonly subtask?: boolean;

    constructor(data?: IIssueTypeIssueCreateMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).avatarId = _data["avatarId"];
            (<any>this).description = _data["description"];
            (<any>this).entityId = _data["entityId"];
            (<any>this).expand = _data["expand"];
            if (_data["fields"]) {
                (<any>this).fields = {} as any;
                for (let key in _data["fields"]) {
                    if (_data["fields"].hasOwnProperty(key))
                        (<any>(<any>this).fields)![key] = _data["fields"][key] ? FieldMetadata.fromJS(_data["fields"][key]) : new FieldMetadata();
                }
            }
            (<any>this).hierarchyLevel = _data["hierarchyLevel"];
            (<any>this).iconUrl = _data["iconUrl"];
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            (<any>this).scope = _data["scope"] ? Scope.fromJS(_data["scope"]) : <any>undefined;
            (<any>this).self = _data["self"];
            (<any>this).subtask = _data["subtask"];
        }
    }

    static fromJS(data: any): IssueTypeIssueCreateMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeIssueCreateMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatarId"] = this.avatarId;
        data["description"] = this.description;
        data["entityId"] = this.entityId;
        data["expand"] = this.expand;
        if (this.fields) {
            data["fields"] = {};
            for (let key in this.fields) {
                if (this.fields.hasOwnProperty(key))
                    (<any>data["fields"])[key] = this.fields[key] ? this.fields[key].toJSON() : <any>undefined;
            }
        }
        data["hierarchyLevel"] = this.hierarchyLevel;
        data["iconUrl"] = this.iconUrl;
        data["id"] = this.id;
        data["name"] = this.name;
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        data["self"] = this.self;
        data["subtask"] = this.subtask;
        return data;
    }
}

/** Details of the issue creation metadata for an issue type. */
export interface IIssueTypeIssueCreateMetadata {
    /** The ID of the issue type's avatar. */
    avatarId?: number;
    /** The description of the issue type. */
    description?: string;
    /** Unique ID for next-gen projects. */
    entityId?: string;
    /** Expand options that include additional issue type metadata details in the response. */
    expand?: string;
    /** List of the fields available when creating an issue for the issue type. */
    fields?: { [key: string]: FieldMetadata; };
    /** Hierarchy level of the issue type. */
    hierarchyLevel?: number;
    /** The URL of the issue type's avatar. */
    iconUrl?: string;
    /** The ID of the issue type. */
    id?: string;
    /** The name of the issue type. */
    name?: string;
    /** Details of the next-gen projects the issue type is available in. */
    scope?: Scope;
    /** The URL of these issue type details. */
    self?: string;
    /** Whether this issue type is used to create subtasks. */
    subtask?: boolean;
}

/** The payload for creating an issue type */
export class IssueTypePayload implements IIssueTypePayload {
    /** The avatar ID of the issue type. Go to https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-avatars/\#api-rest-api-3-avatar-type-system-get to choose an avatarId existing in Jira */
    avatarId?: number | undefined;
    /** The description of the issue type */
    description?: string | undefined;
    /** The hierarchy level of the issue type. 0, 1, 2, 3 .. n; Negative values for subtasks */
    hierarchyLevel?: number;
    /** The name of the issue type */
    name?: string;
    /** The conflict strategy to use when the issue type already exists. FAIL - Fail execution, this always needs to be unique; USE - Use the existing entity and ignore new entity parameters */
    onConflict?: IssueTypePayloadOnConflict;
    pcri?: ProjectCreateResourceIdentifier;

    constructor(data?: IIssueTypePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.avatarId = _data["avatarId"];
            this.description = _data["description"];
            this.hierarchyLevel = _data["hierarchyLevel"];
            this.name = _data["name"];
            this.onConflict = _data["onConflict"];
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IssueTypePayload {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatarId"] = this.avatarId;
        data["description"] = this.description;
        data["hierarchyLevel"] = this.hierarchyLevel;
        data["name"] = this.name;
        data["onConflict"] = this.onConflict;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        return data;
    }
}

/** The payload for creating an issue type */
export interface IIssueTypePayload {
    /** The avatar ID of the issue type. Go to https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-avatars/\#api-rest-api-3-avatar-type-system-get to choose an avatarId existing in Jira */
    avatarId?: number | undefined;
    /** The description of the issue type */
    description?: string | undefined;
    /** The hierarchy level of the issue type. 0, 1, 2, 3 .. n; Negative values for subtasks */
    hierarchyLevel?: number;
    /** The name of the issue type */
    name?: string;
    /** The conflict strategy to use when the issue type already exists. FAIL - Fail execution, this always needs to be unique; USE - Use the existing entity and ignore new entity parameters */
    onConflict?: IssueTypePayloadOnConflict;
    pcri?: ProjectCreateResourceIdentifier;
}

/** The payload for creating issue types in a project */
export class IssueTypeProjectCreatePayload implements IIssueTypeProjectCreatePayload {
    /** Defines the issue type hierarhy to be created and used during this project creation. This will only add new levels if there isn't an existing level */
    issueTypeHierarchy?: (IssueTypeHierarchyPayload | undefined)[] | undefined;
    issueTypeScheme?: IssueTypeSchemePayload;
    /** Only needed if you want to create issue types, you can otherwise use the ids of issue types in the scheme configuration */
    issueTypes?: (IssueTypePayload | undefined)[] | undefined;

    constructor(data?: IIssueTypeProjectCreatePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueTypeHierarchy"])) {
                this.issueTypeHierarchy = [] as any;
                for (let item of _data["issueTypeHierarchy"])
                    this.issueTypeHierarchy!.push(IssueTypeHierarchyPayload.fromJS(item));
            }
            this.issueTypeScheme = _data["issueTypeScheme"] ? IssueTypeSchemePayload.fromJS(_data["issueTypeScheme"]) : <any>undefined;
            if (Array.isArray(_data["issueTypes"])) {
                this.issueTypes = [] as any;
                for (let item of _data["issueTypes"])
                    this.issueTypes!.push(IssueTypePayload.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IssueTypeProjectCreatePayload {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeProjectCreatePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueTypeHierarchy)) {
            data["issueTypeHierarchy"] = [];
            for (let item of this.issueTypeHierarchy)
                data["issueTypeHierarchy"].push(item.toJSON());
        }
        data["issueTypeScheme"] = this.issueTypeScheme ? this.issueTypeScheme.toJSON() : <any>undefined;
        if (Array.isArray(this.issueTypes)) {
            data["issueTypes"] = [];
            for (let item of this.issueTypes)
                data["issueTypes"].push(item.toJSON());
        }
        return data;
    }
}

/** The payload for creating issue types in a project */
export interface IIssueTypeProjectCreatePayload {
    /** Defines the issue type hierarhy to be created and used during this project creation. This will only add new levels if there isn't an existing level */
    issueTypeHierarchy?: (IssueTypeHierarchyPayload | undefined)[] | undefined;
    issueTypeScheme?: IssueTypeSchemePayload;
    /** Only needed if you want to create issue types, you can otherwise use the ids of issue types in the scheme configuration */
    issueTypes?: (IssueTypePayload | undefined)[] | undefined;
}

/** Details of an issue type scheme. */
export class IssueTypeScheme implements IIssueTypeScheme {
    /** The ID of the default issue type of the issue type scheme. */
    defaultIssueTypeId?: string;
    /** The description of the issue type scheme. */
    description?: string;
    /** The ID of the issue type scheme. */
    id!: string;
    /** Whether the issue type scheme is the default. */
    isDefault?: boolean;
    /** The name of the issue type scheme. */
    name!: string;

    constructor(data?: IIssueTypeScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultIssueTypeId = _data["defaultIssueTypeId"];
            this.description = _data["description"];
            this.id = _data["id"];
            this.isDefault = _data["isDefault"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IssueTypeScheme {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultIssueTypeId"] = this.defaultIssueTypeId;
        data["description"] = this.description;
        data["id"] = this.id;
        data["isDefault"] = this.isDefault;
        data["name"] = this.name;
        return data;
    }
}

/** Details of an issue type scheme. */
export interface IIssueTypeScheme {
    /** The ID of the default issue type of the issue type scheme. */
    defaultIssueTypeId?: string;
    /** The description of the issue type scheme. */
    description?: string;
    /** The ID of the issue type scheme. */
    id: string;
    /** Whether the issue type scheme is the default. */
    isDefault?: boolean;
    /** The name of the issue type scheme. */
    name: string;
}

/** Details of an issue type scheme and its associated issue types. */
export class IssueTypeSchemeDetails implements IIssueTypeSchemeDetails {
    /** The ID of the default issue type of the issue type scheme. This ID must be included in `issueTypeIds`. */
    defaultIssueTypeId?: string;
    /** The description of the issue type scheme. The maximum length is 4000 characters. */
    description?: string;
    /** The list of issue types IDs of the issue type scheme. At least one standard issue type ID is required. */
    issueTypeIds!: string[];
    /** The name of the issue type scheme. The name must be unique. The maximum length is 255 characters. */
    name!: string;

    constructor(data?: IIssueTypeSchemeDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueTypeIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultIssueTypeId = _data["defaultIssueTypeId"];
            this.description = _data["description"];
            if (Array.isArray(_data["issueTypeIds"])) {
                this.issueTypeIds = [] as any;
                for (let item of _data["issueTypeIds"])
                    this.issueTypeIds!.push(item);
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IssueTypeSchemeDetails {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeSchemeDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultIssueTypeId"] = this.defaultIssueTypeId;
        data["description"] = this.description;
        if (Array.isArray(this.issueTypeIds)) {
            data["issueTypeIds"] = [];
            for (let item of this.issueTypeIds)
                data["issueTypeIds"].push(item);
        }
        data["name"] = this.name;
        return data;
    }
}

/** Details of an issue type scheme and its associated issue types. */
export interface IIssueTypeSchemeDetails {
    /** The ID of the default issue type of the issue type scheme. This ID must be included in `issueTypeIds`. */
    defaultIssueTypeId?: string;
    /** The description of the issue type scheme. The maximum length is 4000 characters. */
    description?: string;
    /** The list of issue types IDs of the issue type scheme. At least one standard issue type ID is required. */
    issueTypeIds: string[];
    /** The name of the issue type scheme. The name must be unique. The maximum length is 255 characters. */
    name: string;
}

/** The ID of an issue type scheme. */
export class IssueTypeSchemeID implements IIssueTypeSchemeID {
    /** The ID of the issue type scheme. */
    readonly issueTypeSchemeId!: string;

    constructor(data?: IIssueTypeSchemeID) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).issueTypeSchemeId = _data["issueTypeSchemeId"];
        }
    }

    static fromJS(data: any): IssueTypeSchemeID {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeSchemeID();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueTypeSchemeId"] = this.issueTypeSchemeId;
        return data;
    }
}

/** The ID of an issue type scheme. */
export interface IIssueTypeSchemeID {
    /** The ID of the issue type scheme. */
    issueTypeSchemeId: string;
}

/** Issue type scheme item. */
export class IssueTypeSchemeMapping implements IIssueTypeSchemeMapping {
    /** The ID of the issue type. */
    issueTypeId!: string;
    /** The ID of the issue type scheme. */
    issueTypeSchemeId!: string;

    constructor(data?: IIssueTypeSchemeMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueTypeId = _data["issueTypeId"];
            this.issueTypeSchemeId = _data["issueTypeSchemeId"];
        }
    }

    static fromJS(data: any): IssueTypeSchemeMapping {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeSchemeMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueTypeId"] = this.issueTypeId;
        data["issueTypeSchemeId"] = this.issueTypeSchemeId;
        return data;
    }
}

/** Issue type scheme item. */
export interface IIssueTypeSchemeMapping {
    /** The ID of the issue type. */
    issueTypeId: string;
    /** The ID of the issue type scheme. */
    issueTypeSchemeId: string;
}

/** The payload for creating issue type schemes */
export class IssueTypeSchemePayload implements IIssueTypeSchemePayload {
    defaultIssueTypeId?: ProjectCreateResourceIdentifier;
    /** The description of the issue type scheme */
    description?: string | undefined;
    /** The issue type IDs for the issue type scheme */
    issueTypeIds?: ProjectCreateResourceIdentifier[];
    /** The name of the issue type scheme */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;

    constructor(data?: IIssueTypeSchemePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultIssueTypeId = _data["defaultIssueTypeId"] ? ProjectCreateResourceIdentifier.fromJS(_data["defaultIssueTypeId"]) : <any>undefined;
            this.description = _data["description"];
            if (Array.isArray(_data["issueTypeIds"])) {
                this.issueTypeIds = [] as any;
                for (let item of _data["issueTypeIds"])
                    this.issueTypeIds!.push(ProjectCreateResourceIdentifier.fromJS(item));
            }
            this.name = _data["name"];
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IssueTypeSchemePayload {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeSchemePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultIssueTypeId"] = this.defaultIssueTypeId ? this.defaultIssueTypeId.toJSON() : <any>undefined;
        data["description"] = this.description;
        if (Array.isArray(this.issueTypeIds)) {
            data["issueTypeIds"] = [];
            for (let item of this.issueTypeIds)
                data["issueTypeIds"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        return data;
    }
}

/** The payload for creating issue type schemes */
export interface IIssueTypeSchemePayload {
    defaultIssueTypeId?: ProjectCreateResourceIdentifier;
    /** The description of the issue type scheme */
    description?: string | undefined;
    /** The issue type IDs for the issue type scheme */
    issueTypeIds?: ProjectCreateResourceIdentifier[];
    /** The name of the issue type scheme */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;
}

/** Details of the association between an issue type scheme and project. */
export class IssueTypeSchemeProjectAssociation implements IIssueTypeSchemeProjectAssociation {
    /** The ID of the issue type scheme. */
    issueTypeSchemeId!: string;
    /** The ID of the project. */
    projectId!: string;

    constructor(data?: IIssueTypeSchemeProjectAssociation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueTypeSchemeId = _data["issueTypeSchemeId"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): IssueTypeSchemeProjectAssociation {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeSchemeProjectAssociation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueTypeSchemeId"] = this.issueTypeSchemeId;
        data["projectId"] = this.projectId;
        return data;
    }
}

/** Details of the association between an issue type scheme and project. */
export interface IIssueTypeSchemeProjectAssociation {
    /** The ID of the issue type scheme. */
    issueTypeSchemeId: string;
    /** The ID of the project. */
    projectId: string;
}

/** Issue type scheme with a list of the projects that use it. */
export class IssueTypeSchemeProjects implements IIssueTypeSchemeProjects {
    /** Details of an issue type scheme. */
    issueTypeScheme!: IssueTypeScheme;
    /** The IDs of the projects using the issue type scheme. */
    projectIds!: string[];

    constructor(data?: IIssueTypeSchemeProjects) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueTypeScheme = new IssueTypeScheme();
            this.projectIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueTypeScheme = _data["issueTypeScheme"] ? IssueTypeScheme.fromJS(_data["issueTypeScheme"]) : new IssueTypeScheme();
            if (Array.isArray(_data["projectIds"])) {
                this.projectIds = [] as any;
                for (let item of _data["projectIds"])
                    this.projectIds!.push(item);
            }
        }
    }

    static fromJS(data: any): IssueTypeSchemeProjects {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeSchemeProjects();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueTypeScheme"] = this.issueTypeScheme ? this.issueTypeScheme.toJSON() : <any>undefined;
        if (Array.isArray(this.projectIds)) {
            data["projectIds"] = [];
            for (let item of this.projectIds)
                data["projectIds"].push(item);
        }
        return data;
    }
}

/** Issue type scheme with a list of the projects that use it. */
export interface IIssueTypeSchemeProjects {
    /** Details of an issue type scheme. */
    issueTypeScheme: IssueTypeScheme;
    /** The IDs of the projects using the issue type scheme. */
    projectIds: string[];
}

/** Details of the name, description, and default issue type for an issue type scheme. */
export class IssueTypeSchemeUpdateDetails implements IIssueTypeSchemeUpdateDetails {
    /** The ID of the default issue type of the issue type scheme. */
    defaultIssueTypeId?: string;
    /** The description of the issue type scheme. The maximum length is 4000 characters. */
    description?: string;
    /** The name of the issue type scheme. The name must be unique. The maximum length is 255 characters. */
    name?: string;

    constructor(data?: IIssueTypeSchemeUpdateDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultIssueTypeId = _data["defaultIssueTypeId"];
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IssueTypeSchemeUpdateDetails {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeSchemeUpdateDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultIssueTypeId"] = this.defaultIssueTypeId;
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

/** Details of the name, description, and default issue type for an issue type scheme. */
export interface IIssueTypeSchemeUpdateDetails {
    /** The ID of the default issue type of the issue type scheme. */
    defaultIssueTypeId?: string;
    /** The description of the issue type scheme. The maximum length is 4000 characters. */
    description?: string;
    /** The name of the issue type scheme. The name must be unique. The maximum length is 255 characters. */
    name?: string;
}

/** Details of an issue type screen scheme. */
export class IssueTypeScreenScheme implements IIssueTypeScreenScheme {
    /** The description of the issue type screen scheme. */
    description?: string;
    /** The ID of the issue type screen scheme. */
    id!: string;
    /** The name of the issue type screen scheme. */
    name!: string;

    constructor(data?: IIssueTypeScreenScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IssueTypeScreenScheme {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeScreenScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** Details of an issue type screen scheme. */
export interface IIssueTypeScreenScheme {
    /** The description of the issue type screen scheme. */
    description?: string;
    /** The ID of the issue type screen scheme. */
    id: string;
    /** The name of the issue type screen scheme. */
    name: string;
}

/** The details of an issue type screen scheme. */
export class IssueTypeScreenSchemeDetails implements IIssueTypeScreenSchemeDetails {
    /** The description of the issue type screen scheme. The maximum length is 255 characters. */
    description?: string;
    /** The IDs of the screen schemes for the issue type IDs and *default*. A *default* entry is required to create an issue type screen scheme, it defines the mapping for all issue types without a screen scheme. */
    issueTypeMappings!: IssueTypeScreenSchemeMapping[];
    /** The name of the issue type screen scheme. The name must be unique. The maximum length is 255 characters. */
    name!: string;

    constructor(data?: IIssueTypeScreenSchemeDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueTypeMappings = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            if (Array.isArray(_data["issueTypeMappings"])) {
                this.issueTypeMappings = [] as any;
                for (let item of _data["issueTypeMappings"])
                    this.issueTypeMappings!.push(IssueTypeScreenSchemeMapping.fromJS(item));
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IssueTypeScreenSchemeDetails {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeScreenSchemeDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        if (Array.isArray(this.issueTypeMappings)) {
            data["issueTypeMappings"] = [];
            for (let item of this.issueTypeMappings)
                data["issueTypeMappings"].push(item.toJSON());
        }
        data["name"] = this.name;
        return data;
    }
}

/** The details of an issue type screen scheme. */
export interface IIssueTypeScreenSchemeDetails {
    /** The description of the issue type screen scheme. The maximum length is 255 characters. */
    description?: string;
    /** The IDs of the screen schemes for the issue type IDs and *default*. A *default* entry is required to create an issue type screen scheme, it defines the mapping for all issue types without a screen scheme. */
    issueTypeMappings: IssueTypeScreenSchemeMapping[];
    /** The name of the issue type screen scheme. The name must be unique. The maximum length is 255 characters. */
    name: string;
}

/** The ID of an issue type screen scheme. */
export class IssueTypeScreenSchemeId implements IIssueTypeScreenSchemeId {
    /** The ID of the issue type screen scheme. */
    readonly id!: string;

    constructor(data?: IIssueTypeScreenSchemeId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
        }
    }

    static fromJS(data: any): IssueTypeScreenSchemeId {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeScreenSchemeId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** The ID of an issue type screen scheme. */
export interface IIssueTypeScreenSchemeId {
    /** The ID of the issue type screen scheme. */
    id: string;
}

/** The screen scheme for an issue type. */
export class IssueTypeScreenSchemeItem implements IIssueTypeScreenSchemeItem {
    /** The ID of the issue type or *default*. Only issue types used in classic projects are accepted. When creating an issue screen scheme, an entry for *default* must be provided and defines the mapping for all issue types without a screen scheme. Otherwise, a *default* entry can't be provided. */
    issueTypeId!: string;
    /** The ID of the issue type screen scheme. */
    issueTypeScreenSchemeId!: string;
    /** The ID of the screen scheme. */
    screenSchemeId!: string;

    constructor(data?: IIssueTypeScreenSchemeItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueTypeId = _data["issueTypeId"];
            this.issueTypeScreenSchemeId = _data["issueTypeScreenSchemeId"];
            this.screenSchemeId = _data["screenSchemeId"];
        }
    }

    static fromJS(data: any): IssueTypeScreenSchemeItem {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeScreenSchemeItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueTypeId"] = this.issueTypeId;
        data["issueTypeScreenSchemeId"] = this.issueTypeScreenSchemeId;
        data["screenSchemeId"] = this.screenSchemeId;
        return data;
    }
}

/** The screen scheme for an issue type. */
export interface IIssueTypeScreenSchemeItem {
    /** The ID of the issue type or *default*. Only issue types used in classic projects are accepted. When creating an issue screen scheme, an entry for *default* must be provided and defines the mapping for all issue types without a screen scheme. Otherwise, a *default* entry can't be provided. */
    issueTypeId: string;
    /** The ID of the issue type screen scheme. */
    issueTypeScreenSchemeId: string;
    /** The ID of the screen scheme. */
    screenSchemeId: string;
}

/** The IDs of the screen schemes for the issue type IDs. */
export class IssueTypeScreenSchemeMapping implements IIssueTypeScreenSchemeMapping {
    /** The ID of the issue type or *default*. Only issue types used in classic projects are accepted. An entry for *default* must be provided and defines the mapping for all issue types without a screen scheme. */
    issueTypeId!: string;
    /** The ID of the screen scheme. Only screen schemes used in classic projects are accepted. */
    screenSchemeId!: string;

    constructor(data?: IIssueTypeScreenSchemeMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueTypeId = _data["issueTypeId"];
            this.screenSchemeId = _data["screenSchemeId"];
        }
    }

    static fromJS(data: any): IssueTypeScreenSchemeMapping {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeScreenSchemeMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueTypeId"] = this.issueTypeId;
        data["screenSchemeId"] = this.screenSchemeId;
        return data;
    }
}

/** The IDs of the screen schemes for the issue type IDs. */
export interface IIssueTypeScreenSchemeMapping {
    /** The ID of the issue type or *default*. Only issue types used in classic projects are accepted. An entry for *default* must be provided and defines the mapping for all issue types without a screen scheme. */
    issueTypeId: string;
    /** The ID of the screen scheme. Only screen schemes used in classic projects are accepted. */
    screenSchemeId: string;
}

/** A list of issue type screen scheme mappings. */
export class IssueTypeScreenSchemeMappingDetails implements IIssueTypeScreenSchemeMappingDetails {
    /** The list of issue type to screen scheme mappings. A *default* entry cannot be specified because a default entry is added when an issue type screen scheme is created. */
    issueTypeMappings!: IssueTypeScreenSchemeMapping[];

    constructor(data?: IIssueTypeScreenSchemeMappingDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueTypeMappings = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueTypeMappings"])) {
                this.issueTypeMappings = [] as any;
                for (let item of _data["issueTypeMappings"])
                    this.issueTypeMappings!.push(IssueTypeScreenSchemeMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IssueTypeScreenSchemeMappingDetails {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeScreenSchemeMappingDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueTypeMappings)) {
            data["issueTypeMappings"] = [];
            for (let item of this.issueTypeMappings)
                data["issueTypeMappings"].push(item.toJSON());
        }
        return data;
    }
}

/** A list of issue type screen scheme mappings. */
export interface IIssueTypeScreenSchemeMappingDetails {
    /** The list of issue type to screen scheme mappings. A *default* entry cannot be specified because a default entry is added when an issue type screen scheme is created. */
    issueTypeMappings: IssueTypeScreenSchemeMapping[];
}

/** Defines the payload for the issue type screen schemes. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-type-screen-schemes/\#api-rest-api-3-issuetypescreenscheme-post */
export class IssueTypeScreenSchemePayload implements IIssueTypeScreenSchemePayload {
    defaultScreenScheme?: ProjectCreateResourceIdentifier;
    /** The description of the issue type screen scheme */
    description?: string;
    /** The IDs of the screen schemes for the issue type IDs and default. A default entry is required to create an issue type screen scheme, it defines the mapping for all issue types without a screen scheme. */
    explicitMappings?: { [key: string]: ProjectCreateResourceIdentifier; };
    /** The name of the issue type screen scheme */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;

    constructor(data?: IIssueTypeScreenSchemePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultScreenScheme = _data["defaultScreenScheme"] ? ProjectCreateResourceIdentifier.fromJS(_data["defaultScreenScheme"]) : <any>undefined;
            this.description = _data["description"];
            if (_data["explicitMappings"]) {
                this.explicitMappings = {} as any;
                for (let key in _data["explicitMappings"]) {
                    if (_data["explicitMappings"].hasOwnProperty(key))
                        (<any>this.explicitMappings)![key] = _data["explicitMappings"][key] ? ProjectCreateResourceIdentifier.fromJS(_data["explicitMappings"][key]) : new ProjectCreateResourceIdentifier();
                }
            }
            this.name = _data["name"];
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IssueTypeScreenSchemePayload {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeScreenSchemePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultScreenScheme"] = this.defaultScreenScheme ? this.defaultScreenScheme.toJSON() : <any>undefined;
        data["description"] = this.description;
        if (this.explicitMappings) {
            data["explicitMappings"] = {};
            for (let key in this.explicitMappings) {
                if (this.explicitMappings.hasOwnProperty(key))
                    (<any>data["explicitMappings"])[key] = this.explicitMappings[key] ? this.explicitMappings[key].toJSON() : <any>undefined;
            }
        }
        data["name"] = this.name;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        return data;
    }
}

/** Defines the payload for the issue type screen schemes. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-type-screen-schemes/\#api-rest-api-3-issuetypescreenscheme-post */
export interface IIssueTypeScreenSchemePayload {
    defaultScreenScheme?: ProjectCreateResourceIdentifier;
    /** The description of the issue type screen scheme */
    description?: string;
    /** The IDs of the screen schemes for the issue type IDs and default. A default entry is required to create an issue type screen scheme, it defines the mapping for all issue types without a screen scheme. */
    explicitMappings?: { [key: string]: ProjectCreateResourceIdentifier; };
    /** The name of the issue type screen scheme */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;
}

/** Associated issue type screen scheme and project. */
export class IssueTypeScreenSchemeProjectAssociation implements IIssueTypeScreenSchemeProjectAssociation {
    /** The ID of the issue type screen scheme. */
    issueTypeScreenSchemeId?: string;
    /** The ID of the project. */
    projectId?: string;

    constructor(data?: IIssueTypeScreenSchemeProjectAssociation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueTypeScreenSchemeId = _data["issueTypeScreenSchemeId"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): IssueTypeScreenSchemeProjectAssociation {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeScreenSchemeProjectAssociation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueTypeScreenSchemeId"] = this.issueTypeScreenSchemeId;
        data["projectId"] = this.projectId;
        return data;
    }
}

/** Associated issue type screen scheme and project. */
export interface IIssueTypeScreenSchemeProjectAssociation {
    /** The ID of the issue type screen scheme. */
    issueTypeScreenSchemeId?: string;
    /** The ID of the project. */
    projectId?: string;
}

/** Details of an issue type screen scheme. */
export class IssueTypeScreenSchemeUpdateDetails implements IIssueTypeScreenSchemeUpdateDetails {
    /** The description of the issue type screen scheme. The maximum length is 255 characters. */
    description?: string;
    /** The name of the issue type screen scheme. The name must be unique. The maximum length is 255 characters. */
    name?: string;

    constructor(data?: IIssueTypeScreenSchemeUpdateDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IssueTypeScreenSchemeUpdateDetails {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeScreenSchemeUpdateDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

/** Details of an issue type screen scheme. */
export interface IIssueTypeScreenSchemeUpdateDetails {
    /** The description of the issue type screen scheme. The maximum length is 255 characters. */
    description?: string;
    /** The name of the issue type screen scheme. The name must be unique. The maximum length is 255 characters. */
    name?: string;
}

/** Issue type screen scheme with a list of the projects that use it. */
export class IssueTypeScreenSchemesProjects implements IIssueTypeScreenSchemesProjects {
    /** Details of an issue type screen scheme. */
    issueTypeScreenScheme!: IssueTypeScreenScheme;
    /** The IDs of the projects using the issue type screen scheme. */
    projectIds!: string[];

    constructor(data?: IIssueTypeScreenSchemesProjects) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueTypeScreenScheme = new IssueTypeScreenScheme();
            this.projectIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueTypeScreenScheme = _data["issueTypeScreenScheme"] ? IssueTypeScreenScheme.fromJS(_data["issueTypeScreenScheme"]) : new IssueTypeScreenScheme();
            if (Array.isArray(_data["projectIds"])) {
                this.projectIds = [] as any;
                for (let item of _data["projectIds"])
                    this.projectIds!.push(item);
            }
        }
    }

    static fromJS(data: any): IssueTypeScreenSchemesProjects {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeScreenSchemesProjects();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueTypeScreenScheme"] = this.issueTypeScreenScheme ? this.issueTypeScreenScheme.toJSON() : <any>undefined;
        if (Array.isArray(this.projectIds)) {
            data["projectIds"] = [];
            for (let item of this.projectIds)
                data["projectIds"].push(item);
        }
        return data;
    }
}

/** Issue type screen scheme with a list of the projects that use it. */
export interface IIssueTypeScreenSchemesProjects {
    /** Details of an issue type screen scheme. */
    issueTypeScreenScheme: IssueTypeScreenScheme;
    /** The IDs of the projects using the issue type screen scheme. */
    projectIds: string[];
}

/** Mapping of an issue type to a context. */
export class IssueTypeToContextMapping implements IIssueTypeToContextMapping {
    /** The ID of the context. */
    contextId!: string;
    /** Whether the context is mapped to any issue type. */
    isAnyIssueType?: boolean;
    /** The ID of the issue type. */
    issueTypeId?: string;

    constructor(data?: IIssueTypeToContextMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contextId = _data["contextId"];
            this.isAnyIssueType = _data["isAnyIssueType"];
            this.issueTypeId = _data["issueTypeId"];
        }
    }

    static fromJS(data: any): IssueTypeToContextMapping {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeToContextMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contextId"] = this.contextId;
        data["isAnyIssueType"] = this.isAnyIssueType;
        data["issueTypeId"] = this.issueTypeId;
        return data;
    }
}

/** Mapping of an issue type to a context. */
export interface IIssueTypeToContextMapping {
    /** The ID of the context. */
    contextId: string;
    /** Whether the context is mapped to any issue type. */
    isAnyIssueType?: boolean;
    /** The ID of the issue type. */
    issueTypeId?: string;
}

export class IssueTypeUpdateBean implements IIssueTypeUpdateBean {
    /** The ID of an issue type avatar. */
    avatarId?: number;
    /** The description of the issue type. */
    description?: string;
    /** The unique name for the issue type. The maximum length is 60 characters. */
    name?: string;

    constructor(data?: IIssueTypeUpdateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.avatarId = _data["avatarId"];
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IssueTypeUpdateBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeUpdateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatarId"] = this.avatarId;
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

export interface IIssueTypeUpdateBean {
    /** The ID of an issue type avatar. */
    avatarId?: number;
    /** The description of the issue type. */
    description?: string;
    /** The unique name for the issue type. The maximum length is 60 characters. */
    name?: string;
}

/** Status details for an issue type. */
export class IssueTypeWithStatus implements IIssueTypeWithStatus {
    /** The ID of the issue type. */
    readonly id!: string;
    /** The name of the issue type. */
    readonly name!: string;
    /** The URL of the issue type's status details. */
    readonly self!: string;
    /** List of status details for the issue type. */
    readonly statuses!: StatusDetails[];
    /** Whether this issue type represents subtasks. */
    readonly subtask!: boolean;

    constructor(data?: IIssueTypeWithStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.statuses = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            (<any>this).self = _data["self"];
            if (Array.isArray(_data["statuses"])) {
                (<any>this).statuses = [] as any;
                for (let item of _data["statuses"])
                    (<any>this).statuses!.push(StatusDetails.fromJS(item));
            }
            (<any>this).subtask = _data["subtask"];
        }
    }

    static fromJS(data: any): IssueTypeWithStatus {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeWithStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        data["subtask"] = this.subtask;
        return data;
    }
}

/** Status details for an issue type. */
export interface IIssueTypeWithStatus {
    /** The ID of the issue type. */
    id: string;
    /** The name of the issue type. */
    name: string;
    /** The URL of the issue type's status details. */
    self: string;
    /** List of status details for the issue type. */
    statuses: StatusDetails[];
    /** Whether this issue type represents subtasks. */
    subtask: boolean;
}

/** Details about the mapping between an issue type and a workflow. */
export class IssueTypeWorkflowMapping implements IIssueTypeWorkflowMapping {
    /** The ID of the issue type. Not required if updating the issue type-workflow mapping. */
    issueType?: string;
    /** Set to true to create or update the draft of a workflow scheme and update the mapping in the draft, when the workflow scheme cannot be edited. Defaults to `false`. Only applicable when updating the workflow-issue types mapping. */
    updateDraftIfNeeded?: boolean;
    /** The name of the workflow. */
    workflow?: string;

    constructor(data?: IIssueTypeWorkflowMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueType = _data["issueType"];
            this.updateDraftIfNeeded = _data["updateDraftIfNeeded"];
            this.workflow = _data["workflow"];
        }
    }

    static fromJS(data: any): IssueTypeWorkflowMapping {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypeWorkflowMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueType"] = this.issueType;
        data["updateDraftIfNeeded"] = this.updateDraftIfNeeded;
        data["workflow"] = this.workflow;
        return data;
    }
}

/** Details about the mapping between an issue type and a workflow. */
export interface IIssueTypeWorkflowMapping {
    /** The ID of the issue type. Not required if updating the issue type-workflow mapping. */
    issueType?: string;
    /** Set to true to create or update the draft of a workflow scheme and update the mapping in the draft, when the workflow scheme cannot be edited. Defaults to `false`. Only applicable when updating the workflow-issue types mapping. */
    updateDraftIfNeeded?: boolean;
    /** The name of the workflow. */
    workflow?: string;
}

/** Details about the mapping between issue types and a workflow. */
export class IssueTypesWorkflowMapping implements IIssueTypesWorkflowMapping {
    /** Whether the workflow is the default workflow for the workflow scheme. */
    defaultMapping?: boolean;
    /** The list of issue type IDs. */
    issueTypes?: string[];
    /** Whether a draft workflow scheme is created or updated when updating an active workflow scheme. The draft is updated with the new workflow-issue types mapping. Defaults to `false`. */
    updateDraftIfNeeded?: boolean;
    /** The name of the workflow. Optional if updating the workflow-issue types mapping. */
    workflow?: string;

    constructor(data?: IIssueTypesWorkflowMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultMapping = _data["defaultMapping"];
            if (Array.isArray(_data["issueTypes"])) {
                this.issueTypes = [] as any;
                for (let item of _data["issueTypes"])
                    this.issueTypes!.push(item);
            }
            this.updateDraftIfNeeded = _data["updateDraftIfNeeded"];
            this.workflow = _data["workflow"];
        }
    }

    static fromJS(data: any): IssueTypesWorkflowMapping {
        data = typeof data === 'object' ? data : {};
        let result = new IssueTypesWorkflowMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultMapping"] = this.defaultMapping;
        if (Array.isArray(this.issueTypes)) {
            data["issueTypes"] = [];
            for (let item of this.issueTypes)
                data["issueTypes"].push(item);
        }
        data["updateDraftIfNeeded"] = this.updateDraftIfNeeded;
        data["workflow"] = this.workflow;
        return data;
    }
}

/** Details about the mapping between issue types and a workflow. */
export interface IIssueTypesWorkflowMapping {
    /** Whether the workflow is the default workflow for the workflow scheme. */
    defaultMapping?: boolean;
    /** The list of issue type IDs. */
    issueTypes?: string[];
    /** Whether a draft workflow scheme is created or updated when updating an active workflow scheme. The draft is updated with the new workflow-issue types mapping. Defaults to `false`. */
    updateDraftIfNeeded?: boolean;
    /** The name of the workflow. Optional if updating the workflow-issue types mapping. */
    workflow?: string;
}

/** Details of an issue update request. */
export class IssueUpdateDetails implements IIssueUpdateDetails {
    /** List of issue screen fields to update, specifying the sub-field to update and its value for each field. This field provides a straightforward option when setting a sub-field. When multiple sub-fields or other operations are required, use `update`. Fields included in here cannot be included in `update`. */
    fields?: { [key: string]: any; };
    /** Additional issue history details. */
    historyMetadata?: HistoryMetadata;
    /** Details of issue properties to be add or update. */
    properties?: EntityProperty[];
    /** Details of a transition. Required when performing a transition, optional when creating or editing an issue. */
    transition?: IssueTransition;
    /** A Map containing the field field name and a list of operations to perform on the issue screen field. Note that fields included in here cannot be included in `fields`. */
    update?: { [key: string]: FieldUpdateOperation[]; };

    [key: string]: any;

    constructor(data?: IIssueUpdateDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["fields"]) {
                this.fields = {} as any;
                for (let key in _data["fields"]) {
                    if (_data["fields"].hasOwnProperty(key))
                        (<any>this.fields)![key] = _data["fields"][key];
                }
            }
            this.historyMetadata = _data["historyMetadata"] ? HistoryMetadata.fromJS(_data["historyMetadata"]) : <any>undefined;
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(EntityProperty.fromJS(item));
            }
            this.transition = _data["transition"] ? IssueTransition.fromJS(_data["transition"]) : <any>undefined;
            if (_data["update"]) {
                this.update = {} as any;
                for (let key in _data["update"]) {
                    if (_data["update"].hasOwnProperty(key))
                        (<any>this.update)![key] = _data["update"][key] ? _data["update"][key].map((i: any) => FieldUpdateOperation.fromJS(i)) : [];
                }
            }
        }
    }

    static fromJS(data: any): IssueUpdateDetails {
        data = typeof data === 'object' ? data : {};
        let result = new IssueUpdateDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.fields) {
            data["fields"] = {};
            for (let key in this.fields) {
                if (this.fields.hasOwnProperty(key))
                    (<any>data["fields"])[key] = (<any>this.fields)[key];
            }
        }
        data["historyMetadata"] = this.historyMetadata ? this.historyMetadata.toJSON() : <any>undefined;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        data["transition"] = this.transition ? this.transition.toJSON() : <any>undefined;
        if (this.update) {
            data["update"] = {};
            for (let key in this.update) {
                if (this.update.hasOwnProperty(key))
                    (<any>data["update"])[key] = (<any>this.update)[key];
            }
        }
        return data;
    }
}

/** Details of an issue update request. */
export interface IIssueUpdateDetails {
    /** List of issue screen fields to update, specifying the sub-field to update and its value for each field. This field provides a straightforward option when setting a sub-field. When multiple sub-fields or other operations are required, use `update`. Fields included in here cannot be included in `update`. */
    fields?: { [key: string]: any; };
    /** Additional issue history details. */
    historyMetadata?: HistoryMetadata;
    /** Details of issue properties to be add or update. */
    properties?: EntityProperty[];
    /** Details of a transition. Required when performing a transition, optional when creating or editing an issue. */
    transition?: IssueTransition;
    /** A Map containing the field field name and a list of operations to perform on the issue screen field. Note that fields included in here cannot be included in `fields`. */
    update?: { [key: string]: FieldUpdateOperation[]; };

    [key: string]: any;
}

/** A list of editable field details. */
export class IssueUpdateMetadata implements IIssueUpdateMetadata {
    readonly fields?: { [key: string]: FieldMetadata; };

    [key: string]: any;

    constructor(data?: IIssueUpdateMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["fields"]) {
                (<any>this).fields = {} as any;
                for (let key in _data["fields"]) {
                    if (_data["fields"].hasOwnProperty(key))
                        (<any>(<any>this).fields)![key] = _data["fields"][key] ? FieldMetadata.fromJS(_data["fields"][key]) : new FieldMetadata();
                }
            }
        }
    }

    static fromJS(data: any): IssueUpdateMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new IssueUpdateMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.fields) {
            data["fields"] = {};
            for (let key in this.fields) {
                if (this.fields.hasOwnProperty(key))
                    (<any>data["fields"])[key] = this.fields[key] ? this.fields[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** A list of editable field details. */
export interface IIssueUpdateMetadata {
    fields?: { [key: string]: FieldMetadata; };

    [key: string]: any;
}

/** List of issues and JQL queries. */
export class IssuesAndJQLQueries implements IIssuesAndJQLQueries {
    /** A list of issue IDs. */
    issueIds!: number[];
    /** A list of JQL queries. */
    jqls!: string[];

    constructor(data?: IIssuesAndJQLQueries) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueIds = [];
            this.jqls = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueIds"])) {
                this.issueIds = [] as any;
                for (let item of _data["issueIds"])
                    this.issueIds!.push(item);
            }
            if (Array.isArray(_data["jqls"])) {
                this.jqls = [] as any;
                for (let item of _data["jqls"])
                    this.jqls!.push(item);
            }
        }
    }

    static fromJS(data: any): IssuesAndJQLQueries {
        data = typeof data === 'object' ? data : {};
        let result = new IssuesAndJQLQueries();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueIds)) {
            data["issueIds"] = [];
            for (let item of this.issueIds)
                data["issueIds"].push(item);
        }
        if (Array.isArray(this.jqls)) {
            data["jqls"] = [];
            for (let item of this.jqls)
                data["jqls"].push(item);
        }
        return data;
    }
}

/** List of issues and JQL queries. */
export interface IIssuesAndJQLQueries {
    /** A list of issue IDs. */
    issueIds: number[];
    /** A list of JQL queries. */
    jqls: string[];
}

/** The description of the page of issues loaded by the provided JQL query. */
export class IssuesJqlMetaDataBean implements IIssuesJqlMetaDataBean {
    /** The number of issues that were loaded in this evaluation. */
    count!: number;
    /** The maximum number of issues that could be loaded in this evaluation. */
    maxResults!: number;
    /** The index of the first issue. */
    startAt!: number;
    /** The total number of issues the JQL returned. */
    totalCount!: number;
    /** Any warnings related to the JQL query. Present only if the validation mode was set to `warn`. */
    validationWarnings?: string[];

    constructor(data?: IIssuesJqlMetaDataBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            this.maxResults = _data["maxResults"];
            this.startAt = _data["startAt"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["validationWarnings"])) {
                this.validationWarnings = [] as any;
                for (let item of _data["validationWarnings"])
                    this.validationWarnings!.push(item);
            }
        }
    }

    static fromJS(data: any): IssuesJqlMetaDataBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssuesJqlMetaDataBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["maxResults"] = this.maxResults;
        data["startAt"] = this.startAt;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.validationWarnings)) {
            data["validationWarnings"] = [];
            for (let item of this.validationWarnings)
                data["validationWarnings"].push(item);
        }
        return data;
    }
}

/** The description of the page of issues loaded by the provided JQL query. */
export interface IIssuesJqlMetaDataBean {
    /** The number of issues that were loaded in this evaluation. */
    count: number;
    /** The maximum number of issues that could be loaded in this evaluation. */
    maxResults: number;
    /** The index of the first issue. */
    startAt: number;
    /** The total number of issues the JQL returned. */
    totalCount: number;
    /** Any warnings related to the JQL query. Present only if the validation mode was set to `warn`. */
    validationWarnings?: string[];
}

/** Meta data describing the `issues` context variable. */
export class IssuesMetaBean implements IIssuesMetaBean {
    jql?: IssuesJqlMetaDataBean;

    constructor(data?: IIssuesMetaBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jql = _data["jql"] ? IssuesJqlMetaDataBean.fromJS(_data["jql"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IssuesMetaBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssuesMetaBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jql"] = this.jql ? this.jql.toJSON() : <any>undefined;
        return data;
    }
}

/** Meta data describing the `issues` context variable. */
export interface IIssuesMetaBean {
    jql?: IssuesJqlMetaDataBean;
}

export class IssuesUpdateBean implements IIssuesUpdateBean {
    issueUpdates?: IssueUpdateDetails[];

    [key: string]: any;

    constructor(data?: IIssuesUpdateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["issueUpdates"])) {
                this.issueUpdates = [] as any;
                for (let item of _data["issueUpdates"])
                    this.issueUpdates!.push(IssueUpdateDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IssuesUpdateBean {
        data = typeof data === 'object' ? data : {};
        let result = new IssuesUpdateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.issueUpdates)) {
            data["issueUpdates"] = [];
            for (let item of this.issueUpdates)
                data["issueUpdates"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIssuesUpdateBean {
    issueUpdates?: IssueUpdateDetails[];

    [key: string]: any;
}

/** The description of the page of issues loaded by the provided JQL query.This bean will be replacing IssuesJqlMetaDataBean bean as part of new `evaluate` endpoint */
export class JExpEvaluateIssuesJqlMetaDataBean implements IJExpEvaluateIssuesJqlMetaDataBean {
    /** Next Page token for the next page of issues. */
    nextPageToken!: string;

    constructor(data?: IJExpEvaluateIssuesJqlMetaDataBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nextPageToken = _data["nextPageToken"];
        }
    }

    static fromJS(data: any): JExpEvaluateIssuesJqlMetaDataBean {
        data = typeof data === 'object' ? data : {};
        let result = new JExpEvaluateIssuesJqlMetaDataBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nextPageToken"] = this.nextPageToken;
        return data;
    }
}

/** The description of the page of issues loaded by the provided JQL query.This bean will be replacing IssuesJqlMetaDataBean bean as part of new `evaluate` endpoint */
export interface IJExpEvaluateIssuesJqlMetaDataBean {
    /** Next Page token for the next page of issues. */
    nextPageToken: string;
}

/** Meta data describing the `issues` context variable.This bean will be replacing IssuesMetaBean bean as part of new `evaluate` endpoint */
export class JExpEvaluateIssuesMetaBean implements IJExpEvaluateIssuesMetaBean {
    jql?: JExpEvaluateIssuesJqlMetaDataBean;

    constructor(data?: IJExpEvaluateIssuesMetaBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jql = _data["jql"] ? JExpEvaluateIssuesJqlMetaDataBean.fromJS(_data["jql"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JExpEvaluateIssuesMetaBean {
        data = typeof data === 'object' ? data : {};
        let result = new JExpEvaluateIssuesMetaBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jql"] = this.jql ? this.jql.toJSON() : <any>undefined;
        return data;
    }
}

/** Meta data describing the `issues` context variable.This bean will be replacing IssuesMetaBean bean as part of new `evaluate` endpoint */
export interface IJExpEvaluateIssuesMetaBean {
    jql?: JExpEvaluateIssuesJqlMetaDataBean;
}

/** The result of evaluating a Jira expression.This bean will be replacing `JiraExpressionResultBean` bean as part of new evaluate endpoint */
export class JExpEvaluateJiraExpressionResultBean implements IJExpEvaluateJiraExpressionResultBean {
    /** Contains various characteristics of the performed expression evaluation. */
    meta?: JExpEvaluateMetaDataBean;
    /** The value of the evaluated expression. It may be a primitive JSON value or a Jira REST API object. (Some expressions do not produce any meaningful results—for example, an expression that returns a lambda function—if that's the case a simple string representation is returned. These string representations should not be relied upon and may change without notice.) */
    value!: any;

    constructor(data?: IJExpEvaluateJiraExpressionResultBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.meta = _data["meta"] ? JExpEvaluateMetaDataBean.fromJS(_data["meta"]) : <any>undefined;
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): JExpEvaluateJiraExpressionResultBean {
        data = typeof data === 'object' ? data : {};
        let result = new JExpEvaluateJiraExpressionResultBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        data["value"] = this.value;
        return data;
    }
}

/** The result of evaluating a Jira expression.This bean will be replacing `JiraExpressionResultBean` bean as part of new evaluate endpoint */
export interface IJExpEvaluateJiraExpressionResultBean {
    /** Contains various characteristics of the performed expression evaluation. */
    meta?: JExpEvaluateMetaDataBean;
    /** The value of the evaluated expression. It may be a primitive JSON value or a Jira REST API object. (Some expressions do not produce any meaningful results—for example, an expression that returns a lambda function—if that's the case a simple string representation is returned. These string representations should not be relied upon and may change without notice.) */
    value: any;
}

/** Contains information about the expression evaluation. This bean will be replacing `JiraExpressionEvaluationMetaDataBean` bean as part of new `evaluate` endpoint */
export class JExpEvaluateMetaDataBean implements IJExpEvaluateMetaDataBean {
    /** Contains information about the expression complexity. For example, the number of steps it took to evaluate the expression. */
    complexity?: JiraExpressionsComplexityBean;
    /** Contains information about the `issues` variable in the context. For example, is the issues were loaded with JQL, information about the page will be included here. */
    issues?: JExpEvaluateIssuesMetaBean;

    constructor(data?: IJExpEvaluateMetaDataBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.complexity = _data["complexity"] ? JiraExpressionsComplexityBean.fromJS(_data["complexity"]) : <any>undefined;
            this.issues = _data["issues"] ? JExpEvaluateIssuesMetaBean.fromJS(_data["issues"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JExpEvaluateMetaDataBean {
        data = typeof data === 'object' ? data : {};
        let result = new JExpEvaluateMetaDataBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["complexity"] = this.complexity ? this.complexity.toJSON() : <any>undefined;
        data["issues"] = this.issues ? this.issues.toJSON() : <any>undefined;
        return data;
    }
}

/** Contains information about the expression evaluation. This bean will be replacing `JiraExpressionEvaluationMetaDataBean` bean as part of new `evaluate` endpoint */
export interface IJExpEvaluateMetaDataBean {
    /** Contains information about the expression complexity. For example, the number of steps it took to evaluate the expression. */
    complexity?: JiraExpressionsComplexityBean;
    /** Contains information about the `issues` variable in the context. For example, is the issues were loaded with JQL, information about the page will be included here. */
    issues?: JExpEvaluateIssuesMetaBean;
}

export class JQLCountRequestBean implements IJQLCountRequestBean {
    /** A [JQL](https://confluence.atlassian.com/x/egORLQ) expression. For performance reasons, this parameter requires a bounded query. A bounded query is a query with a search restriction. */
    jql?: string;

    constructor(data?: IJQLCountRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jql = _data["jql"];
        }
    }

    static fromJS(data: any): JQLCountRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new JQLCountRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jql"] = this.jql;
        return data;
    }
}

export interface IJQLCountRequestBean {
    /** A [JQL](https://confluence.atlassian.com/x/egORLQ) expression. For performance reasons, this parameter requires a bounded query. A bounded query is a query with a search restriction. */
    jql?: string;
}

export class JQLCountResultsBean implements IJQLCountResultsBean {
    /** Number of issues matching JQL query. */
    count?: number;

    constructor(data?: IJQLCountResultsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): JQLCountResultsBean {
        data = typeof data === 'object' ? data : {};
        let result = new JQLCountResultsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        return data;
    }
}

export interface IJQLCountResultsBean {
    /** Number of issues matching JQL query. */
    count?: number;
}

/** The JQL queries to be converted. */
export class JQLPersonalDataMigrationRequest implements IJQLPersonalDataMigrationRequest {
    /** A list of queries with user identifiers. Maximum of 100 queries. */
    queryStrings?: string[];

    constructor(data?: IJQLPersonalDataMigrationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["queryStrings"])) {
                this.queryStrings = [] as any;
                for (let item of _data["queryStrings"])
                    this.queryStrings!.push(item);
            }
        }
    }

    static fromJS(data: any): JQLPersonalDataMigrationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new JQLPersonalDataMigrationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queryStrings)) {
            data["queryStrings"] = [];
            for (let item of this.queryStrings)
                data["queryStrings"].push(item);
        }
        return data;
    }
}

/** The JQL queries to be converted. */
export interface IJQLPersonalDataMigrationRequest {
    /** A list of queries with user identifiers. Maximum of 100 queries. */
    queryStrings?: string[];
}

/** JQL queries that contained users that could not be found */
export class JQLQueryWithUnknownUsers implements IJQLQueryWithUnknownUsers {
    /** The converted query, with accountIDs instead of user identifiers, or 'unknown' for users that could not be found */
    convertedQuery?: string;
    /** The original query, for reference */
    originalQuery?: string;

    constructor(data?: IJQLQueryWithUnknownUsers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.convertedQuery = _data["convertedQuery"];
            this.originalQuery = _data["originalQuery"];
        }
    }

    static fromJS(data: any): JQLQueryWithUnknownUsers {
        data = typeof data === 'object' ? data : {};
        let result = new JQLQueryWithUnknownUsers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["convertedQuery"] = this.convertedQuery;
        data["originalQuery"] = this.originalQuery;
        return data;
    }
}

/** JQL queries that contained users that could not be found */
export interface IJQLQueryWithUnknownUsers {
    /** The converted query, with accountIDs instead of user identifiers, or 'unknown' for users that could not be found */
    convertedQuery?: string;
    /** The original query, for reference */
    originalQuery?: string;
}

/** Lists of JQL reference data. */
export class JQLReferenceData implements IJQLReferenceData {
    /** List of JQL query reserved words. */
    jqlReservedWords?: string[];
    /** List of fields usable in JQL queries. */
    visibleFieldNames?: FieldReferenceData[];
    /** List of functions usable in JQL queries. */
    visibleFunctionNames?: FunctionReferenceData[];

    constructor(data?: IJQLReferenceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["jqlReservedWords"])) {
                this.jqlReservedWords = [] as any;
                for (let item of _data["jqlReservedWords"])
                    this.jqlReservedWords!.push(item);
            }
            if (Array.isArray(_data["visibleFieldNames"])) {
                this.visibleFieldNames = [] as any;
                for (let item of _data["visibleFieldNames"])
                    this.visibleFieldNames!.push(FieldReferenceData.fromJS(item));
            }
            if (Array.isArray(_data["visibleFunctionNames"])) {
                this.visibleFunctionNames = [] as any;
                for (let item of _data["visibleFunctionNames"])
                    this.visibleFunctionNames!.push(FunctionReferenceData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JQLReferenceData {
        data = typeof data === 'object' ? data : {};
        let result = new JQLReferenceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.jqlReservedWords)) {
            data["jqlReservedWords"] = [];
            for (let item of this.jqlReservedWords)
                data["jqlReservedWords"].push(item);
        }
        if (Array.isArray(this.visibleFieldNames)) {
            data["visibleFieldNames"] = [];
            for (let item of this.visibleFieldNames)
                data["visibleFieldNames"].push(item.toJSON());
        }
        if (Array.isArray(this.visibleFunctionNames)) {
            data["visibleFunctionNames"] = [];
            for (let item of this.visibleFunctionNames)
                data["visibleFunctionNames"].push(item.toJSON());
        }
        return data;
    }
}

/** Lists of JQL reference data. */
export interface IJQLReferenceData {
    /** List of JQL query reserved words. */
    jqlReservedWords?: string[];
    /** List of fields usable in JQL queries. */
    visibleFieldNames?: FieldReferenceData[];
    /** List of functions usable in JQL queries. */
    visibleFunctionNames?: FunctionReferenceData[];
}

/** The JQL specifying the issues available in the evaluated Jira expression under the `issues` context variable. This bean will be replacing `JexpIssues` bean as part of new `evaluate` endpoint */
export class JexpEvaluateCtxIssues implements IJexpEvaluateCtxIssues {
    /** The JQL query that specifies the set of issues available in the Jira expression. */
    jql?: JexpEvaluateCtxJqlIssues;

    constructor(data?: IJexpEvaluateCtxIssues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jql = _data["jql"] ? JexpEvaluateCtxJqlIssues.fromJS(_data["jql"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JexpEvaluateCtxIssues {
        data = typeof data === 'object' ? data : {};
        let result = new JexpEvaluateCtxIssues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jql"] = this.jql ? this.jql.toJSON() : <any>undefined;
        return data;
    }
}

/** The JQL specifying the issues available in the evaluated Jira expression under the `issues` context variable. This bean will be replacing `JexpIssues` bean as part of new `evaluate` endpoint */
export interface IJexpEvaluateCtxIssues {
    /** The JQL query that specifies the set of issues available in the Jira expression. */
    jql?: JexpEvaluateCtxJqlIssues;
}

/** The JQL specifying the issues available in the evaluated Jira expression under the `issues` context variable. Not all issues returned by the JQL query are loaded, only those described by the `nextPageToken` and `maxResults` properties. This bean will be replacing JexpJqlIssues bean as part of new `evaluate` endpoint */
export class JexpEvaluateCtxJqlIssues implements IJexpEvaluateCtxJqlIssues {
    /** The maximum number of issues to return from the JQL query. max results value considered may be lower than the number specific here. */
    maxResults?: number;
    /** The token for a page to fetch that is not the first page. The first page has a `nextPageToken` of `null`. Use the `nextPageToken` to fetch the next page of issues. */
    nextPageToken?: string;
    /** The JQL query, required to be bounded. Additionally, `orderBy` clause can contain a maximum of 7 fields */
    query?: string;

    constructor(data?: IJexpEvaluateCtxJqlIssues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResults = _data["maxResults"];
            this.nextPageToken = _data["nextPageToken"];
            this.query = _data["query"];
        }
    }

    static fromJS(data: any): JexpEvaluateCtxJqlIssues {
        data = typeof data === 'object' ? data : {};
        let result = new JexpEvaluateCtxJqlIssues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResults"] = this.maxResults;
        data["nextPageToken"] = this.nextPageToken;
        data["query"] = this.query;
        return data;
    }
}

/** The JQL specifying the issues available in the evaluated Jira expression under the `issues` context variable. Not all issues returned by the JQL query are loaded, only those described by the `nextPageToken` and `maxResults` properties. This bean will be replacing JexpJqlIssues bean as part of new `evaluate` endpoint */
export interface IJexpEvaluateCtxJqlIssues {
    /** The maximum number of issues to return from the JQL query. max results value considered may be lower than the number specific here. */
    maxResults?: number;
    /** The token for a page to fetch that is not the first page. The first page has a `nextPageToken` of `null`. Use the `nextPageToken` to fetch the next page of issues. */
    nextPageToken?: string;
    /** The JQL query, required to be bounded. Additionally, `orderBy` clause can contain a maximum of 7 fields */
    query?: string;
}

/** The JQL specifying the issues available in the evaluated Jira expression under the `issues` context variable. */
export class JexpIssues implements IJexpIssues {
    /** The JQL query that specifies the set of issues available in the Jira expression. */
    jql?: JexpJqlIssues;

    constructor(data?: IJexpIssues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jql = _data["jql"] ? JexpJqlIssues.fromJS(_data["jql"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JexpIssues {
        data = typeof data === 'object' ? data : {};
        let result = new JexpIssues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jql"] = this.jql ? this.jql.toJSON() : <any>undefined;
        return data;
    }
}

/** The JQL specifying the issues available in the evaluated Jira expression under the `issues` context variable. */
export interface IJexpIssues {
    /** The JQL query that specifies the set of issues available in the Jira expression. */
    jql?: JexpJqlIssues;
}

/** The JQL specifying the issues available in the evaluated Jira expression under the `issues` context variable. Not all issues returned by the JQL query are loaded, only those described by the `startAt` and `maxResults` properties. To determine whether it is necessary to iterate to ensure all the issues returned by the JQL query are evaluated, inspect `meta.issues.jql.count` in the response. */
export class JexpJqlIssues implements IJexpJqlIssues {
    /** The maximum number of issues to return from the JQL query. Inspect `meta.issues.jql.maxResults` in the response to ensure the maximum value has not been exceeded. */
    maxResults?: number;
    /** The JQL query. */
    query?: string;
    /** The index of the first issue to return from the JQL query. */
    startAt?: number;
    /** Determines how to validate the JQL query and treat the validation results. */
    validation?: JexpJqlIssuesValidation;

    constructor(data?: IJexpJqlIssues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.validation = JexpJqlIssuesValidation.Strict;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResults = _data["maxResults"];
            this.query = _data["query"];
            this.startAt = _data["startAt"];
            this.validation = _data["validation"] !== undefined ? _data["validation"] : JexpJqlIssuesValidation.Strict;
        }
    }

    static fromJS(data: any): JexpJqlIssues {
        data = typeof data === 'object' ? data : {};
        let result = new JexpJqlIssues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResults"] = this.maxResults;
        data["query"] = this.query;
        data["startAt"] = this.startAt;
        data["validation"] = this.validation;
        return data;
    }
}

/** The JQL specifying the issues available in the evaluated Jira expression under the `issues` context variable. Not all issues returned by the JQL query are loaded, only those described by the `startAt` and `maxResults` properties. To determine whether it is necessary to iterate to ensure all the issues returned by the JQL query are evaluated, inspect `meta.issues.jql.count` in the response. */
export interface IJexpJqlIssues {
    /** The maximum number of issues to return from the JQL query. Inspect `meta.issues.jql.maxResults` in the response to ensure the maximum value has not been exceeded. */
    maxResults?: number;
    /** The JQL query. */
    query?: string;
    /** The index of the first issue to return from the JQL query. */
    startAt?: number;
    /** Determines how to validate the JQL query and treat the validation results. */
    validation?: JexpJqlIssuesValidation;
}

export class JiraCascadingSelectField implements IJiraCascadingSelectField {
    childOptionValue?: JiraSelectedOptionField;
    fieldId!: string;
    parentOptionValue!: JiraSelectedOptionField;

    constructor(data?: IJiraCascadingSelectField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.parentOptionValue = new JiraSelectedOptionField();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.childOptionValue = _data["childOptionValue"] ? JiraSelectedOptionField.fromJS(_data["childOptionValue"]) : <any>undefined;
            this.fieldId = _data["fieldId"];
            this.parentOptionValue = _data["parentOptionValue"] ? JiraSelectedOptionField.fromJS(_data["parentOptionValue"]) : new JiraSelectedOptionField();
        }
    }

    static fromJS(data: any): JiraCascadingSelectField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraCascadingSelectField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["childOptionValue"] = this.childOptionValue ? this.childOptionValue.toJSON() : <any>undefined;
        data["fieldId"] = this.fieldId;
        data["parentOptionValue"] = this.parentOptionValue ? this.parentOptionValue.toJSON() : <any>undefined;
        return data;
    }
}

export interface IJiraCascadingSelectField {
    childOptionValue?: JiraSelectedOptionField;
    fieldId: string;
    parentOptionValue: JiraSelectedOptionField;
}

export class JiraColorField implements IJiraColorField {
    color!: JiraColorInput;
    fieldId!: string;

    constructor(data?: IJiraColorField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.color = new JiraColorInput();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.color = _data["color"] ? JiraColorInput.fromJS(_data["color"]) : new JiraColorInput();
            this.fieldId = _data["fieldId"];
        }
    }

    static fromJS(data: any): JiraColorField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraColorField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["color"] = this.color ? this.color.toJSON() : <any>undefined;
        data["fieldId"] = this.fieldId;
        return data;
    }
}

export interface IJiraColorField {
    color: JiraColorInput;
    fieldId: string;
}

export class JiraColorInput implements IJiraColorInput {
    name!: string;

    constructor(data?: IJiraColorInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): JiraColorInput {
        data = typeof data === 'object' ? data : {};
        let result = new JiraColorInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IJiraColorInput {
    name: string;
}

export class JiraComponentField implements IJiraComponentField {
    componentId!: number;

    constructor(data?: IJiraComponentField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.componentId = _data["componentId"];
        }
    }

    static fromJS(data: any): JiraComponentField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraComponentField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["componentId"] = this.componentId;
        return data;
    }
}

export interface IJiraComponentField {
    componentId: number;
}

export class JiraDateField implements IJiraDateField {
    date?: JiraDateInput;
    fieldId!: string;

    constructor(data?: IJiraDateField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? JiraDateInput.fromJS(_data["date"]) : <any>undefined;
            this.fieldId = _data["fieldId"];
        }
    }

    static fromJS(data: any): JiraDateField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraDateField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toJSON() : <any>undefined;
        data["fieldId"] = this.fieldId;
        return data;
    }
}

export interface IJiraDateField {
    date?: JiraDateInput;
    fieldId: string;
}

export class JiraDateInput implements IJiraDateInput {
    formattedDate!: string;

    constructor(data?: IJiraDateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formattedDate = _data["formattedDate"];
        }
    }

    static fromJS(data: any): JiraDateInput {
        data = typeof data === 'object' ? data : {};
        let result = new JiraDateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formattedDate"] = this.formattedDate;
        return data;
    }
}

export interface IJiraDateInput {
    formattedDate: string;
}

export class JiraDateTimeField implements IJiraDateTimeField {
    dateTime!: JiraDateTimeInput;
    fieldId!: string;

    constructor(data?: IJiraDateTimeField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dateTime = new JiraDateTimeInput();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"] ? JiraDateTimeInput.fromJS(_data["dateTime"]) : new JiraDateTimeInput();
            this.fieldId = _data["fieldId"];
        }
    }

    static fromJS(data: any): JiraDateTimeField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraDateTimeField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime ? this.dateTime.toJSON() : <any>undefined;
        data["fieldId"] = this.fieldId;
        return data;
    }
}

export interface IJiraDateTimeField {
    dateTime: JiraDateTimeInput;
    fieldId: string;
}

export class JiraDateTimeInput implements IJiraDateTimeInput {
    formattedDateTime!: string;

    constructor(data?: IJiraDateTimeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formattedDateTime = _data["formattedDateTime"];
        }
    }

    static fromJS(data: any): JiraDateTimeInput {
        data = typeof data === 'object' ? data : {};
        let result = new JiraDateTimeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formattedDateTime"] = this.formattedDateTime;
        return data;
    }
}

export interface IJiraDateTimeInput {
    formattedDateTime: string;
}

export class JiraDurationField implements IJiraDurationField {
    originalEstimateField!: string;

    constructor(data?: IJiraDurationField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.originalEstimateField = _data["originalEstimateField"];
        }
    }

    static fromJS(data: any): JiraDurationField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraDurationField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originalEstimateField"] = this.originalEstimateField;
        return data;
    }
}

export interface IJiraDurationField {
    originalEstimateField: string;
}

/** Details about the analysed Jira expression. */
export class JiraExpressionAnalysis implements IJiraExpressionAnalysis {
    complexity?: JiraExpressionComplexity;
    /** A list of validation errors. Not included if the expression is valid. */
    errors?: JiraExpressionValidationError[];
    /** The analysed expression. */
    expression!: string;
    /** EXPERIMENTAL. The inferred type of the expression. */
    type?: string;
    /** Whether the expression is valid and the interpreter will evaluate it. Note that the expression may fail at runtime (for example, if it executes too many expensive operations). */
    valid!: boolean;

    constructor(data?: IJiraExpressionAnalysis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.complexity = _data["complexity"] ? JiraExpressionComplexity.fromJS(_data["complexity"]) : <any>undefined;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(JiraExpressionValidationError.fromJS(item));
            }
            this.expression = _data["expression"];
            this.type = _data["type"];
            this.valid = _data["valid"];
        }
    }

    static fromJS(data: any): JiraExpressionAnalysis {
        data = typeof data === 'object' ? data : {};
        let result = new JiraExpressionAnalysis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["complexity"] = this.complexity ? this.complexity.toJSON() : <any>undefined;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["expression"] = this.expression;
        data["type"] = this.type;
        data["valid"] = this.valid;
        return data;
    }
}

/** Details about the analysed Jira expression. */
export interface IJiraExpressionAnalysis {
    complexity?: JiraExpressionComplexity;
    /** A list of validation errors. Not included if the expression is valid. */
    errors?: JiraExpressionValidationError[];
    /** The analysed expression. */
    expression: string;
    /** EXPERIMENTAL. The inferred type of the expression. */
    type?: string;
    /** Whether the expression is valid and the interpreter will evaluate it. Note that the expression may fail at runtime (for example, if it executes too many expensive operations). */
    valid: boolean;
}

/** Details about the complexity of the analysed Jira expression. */
export class JiraExpressionComplexity implements IJiraExpressionComplexity {
    /** Information that can be used to determine how many [expensive operations](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#expensive-operations) the evaluation of the expression will perform. This information may be a formula or number. For example:

 *  `issues.map(i => i.comments)` performs as many expensive operations as there are issues on the issues list. So this parameter returns `N`, where `N` is the size of issue list.
 *  `new Issue(10010).comments` gets comments for one issue, so its complexity is `2` (`1` to retrieve issue 10010 from the database plus `1` to get its comments). */
    expensiveOperations!: string;
    /** Variables used in the formula, mapped to the parts of the expression they refer to. */
    variables?: { [key: string]: string; };

    constructor(data?: IJiraExpressionComplexity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expensiveOperations = _data["expensiveOperations"];
            if (_data["variables"]) {
                this.variables = {} as any;
                for (let key in _data["variables"]) {
                    if (_data["variables"].hasOwnProperty(key))
                        (<any>this.variables)![key] = _data["variables"][key];
                }
            }
        }
    }

    static fromJS(data: any): JiraExpressionComplexity {
        data = typeof data === 'object' ? data : {};
        let result = new JiraExpressionComplexity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expensiveOperations"] = this.expensiveOperations;
        if (this.variables) {
            data["variables"] = {};
            for (let key in this.variables) {
                if (this.variables.hasOwnProperty(key))
                    (<any>data["variables"])[key] = (<any>this.variables)[key];
            }
        }
        return data;
    }
}

/** Details about the complexity of the analysed Jira expression. */
export interface IJiraExpressionComplexity {
    /** Information that can be used to determine how many [expensive operations](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#expensive-operations) the evaluation of the expression will perform. This information may be a formula or number. For example:

 *  `issues.map(i => i.comments)` performs as many expensive operations as there are issues on the issues list. So this parameter returns `N`, where `N` is the size of issue list.
 *  `new Issue(10010).comments` gets comments for one issue, so its complexity is `2` (`1` to retrieve issue 10010 from the database plus `1` to get its comments). */
    expensiveOperations: string;
    /** Variables used in the formula, mapped to the parts of the expression they refer to. */
    variables?: { [key: string]: string; };
}

export class JiraExpressionEvalContextBean implements IJiraExpressionEvalContextBean {
    /** The ID of the board that is available under the `board` variable when evaluating the expression. */
    board?: number;
    /** Custom context variables and their types. These variable types are available for use in a custom context:

 *  `user`: A [user](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#user) specified as an Atlassian account ID.
 *  `issue`: An [issue](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#issue) specified by ID or key. All the fields of the issue object are available in the Jira expression.
 *  `json`: A JSON object containing custom content.
 *  `list`: A JSON list of `user`, `issue`, or `json` variable types. */
    custom?: Custom[];
    /** The ID of the customer request that is available under the `customerRequest` variable when evaluating the expression. This is the same as the ID of the underlying Jira issue, but the customer request context variable will have a different type. */
    customerRequest?: number;
    /** The issue that is available under the `issue` variable when evaluating the expression. */
    issue?: IdOrKeyBean;
    /** The collection of issues that is available under the `issues` variable when evaluating the expression. */
    issues?: JexpIssues;
    /** The project that is available under the `project` variable when evaluating the expression. */
    project?: IdOrKeyBean;
    /** The ID of the service desk that is available under the `serviceDesk` variable when evaluating the expression. */
    serviceDesk?: number;
    /** The ID of the sprint that is available under the `sprint` variable when evaluating the expression. */
    sprint?: number;

    constructor(data?: IJiraExpressionEvalContextBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.board = _data["board"];
            if (Array.isArray(_data["custom"])) {
                this.custom = [] as any;
                for (let item of _data["custom"])
                    this.custom!.push(Custom.fromJS(item));
            }
            this.customerRequest = _data["customerRequest"];
            this.issue = _data["issue"] ? IdOrKeyBean.fromJS(_data["issue"]) : <any>undefined;
            this.issues = _data["issues"] ? JexpIssues.fromJS(_data["issues"]) : <any>undefined;
            this.project = _data["project"] ? IdOrKeyBean.fromJS(_data["project"]) : <any>undefined;
            this.serviceDesk = _data["serviceDesk"];
            this.sprint = _data["sprint"];
        }
    }

    static fromJS(data: any): JiraExpressionEvalContextBean {
        data = typeof data === 'object' ? data : {};
        let result = new JiraExpressionEvalContextBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["board"] = this.board;
        if (Array.isArray(this.custom)) {
            data["custom"] = [];
            for (let item of this.custom)
                data["custom"].push(item.toJSON());
        }
        data["customerRequest"] = this.customerRequest;
        data["issue"] = this.issue ? this.issue.toJSON() : <any>undefined;
        data["issues"] = this.issues ? this.issues.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["serviceDesk"] = this.serviceDesk;
        data["sprint"] = this.sprint;
        return data;
    }
}

export interface IJiraExpressionEvalContextBean {
    /** The ID of the board that is available under the `board` variable when evaluating the expression. */
    board?: number;
    /** Custom context variables and their types. These variable types are available for use in a custom context:

 *  `user`: A [user](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#user) specified as an Atlassian account ID.
 *  `issue`: An [issue](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#issue) specified by ID or key. All the fields of the issue object are available in the Jira expression.
 *  `json`: A JSON object containing custom content.
 *  `list`: A JSON list of `user`, `issue`, or `json` variable types. */
    custom?: Custom[];
    /** The ID of the customer request that is available under the `customerRequest` variable when evaluating the expression. This is the same as the ID of the underlying Jira issue, but the customer request context variable will have a different type. */
    customerRequest?: number;
    /** The issue that is available under the `issue` variable when evaluating the expression. */
    issue?: IdOrKeyBean;
    /** The collection of issues that is available under the `issues` variable when evaluating the expression. */
    issues?: JexpIssues;
    /** The project that is available under the `project` variable when evaluating the expression. */
    project?: IdOrKeyBean;
    /** The ID of the service desk that is available under the `serviceDesk` variable when evaluating the expression. */
    serviceDesk?: number;
    /** The ID of the sprint that is available under the `sprint` variable when evaluating the expression. */
    sprint?: number;
}

export class JiraExpressionEvalRequestBean implements IJiraExpressionEvalRequestBean {
    /** The context in which the Jira expression is evaluated. */
    context?: JiraExpressionEvalContextBean;
    /** The Jira expression to evaluate. */
    expression!: string;

    constructor(data?: IJiraExpressionEvalRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.context = _data["context"] ? JiraExpressionEvalContextBean.fromJS(_data["context"]) : <any>undefined;
            this.expression = _data["expression"];
        }
    }

    static fromJS(data: any): JiraExpressionEvalRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new JiraExpressionEvalRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["context"] = this.context ? this.context.toJSON() : <any>undefined;
        data["expression"] = this.expression;
        return data;
    }
}

export interface IJiraExpressionEvalRequestBean {
    /** The context in which the Jira expression is evaluated. */
    context?: JiraExpressionEvalContextBean;
    /** The Jira expression to evaluate. */
    expression: string;
}

export class JiraExpressionEvaluateContextBean implements IJiraExpressionEvaluateContextBean {
    /** The ID of the board that is available under the `board` variable when evaluating the expression. */
    board?: number;
    /** Custom context variables and their types. These variable types are available for use in a custom context:

 *  `user`: A [user](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#user) specified as an Atlassian account ID.
 *  `issue`: An [issue](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#issue) specified by ID or key. All the fields of the issue object are available in the Jira expression.
 *  `json`: A JSON object containing custom content.
 *  `list`: A JSON list of `user`, `issue`, or `json` variable types. */
    custom?: Custom[];
    /** The ID of the customer request that is available under the `customerRequest` variable when evaluating the expression. This is the same as the ID of the underlying Jira issue, but the customer request context variable will have a different type. */
    customerRequest?: number;
    /** The issue that is available under the `issue` variable when evaluating the expression. */
    issue?: IdOrKeyBean;
    /** The collection of issues that is available under the `issues` variable when evaluating the expression. */
    issues?: JexpEvaluateCtxIssues;
    /** The project that is available under the `project` variable when evaluating the expression. */
    project?: IdOrKeyBean;
    /** The ID of the service desk that is available under the `serviceDesk` variable when evaluating the expression. */
    serviceDesk?: number;
    /** The ID of the sprint that is available under the `sprint` variable when evaluating the expression. */
    sprint?: number;

    constructor(data?: IJiraExpressionEvaluateContextBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.board = _data["board"];
            if (Array.isArray(_data["custom"])) {
                this.custom = [] as any;
                for (let item of _data["custom"])
                    this.custom!.push(Custom.fromJS(item));
            }
            this.customerRequest = _data["customerRequest"];
            this.issue = _data["issue"] ? IdOrKeyBean.fromJS(_data["issue"]) : <any>undefined;
            this.issues = _data["issues"] ? JexpEvaluateCtxIssues.fromJS(_data["issues"]) : <any>undefined;
            this.project = _data["project"] ? IdOrKeyBean.fromJS(_data["project"]) : <any>undefined;
            this.serviceDesk = _data["serviceDesk"];
            this.sprint = _data["sprint"];
        }
    }

    static fromJS(data: any): JiraExpressionEvaluateContextBean {
        data = typeof data === 'object' ? data : {};
        let result = new JiraExpressionEvaluateContextBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["board"] = this.board;
        if (Array.isArray(this.custom)) {
            data["custom"] = [];
            for (let item of this.custom)
                data["custom"].push(item.toJSON());
        }
        data["customerRequest"] = this.customerRequest;
        data["issue"] = this.issue ? this.issue.toJSON() : <any>undefined;
        data["issues"] = this.issues ? this.issues.toJSON() : <any>undefined;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["serviceDesk"] = this.serviceDesk;
        data["sprint"] = this.sprint;
        return data;
    }
}

export interface IJiraExpressionEvaluateContextBean {
    /** The ID of the board that is available under the `board` variable when evaluating the expression. */
    board?: number;
    /** Custom context variables and their types. These variable types are available for use in a custom context:

 *  `user`: A [user](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#user) specified as an Atlassian account ID.
 *  `issue`: An [issue](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#issue) specified by ID or key. All the fields of the issue object are available in the Jira expression.
 *  `json`: A JSON object containing custom content.
 *  `list`: A JSON list of `user`, `issue`, or `json` variable types. */
    custom?: Custom[];
    /** The ID of the customer request that is available under the `customerRequest` variable when evaluating the expression. This is the same as the ID of the underlying Jira issue, but the customer request context variable will have a different type. */
    customerRequest?: number;
    /** The issue that is available under the `issue` variable when evaluating the expression. */
    issue?: IdOrKeyBean;
    /** The collection of issues that is available under the `issues` variable when evaluating the expression. */
    issues?: JexpEvaluateCtxIssues;
    /** The project that is available under the `project` variable when evaluating the expression. */
    project?: IdOrKeyBean;
    /** The ID of the service desk that is available under the `serviceDesk` variable when evaluating the expression. */
    serviceDesk?: number;
    /** The ID of the sprint that is available under the `sprint` variable when evaluating the expression. */
    sprint?: number;
}

/** The request to evaluate a Jira expression. This bean will be replacing `JiraExpressionEvaluateRequest` as part of new `evaluate` endpoint */
export class JiraExpressionEvaluateRequestBean implements IJiraExpressionEvaluateRequestBean {
    /** The context in which the Jira expression is evaluated. */
    context?: JiraExpressionEvaluateContextBean;
    /** The Jira expression to evaluate. */
    expression!: string;

    constructor(data?: IJiraExpressionEvaluateRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.context = _data["context"] ? JiraExpressionEvaluateContextBean.fromJS(_data["context"]) : <any>undefined;
            this.expression = _data["expression"];
        }
    }

    static fromJS(data: any): JiraExpressionEvaluateRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new JiraExpressionEvaluateRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["context"] = this.context ? this.context.toJSON() : <any>undefined;
        data["expression"] = this.expression;
        return data;
    }
}

/** The request to evaluate a Jira expression. This bean will be replacing `JiraExpressionEvaluateRequest` as part of new `evaluate` endpoint */
export interface IJiraExpressionEvaluateRequestBean {
    /** The context in which the Jira expression is evaluated. */
    context?: JiraExpressionEvaluateContextBean;
    /** The Jira expression to evaluate. */
    expression: string;
}

export class JiraExpressionEvaluationMetaDataBean implements IJiraExpressionEvaluationMetaDataBean {
    /** Contains information about the expression complexity. For example, the number of steps it took to evaluate the expression. */
    complexity?: JiraExpressionsComplexityBean;
    /** Contains information about the `issues` variable in the context. For example, is the issues were loaded with JQL, information about the page will be included here. */
    issues?: IssuesMetaBean;

    constructor(data?: IJiraExpressionEvaluationMetaDataBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.complexity = _data["complexity"] ? JiraExpressionsComplexityBean.fromJS(_data["complexity"]) : <any>undefined;
            this.issues = _data["issues"] ? IssuesMetaBean.fromJS(_data["issues"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JiraExpressionEvaluationMetaDataBean {
        data = typeof data === 'object' ? data : {};
        let result = new JiraExpressionEvaluationMetaDataBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["complexity"] = this.complexity ? this.complexity.toJSON() : <any>undefined;
        data["issues"] = this.issues ? this.issues.toJSON() : <any>undefined;
        return data;
    }
}

export interface IJiraExpressionEvaluationMetaDataBean {
    /** Contains information about the expression complexity. For example, the number of steps it took to evaluate the expression. */
    complexity?: JiraExpressionsComplexityBean;
    /** Contains information about the `issues` variable in the context. For example, is the issues were loaded with JQL, information about the page will be included here. */
    issues?: IssuesMetaBean;
}

/** Details of Jira expressions for analysis. */
export class JiraExpressionForAnalysis implements IJiraExpressionForAnalysis {
    /** Context variables and their types. The type checker assumes that [common context variables](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#context-variables), such as `issue` or `project`, are available in context and sets their type. Use this property to override the default types or provide details of new variables. */
    contextVariables?: { [key: string]: string; };
    /** The list of Jira expressions to analyse. */
    expressions!: string[];

    constructor(data?: IJiraExpressionForAnalysis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.expressions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["contextVariables"]) {
                this.contextVariables = {} as any;
                for (let key in _data["contextVariables"]) {
                    if (_data["contextVariables"].hasOwnProperty(key))
                        (<any>this.contextVariables)![key] = _data["contextVariables"][key];
                }
            }
            if (Array.isArray(_data["expressions"])) {
                this.expressions = [] as any;
                for (let item of _data["expressions"])
                    this.expressions!.push(item);
            }
        }
    }

    static fromJS(data: any): JiraExpressionForAnalysis {
        data = typeof data === 'object' ? data : {};
        let result = new JiraExpressionForAnalysis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.contextVariables) {
            data["contextVariables"] = {};
            for (let key in this.contextVariables) {
                if (this.contextVariables.hasOwnProperty(key))
                    (<any>data["contextVariables"])[key] = (<any>this.contextVariables)[key];
            }
        }
        if (Array.isArray(this.expressions)) {
            data["expressions"] = [];
            for (let item of this.expressions)
                data["expressions"].push(item);
        }
        return data;
    }
}

/** Details of Jira expressions for analysis. */
export interface IJiraExpressionForAnalysis {
    /** Context variables and their types. The type checker assumes that [common context variables](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#context-variables), such as `issue` or `project`, are available in context and sets their type. Use this property to override the default types or provide details of new variables. */
    contextVariables?: { [key: string]: string; };
    /** The list of Jira expressions to analyse. */
    expressions: string[];
}

/** The result of evaluating a Jira expression. */
export class JiraExpressionResult implements IJiraExpressionResult {
    /** Contains various characteristics of the performed expression evaluation. */
    meta?: JiraExpressionEvaluationMetaDataBean;
    /** The value of the evaluated expression. It may be a primitive JSON value or a Jira REST API object. (Some expressions do not produce any meaningful results—for example, an expression that returns a lambda function—if that's the case a simple string representation is returned. These string representations should not be relied upon and may change without notice.) */
    value!: any;

    constructor(data?: IJiraExpressionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.meta = _data["meta"] ? JiraExpressionEvaluationMetaDataBean.fromJS(_data["meta"]) : <any>undefined;
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): JiraExpressionResult {
        data = typeof data === 'object' ? data : {};
        let result = new JiraExpressionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        data["value"] = this.value;
        return data;
    }
}

/** The result of evaluating a Jira expression. */
export interface IJiraExpressionResult {
    /** Contains various characteristics of the performed expression evaluation. */
    meta?: JiraExpressionEvaluationMetaDataBean;
    /** The value of the evaluated expression. It may be a primitive JSON value or a Jira REST API object. (Some expressions do not produce any meaningful results—for example, an expression that returns a lambda function—if that's the case a simple string representation is returned. These string representations should not be relied upon and may change without notice.) */
    value: any;
}

/** Details about syntax and type errors. The error details apply to the entire expression, unless the object includes: *  `line` and `column` *  `expression` */
export class JiraExpressionValidationError implements IJiraExpressionValidationError {
    /** The text column in which the error occurred. */
    column?: number;
    /** The part of the expression in which the error occurred. */
    expression?: string;
    /** The text line in which the error occurred. */
    line?: number;
    /** Details about the error. */
    message!: string;
    /** The error type. */
    type!: JiraExpressionValidationErrorType;

    constructor(data?: IJiraExpressionValidationError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.column = _data["column"];
            this.expression = _data["expression"];
            this.line = _data["line"];
            this.message = _data["message"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): JiraExpressionValidationError {
        data = typeof data === 'object' ? data : {};
        let result = new JiraExpressionValidationError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["column"] = this.column;
        data["expression"] = this.expression;
        data["line"] = this.line;
        data["message"] = this.message;
        data["type"] = this.type;
        return data;
    }
}

/** Details about syntax and type errors. The error details apply to the entire expression, unless the object includes: *  `line` and `column` *  `expression` */
export interface IJiraExpressionValidationError {
    /** The text column in which the error occurred. */
    column?: number;
    /** The part of the expression in which the error occurred. */
    expression?: string;
    /** The text line in which the error occurred. */
    line?: number;
    /** Details about the error. */
    message: string;
    /** The error type. */
    type: JiraExpressionValidationErrorType;
}

/** Details about the analysed Jira expression. */
export class JiraExpressionsAnalysis implements IJiraExpressionsAnalysis {
    /** The results of Jira expressions analysis. */
    results!: JiraExpressionAnalysis[];

    constructor(data?: IJiraExpressionsAnalysis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(JiraExpressionAnalysis.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JiraExpressionsAnalysis {
        data = typeof data === 'object' ? data : {};
        let result = new JiraExpressionsAnalysis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

/** Details about the analysed Jira expression. */
export interface IJiraExpressionsAnalysis {
    /** The results of Jira expressions analysis. */
    results: JiraExpressionAnalysis[];
}

export class JiraExpressionsComplexityBean implements IJiraExpressionsComplexityBean {
    /** The number of Jira REST API beans returned in the response. */
    beans!: JiraExpressionsComplexityValueBean;
    /** The number of expensive operations executed while evaluating the expression. Expensive operations are those that load additional data, such as entity properties, comments, or custom fields. */
    expensiveOperations!: JiraExpressionsComplexityValueBean;
    /** The number of primitive values returned in the response. */
    primitiveValues!: JiraExpressionsComplexityValueBean;
    /** The number of steps it took to evaluate the expression, where a step is a high-level operation performed by the expression. A step is an operation such as arithmetic, accessing a property, accessing a context variable, or calling a function. */
    steps!: JiraExpressionsComplexityValueBean;

    constructor(data?: IJiraExpressionsComplexityBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.beans = new JiraExpressionsComplexityValueBean();
            this.expensiveOperations = new JiraExpressionsComplexityValueBean();
            this.primitiveValues = new JiraExpressionsComplexityValueBean();
            this.steps = new JiraExpressionsComplexityValueBean();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.beans = _data["beans"] ? JiraExpressionsComplexityValueBean.fromJS(_data["beans"]) : new JiraExpressionsComplexityValueBean();
            this.expensiveOperations = _data["expensiveOperations"] ? JiraExpressionsComplexityValueBean.fromJS(_data["expensiveOperations"]) : new JiraExpressionsComplexityValueBean();
            this.primitiveValues = _data["primitiveValues"] ? JiraExpressionsComplexityValueBean.fromJS(_data["primitiveValues"]) : new JiraExpressionsComplexityValueBean();
            this.steps = _data["steps"] ? JiraExpressionsComplexityValueBean.fromJS(_data["steps"]) : new JiraExpressionsComplexityValueBean();
        }
    }

    static fromJS(data: any): JiraExpressionsComplexityBean {
        data = typeof data === 'object' ? data : {};
        let result = new JiraExpressionsComplexityBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["beans"] = this.beans ? this.beans.toJSON() : <any>undefined;
        data["expensiveOperations"] = this.expensiveOperations ? this.expensiveOperations.toJSON() : <any>undefined;
        data["primitiveValues"] = this.primitiveValues ? this.primitiveValues.toJSON() : <any>undefined;
        data["steps"] = this.steps ? this.steps.toJSON() : <any>undefined;
        return data;
    }
}

export interface IJiraExpressionsComplexityBean {
    /** The number of Jira REST API beans returned in the response. */
    beans: JiraExpressionsComplexityValueBean;
    /** The number of expensive operations executed while evaluating the expression. Expensive operations are those that load additional data, such as entity properties, comments, or custom fields. */
    expensiveOperations: JiraExpressionsComplexityValueBean;
    /** The number of primitive values returned in the response. */
    primitiveValues: JiraExpressionsComplexityValueBean;
    /** The number of steps it took to evaluate the expression, where a step is a high-level operation performed by the expression. A step is an operation such as arithmetic, accessing a property, accessing a context variable, or calling a function. */
    steps: JiraExpressionsComplexityValueBean;
}

export class JiraExpressionsComplexityValueBean implements IJiraExpressionsComplexityValueBean {
    /** The maximum allowed complexity. The evaluation will fail if this value is exceeded. */
    limit!: number;
    /** The complexity value of the current expression. */
    value!: number;

    constructor(data?: IJiraExpressionsComplexityValueBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.limit = _data["limit"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): JiraExpressionsComplexityValueBean {
        data = typeof data === 'object' ? data : {};
        let result = new JiraExpressionsComplexityValueBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["value"] = this.value;
        return data;
    }
}

export interface IJiraExpressionsComplexityValueBean {
    /** The maximum allowed complexity. The evaluation will fail if this value is exceeded. */
    limit: number;
    /** The complexity value of the current expression. */
    value: number;
}

export class JiraGroupInput implements IJiraGroupInput {
    groupName!: string;

    constructor(data?: IJiraGroupInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupName = _data["groupName"];
        }
    }

    static fromJS(data: any): JiraGroupInput {
        data = typeof data === 'object' ? data : {};
        let result = new JiraGroupInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName;
        return data;
    }
}

export interface IJiraGroupInput {
    groupName: string;
}

export class JiraIssueFields implements IJiraIssueFields {
    /** Add or clear a cascading select field:

 *  To add, specify `optionId` for both parent and child.
 *  To clear the child, set its `optionId` to null.
 *  To clear both, set the parent's `optionId` to null. */
    cascadingSelectFields?: JiraCascadingSelectField[];
    /** Add or clear a number field:

 *  To add, specify a numeric `value`.
 *  To clear, set `value` to `null`. */
    clearableNumberFields?: JiraNumberField[];
    /** Add or clear a color field:

 *  To add, specify the color `name`. Available colors are: `purple`, `blue`, `green`, `teal`, `yellow`, `orange`, `grey`, `dark purple`, `dark blue`, `dark green`, `dark teal`, `dark yellow`, `dark orange`, `dark grey`.
 *  To clear, set the color `name` to an empty string. */
    colorFields?: JiraColorField[];
    /** Add or clear a date picker field:

 *  To add, specify the date in `d/mmm/yy` format or ISO format `dd-mm-yyyy`.
 *  To clear, set `formattedDate` to an empty string. */
    datePickerFields?: JiraDateField[];
    /** Add or clear the planned start date and time:

 *  To add, specify the date and time in ISO format for `formattedDateTime`.
 *  To clear, provide an empty string for `formattedDateTime`. */
    dateTimePickerFields?: JiraDateTimeField[];
    /** Set the issue type field by providing an `issueTypeId`. */
    issueType?: JiraIssueTypeField;
    /** Edit a labels field:

 *  Options include `ADD`, `REPLACE`, `REMOVE`, or `REMOVE_ALL` for bulk edits.
 *  To clear labels, use the `REMOVE_ALL` option with an empty `labels` array. */
    labelsFields?: JiraLabelsField[];
    /** Add or clear a multi-group picker field:

 *  To add groups, provide an array of groups with `groupName`s.
 *  To clear all groups, use an empty `groups` array. */
    multipleGroupPickerFields?: JiraMultipleGroupPickerField[];
    /** Assign or unassign multiple users to/from a field:

 *  To assign, provide an array of user `accountId`s.
 *  To clear, set `users` to `null`. */
    multipleSelectClearableUserPickerFields?: JiraMultipleSelectUserPickerField[];
    /** Add or clear a multi-select field:

 *  To add, provide an array of options with `optionId`s.
 *  To clear, use an empty `options` array. */
    multipleSelectFields?: JiraMultipleSelectField[];
    /** Edit a multi-version picker field like Fix Versions/Affects Versions:

 *  Options include `ADD`, `REPLACE`, `REMOVE`, or `REMOVE_ALL` for bulk edits.
 *  To clear the field, use the `REMOVE_ALL` option with an empty `versions` array. */
    multipleVersionPickerFields?: JiraMultipleVersionPickerField[];
    /** Edit a multi select components field:

 *  Options include `ADD`, `REPLACE`, `REMOVE`, or `REMOVE_ALL` for bulk edits.
 *  To clear, use the `REMOVE_ALL` option with an empty `components` array. */
    multiselectComponents?: JiraMultiSelectComponentField;
    /** Edit the original estimate field. */
    originalEstimateField?: JiraDurationField;
    /** Set the priority of an issue by specifying a `priorityId`. */
    priority?: JiraPriorityField;
    /** Add or clear a rich text field:

 *  To add, provide `adfValue`. Note that rich text fields only support ADF values.
 *  To clear, use an empty `richText` object.

For ADF format details, refer to: [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure). */
    richTextFields?: JiraRichTextField[];
    /** Add or clear a single group picker field:

 *  To add, specify the group with `groupName`.
 *  To clear, set `groupName` to an empty string. */
    singleGroupPickerFields?: JiraSingleGroupPickerField[];
    /** Add or clear a single line text field:

 *  To add, provide the `text` value.
 *  To clear, set `text` to an empty string. */
    singleLineTextFields?: JiraSingleLineTextField[];
    /** Edit assignment for single select user picker fields like Assignee/Reporter:

 *  To assign an issue, specify the user's `accountId`.
 *  To unassign an issue, set `user` to `null`.
 *  For automatic assignment, set `accountId` to `-1`. */
    singleSelectClearableUserPickerFields?: JiraSingleSelectUserPickerField[];
    /** Add or clear a single select field:

 *  To add, specify the option with an `optionId`.
 *  To clear, pass an option with `optionId` as `-1`. */
    singleSelectFields?: JiraSingleSelectField[];
    /** Add or clear a single version picker field:

 *  To add, specify the version with a `versionId`.
 *  To clear, set `versionId` to `-1`. */
    singleVersionPickerFields?: JiraSingleVersionPickerField[];
    status?: JiraStatusInput;
    /** Edit the time tracking field. */
    timeTrackingField?: JiraTimeTrackingField;
    /** Add or clear a URL field:

 *  To add, provide the `url` with the desired URL value.
 *  To clear, set `url` to an empty string. */
    urlFields?: JiraUrlField[];

    constructor(data?: IJiraIssueFields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cascadingSelectFields"])) {
                this.cascadingSelectFields = [] as any;
                for (let item of _data["cascadingSelectFields"])
                    this.cascadingSelectFields!.push(JiraCascadingSelectField.fromJS(item));
            }
            if (Array.isArray(_data["clearableNumberFields"])) {
                this.clearableNumberFields = [] as any;
                for (let item of _data["clearableNumberFields"])
                    this.clearableNumberFields!.push(JiraNumberField.fromJS(item));
            }
            if (Array.isArray(_data["colorFields"])) {
                this.colorFields = [] as any;
                for (let item of _data["colorFields"])
                    this.colorFields!.push(JiraColorField.fromJS(item));
            }
            if (Array.isArray(_data["datePickerFields"])) {
                this.datePickerFields = [] as any;
                for (let item of _data["datePickerFields"])
                    this.datePickerFields!.push(JiraDateField.fromJS(item));
            }
            if (Array.isArray(_data["dateTimePickerFields"])) {
                this.dateTimePickerFields = [] as any;
                for (let item of _data["dateTimePickerFields"])
                    this.dateTimePickerFields!.push(JiraDateTimeField.fromJS(item));
            }
            this.issueType = _data["issueType"] ? JiraIssueTypeField.fromJS(_data["issueType"]) : <any>undefined;
            if (Array.isArray(_data["labelsFields"])) {
                this.labelsFields = [] as any;
                for (let item of _data["labelsFields"])
                    this.labelsFields!.push(JiraLabelsField.fromJS(item));
            }
            if (Array.isArray(_data["multipleGroupPickerFields"])) {
                this.multipleGroupPickerFields = [] as any;
                for (let item of _data["multipleGroupPickerFields"])
                    this.multipleGroupPickerFields!.push(JiraMultipleGroupPickerField.fromJS(item));
            }
            if (Array.isArray(_data["multipleSelectClearableUserPickerFields"])) {
                this.multipleSelectClearableUserPickerFields = [] as any;
                for (let item of _data["multipleSelectClearableUserPickerFields"])
                    this.multipleSelectClearableUserPickerFields!.push(JiraMultipleSelectUserPickerField.fromJS(item));
            }
            if (Array.isArray(_data["multipleSelectFields"])) {
                this.multipleSelectFields = [] as any;
                for (let item of _data["multipleSelectFields"])
                    this.multipleSelectFields!.push(JiraMultipleSelectField.fromJS(item));
            }
            if (Array.isArray(_data["multipleVersionPickerFields"])) {
                this.multipleVersionPickerFields = [] as any;
                for (let item of _data["multipleVersionPickerFields"])
                    this.multipleVersionPickerFields!.push(JiraMultipleVersionPickerField.fromJS(item));
            }
            this.multiselectComponents = _data["multiselectComponents"] ? JiraMultiSelectComponentField.fromJS(_data["multiselectComponents"]) : <any>undefined;
            this.originalEstimateField = _data["originalEstimateField"] ? JiraDurationField.fromJS(_data["originalEstimateField"]) : <any>undefined;
            this.priority = _data["priority"] ? JiraPriorityField.fromJS(_data["priority"]) : <any>undefined;
            if (Array.isArray(_data["richTextFields"])) {
                this.richTextFields = [] as any;
                for (let item of _data["richTextFields"])
                    this.richTextFields!.push(JiraRichTextField.fromJS(item));
            }
            if (Array.isArray(_data["singleGroupPickerFields"])) {
                this.singleGroupPickerFields = [] as any;
                for (let item of _data["singleGroupPickerFields"])
                    this.singleGroupPickerFields!.push(JiraSingleGroupPickerField.fromJS(item));
            }
            if (Array.isArray(_data["singleLineTextFields"])) {
                this.singleLineTextFields = [] as any;
                for (let item of _data["singleLineTextFields"])
                    this.singleLineTextFields!.push(JiraSingleLineTextField.fromJS(item));
            }
            if (Array.isArray(_data["singleSelectClearableUserPickerFields"])) {
                this.singleSelectClearableUserPickerFields = [] as any;
                for (let item of _data["singleSelectClearableUserPickerFields"])
                    this.singleSelectClearableUserPickerFields!.push(JiraSingleSelectUserPickerField.fromJS(item));
            }
            if (Array.isArray(_data["singleSelectFields"])) {
                this.singleSelectFields = [] as any;
                for (let item of _data["singleSelectFields"])
                    this.singleSelectFields!.push(JiraSingleSelectField.fromJS(item));
            }
            if (Array.isArray(_data["singleVersionPickerFields"])) {
                this.singleVersionPickerFields = [] as any;
                for (let item of _data["singleVersionPickerFields"])
                    this.singleVersionPickerFields!.push(JiraSingleVersionPickerField.fromJS(item));
            }
            this.status = _data["status"] ? JiraStatusInput.fromJS(_data["status"]) : <any>undefined;
            this.timeTrackingField = _data["timeTrackingField"] ? JiraTimeTrackingField.fromJS(_data["timeTrackingField"]) : <any>undefined;
            if (Array.isArray(_data["urlFields"])) {
                this.urlFields = [] as any;
                for (let item of _data["urlFields"])
                    this.urlFields!.push(JiraUrlField.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JiraIssueFields {
        data = typeof data === 'object' ? data : {};
        let result = new JiraIssueFields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cascadingSelectFields)) {
            data["cascadingSelectFields"] = [];
            for (let item of this.cascadingSelectFields)
                data["cascadingSelectFields"].push(item.toJSON());
        }
        if (Array.isArray(this.clearableNumberFields)) {
            data["clearableNumberFields"] = [];
            for (let item of this.clearableNumberFields)
                data["clearableNumberFields"].push(item.toJSON());
        }
        if (Array.isArray(this.colorFields)) {
            data["colorFields"] = [];
            for (let item of this.colorFields)
                data["colorFields"].push(item.toJSON());
        }
        if (Array.isArray(this.datePickerFields)) {
            data["datePickerFields"] = [];
            for (let item of this.datePickerFields)
                data["datePickerFields"].push(item.toJSON());
        }
        if (Array.isArray(this.dateTimePickerFields)) {
            data["dateTimePickerFields"] = [];
            for (let item of this.dateTimePickerFields)
                data["dateTimePickerFields"].push(item.toJSON());
        }
        data["issueType"] = this.issueType ? this.issueType.toJSON() : <any>undefined;
        if (Array.isArray(this.labelsFields)) {
            data["labelsFields"] = [];
            for (let item of this.labelsFields)
                data["labelsFields"].push(item.toJSON());
        }
        if (Array.isArray(this.multipleGroupPickerFields)) {
            data["multipleGroupPickerFields"] = [];
            for (let item of this.multipleGroupPickerFields)
                data["multipleGroupPickerFields"].push(item.toJSON());
        }
        if (Array.isArray(this.multipleSelectClearableUserPickerFields)) {
            data["multipleSelectClearableUserPickerFields"] = [];
            for (let item of this.multipleSelectClearableUserPickerFields)
                data["multipleSelectClearableUserPickerFields"].push(item.toJSON());
        }
        if (Array.isArray(this.multipleSelectFields)) {
            data["multipleSelectFields"] = [];
            for (let item of this.multipleSelectFields)
                data["multipleSelectFields"].push(item.toJSON());
        }
        if (Array.isArray(this.multipleVersionPickerFields)) {
            data["multipleVersionPickerFields"] = [];
            for (let item of this.multipleVersionPickerFields)
                data["multipleVersionPickerFields"].push(item.toJSON());
        }
        data["multiselectComponents"] = this.multiselectComponents ? this.multiselectComponents.toJSON() : <any>undefined;
        data["originalEstimateField"] = this.originalEstimateField ? this.originalEstimateField.toJSON() : <any>undefined;
        data["priority"] = this.priority ? this.priority.toJSON() : <any>undefined;
        if (Array.isArray(this.richTextFields)) {
            data["richTextFields"] = [];
            for (let item of this.richTextFields)
                data["richTextFields"].push(item.toJSON());
        }
        if (Array.isArray(this.singleGroupPickerFields)) {
            data["singleGroupPickerFields"] = [];
            for (let item of this.singleGroupPickerFields)
                data["singleGroupPickerFields"].push(item.toJSON());
        }
        if (Array.isArray(this.singleLineTextFields)) {
            data["singleLineTextFields"] = [];
            for (let item of this.singleLineTextFields)
                data["singleLineTextFields"].push(item.toJSON());
        }
        if (Array.isArray(this.singleSelectClearableUserPickerFields)) {
            data["singleSelectClearableUserPickerFields"] = [];
            for (let item of this.singleSelectClearableUserPickerFields)
                data["singleSelectClearableUserPickerFields"].push(item.toJSON());
        }
        if (Array.isArray(this.singleSelectFields)) {
            data["singleSelectFields"] = [];
            for (let item of this.singleSelectFields)
                data["singleSelectFields"].push(item.toJSON());
        }
        if (Array.isArray(this.singleVersionPickerFields)) {
            data["singleVersionPickerFields"] = [];
            for (let item of this.singleVersionPickerFields)
                data["singleVersionPickerFields"].push(item.toJSON());
        }
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["timeTrackingField"] = this.timeTrackingField ? this.timeTrackingField.toJSON() : <any>undefined;
        if (Array.isArray(this.urlFields)) {
            data["urlFields"] = [];
            for (let item of this.urlFields)
                data["urlFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IJiraIssueFields {
    /** Add or clear a cascading select field:

 *  To add, specify `optionId` for both parent and child.
 *  To clear the child, set its `optionId` to null.
 *  To clear both, set the parent's `optionId` to null. */
    cascadingSelectFields?: JiraCascadingSelectField[];
    /** Add or clear a number field:

 *  To add, specify a numeric `value`.
 *  To clear, set `value` to `null`. */
    clearableNumberFields?: JiraNumberField[];
    /** Add or clear a color field:

 *  To add, specify the color `name`. Available colors are: `purple`, `blue`, `green`, `teal`, `yellow`, `orange`, `grey`, `dark purple`, `dark blue`, `dark green`, `dark teal`, `dark yellow`, `dark orange`, `dark grey`.
 *  To clear, set the color `name` to an empty string. */
    colorFields?: JiraColorField[];
    /** Add or clear a date picker field:

 *  To add, specify the date in `d/mmm/yy` format or ISO format `dd-mm-yyyy`.
 *  To clear, set `formattedDate` to an empty string. */
    datePickerFields?: JiraDateField[];
    /** Add or clear the planned start date and time:

 *  To add, specify the date and time in ISO format for `formattedDateTime`.
 *  To clear, provide an empty string for `formattedDateTime`. */
    dateTimePickerFields?: JiraDateTimeField[];
    /** Set the issue type field by providing an `issueTypeId`. */
    issueType?: JiraIssueTypeField;
    /** Edit a labels field:

 *  Options include `ADD`, `REPLACE`, `REMOVE`, or `REMOVE_ALL` for bulk edits.
 *  To clear labels, use the `REMOVE_ALL` option with an empty `labels` array. */
    labelsFields?: JiraLabelsField[];
    /** Add or clear a multi-group picker field:

 *  To add groups, provide an array of groups with `groupName`s.
 *  To clear all groups, use an empty `groups` array. */
    multipleGroupPickerFields?: JiraMultipleGroupPickerField[];
    /** Assign or unassign multiple users to/from a field:

 *  To assign, provide an array of user `accountId`s.
 *  To clear, set `users` to `null`. */
    multipleSelectClearableUserPickerFields?: JiraMultipleSelectUserPickerField[];
    /** Add or clear a multi-select field:

 *  To add, provide an array of options with `optionId`s.
 *  To clear, use an empty `options` array. */
    multipleSelectFields?: JiraMultipleSelectField[];
    /** Edit a multi-version picker field like Fix Versions/Affects Versions:

 *  Options include `ADD`, `REPLACE`, `REMOVE`, or `REMOVE_ALL` for bulk edits.
 *  To clear the field, use the `REMOVE_ALL` option with an empty `versions` array. */
    multipleVersionPickerFields?: JiraMultipleVersionPickerField[];
    /** Edit a multi select components field:

 *  Options include `ADD`, `REPLACE`, `REMOVE`, or `REMOVE_ALL` for bulk edits.
 *  To clear, use the `REMOVE_ALL` option with an empty `components` array. */
    multiselectComponents?: JiraMultiSelectComponentField;
    /** Edit the original estimate field. */
    originalEstimateField?: JiraDurationField;
    /** Set the priority of an issue by specifying a `priorityId`. */
    priority?: JiraPriorityField;
    /** Add or clear a rich text field:

 *  To add, provide `adfValue`. Note that rich text fields only support ADF values.
 *  To clear, use an empty `richText` object.

For ADF format details, refer to: [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure). */
    richTextFields?: JiraRichTextField[];
    /** Add or clear a single group picker field:

 *  To add, specify the group with `groupName`.
 *  To clear, set `groupName` to an empty string. */
    singleGroupPickerFields?: JiraSingleGroupPickerField[];
    /** Add or clear a single line text field:

 *  To add, provide the `text` value.
 *  To clear, set `text` to an empty string. */
    singleLineTextFields?: JiraSingleLineTextField[];
    /** Edit assignment for single select user picker fields like Assignee/Reporter:

 *  To assign an issue, specify the user's `accountId`.
 *  To unassign an issue, set `user` to `null`.
 *  For automatic assignment, set `accountId` to `-1`. */
    singleSelectClearableUserPickerFields?: JiraSingleSelectUserPickerField[];
    /** Add or clear a single select field:

 *  To add, specify the option with an `optionId`.
 *  To clear, pass an option with `optionId` as `-1`. */
    singleSelectFields?: JiraSingleSelectField[];
    /** Add or clear a single version picker field:

 *  To add, specify the version with a `versionId`.
 *  To clear, set `versionId` to `-1`. */
    singleVersionPickerFields?: JiraSingleVersionPickerField[];
    status?: JiraStatusInput;
    /** Edit the time tracking field. */
    timeTrackingField?: JiraTimeTrackingField;
    /** Add or clear a URL field:

 *  To add, provide the `url` with the desired URL value.
 *  To clear, set `url` to an empty string. */
    urlFields?: JiraUrlField[];
}

export class JiraIssueTypeField implements IJiraIssueTypeField {
    issueTypeId!: string;

    constructor(data?: IJiraIssueTypeField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueTypeId = _data["issueTypeId"];
        }
    }

    static fromJS(data: any): JiraIssueTypeField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraIssueTypeField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueTypeId"] = this.issueTypeId;
        return data;
    }
}

export interface IJiraIssueTypeField {
    issueTypeId: string;
}

export class JiraLabelsField implements IJiraLabelsField {
    bulkEditMultiSelectFieldOption!: JiraLabelsFieldBulkEditMultiSelectFieldOption;
    fieldId!: string;
    labels!: JiraLabelsInput[];

    constructor(data?: IJiraLabelsField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.labels = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bulkEditMultiSelectFieldOption = _data["bulkEditMultiSelectFieldOption"];
            this.fieldId = _data["fieldId"];
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(JiraLabelsInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JiraLabelsField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraLabelsField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bulkEditMultiSelectFieldOption"] = this.bulkEditMultiSelectFieldOption;
        data["fieldId"] = this.fieldId;
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        return data;
    }
}

export interface IJiraLabelsField {
    bulkEditMultiSelectFieldOption: JiraLabelsFieldBulkEditMultiSelectFieldOption;
    fieldId: string;
    labels: JiraLabelsInput[];
}

export class JiraLabelsInput implements IJiraLabelsInput {
    name!: string;

    constructor(data?: IJiraLabelsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): JiraLabelsInput {
        data = typeof data === 'object' ? data : {};
        let result = new JiraLabelsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IJiraLabelsInput {
    name: string;
}

export class JiraMultiSelectComponentField implements IJiraMultiSelectComponentField {
    bulkEditMultiSelectFieldOption!: JiraMultiSelectComponentFieldBulkEditMultiSelectFieldOption;
    components!: JiraComponentField[];
    fieldId!: string;

    constructor(data?: IJiraMultiSelectComponentField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.components = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bulkEditMultiSelectFieldOption = _data["bulkEditMultiSelectFieldOption"];
            if (Array.isArray(_data["components"])) {
                this.components = [] as any;
                for (let item of _data["components"])
                    this.components!.push(JiraComponentField.fromJS(item));
            }
            this.fieldId = _data["fieldId"];
        }
    }

    static fromJS(data: any): JiraMultiSelectComponentField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraMultiSelectComponentField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bulkEditMultiSelectFieldOption"] = this.bulkEditMultiSelectFieldOption;
        if (Array.isArray(this.components)) {
            data["components"] = [];
            for (let item of this.components)
                data["components"].push(item.toJSON());
        }
        data["fieldId"] = this.fieldId;
        return data;
    }
}

export interface IJiraMultiSelectComponentField {
    bulkEditMultiSelectFieldOption: JiraMultiSelectComponentFieldBulkEditMultiSelectFieldOption;
    components: JiraComponentField[];
    fieldId: string;
}

export class JiraMultipleGroupPickerField implements IJiraMultipleGroupPickerField {
    fieldId!: string;
    groups!: JiraGroupInput[];

    constructor(data?: IJiraMultipleGroupPickerField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.groups = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(JiraGroupInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JiraMultipleGroupPickerField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraMultipleGroupPickerField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        return data;
    }
}

export interface IJiraMultipleGroupPickerField {
    fieldId: string;
    groups: JiraGroupInput[];
}

export class JiraMultipleSelectField implements IJiraMultipleSelectField {
    fieldId!: string;
    options!: JiraSelectedOptionField[];

    constructor(data?: IJiraMultipleSelectField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.options = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(JiraSelectedOptionField.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JiraMultipleSelectField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraMultipleSelectField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data;
    }
}

export interface IJiraMultipleSelectField {
    fieldId: string;
    options: JiraSelectedOptionField[];
}

export class JiraMultipleSelectUserPickerField implements IJiraMultipleSelectUserPickerField {
    fieldId!: string;
    users?: JiraUserField[];

    constructor(data?: IJiraMultipleSelectUserPickerField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(JiraUserField.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JiraMultipleSelectUserPickerField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraMultipleSelectUserPickerField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

export interface IJiraMultipleSelectUserPickerField {
    fieldId: string;
    users?: JiraUserField[];
}

export class JiraMultipleVersionPickerField implements IJiraMultipleVersionPickerField {
    bulkEditMultiSelectFieldOption!: JiraMultipleVersionPickerFieldBulkEditMultiSelectFieldOption;
    fieldId!: string;
    versions!: JiraVersionField[];

    constructor(data?: IJiraMultipleVersionPickerField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.versions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bulkEditMultiSelectFieldOption = _data["bulkEditMultiSelectFieldOption"];
            this.fieldId = _data["fieldId"];
            if (Array.isArray(_data["versions"])) {
                this.versions = [] as any;
                for (let item of _data["versions"])
                    this.versions!.push(JiraVersionField.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JiraMultipleVersionPickerField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraMultipleVersionPickerField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bulkEditMultiSelectFieldOption"] = this.bulkEditMultiSelectFieldOption;
        data["fieldId"] = this.fieldId;
        if (Array.isArray(this.versions)) {
            data["versions"] = [];
            for (let item of this.versions)
                data["versions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IJiraMultipleVersionPickerField {
    bulkEditMultiSelectFieldOption: JiraMultipleVersionPickerFieldBulkEditMultiSelectFieldOption;
    fieldId: string;
    versions: JiraVersionField[];
}

export class JiraNumberField implements IJiraNumberField {
    fieldId!: string;
    value?: number;

    constructor(data?: IJiraNumberField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): JiraNumberField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraNumberField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["value"] = this.value;
        return data;
    }
}

export interface IJiraNumberField {
    fieldId: string;
    value?: number;
}

export class JiraPriorityField implements IJiraPriorityField {
    priorityId!: string;

    constructor(data?: IJiraPriorityField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.priorityId = _data["priorityId"];
        }
    }

    static fromJS(data: any): JiraPriorityField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraPriorityField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priorityId"] = this.priorityId;
        return data;
    }
}

export interface IJiraPriorityField {
    priorityId: string;
}

export class JiraRichTextField implements IJiraRichTextField {
    fieldId!: string;
    richText!: JiraRichTextInput;

    constructor(data?: IJiraRichTextField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.richText = new JiraRichTextInput();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.richText = _data["richText"] ? JiraRichTextInput.fromJS(_data["richText"]) : new JiraRichTextInput();
        }
    }

    static fromJS(data: any): JiraRichTextField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraRichTextField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["richText"] = this.richText ? this.richText.toJSON() : <any>undefined;
        return data;
    }
}

export interface IJiraRichTextField {
    fieldId: string;
    richText: JiraRichTextInput;
}

export class JiraRichTextInput implements IJiraRichTextInput {
    adfValue?: { [key: string]: any; };

    constructor(data?: IJiraRichTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["adfValue"]) {
                this.adfValue = {} as any;
                for (let key in _data["adfValue"]) {
                    if (_data["adfValue"].hasOwnProperty(key))
                        (<any>this.adfValue)![key] = _data["adfValue"][key];
                }
            }
        }
    }

    static fromJS(data: any): JiraRichTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new JiraRichTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.adfValue) {
            data["adfValue"] = {};
            for (let key in this.adfValue) {
                if (this.adfValue.hasOwnProperty(key))
                    (<any>data["adfValue"])[key] = (<any>this.adfValue)[key];
            }
        }
        return data;
    }
}

export interface IJiraRichTextInput {
    adfValue?: { [key: string]: any; };
}

export class JiraSelectedOptionField implements IJiraSelectedOptionField {
    optionId?: number;

    constructor(data?: IJiraSelectedOptionField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.optionId = _data["optionId"];
        }
    }

    static fromJS(data: any): JiraSelectedOptionField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraSelectedOptionField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["optionId"] = this.optionId;
        return data;
    }
}

export interface IJiraSelectedOptionField {
    optionId?: number;
}

export class JiraSingleGroupPickerField implements IJiraSingleGroupPickerField {
    fieldId!: string;
    group!: JiraGroupInput;

    constructor(data?: IJiraSingleGroupPickerField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.group = new JiraGroupInput();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.group = _data["group"] ? JiraGroupInput.fromJS(_data["group"]) : new JiraGroupInput();
        }
    }

    static fromJS(data: any): JiraSingleGroupPickerField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraSingleGroupPickerField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        return data;
    }
}

export interface IJiraSingleGroupPickerField {
    fieldId: string;
    group: JiraGroupInput;
}

export class JiraSingleLineTextField implements IJiraSingleLineTextField {
    fieldId!: string;
    text!: string;

    constructor(data?: IJiraSingleLineTextField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.text = _data["text"];
        }
    }

    static fromJS(data: any): JiraSingleLineTextField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraSingleLineTextField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["text"] = this.text;
        return data;
    }
}

export interface IJiraSingleLineTextField {
    fieldId: string;
    text: string;
}

/** Add or clear a single select field: *  To add, specify the option with an `optionId`. *  To clear, pass an option with `optionId` as `-1`. */
export class JiraSingleSelectField implements IJiraSingleSelectField {
    fieldId!: string;
    option!: JiraSelectedOptionField;

    constructor(data?: IJiraSingleSelectField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.option = new JiraSelectedOptionField();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.option = _data["option"] ? JiraSelectedOptionField.fromJS(_data["option"]) : new JiraSelectedOptionField();
        }
    }

    static fromJS(data: any): JiraSingleSelectField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraSingleSelectField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["option"] = this.option ? this.option.toJSON() : <any>undefined;
        return data;
    }
}

/** Add or clear a single select field: *  To add, specify the option with an `optionId`. *  To clear, pass an option with `optionId` as `-1`. */
export interface IJiraSingleSelectField {
    fieldId: string;
    option: JiraSelectedOptionField;
}

export class JiraSingleSelectUserPickerField implements IJiraSingleSelectUserPickerField {
    fieldId!: string;
    user?: JiraUserField;

    constructor(data?: IJiraSingleSelectUserPickerField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.user = _data["user"] ? JiraUserField.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JiraSingleSelectUserPickerField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraSingleSelectUserPickerField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface IJiraSingleSelectUserPickerField {
    fieldId: string;
    user?: JiraUserField;
}

export class JiraSingleVersionPickerField implements IJiraSingleVersionPickerField {
    fieldId!: string;
    version!: JiraVersionField;

    constructor(data?: IJiraSingleVersionPickerField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.version = new JiraVersionField();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.version = _data["version"] ? JiraVersionField.fromJS(_data["version"]) : new JiraVersionField();
        }
    }

    static fromJS(data: any): JiraSingleVersionPickerField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraSingleVersionPickerField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["version"] = this.version ? this.version.toJSON() : <any>undefined;
        return data;
    }
}

export interface IJiraSingleVersionPickerField {
    fieldId: string;
    version: JiraVersionField;
}

/** Details of a status. */
export class JiraStatus implements IJiraStatus {
    /** The description of the status. */
    description?: string;
    /** The ID of the status. */
    id?: string;
    /** The name of the status. */
    name?: string;
    scope?: StatusScope;
    /** The category of the status. */
    statusCategory?: JiraStatusStatusCategory;
    /** Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details.

Projects and issue types where the status is used. Only available if the `usages` expand is requested. */
    usages?: (ProjectIssueTypes | undefined)[] | undefined;
    /** Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details.

The workflows that use this status. Only available if the `workflowUsages` expand is requested. */
    workflowUsages?: (WorkflowUsages | undefined)[] | undefined;

    constructor(data?: IJiraStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.scope = _data["scope"] ? StatusScope.fromJS(_data["scope"]) : <any>undefined;
            this.statusCategory = _data["statusCategory"];
            if (Array.isArray(_data["usages"])) {
                this.usages = [] as any;
                for (let item of _data["usages"])
                    this.usages!.push(ProjectIssueTypes.fromJS(item));
            }
            if (Array.isArray(_data["workflowUsages"])) {
                this.workflowUsages = [] as any;
                for (let item of _data["workflowUsages"])
                    this.workflowUsages!.push(WorkflowUsages.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JiraStatus {
        data = typeof data === 'object' ? data : {};
        let result = new JiraStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        data["statusCategory"] = this.statusCategory;
        if (Array.isArray(this.usages)) {
            data["usages"] = [];
            for (let item of this.usages)
                data["usages"].push(item.toJSON());
        }
        if (Array.isArray(this.workflowUsages)) {
            data["workflowUsages"] = [];
            for (let item of this.workflowUsages)
                data["workflowUsages"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of a status. */
export interface IJiraStatus {
    /** The description of the status. */
    description?: string;
    /** The ID of the status. */
    id?: string;
    /** The name of the status. */
    name?: string;
    scope?: StatusScope;
    /** The category of the status. */
    statusCategory?: JiraStatusStatusCategory;
    /** Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details.

Projects and issue types where the status is used. Only available if the `usages` expand is requested. */
    usages?: (ProjectIssueTypes | undefined)[] | undefined;
    /** Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details.

The workflows that use this status. Only available if the `workflowUsages` expand is requested. */
    workflowUsages?: (WorkflowUsages | undefined)[] | undefined;
}

export class JiraStatusInput implements IJiraStatusInput {
    statusId!: string;

    constructor(data?: IJiraStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): JiraStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new JiraStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusId"] = this.statusId;
        return data;
    }
}

export interface IJiraStatusInput {
    statusId: string;
}

export class JiraTimeTrackingField implements IJiraTimeTrackingField {
    timeRemaining!: string;

    constructor(data?: IJiraTimeTrackingField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeRemaining = _data["timeRemaining"];
        }
    }

    static fromJS(data: any): JiraTimeTrackingField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraTimeTrackingField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeRemaining"] = this.timeRemaining;
        return data;
    }
}

export interface IJiraTimeTrackingField {
    timeRemaining: string;
}

export class JiraUrlField implements IJiraUrlField {
    fieldId!: string;
    url!: string;

    constructor(data?: IJiraUrlField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldId = _data["fieldId"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): JiraUrlField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraUrlField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldId"] = this.fieldId;
        data["url"] = this.url;
        return data;
    }
}

export interface IJiraUrlField {
    fieldId: string;
    url: string;
}

export class JiraUserField implements IJiraUserField {
    accountId!: string;

    constructor(data?: IJiraUserField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
        }
    }

    static fromJS(data: any): JiraUserField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraUserField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        return data;
    }
}

export interface IJiraUserField {
    accountId: string;
}

export class JiraVersionField implements IJiraVersionField {
    versionId?: string;

    constructor(data?: IJiraVersionField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.versionId = _data["versionId"];
        }
    }

    static fromJS(data: any): JiraVersionField {
        data = typeof data === 'object' ? data : {};
        let result = new JiraVersionField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["versionId"] = this.versionId;
        return data;
    }
}

export interface IJiraVersionField {
    versionId?: string;
}

/** Details of a workflow. */
export class JiraWorkflow implements IJiraWorkflow {
    /** The creation date of the workflow. */
    created?: string | undefined;
    /** The description of the workflow. */
    description?: string;
    /** The ID of the workflow. */
    id?: string;
    /** Indicates if the workflow can be edited. */
    isEditable?: boolean;
    loopedTransitionContainerLayout?: WorkflowLayout | undefined;
    /** The name of the workflow. */
    name?: string;
    scope?: WorkflowScope;
    startPointLayout?: WorkflowLayout | undefined;
    /** The statuses referenced in this workflow. */
    statuses?: WorkflowReferenceStatus[];
    /** If there is a current [asynchronous task](#async-operations) operation for this workflow. */
    taskId?: string | undefined;
    /** The transitions of the workflow. Note that a transition can have either the deprecated `to`/`from` fields or the `toStatusReference`/`links` fields, but never both nor a combination. */
    transitions?: WorkflowTransitions[];
    /** The last edited date of the workflow. */
    updated?: string | undefined;
    /** Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details.

Use the optional `workflows.usages` expand to get additional information about the projects and issue types associated with the requested workflows. */
    usages?: (ProjectIssueTypes | undefined)[] | undefined;
    version?: DocumentVersion;

    constructor(data?: IJiraWorkflow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.created = _data["created"];
            this.description = _data["description"];
            this.id = _data["id"];
            this.isEditable = _data["isEditable"];
            this.loopedTransitionContainerLayout = _data["loopedTransitionContainerLayout"] ? WorkflowLayout.fromJS(_data["loopedTransitionContainerLayout"]) : <any>undefined;
            this.name = _data["name"];
            this.scope = _data["scope"] ? WorkflowScope.fromJS(_data["scope"]) : <any>undefined;
            this.startPointLayout = _data["startPointLayout"] ? WorkflowLayout.fromJS(_data["startPointLayout"]) : <any>undefined;
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(WorkflowReferenceStatus.fromJS(item));
            }
            this.taskId = _data["taskId"];
            if (Array.isArray(_data["transitions"])) {
                this.transitions = [] as any;
                for (let item of _data["transitions"])
                    this.transitions!.push(WorkflowTransitions.fromJS(item));
            }
            this.updated = _data["updated"];
            if (Array.isArray(_data["usages"])) {
                this.usages = [] as any;
                for (let item of _data["usages"])
                    this.usages!.push(ProjectIssueTypes.fromJS(item));
            }
            this.version = _data["version"] ? DocumentVersion.fromJS(_data["version"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JiraWorkflow {
        data = typeof data === 'object' ? data : {};
        let result = new JiraWorkflow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created;
        data["description"] = this.description;
        data["id"] = this.id;
        data["isEditable"] = this.isEditable;
        data["loopedTransitionContainerLayout"] = this.loopedTransitionContainerLayout ? this.loopedTransitionContainerLayout.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        data["startPointLayout"] = this.startPointLayout ? this.startPointLayout.toJSON() : <any>undefined;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        data["taskId"] = this.taskId;
        if (Array.isArray(this.transitions)) {
            data["transitions"] = [];
            for (let item of this.transitions)
                data["transitions"].push(item.toJSON());
        }
        data["updated"] = this.updated;
        if (Array.isArray(this.usages)) {
            data["usages"] = [];
            for (let item of this.usages)
                data["usages"].push(item.toJSON());
        }
        data["version"] = this.version ? this.version.toJSON() : <any>undefined;
        return data;
    }
}

/** Details of a workflow. */
export interface IJiraWorkflow {
    /** The creation date of the workflow. */
    created?: string | undefined;
    /** The description of the workflow. */
    description?: string;
    /** The ID of the workflow. */
    id?: string;
    /** Indicates if the workflow can be edited. */
    isEditable?: boolean;
    loopedTransitionContainerLayout?: WorkflowLayout | undefined;
    /** The name of the workflow. */
    name?: string;
    scope?: WorkflowScope;
    startPointLayout?: WorkflowLayout | undefined;
    /** The statuses referenced in this workflow. */
    statuses?: WorkflowReferenceStatus[];
    /** If there is a current [asynchronous task](#async-operations) operation for this workflow. */
    taskId?: string | undefined;
    /** The transitions of the workflow. Note that a transition can have either the deprecated `to`/`from` fields or the `toStatusReference`/`links` fields, but never both nor a combination. */
    transitions?: WorkflowTransitions[];
    /** The last edited date of the workflow. */
    updated?: string | undefined;
    /** Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details.

Use the optional `workflows.usages` expand to get additional information about the projects and issue types associated with the requested workflows. */
    usages?: (ProjectIssueTypes | undefined)[] | undefined;
    version?: DocumentVersion;
}

/** Details of a status. */
export class JiraWorkflowStatus implements IJiraWorkflowStatus {
    /** The description of the status. */
    description?: string;
    /** The ID of the status. */
    id?: string;
    /** The name of the status. */
    name?: string;
    scope?: WorkflowScope;
    /** The category of the status. */
    statusCategory?: JiraWorkflowStatusStatusCategory;
    /** The reference of the status. */
    statusReference?: string;
    /** Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details.

The `statuses.usages` expand is an optional parameter that can be used when reading and updating statuses in Jira. It provides additional information about the projects and issue types associated with the requested statuses. */
    usages?: (ProjectIssueTypes | undefined)[] | undefined;

    constructor(data?: IJiraWorkflowStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.scope = _data["scope"] ? WorkflowScope.fromJS(_data["scope"]) : <any>undefined;
            this.statusCategory = _data["statusCategory"];
            this.statusReference = _data["statusReference"];
            if (Array.isArray(_data["usages"])) {
                this.usages = [] as any;
                for (let item of _data["usages"])
                    this.usages!.push(ProjectIssueTypes.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JiraWorkflowStatus {
        data = typeof data === 'object' ? data : {};
        let result = new JiraWorkflowStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        data["statusCategory"] = this.statusCategory;
        data["statusReference"] = this.statusReference;
        if (Array.isArray(this.usages)) {
            data["usages"] = [];
            for (let item of this.usages)
                data["usages"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of a status. */
export interface IJiraWorkflowStatus {
    /** The description of the status. */
    description?: string;
    /** The ID of the status. */
    id?: string;
    /** The name of the status. */
    name?: string;
    scope?: WorkflowScope;
    /** The category of the status. */
    statusCategory?: JiraWorkflowStatusStatusCategory;
    /** The reference of the status. */
    statusReference?: string;
    /** Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details.

The `statuses.usages` expand is an optional parameter that can be used when reading and updating statuses in Jira. It provides additional information about the projects and issue types associated with the requested statuses. */
    usages?: (ProjectIssueTypes | undefined)[] | undefined;
}

/** Jql function precomputation. */
export class JqlFunctionPrecomputationBean implements IJqlFunctionPrecomputationBean {
    /** The list of arguments function was invoked with. */
    readonly arguments?: string[];
    /** The timestamp of the precomputation creation. */
    readonly created?: Date;
    /** The error message to be displayed to the user. */
    readonly error?: string;
    /** The field the function was executed against. */
    readonly field?: string;
    /** The function key. */
    readonly functionKey?: string;
    /** The name of the function. */
    readonly functionName?: string;
    /** The id of the precomputation. */
    readonly id?: string;
    /** The operator in context of which function was executed. */
    readonly operator?: string;
    /** The timestamp of the precomputation last update. */
    readonly updated?: Date;
    /** The timestamp of the precomputation last usage. */
    readonly used?: Date;
    /** The JQL fragment stored as the precomputation. */
    readonly value?: string;

    constructor(data?: IJqlFunctionPrecomputationBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["arguments"])) {
                (<any>this).arguments = [] as any;
                for (let item of _data["arguments"])
                    (<any>this).arguments!.push(item);
            }
            (<any>this).created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            (<any>this).error = _data["error"];
            (<any>this).field = _data["field"];
            (<any>this).functionKey = _data["functionKey"];
            (<any>this).functionName = _data["functionName"];
            (<any>this).id = _data["id"];
            (<any>this).operator = _data["operator"];
            (<any>this).updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
            (<any>this).used = _data["used"] ? new Date(_data["used"].toString()) : <any>undefined;
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): JqlFunctionPrecomputationBean {
        data = typeof data === 'object' ? data : {};
        let result = new JqlFunctionPrecomputationBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.arguments)) {
            data["arguments"] = [];
            for (let item of this.arguments)
                data["arguments"].push(item);
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["error"] = this.error;
        data["field"] = this.field;
        data["functionKey"] = this.functionKey;
        data["functionName"] = this.functionName;
        data["id"] = this.id;
        data["operator"] = this.operator;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["used"] = this.used ? this.used.toISOString() : <any>undefined;
        data["value"] = this.value;
        return data;
    }
}

/** Jql function precomputation. */
export interface IJqlFunctionPrecomputationBean {
    /** The list of arguments function was invoked with. */
    arguments?: string[];
    /** The timestamp of the precomputation creation. */
    created?: Date;
    /** The error message to be displayed to the user. */
    error?: string;
    /** The field the function was executed against. */
    field?: string;
    /** The function key. */
    functionKey?: string;
    /** The name of the function. */
    functionName?: string;
    /** The id of the precomputation. */
    id?: string;
    /** The operator in context of which function was executed. */
    operator?: string;
    /** The timestamp of the precomputation last update. */
    updated?: Date;
    /** The timestamp of the precomputation last usage. */
    used?: Date;
    /** The JQL fragment stored as the precomputation. */
    value?: string;
}

/** Request to fetch precomputations by ID. */
export class JqlFunctionPrecomputationGetByIdRequest implements IJqlFunctionPrecomputationGetByIdRequest {
    precomputationIDs?: string[];

    constructor(data?: IJqlFunctionPrecomputationGetByIdRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["precomputationIDs"])) {
                this.precomputationIDs = [] as any;
                for (let item of _data["precomputationIDs"])
                    this.precomputationIDs!.push(item);
            }
        }
    }

    static fromJS(data: any): JqlFunctionPrecomputationGetByIdRequest {
        data = typeof data === 'object' ? data : {};
        let result = new JqlFunctionPrecomputationGetByIdRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.precomputationIDs)) {
            data["precomputationIDs"] = [];
            for (let item of this.precomputationIDs)
                data["precomputationIDs"].push(item);
        }
        return data;
    }
}

/** Request to fetch precomputations by ID. */
export interface IJqlFunctionPrecomputationGetByIdRequest {
    precomputationIDs?: string[];
}

/** Get precomputations by ID response. */
export class JqlFunctionPrecomputationGetByIdResponse implements IJqlFunctionPrecomputationGetByIdResponse {
    /** List of precomputations that were not found. */
    readonly notFoundPrecomputationIDs?: string[];
    /** The list of precomputations. */
    readonly precomputations?: JqlFunctionPrecomputationBean[];

    constructor(data?: IJqlFunctionPrecomputationGetByIdResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["notFoundPrecomputationIDs"])) {
                (<any>this).notFoundPrecomputationIDs = [] as any;
                for (let item of _data["notFoundPrecomputationIDs"])
                    (<any>this).notFoundPrecomputationIDs!.push(item);
            }
            if (Array.isArray(_data["precomputations"])) {
                (<any>this).precomputations = [] as any;
                for (let item of _data["precomputations"])
                    (<any>this).precomputations!.push(JqlFunctionPrecomputationBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JqlFunctionPrecomputationGetByIdResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JqlFunctionPrecomputationGetByIdResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.notFoundPrecomputationIDs)) {
            data["notFoundPrecomputationIDs"] = [];
            for (let item of this.notFoundPrecomputationIDs)
                data["notFoundPrecomputationIDs"].push(item);
        }
        if (Array.isArray(this.precomputations)) {
            data["precomputations"] = [];
            for (let item of this.precomputations)
                data["precomputations"].push(item.toJSON());
        }
        return data;
    }
}

/** Get precomputations by ID response. */
export interface IJqlFunctionPrecomputationGetByIdResponse {
    /** List of precomputations that were not found. */
    notFoundPrecomputationIDs?: string[];
    /** The list of precomputations. */
    precomputations?: JqlFunctionPrecomputationBean[];
}

/** Precomputation id and its new value. */
export class JqlFunctionPrecomputationUpdateBean implements IJqlFunctionPrecomputationUpdateBean {
    /** The error message to be displayed to the user if the given function clause is no longer valid during recalculation of the precomputation. */
    error?: string;
    /** The id of the precomputation to update. */
    id!: string;
    /** The new value of the precomputation. */
    value?: string;

    constructor(data?: IJqlFunctionPrecomputationUpdateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"];
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): JqlFunctionPrecomputationUpdateBean {
        data = typeof data === 'object' ? data : {};
        let result = new JqlFunctionPrecomputationUpdateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error;
        data["id"] = this.id;
        data["value"] = this.value;
        return data;
    }
}

/** Precomputation id and its new value. */
export interface IJqlFunctionPrecomputationUpdateBean {
    /** The error message to be displayed to the user if the given function clause is no longer valid during recalculation of the precomputation. */
    error?: string;
    /** The id of the precomputation to update. */
    id: string;
    /** The new value of the precomputation. */
    value?: string;
}

/** Error response returned updating JQL Function precomputations fails. */
export class JqlFunctionPrecomputationUpdateErrorResponse implements IJqlFunctionPrecomputationUpdateErrorResponse {
    /** The list of error messages produced by this operation. */
    readonly errorMessages?: string[];
    /** List of precomputations that were not found. */
    readonly notFoundPrecomputationIDs?: string[];

    constructor(data?: IJqlFunctionPrecomputationUpdateErrorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errorMessages"])) {
                (<any>this).errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    (<any>this).errorMessages!.push(item);
            }
            if (Array.isArray(_data["notFoundPrecomputationIDs"])) {
                (<any>this).notFoundPrecomputationIDs = [] as any;
                for (let item of _data["notFoundPrecomputationIDs"])
                    (<any>this).notFoundPrecomputationIDs!.push(item);
            }
        }
    }

    static fromJS(data: any): JqlFunctionPrecomputationUpdateErrorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JqlFunctionPrecomputationUpdateErrorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        if (Array.isArray(this.notFoundPrecomputationIDs)) {
            data["notFoundPrecomputationIDs"] = [];
            for (let item of this.notFoundPrecomputationIDs)
                data["notFoundPrecomputationIDs"].push(item);
        }
        return data;
    }
}

/** Error response returned updating JQL Function precomputations fails. */
export interface IJqlFunctionPrecomputationUpdateErrorResponse {
    /** The list of error messages produced by this operation. */
    errorMessages?: string[];
    /** List of precomputations that were not found. */
    notFoundPrecomputationIDs?: string[];
}

/** List of pairs (id and value) for precomputation updates. */
export class JqlFunctionPrecomputationUpdateRequestBean implements IJqlFunctionPrecomputationUpdateRequestBean {
    values?: JqlFunctionPrecomputationUpdateBean[];

    constructor(data?: IJqlFunctionPrecomputationUpdateRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(JqlFunctionPrecomputationUpdateBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JqlFunctionPrecomputationUpdateRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new JqlFunctionPrecomputationUpdateRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** List of pairs (id and value) for precomputation updates. */
export interface IJqlFunctionPrecomputationUpdateRequestBean {
    values?: JqlFunctionPrecomputationUpdateBean[];
}

/** Result of updating JQL Function precomputations. */
export class JqlFunctionPrecomputationUpdateResponse implements IJqlFunctionPrecomputationUpdateResponse {
    /** List of precomputations that were not found and skipped. Only returned if the request passed skipNotFoundPrecomputations=true. */
    readonly notFoundPrecomputationIDs?: string[];

    constructor(data?: IJqlFunctionPrecomputationUpdateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["notFoundPrecomputationIDs"])) {
                (<any>this).notFoundPrecomputationIDs = [] as any;
                for (let item of _data["notFoundPrecomputationIDs"])
                    (<any>this).notFoundPrecomputationIDs!.push(item);
            }
        }
    }

    static fromJS(data: any): JqlFunctionPrecomputationUpdateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JqlFunctionPrecomputationUpdateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.notFoundPrecomputationIDs)) {
            data["notFoundPrecomputationIDs"] = [];
            for (let item of this.notFoundPrecomputationIDs)
                data["notFoundPrecomputationIDs"].push(item);
        }
        return data;
    }
}

/** Result of updating JQL Function precomputations. */
export interface IJqlFunctionPrecomputationUpdateResponse {
    /** List of precomputations that were not found and skipped. Only returned if the request passed skipNotFoundPrecomputations=true. */
    notFoundPrecomputationIDs?: string[];
}

/** A list of JQL queries to parse. */
export class JqlQueriesToParse implements IJqlQueriesToParse {
    /** A list of queries to parse. */
    queries!: string[];

    constructor(data?: IJqlQueriesToParse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.queries = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["queries"])) {
                this.queries = [] as any;
                for (let item of _data["queries"])
                    this.queries!.push(item);
            }
        }
    }

    static fromJS(data: any): JqlQueriesToParse {
        data = typeof data === 'object' ? data : {};
        let result = new JqlQueriesToParse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queries)) {
            data["queries"] = [];
            for (let item of this.queries)
                data["queries"].push(item);
        }
        return data;
    }
}

/** A list of JQL queries to parse. */
export interface IJqlQueriesToParse {
    /** A list of queries to parse. */
    queries: string[];
}

/** The list of JQL queries to sanitize for the given account IDs. */
export class JqlQueriesToSanitize implements IJqlQueriesToSanitize {
    /** The list of JQL queries to sanitize. Must contain unique values. Maximum of 20 queries. */
    queries!: JqlQueryToSanitize[];

    constructor(data?: IJqlQueriesToSanitize) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.queries = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["queries"])) {
                this.queries = [] as any;
                for (let item of _data["queries"])
                    this.queries!.push(JqlQueryToSanitize.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JqlQueriesToSanitize {
        data = typeof data === 'object' ? data : {};
        let result = new JqlQueriesToSanitize();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queries)) {
            data["queries"] = [];
            for (let item of this.queries)
                data["queries"].push(item.toJSON());
        }
        return data;
    }
}

/** The list of JQL queries to sanitize for the given account IDs. */
export interface IJqlQueriesToSanitize {
    /** The list of JQL queries to sanitize. Must contain unique values. Maximum of 20 queries. */
    queries: JqlQueryToSanitize[];
}

/** A parsed JQL query. */
export class JqlQuery implements IJqlQuery {
    orderBy?: JqlQueryOrderByClause;
    where?: JqlQueryClause;

    constructor(data?: IJqlQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderBy = _data["orderBy"] ? JqlQueryOrderByClause.fromJS(_data["orderBy"]) : <any>undefined;
            this.where = _data["where"] ? JqlQueryClause.fromJS(_data["where"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JqlQuery {
        data = typeof data === 'object' ? data : {};
        let result = new JqlQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderBy"] = this.orderBy ? this.orderBy.toJSON() : <any>undefined;
        data["where"] = this.where ? this.where.toJSON() : <any>undefined;
        return data;
    }
}

/** A parsed JQL query. */
export interface IJqlQuery {
    orderBy?: JqlQueryOrderByClause;
    where?: JqlQueryClause;
}

/** A JQL query clause. */
export class JqlQueryClause implements IJqlQueryClause {

    constructor(data?: IJqlQueryClause) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): JqlQueryClause {
        data = typeof data === 'object' ? data : {};
        let result = new JqlQueryClause();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** A JQL query clause. */
export interface IJqlQueryClause {
}

/** Details of an operand in a JQL clause. */
export class JqlQueryClauseOperand implements IJqlQueryClauseOperand {

    [key: string]: any;

    constructor(data?: IJqlQueryClauseOperand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): JqlQueryClauseOperand {
        data = typeof data === 'object' ? data : {};
        let result = new JqlQueryClauseOperand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

/** Details of an operand in a JQL clause. */
export interface IJqlQueryClauseOperand {

    [key: string]: any;
}

/** A time predicate for a temporal JQL clause. */
export class JqlQueryClauseTimePredicate implements IJqlQueryClauseTimePredicate {
    operand!: JqlQueryClauseOperand;
    /** The operator between the field and the operand. */
    operator!: JqlQueryClauseTimePredicateOperator;

    [key: string]: any;

    constructor(data?: IJqlQueryClauseTimePredicate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.operand = new JqlQueryClauseOperand();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.operand = _data["operand"] ? JqlQueryClauseOperand.fromJS(_data["operand"]) : new JqlQueryClauseOperand();
            this.operator = _data["operator"];
        }
    }

    static fromJS(data: any): JqlQueryClauseTimePredicate {
        data = typeof data === 'object' ? data : {};
        let result = new JqlQueryClauseTimePredicate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["operand"] = this.operand ? this.operand.toJSON() : <any>undefined;
        data["operator"] = this.operator;
        return data;
    }
}

/** A time predicate for a temporal JQL clause. */
export interface IJqlQueryClauseTimePredicate {
    operand: JqlQueryClauseOperand;
    /** The operator between the field and the operand. */
    operator: JqlQueryClauseTimePredicateOperator;

    [key: string]: any;
}

/** A field used in a JQL query. See [Advanced searching - fields reference](https://confluence.atlassian.com/x/dAiiLQ) for more information about fields in JQL queries. */
export class JqlQueryField implements IJqlQueryField {
    /** The encoded name of the field, which can be used directly in a JQL query. */
    encodedName?: string;
    /** The name of the field. */
    name!: string;
    /** When the field refers to a value in an entity property, details of the entity property value. */
    property?: JqlQueryFieldEntityProperty[];

    constructor(data?: IJqlQueryField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.encodedName = _data["encodedName"];
            this.name = _data["name"];
            if (Array.isArray(_data["property"])) {
                this.property = [] as any;
                for (let item of _data["property"])
                    this.property!.push(JqlQueryFieldEntityProperty.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JqlQueryField {
        data = typeof data === 'object' ? data : {};
        let result = new JqlQueryField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["encodedName"] = this.encodedName;
        data["name"] = this.name;
        if (Array.isArray(this.property)) {
            data["property"] = [];
            for (let item of this.property)
                data["property"].push(item.toJSON());
        }
        return data;
    }
}

/** A field used in a JQL query. See [Advanced searching - fields reference](https://confluence.atlassian.com/x/dAiiLQ) for more information about fields in JQL queries. */
export interface IJqlQueryField {
    /** The encoded name of the field, which can be used directly in a JQL query. */
    encodedName?: string;
    /** The name of the field. */
    name: string;
    /** When the field refers to a value in an entity property, details of the entity property value. */
    property?: JqlQueryFieldEntityProperty[];
}

/** Details of an entity property. */
export class JqlQueryFieldEntityProperty implements IJqlQueryFieldEntityProperty {
    /** The object on which the property is set. */
    entity!: string;
    /** The key of the property. */
    key!: string;
    /** The path in the property value to query. */
    path!: string;
    /** The type of the property value extraction. Not available if the extraction for the property is not registered on the instance with the [Entity property](https://developer.atlassian.com/cloud/jira/platform/modules/entity-property/) module. */
    type?: JqlQueryFieldEntityPropertyType;

    [key: string]: any;

    constructor(data?: IJqlQueryFieldEntityProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.entity = _data["entity"];
            this.key = _data["key"];
            this.path = _data["path"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): JqlQueryFieldEntityProperty {
        data = typeof data === 'object' ? data : {};
        let result = new JqlQueryFieldEntityProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["entity"] = this.entity;
        data["key"] = this.key;
        data["path"] = this.path;
        data["type"] = this.type;
        return data;
    }
}

/** Details of an entity property. */
export interface IJqlQueryFieldEntityProperty {
    /** The object on which the property is set. */
    entity: string;
    /** The key of the property. */
    key: string;
    /** The path in the property value to query. */
    path: string;
    /** The type of the property value extraction. Not available if the extraction for the property is not registered on the instance with the [Entity property](https://developer.atlassian.com/cloud/jira/platform/modules/entity-property/) module. */
    type?: JqlQueryFieldEntityPropertyType;

    [key: string]: any;
}

/** Details of the order-by JQL clause. */
export class JqlQueryOrderByClause implements IJqlQueryOrderByClause {
    /** The list of order-by clause fields and their ordering directives. */
    fields!: JqlQueryOrderByClauseElement[];

    constructor(data?: IJqlQueryOrderByClause) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fields = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(JqlQueryOrderByClauseElement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JqlQueryOrderByClause {
        data = typeof data === 'object' ? data : {};
        let result = new JqlQueryOrderByClause();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of the order-by JQL clause. */
export interface IJqlQueryOrderByClause {
    /** The list of order-by clause fields and their ordering directives. */
    fields: JqlQueryOrderByClauseElement[];
}

/** An element of the order-by JQL clause. */
export class JqlQueryOrderByClauseElement implements IJqlQueryOrderByClauseElement {
    /** The direction in which to order the results. */
    direction?: JqlQueryOrderByClauseElementDirection;
    field!: JqlQueryField;

    constructor(data?: IJqlQueryOrderByClauseElement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.field = new JqlQueryField();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.direction = _data["direction"];
            this.field = _data["field"] ? JqlQueryField.fromJS(_data["field"]) : new JqlQueryField();
        }
    }

    static fromJS(data: any): JqlQueryOrderByClauseElement {
        data = typeof data === 'object' ? data : {};
        let result = new JqlQueryOrderByClauseElement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["direction"] = this.direction;
        data["field"] = this.field ? this.field.toJSON() : <any>undefined;
        return data;
    }
}

/** An element of the order-by JQL clause. */
export interface IJqlQueryOrderByClauseElement {
    /** The direction in which to order the results. */
    direction?: JqlQueryOrderByClauseElementDirection;
    field: JqlQueryField;
}

/** The JQL query to sanitize for the account ID. If the account ID is null, sanitizing is performed for an anonymous user. */
export class JqlQueryToSanitize implements IJqlQueryToSanitize {
    /** The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. */
    accountId?: string | undefined;
    /** The query to sanitize. */
    query!: string;

    constructor(data?: IJqlQueryToSanitize) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.query = _data["query"];
        }
    }

    static fromJS(data: any): JqlQueryToSanitize {
        data = typeof data === 'object' ? data : {};
        let result = new JqlQueryToSanitize();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["query"] = this.query;
        return data;
    }
}

/** The JQL query to sanitize for the account ID. If the account ID is null, sanitizing is performed for an anonymous user. */
export interface IJqlQueryToSanitize {
    /** The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. */
    accountId?: string | undefined;
    /** The query to sanitize. */
    query: string;
}

/** An operand that can be part of a list operand. */
export class JqlQueryUnitaryOperand implements IJqlQueryUnitaryOperand {

    [key: string]: any;

    constructor(data?: IJqlQueryUnitaryOperand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): JqlQueryUnitaryOperand {
        data = typeof data === 'object' ? data : {};
        let result = new JqlQueryUnitaryOperand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

/** An operand that can be part of a list operand. */
export interface IJqlQueryUnitaryOperand {

    [key: string]: any;
}

/** A JSON object with custom content. */
export class JsonContextVariable implements IJsonContextVariable {
    /** Type of custom context variable. */
    type!: string;
    /** A JSON object containing custom content. */
    value?: any;

    [key: string]: any;

    constructor(data?: IJsonContextVariable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): JsonContextVariable {
        data = typeof data === 'object' ? data : {};
        let result = new JsonContextVariable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

/** A JSON object with custom content. */
export interface IJsonContextVariable {
    /** Type of custom context variable. */
    type: string;
    /** A JSON object containing custom content. */
    value?: any;

    [key: string]: any;
}

export class JsonNode implements IJsonNode {
    array?: boolean;
    bigDecimal?: boolean;
    bigInteger?: boolean;
    bigIntegerValue?: number;
    binary?: boolean;
    binaryValue?: string[];
    boolean?: boolean;
    booleanValue?: boolean;
    containerNode?: boolean;
    decimalValue?: number;
    double?: boolean;
    doubleValue?: number;
    elements?: any;
    fieldNames?: any;
    fields?: any;
    floatingPointNumber?: boolean;
    int?: boolean;
    intValue?: number;
    integralNumber?: boolean;
    long?: boolean;
    longValue?: number;
    missingNode?: boolean;
    null?: boolean;
    number?: boolean;
    numberType?: JsonNodeNumberType;
    numberValue?: number;
    object?: boolean;
    pojo?: boolean;
    textValue?: string;
    textual?: boolean;
    valueAsBoolean?: boolean;
    valueAsDouble?: number;
    valueAsInt?: number;
    valueAsLong?: number;
    valueAsText?: string;
    valueNode?: boolean;

    constructor(data?: IJsonNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.array = _data["array"];
            this.bigDecimal = _data["bigDecimal"];
            this.bigInteger = _data["bigInteger"];
            this.bigIntegerValue = _data["bigIntegerValue"];
            this.binary = _data["binary"];
            if (Array.isArray(_data["binaryValue"])) {
                this.binaryValue = [] as any;
                for (let item of _data["binaryValue"])
                    this.binaryValue!.push(item);
            }
            this.boolean = _data["boolean"];
            this.booleanValue = _data["booleanValue"];
            this.containerNode = _data["containerNode"];
            this.decimalValue = _data["decimalValue"];
            this.double = _data["double"];
            this.doubleValue = _data["doubleValue"];
            this.elements = _data["elements"];
            this.fieldNames = _data["fieldNames"];
            this.fields = _data["fields"];
            this.floatingPointNumber = _data["floatingPointNumber"];
            this.int = _data["int"];
            this.intValue = _data["intValue"];
            this.integralNumber = _data["integralNumber"];
            this.long = _data["long"];
            this.longValue = _data["longValue"];
            this.missingNode = _data["missingNode"];
            this.null = _data["null"];
            this.number = _data["number"];
            this.numberType = _data["numberType"];
            this.numberValue = _data["numberValue"];
            this.object = _data["object"];
            this.pojo = _data["pojo"];
            this.textValue = _data["textValue"];
            this.textual = _data["textual"];
            this.valueAsBoolean = _data["valueAsBoolean"];
            this.valueAsDouble = _data["valueAsDouble"];
            this.valueAsInt = _data["valueAsInt"];
            this.valueAsLong = _data["valueAsLong"];
            this.valueAsText = _data["valueAsText"];
            this.valueNode = _data["valueNode"];
        }
    }

    static fromJS(data: any): JsonNode {
        data = typeof data === 'object' ? data : {};
        let result = new JsonNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["array"] = this.array;
        data["bigDecimal"] = this.bigDecimal;
        data["bigInteger"] = this.bigInteger;
        data["bigIntegerValue"] = this.bigIntegerValue;
        data["binary"] = this.binary;
        if (Array.isArray(this.binaryValue)) {
            data["binaryValue"] = [];
            for (let item of this.binaryValue)
                data["binaryValue"].push(item);
        }
        data["boolean"] = this.boolean;
        data["booleanValue"] = this.booleanValue;
        data["containerNode"] = this.containerNode;
        data["decimalValue"] = this.decimalValue;
        data["double"] = this.double;
        data["doubleValue"] = this.doubleValue;
        data["elements"] = this.elements;
        data["fieldNames"] = this.fieldNames;
        data["fields"] = this.fields;
        data["floatingPointNumber"] = this.floatingPointNumber;
        data["int"] = this.int;
        data["intValue"] = this.intValue;
        data["integralNumber"] = this.integralNumber;
        data["long"] = this.long;
        data["longValue"] = this.longValue;
        data["missingNode"] = this.missingNode;
        data["null"] = this.null;
        data["number"] = this.number;
        data["numberType"] = this.numberType;
        data["numberValue"] = this.numberValue;
        data["object"] = this.object;
        data["pojo"] = this.pojo;
        data["textValue"] = this.textValue;
        data["textual"] = this.textual;
        data["valueAsBoolean"] = this.valueAsBoolean;
        data["valueAsDouble"] = this.valueAsDouble;
        data["valueAsInt"] = this.valueAsInt;
        data["valueAsLong"] = this.valueAsLong;
        data["valueAsText"] = this.valueAsText;
        data["valueNode"] = this.valueNode;
        return data;
    }
}

export interface IJsonNode {
    array?: boolean;
    bigDecimal?: boolean;
    bigInteger?: boolean;
    bigIntegerValue?: number;
    binary?: boolean;
    binaryValue?: string[];
    boolean?: boolean;
    booleanValue?: boolean;
    containerNode?: boolean;
    decimalValue?: number;
    double?: boolean;
    doubleValue?: number;
    elements?: any;
    fieldNames?: any;
    fields?: any;
    floatingPointNumber?: boolean;
    int?: boolean;
    intValue?: number;
    integralNumber?: boolean;
    long?: boolean;
    longValue?: number;
    missingNode?: boolean;
    null?: boolean;
    number?: boolean;
    numberType?: JsonNodeNumberType;
    numberValue?: number;
    object?: boolean;
    pojo?: boolean;
    textValue?: string;
    textual?: boolean;
    valueAsBoolean?: boolean;
    valueAsDouble?: number;
    valueAsInt?: number;
    valueAsLong?: number;
    valueAsText?: string;
    valueNode?: boolean;
}

/** The schema of a field. */
export class JsonTypeBean implements IJsonTypeBean {
    /** If the field is a custom field, the configuration of the field. */
    readonly configuration?: { [key: string]: any; };
    /** If the field is a custom field, the URI of the field. */
    readonly custom?: string;
    /** If the field is a custom field, the custom ID of the field. */
    readonly customId?: number;
    /** When the data type is an array, the name of the field items within the array. */
    readonly items?: string;
    /** If the field is a system field, the name of the field. */
    readonly system?: string;
    /** The data type of the field. */
    readonly type!: string;

    constructor(data?: IJsonTypeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["configuration"]) {
                (<any>this).configuration = {} as any;
                for (let key in _data["configuration"]) {
                    if (_data["configuration"].hasOwnProperty(key))
                        (<any>(<any>this).configuration)![key] = _data["configuration"][key];
                }
            }
            (<any>this).custom = _data["custom"];
            (<any>this).customId = _data["customId"];
            (<any>this).items = _data["items"];
            (<any>this).system = _data["system"];
            (<any>this).type = _data["type"];
        }
    }

    static fromJS(data: any): JsonTypeBean {
        data = typeof data === 'object' ? data : {};
        let result = new JsonTypeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.configuration) {
            data["configuration"] = {};
            for (let key in this.configuration) {
                if (this.configuration.hasOwnProperty(key))
                    (<any>data["configuration"])[key] = (<any>this.configuration)[key];
            }
        }
        data["custom"] = this.custom;
        data["customId"] = this.customId;
        data["items"] = this.items;
        data["system"] = this.system;
        data["type"] = this.type;
        return data;
    }
}

/** The schema of a field. */
export interface IJsonTypeBean {
    /** If the field is a custom field, the configuration of the field. */
    configuration?: { [key: string]: any; };
    /** If the field is a custom field, the URI of the field. */
    custom?: string;
    /** If the field is a custom field, the custom ID of the field. */
    customId?: number;
    /** When the data type is an array, the name of the field items within the array. */
    items?: string;
    /** If the field is a system field, the name of the field. */
    system?: string;
    /** The data type of the field. */
    type: string;
}

/** An operand that is a JQL keyword. See [Advanced searching - keywords reference](https://confluence.atlassian.com/jiracorecloud/advanced-searching-keywords-reference-765593717.html#Advancedsearching-keywordsreference-EMPTYEMPTY) for more information about operand keywords. */
export class KeywordOperand implements IKeywordOperand {
    /** The keyword that is the operand value. */
    keyword!: KeywordOperandKeyword;

    [key: string]: any;

    constructor(data?: IKeywordOperand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.keyword = _data["keyword"];
        }
    }

    static fromJS(data: any): KeywordOperand {
        data = typeof data === 'object' ? data : {};
        let result = new KeywordOperand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["keyword"] = this.keyword;
        return data;
    }
}

/** An operand that is a JQL keyword. See [Advanced searching - keywords reference](https://confluence.atlassian.com/jiracorecloud/advanced-searching-keywords-reference-765593717.html#Advancedsearching-keywordsreference-EMPTYEMPTY) for more information about operand keywords. */
export interface IKeywordOperand {
    /** The keyword that is the operand value. */
    keyword: KeywordOperandKeyword;

    [key: string]: any;
}

/** Details about a license for the Jira instance. */
export class License implements ILicense {
    /** The applications under this license. */
    readonly applications!: LicensedApplication[];

    constructor(data?: ILicense) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.applications = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["applications"])) {
                (<any>this).applications = [] as any;
                for (let item of _data["applications"])
                    (<any>this).applications!.push(LicensedApplication.fromJS(item));
            }
        }
    }

    static fromJS(data: any): License {
        data = typeof data === 'object' ? data : {};
        let result = new License();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.applications)) {
            data["applications"] = [];
            for (let item of this.applications)
                data["applications"].push(item.toJSON());
        }
        return data;
    }
}

/** Details about a license for the Jira instance. */
export interface ILicense {
    /** The applications under this license. */
    applications: LicensedApplication[];
}

/** A metric that provides insight into the active licence details */
export class LicenseMetric implements ILicenseMetric {
    /** The key of a specific license metric. */
    key?: string;
    /** The calculated value of a licence metric linked to the key. An example licence metric is the approximate number of user accounts. */
    value?: string;

    constructor(data?: ILicenseMetric) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): LicenseMetric {
        data = typeof data === 'object' ? data : {};
        let result = new LicenseMetric();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

/** A metric that provides insight into the active licence details */
export interface ILicenseMetric {
    /** The key of a specific license metric. */
    key?: string;
    /** The calculated value of a licence metric linked to the key. An example licence metric is the approximate number of user accounts. */
    value?: string;
}

/** Details about a licensed Jira application. */
export class LicensedApplication implements ILicensedApplication {
    /** The ID of the application. */
    readonly id!: string;
    /** The licensing plan. */
    readonly plan!: LicensedApplicationPlan;

    constructor(data?: ILicensedApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).plan = _data["plan"];
        }
    }

    static fromJS(data: any): LicensedApplication {
        data = typeof data === 'object' ? data : {};
        let result = new LicensedApplication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["plan"] = this.plan;
        return data;
    }
}

/** Details about a licensed Jira application. */
export interface ILicensedApplication {
    /** The ID of the application. */
    id: string;
    /** The licensing plan. */
    plan: LicensedApplicationPlan;
}

/** Details a link group, which defines issue operations. */
export class LinkGroup implements ILinkGroup {
    groups?: LinkGroup[];
    header?: SimpleLink;
    id?: string;
    links?: SimpleLink[];
    styleClass?: string;
    weight?: number;

    constructor(data?: ILinkGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(LinkGroup.fromJS(item));
            }
            this.header = _data["header"] ? SimpleLink.fromJS(_data["header"]) : <any>undefined;
            this.id = _data["id"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(SimpleLink.fromJS(item));
            }
            this.styleClass = _data["styleClass"];
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): LinkGroup {
        data = typeof data === 'object' ? data : {};
        let result = new LinkGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["id"] = this.id;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["styleClass"] = this.styleClass;
        data["weight"] = this.weight;
        return data;
    }
}

/** Details a link group, which defines issue operations. */
export interface ILinkGroup {
    groups?: LinkGroup[];
    header?: SimpleLink;
    id?: string;
    links?: SimpleLink[];
    styleClass?: string;
    weight?: number;
}

export class LinkIssueRequestJsonBean implements ILinkIssueRequestJsonBean {
    comment?: Comment;
    inwardIssue!: LinkedIssue;
    outwardIssue!: LinkedIssue;
    type!: IssueLinkType;

    constructor(data?: ILinkIssueRequestJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.inwardIssue = new LinkedIssue();
            this.outwardIssue = new LinkedIssue();
            this.type = new IssueLinkType();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.comment = _data["comment"] ? Comment.fromJS(_data["comment"]) : <any>undefined;
            this.inwardIssue = _data["inwardIssue"] ? LinkedIssue.fromJS(_data["inwardIssue"]) : new LinkedIssue();
            this.outwardIssue = _data["outwardIssue"] ? LinkedIssue.fromJS(_data["outwardIssue"]) : new LinkedIssue();
            this.type = _data["type"] ? IssueLinkType.fromJS(_data["type"]) : new IssueLinkType();
        }
    }

    static fromJS(data: any): LinkIssueRequestJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new LinkIssueRequestJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment ? this.comment.toJSON() : <any>undefined;
        data["inwardIssue"] = this.inwardIssue ? this.inwardIssue.toJSON() : <any>undefined;
        data["outwardIssue"] = this.outwardIssue ? this.outwardIssue.toJSON() : <any>undefined;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILinkIssueRequestJsonBean {
    comment?: Comment;
    inwardIssue: LinkedIssue;
    outwardIssue: LinkedIssue;
    type: IssueLinkType;
}

/** The ID or key of a linked issue. */
export class LinkedIssue implements ILinkedIssue {
    /** The fields associated with the issue. */
    readonly fields?: Fields;
    /** The ID of an issue. Required if `key` isn't provided. */
    id?: string;
    /** The key of an issue. Required if `id` isn't provided. */
    key?: string;
    /** The URL of the issue. */
    readonly self?: string;

    constructor(data?: ILinkedIssue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).fields = _data["fields"] ? Fields.fromJS(_data["fields"]) : <any>undefined;
            this.id = _data["id"];
            this.key = _data["key"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): LinkedIssue {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedIssue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fields"] = this.fields ? this.fields.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["key"] = this.key;
        data["self"] = this.self;
        return data;
    }
}

/** The ID or key of a linked issue. */
export interface ILinkedIssue {
    /** The fields associated with the issue. */
    fields?: Fields;
    /** The ID of an issue. Required if `key` isn't provided. */
    id?: string;
    /** The key of an issue. Required if `id` isn't provided. */
    key?: string;
    /** The URL of the issue. */
    self?: string;
}

/** An operand that is a list of values. */
export class ListOperand implements IListOperand {
    /** Encoded operand, which can be used directly in a JQL query. */
    encodedOperand?: string;
    /** The list of operand values. */
    values!: JqlQueryUnitaryOperand[];

    [key: string]: any;

    constructor(data?: IListOperand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.values = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.encodedOperand = _data["encodedOperand"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(JqlQueryUnitaryOperand.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListOperand {
        data = typeof data === 'object' ? data : {};
        let result = new ListOperand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["encodedOperand"] = this.encodedOperand;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** An operand that is a list of values. */
export interface IListOperand {
    /** Encoded operand, which can be used directly in a JQL query. */
    encodedOperand?: string;
    /** The list of operand values. */
    values: JqlQueryUnitaryOperand[];

    [key: string]: any;
}

export class ListWrapperCallbackApplicationRole implements IListWrapperCallbackApplicationRole {

    constructor(data?: IListWrapperCallbackApplicationRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ListWrapperCallbackApplicationRole {
        data = typeof data === 'object' ? data : {};
        let result = new ListWrapperCallbackApplicationRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IListWrapperCallbackApplicationRole {
}

export class ListWrapperCallbackGroupName implements IListWrapperCallbackGroupName {

    constructor(data?: IListWrapperCallbackGroupName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ListWrapperCallbackGroupName {
        data = typeof data === 'object' ? data : {};
        let result = new ListWrapperCallbackGroupName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IListWrapperCallbackGroupName {
}

/** Details of a locale. */
export class Locale implements ILocale {
    /** The locale code. The Java the locale format is used: a two character language code (ISO 639), an underscore, and two letter country code (ISO 3166). For example, en\_US represents a locale of English (United States). Required on create. */
    locale?: string;

    constructor(data?: ILocale) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locale = _data["locale"];
        }
    }

    static fromJS(data: any): Locale {
        data = typeof data === 'object' ? data : {};
        let result = new Locale();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locale"] = this.locale;
        return data;
    }
}

/** Details of a locale. */
export interface ILocale {
    /** The locale code. The Java the locale format is used: a two character language code (ISO 639), an underscore, and two letter country code (ISO 3166). For example, en\_US represents a locale of English (United States). Required on create. */
    locale?: string;
}

/** List of string of inputs */
export class MandatoryFieldValue implements IMandatoryFieldValue {
    /** If `true`, will try to retain original non-null issue field values on move. */
    retain?: boolean | undefined;
    /** Will treat as `MandatoryFieldValue` if type is `raw` or `empty` */
    type?: MandatoryFieldValueType | undefined;
    /** Value for each field. Provide a `list of strings` for non-ADF fields. */
    value!: string[];

    [key: string]: any;

    constructor(data?: IMandatoryFieldValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.retain = true;
            this.type = MandatoryFieldValueType.Raw;
            this.value = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.retain = _data["retain"] !== undefined ? _data["retain"] : true;
            this.type = _data["type"] !== undefined ? _data["type"] : MandatoryFieldValueType.Raw;
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): MandatoryFieldValue {
        data = typeof data === 'object' ? data : {};
        let result = new MandatoryFieldValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["retain"] = this.retain;
        data["type"] = this.type;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data;
    }
}

/** List of string of inputs */
export interface IMandatoryFieldValue {
    /** If `true`, will try to retain original non-null issue field values on move. */
    retain?: boolean | undefined;
    /** Will treat as `MandatoryFieldValue` if type is `raw` or `empty` */
    type?: MandatoryFieldValueType | undefined;
    /** Value for each field. Provide a `list of strings` for non-ADF fields. */
    value: string[];

    [key: string]: any;
}

/** An object notation input */
export class MandatoryFieldValueForADF implements IMandatoryFieldValueForADF {
    /** If `true`, will try to retain original non-null issue field values on move. */
    retain?: boolean | undefined;
    /** Will treat as `MandatoryFieldValueForADF` if type is `adf` */
    type!: MandatoryFieldValueForADFType;
    /** Value for each field. Accepts Atlassian Document Format (ADF) for rich text fields like `description`, `environments`. For ADF format details, refer to: [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure) */
    value!: any;

    [key: string]: any;

    constructor(data?: IMandatoryFieldValueForADF) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.retain = true;
            this.type = MandatoryFieldValueForADFType.Raw;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.retain = _data["retain"] !== undefined ? _data["retain"] : true;
            this.type = _data["type"] !== undefined ? _data["type"] : MandatoryFieldValueForADFType.Raw;
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): MandatoryFieldValueForADF {
        data = typeof data === 'object' ? data : {};
        let result = new MandatoryFieldValueForADF();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["retain"] = this.retain;
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

/** An object notation input */
export interface IMandatoryFieldValueForADF {
    /** If `true`, will try to retain original non-null issue field values on move. */
    retain?: boolean | undefined;
    /** Will treat as `MandatoryFieldValueForADF` if type is `adf` */
    type: MandatoryFieldValueForADFType;
    /** Value for each field. Accepts Atlassian Document Format (ADF) for rich text fields like `description`, `environments`. For ADF format details, refer to: [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure) */
    value: any;

    [key: string]: any;
}

/** Overrides, for the selected issue types, any status mappings provided in `statusMappingsByWorkflows`. Status mappings are required when the new workflow for an issue type doesn't contain all statuses that the old workflow has. Status mappings can be provided by a combination of `statusMappingsByWorkflows` and `statusMappingsByIssueTypeOverride`. */
export class MappingsByIssueTypeOverride implements IMappingsByIssueTypeOverride {
    /** The ID of the issue type for this mapping. */
    issueTypeId!: string;
    /** The list of status mappings. */
    statusMappings!: WorkflowAssociationStatusMapping[];

    constructor(data?: IMappingsByIssueTypeOverride) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.statusMappings = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueTypeId = _data["issueTypeId"];
            if (Array.isArray(_data["statusMappings"])) {
                this.statusMappings = [] as any;
                for (let item of _data["statusMappings"])
                    this.statusMappings!.push(WorkflowAssociationStatusMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MappingsByIssueTypeOverride {
        data = typeof data === 'object' ? data : {};
        let result = new MappingsByIssueTypeOverride();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueTypeId"] = this.issueTypeId;
        if (Array.isArray(this.statusMappings)) {
            data["statusMappings"] = [];
            for (let item of this.statusMappings)
                data["statusMappings"].push(item.toJSON());
        }
        return data;
    }
}

/** Overrides, for the selected issue types, any status mappings provided in `statusMappingsByWorkflows`. Status mappings are required when the new workflow for an issue type doesn't contain all statuses that the old workflow has. Status mappings can be provided by a combination of `statusMappingsByWorkflows` and `statusMappingsByIssueTypeOverride`. */
export interface IMappingsByIssueTypeOverride {
    /** The ID of the issue type for this mapping. */
    issueTypeId: string;
    /** The list of status mappings. */
    statusMappings: WorkflowAssociationStatusMapping[];
}

/** The status mappings by workflows. Status mappings are required when the new workflow for an issue type doesn't contain all statuses that the old workflow has. Status mappings can be provided by a combination of `statusMappingsByWorkflows` and `statusMappingsByIssueTypeOverride`. */
export class MappingsByWorkflow implements IMappingsByWorkflow {
    /** The ID of the new workflow. */
    newWorkflowId!: string;
    /** The ID of the old workflow. */
    oldWorkflowId!: string;
    /** The list of status mappings. */
    statusMappings!: WorkflowAssociationStatusMapping[];

    constructor(data?: IMappingsByWorkflow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.statusMappings = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newWorkflowId = _data["newWorkflowId"];
            this.oldWorkflowId = _data["oldWorkflowId"];
            if (Array.isArray(_data["statusMappings"])) {
                this.statusMappings = [] as any;
                for (let item of _data["statusMappings"])
                    this.statusMappings!.push(WorkflowAssociationStatusMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MappingsByWorkflow {
        data = typeof data === 'object' ? data : {};
        let result = new MappingsByWorkflow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newWorkflowId"] = this.newWorkflowId;
        data["oldWorkflowId"] = this.oldWorkflowId;
        if (Array.isArray(this.statusMappings)) {
            data["statusMappings"] = [];
            for (let item of this.statusMappings)
                data["statusMappings"].push(item.toJSON());
        }
        return data;
    }
}

/** The status mappings by workflows. Status mappings are required when the new workflow for an issue type doesn't contain all statuses that the old workflow has. Status mappings can be provided by a combination of `statusMappingsByWorkflows` and `statusMappingsByIssueTypeOverride`. */
export interface IMappingsByWorkflow {
    /** The ID of the new workflow. */
    newWorkflowId: string;
    /** The ID of the old workflow. */
    oldWorkflowId: string;
    /** The list of status mappings. */
    statusMappings: WorkflowAssociationStatusMapping[];
}

export class MoveFieldBean implements IMoveFieldBean {
    /** The ID of the screen tab field after which to place the moved screen tab field. Required if `position` isn't provided. */
    after?: string;
    /** The named position to which the screen tab field should be moved. Required if `after` isn't provided. */
    position?: MoveFieldBeanPosition;

    constructor(data?: IMoveFieldBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.after = _data["after"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): MoveFieldBean {
        data = typeof data === 'object' ? data : {};
        let result = new MoveFieldBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["after"] = this.after;
        data["position"] = this.position;
        return data;
    }
}

export interface IMoveFieldBean {
    /** The ID of the screen tab field after which to place the moved screen tab field. Required if `position` isn't provided. */
    after?: string;
    /** The named position to which the screen tab field should be moved. Required if `after` isn't provided. */
    position?: MoveFieldBeanPosition;
}

/** A list of issues and their respective properties to set or update. See [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/) for more information. */
export class MultiIssueEntityProperties implements IMultiIssueEntityProperties {
    /** A list of issue IDs and their respective properties. */
    issues?: IssueEntityPropertiesForMultiUpdate[];

    constructor(data?: IMultiIssueEntityProperties) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issues"])) {
                this.issues = [] as any;
                for (let item of _data["issues"])
                    this.issues!.push(IssueEntityPropertiesForMultiUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MultiIssueEntityProperties {
        data = typeof data === 'object' ? data : {};
        let result = new MultiIssueEntityProperties();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item.toJSON());
        }
        return data;
    }
}

/** A list of issues and their respective properties to set or update. See [Entity properties](https://developer.atlassian.com/cloud/jira/platform/jira-entity-properties/) for more information. */
export interface IMultiIssueEntityProperties {
    /** A list of issue IDs and their respective properties. */
    issues?: IssueEntityPropertiesForMultiUpdate[];
}

export class MultipartFile implements IMultipartFile {
    bytes?: string[];
    contentType?: string;
    empty?: boolean;
    inputStream?: any;
    name?: string;
    originalFilename?: string;
    resource?: Resource;
    size?: number;

    constructor(data?: IMultipartFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bytes"])) {
                this.bytes = [] as any;
                for (let item of _data["bytes"])
                    this.bytes!.push(item);
            }
            this.contentType = _data["contentType"];
            this.empty = _data["empty"];
            this.inputStream = _data["inputStream"];
            this.name = _data["name"];
            this.originalFilename = _data["originalFilename"];
            this.resource = _data["resource"] ? Resource.fromJS(_data["resource"]) : <any>undefined;
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): MultipartFile {
        data = typeof data === 'object' ? data : {};
        let result = new MultipartFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bytes)) {
            data["bytes"] = [];
            for (let item of this.bytes)
                data["bytes"].push(item);
        }
        data["contentType"] = this.contentType;
        data["empty"] = this.empty;
        data["inputStream"] = this.inputStream;
        data["name"] = this.name;
        data["originalFilename"] = this.originalFilename;
        data["resource"] = this.resource ? this.resource.toJSON() : <any>undefined;
        data["size"] = this.size;
        return data;
    }
}

export interface IMultipartFile {
    bytes?: string[];
    contentType?: string;
    empty?: boolean;
    inputStream?: any;
    name?: string;
    originalFilename?: string;
    resource?: Resource;
    size?: number;
}

/** A custom field and its new value with a list of issue to update. */
export class MultipleCustomFieldValuesUpdate implements IMultipleCustomFieldValuesUpdate {
    /** The ID or key of the custom field. For example, `customfield_10010`. */
    customField!: string;
    /** The list of issue IDs. */
    issueIds!: number[];
    /** The value for the custom field. The value must be compatible with the [custom field type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#data-types) as follows:

 *  `string` the value must be a string.
 *  `number` the value must be a number.
 *  `datetime` the value must be a string that represents a date in the ISO format or the simplified extended ISO format. For example, `"2023-01-18T12:00:00-03:00"` or `"2023-01-18T12:00:00.000Z"`. However, the milliseconds part is ignored.
 *  `user` the value must be an object that contains the `accountId` field.
 *  `group` the value must be an object that contains the group `name` or `groupId` field. Because group names can change, we recommend using `groupId`.

A list of appropriate values must be provided if the field is of the `list` [collection type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#collection-types). */
    value!: any;

    constructor(data?: IMultipleCustomFieldValuesUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customField = _data["customField"];
            if (Array.isArray(_data["issueIds"])) {
                this.issueIds = [] as any;
                for (let item of _data["issueIds"])
                    this.issueIds!.push(item);
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): MultipleCustomFieldValuesUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new MultipleCustomFieldValuesUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customField"] = this.customField;
        if (Array.isArray(this.issueIds)) {
            data["issueIds"] = [];
            for (let item of this.issueIds)
                data["issueIds"].push(item);
        }
        data["value"] = this.value;
        return data;
    }
}

/** A custom field and its new value with a list of issue to update. */
export interface IMultipleCustomFieldValuesUpdate {
    /** The ID or key of the custom field. For example, `customfield_10010`. */
    customField: string;
    /** The list of issue IDs. */
    issueIds: number[];
    /** The value for the custom field. The value must be compatible with the [custom field type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#data-types) as follows:

 *  `string` the value must be a string.
 *  `number` the value must be a number.
 *  `datetime` the value must be a string that represents a date in the ISO format or the simplified extended ISO format. For example, `"2023-01-18T12:00:00-03:00"` or `"2023-01-18T12:00:00.000Z"`. However, the milliseconds part is ignored.
 *  `user` the value must be an object that contains the `accountId` field.
 *  `group` the value must be an object that contains the group `name` or `groupId` field. Because group names can change, we recommend using `groupId`.

A list of appropriate values must be provided if the field is of the `list` [collection type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#collection-types). */
    value: any;
}

/** List of updates for a custom fields. */
export class MultipleCustomFieldValuesUpdateDetails implements IMultipleCustomFieldValuesUpdateDetails {
    updates?: MultipleCustomFieldValuesUpdate[];

    constructor(data?: IMultipleCustomFieldValuesUpdateDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["updates"])) {
                this.updates = [] as any;
                for (let item of _data["updates"])
                    this.updates!.push(MultipleCustomFieldValuesUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MultipleCustomFieldValuesUpdateDetails {
        data = typeof data === 'object' ? data : {};
        let result = new MultipleCustomFieldValuesUpdateDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.updates)) {
            data["updates"] = [];
            for (let item of this.updates)
                data["updates"].push(item.toJSON());
        }
        return data;
    }
}

/** List of updates for a custom fields. */
export interface IMultipleCustomFieldValuesUpdateDetails {
    updates?: MultipleCustomFieldValuesUpdate[];
}

export class NestedResponse implements INestedResponse {
    errorCollection?: ErrorCollection;
    status?: number;
    warningCollection?: WarningCollection;

    constructor(data?: INestedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorCollection = _data["errorCollection"] ? ErrorCollection.fromJS(_data["errorCollection"]) : <any>undefined;
            this.status = _data["status"];
            this.warningCollection = _data["warningCollection"] ? WarningCollection.fromJS(_data["warningCollection"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NestedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new NestedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorCollection"] = this.errorCollection ? this.errorCollection.toJSON() : <any>undefined;
        data["status"] = this.status;
        data["warningCollection"] = this.warningCollection ? this.warningCollection.toJSON() : <any>undefined;
        return data;
    }
}

export interface INestedResponse {
    errorCollection?: ErrorCollection;
    status?: number;
    warningCollection?: WarningCollection;
}

/** The user details. */
export class NewUserDetails implements INewUserDetails {
    /** Deprecated, do not use. */
    applicationKeys?: string[];
    /** This property is no longer available. If the user has an Atlassian account, their display name is not changed. If the user does not have an Atlassian account, they are sent an email asking them set up an account. */
    displayName?: string;
    /** The email address for the user. */
    emailAddress!: string;
    /** This property is no longer available. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    key?: string;
    /** This property is no longer available. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    name?: string;
    /** This property is no longer available. If the user has an Atlassian account, their password is not changed. If the user does not have an Atlassian account, they are sent an email asking them set up an account. */
    password?: string;
    /** Products the new user has access to. Valid products are: jira-core, jira-servicedesk, jira-product-discovery, jira-software. To create a user without product access, set this field to be an empty array. */
    products!: string[];
    /** The URL of the user. */
    readonly self?: string;

    [key: string]: any;

    constructor(data?: INewUserDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.products = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["applicationKeys"])) {
                this.applicationKeys = [] as any;
                for (let item of _data["applicationKeys"])
                    this.applicationKeys!.push(item);
            }
            this.displayName = _data["displayName"];
            this.emailAddress = _data["emailAddress"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.password = _data["password"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(item);
            }
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): NewUserDetails {
        data = typeof data === 'object' ? data : {};
        let result = new NewUserDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.applicationKeys)) {
            data["applicationKeys"] = [];
            for (let item of this.applicationKeys)
                data["applicationKeys"].push(item);
        }
        data["displayName"] = this.displayName;
        data["emailAddress"] = this.emailAddress;
        data["key"] = this.key;
        data["name"] = this.name;
        data["password"] = this.password;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item);
        }
        data["self"] = this.self;
        return data;
    }
}

/** The user details. */
export interface INewUserDetails {
    /** Deprecated, do not use. */
    applicationKeys?: string[];
    /** This property is no longer available. If the user has an Atlassian account, their display name is not changed. If the user does not have an Atlassian account, they are sent an email asking them set up an account. */
    displayName?: string;
    /** The email address for the user. */
    emailAddress: string;
    /** This property is no longer available. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    key?: string;
    /** This property is no longer available. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    name?: string;
    /** This property is no longer available. If the user has an Atlassian account, their password is not changed. If the user does not have an Atlassian account, they are sent an email asking them set up an account. */
    password?: string;
    /** Products the new user has access to. Valid products are: jira-core, jira-servicedesk, jira-product-discovery, jira-software. To create a user without product access, set this field to be an empty array. */
    products: string[];
    /** The URL of the user. */
    self?: string;

    [key: string]: any;
}

export class NonWorkingDay implements INonWorkingDay {
    id?: number;
    iso8601Date?: string;

    constructor(data?: INonWorkingDay) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.iso8601Date = _data["iso8601Date"];
        }
    }

    static fromJS(data: any): NonWorkingDay {
        data = typeof data === 'object' ? data : {};
        let result = new NonWorkingDay();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["iso8601Date"] = this.iso8601Date;
        return data;
    }
}

export interface INonWorkingDay {
    id?: number;
    iso8601Date?: string;
}

/** Details about a notification. */
export class Notification implements INotification {
    /** The HTML body of the email notification for the issue. */
    htmlBody?: string;
    /** Restricts the notifications to users with the specified permissions. */
    restrict?: NotificationRecipientsRestrictions;
    /** The subject of the email notification for the issue. If this is not specified, then the subject is set to the issue key and summary. */
    subject?: string;
    /** The plain text body of the email notification for the issue. */
    textBody?: string;
    /** The recipients of the email notification for the issue. */
    to?: NotificationRecipients;

    [key: string]: any;

    constructor(data?: INotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.htmlBody = _data["htmlBody"];
            this.restrict = _data["restrict"] ? NotificationRecipientsRestrictions.fromJS(_data["restrict"]) : <any>undefined;
            this.subject = _data["subject"];
            this.textBody = _data["textBody"];
            this.to = _data["to"] ? NotificationRecipients.fromJS(_data["to"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Notification {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["htmlBody"] = this.htmlBody;
        data["restrict"] = this.restrict ? this.restrict.toJSON() : <any>undefined;
        data["subject"] = this.subject;
        data["textBody"] = this.textBody;
        data["to"] = this.to ? this.to.toJSON() : <any>undefined;
        return data;
    }
}

/** Details about a notification. */
export interface INotification {
    /** The HTML body of the email notification for the issue. */
    htmlBody?: string;
    /** Restricts the notifications to users with the specified permissions. */
    restrict?: NotificationRecipientsRestrictions;
    /** The subject of the email notification for the issue. If this is not specified, then the subject is set to the issue key and summary. */
    subject?: string;
    /** The plain text body of the email notification for the issue. */
    textBody?: string;
    /** The recipients of the email notification for the issue. */
    to?: NotificationRecipients;

    [key: string]: any;
}

/** Details about a notification event. */
export class NotificationEvent implements INotificationEvent {
    /** The description of the event. */
    description?: string;
    /** The ID of the event. The event can be a [Jira system event](https://confluence.atlassian.com/x/8YdKLg#Creatinganotificationscheme-eventsEvents) or a [custom event](https://confluence.atlassian.com/x/AIlKLg). */
    id?: number;
    /** The name of the event. */
    name?: string;
    /** The template of the event. Only custom events configured by Jira administrators have template. */
    templateEvent?: NotificationEvent;

    constructor(data?: INotificationEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.templateEvent = _data["templateEvent"] ? NotificationEvent.fromJS(_data["templateEvent"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationEvent {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["templateEvent"] = this.templateEvent ? this.templateEvent.toJSON() : <any>undefined;
        return data;
    }
}

/** Details about a notification event. */
export interface INotificationEvent {
    /** The description of the event. */
    description?: string;
    /** The ID of the event. The event can be a [Jira system event](https://confluence.atlassian.com/x/8YdKLg#Creatinganotificationscheme-eventsEvents) or a [custom event](https://confluence.atlassian.com/x/AIlKLg). */
    id?: number;
    /** The name of the event. */
    name?: string;
    /** The template of the event. Only custom events configured by Jira administrators have template. */
    templateEvent?: NotificationEvent;
}

/** Details of the users and groups to receive the notification. */
export class NotificationRecipients implements INotificationRecipients {
    /** Whether the notification should be sent to the issue's assignees. */
    assignee?: boolean;
    /** List of groupIds to receive the notification. */
    groupIds?: string[];
    /** List of groups to receive the notification. */
    groups?: GroupName[];
    /** Whether the notification should be sent to the issue's reporter. */
    reporter?: boolean;
    /** List of users to receive the notification. */
    users?: UserDetails[];
    /** Whether the notification should be sent to the issue's voters. */
    voters?: boolean;
    /** Whether the notification should be sent to the issue's watchers. */
    watchers?: boolean;

    [key: string]: any;

    constructor(data?: INotificationRecipients) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.assignee = _data["assignee"];
            if (Array.isArray(_data["groupIds"])) {
                this.groupIds = [] as any;
                for (let item of _data["groupIds"])
                    this.groupIds!.push(item);
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(GroupName.fromJS(item));
            }
            this.reporter = _data["reporter"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserDetails.fromJS(item));
            }
            this.voters = _data["voters"];
            this.watchers = _data["watchers"];
        }
    }

    static fromJS(data: any): NotificationRecipients {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationRecipients();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["assignee"] = this.assignee;
        if (Array.isArray(this.groupIds)) {
            data["groupIds"] = [];
            for (let item of this.groupIds)
                data["groupIds"].push(item);
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        data["reporter"] = this.reporter;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        data["voters"] = this.voters;
        data["watchers"] = this.watchers;
        return data;
    }
}

/** Details of the users and groups to receive the notification. */
export interface INotificationRecipients {
    /** Whether the notification should be sent to the issue's assignees. */
    assignee?: boolean;
    /** List of groupIds to receive the notification. */
    groupIds?: string[];
    /** List of groups to receive the notification. */
    groups?: GroupName[];
    /** Whether the notification should be sent to the issue's reporter. */
    reporter?: boolean;
    /** List of users to receive the notification. */
    users?: UserDetails[];
    /** Whether the notification should be sent to the issue's voters. */
    voters?: boolean;
    /** Whether the notification should be sent to the issue's watchers. */
    watchers?: boolean;

    [key: string]: any;
}

/** Details of the group membership or permissions needed to receive the notification. */
export class NotificationRecipientsRestrictions implements INotificationRecipientsRestrictions {
    /** List of groupId memberships required to receive the notification. */
    groupIds?: string[];
    /** List of group memberships required to receive the notification. */
    groups?: GroupName[];
    /** List of permissions required to receive the notification. */
    permissions?: RestrictedPermission[];

    constructor(data?: INotificationRecipientsRestrictions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["groupIds"])) {
                this.groupIds = [] as any;
                for (let item of _data["groupIds"])
                    this.groupIds!.push(item);
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(GroupName.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(RestrictedPermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationRecipientsRestrictions {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationRecipientsRestrictions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.groupIds)) {
            data["groupIds"] = [];
            for (let item of this.groupIds)
                data["groupIds"].push(item);
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of the group membership or permissions needed to receive the notification. */
export interface INotificationRecipientsRestrictions {
    /** List of groupId memberships required to receive the notification. */
    groupIds?: string[];
    /** List of group memberships required to receive the notification. */
    groups?: GroupName[];
    /** List of permissions required to receive the notification. */
    permissions?: RestrictedPermission[];
}

/** Details about a notification scheme. */
export class NotificationScheme implements INotificationScheme {
    /** The description of the notification scheme. */
    description?: string;
    /** Expand options that include additional notification scheme details in the response. */
    expand?: string;
    /** The ID of the notification scheme. */
    id?: number;
    /** The name of the notification scheme. */
    name?: string;
    /** The notification events and associated recipients. */
    notificationSchemeEvents?: NotificationSchemeEvent[];
    /** The list of project IDs associated with the notification scheme. */
    projects?: number[];
    /** The scope of the notification scheme. */
    scope?: Scope;
    self?: string;

    constructor(data?: INotificationScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.expand = _data["expand"];
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["notificationSchemeEvents"])) {
                this.notificationSchemeEvents = [] as any;
                for (let item of _data["notificationSchemeEvents"])
                    this.notificationSchemeEvents!.push(NotificationSchemeEvent.fromJS(item));
            }
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects!.push(item);
            }
            this.scope = _data["scope"] ? Scope.fromJS(_data["scope"]) : <any>undefined;
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): NotificationScheme {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["expand"] = this.expand;
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.notificationSchemeEvents)) {
            data["notificationSchemeEvents"] = [];
            for (let item of this.notificationSchemeEvents)
                data["notificationSchemeEvents"].push(item.toJSON());
        }
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item);
        }
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        data["self"] = this.self;
        return data;
    }
}

/** Details about a notification scheme. */
export interface INotificationScheme {
    /** The description of the notification scheme. */
    description?: string;
    /** Expand options that include additional notification scheme details in the response. */
    expand?: string;
    /** The ID of the notification scheme. */
    id?: number;
    /** The name of the notification scheme. */
    name?: string;
    /** The notification events and associated recipients. */
    notificationSchemeEvents?: NotificationSchemeEvent[];
    /** The list of project IDs associated with the notification scheme. */
    projects?: number[];
    /** The scope of the notification scheme. */
    scope?: Scope;
    self?: string;
}

export class NotificationSchemeAndProjectMappingJsonBean implements INotificationSchemeAndProjectMappingJsonBean {
    notificationSchemeId?: string;
    projectId?: string;

    constructor(data?: INotificationSchemeAndProjectMappingJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationSchemeId = _data["notificationSchemeId"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): NotificationSchemeAndProjectMappingJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSchemeAndProjectMappingJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationSchemeId"] = this.notificationSchemeId;
        data["projectId"] = this.projectId;
        return data;
    }
}

export interface INotificationSchemeAndProjectMappingJsonBean {
    notificationSchemeId?: string;
    projectId?: string;
}

/** Details about a notification scheme event. */
export class NotificationSchemeEvent implements INotificationSchemeEvent {
    event?: NotificationEvent;
    notifications?: EventNotification[];

    constructor(data?: INotificationSchemeEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.event = _data["event"] ? NotificationEvent.fromJS(_data["event"]) : <any>undefined;
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(EventNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationSchemeEvent {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSchemeEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["event"] = this.event ? this.event.toJSON() : <any>undefined;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

/** Details about a notification scheme event. */
export interface INotificationSchemeEvent {
    event?: NotificationEvent;
    notifications?: EventNotification[];
}

/** Details of a notification scheme event. */
export class NotificationSchemeEventDetails implements INotificationSchemeEventDetails {
    /** The ID of the event. */
    event!: NotificationSchemeEventTypeId;
    /** The list of notifications mapped to a specified event. */
    notifications!: NotificationSchemeNotificationDetails[];

    [key: string]: any;

    constructor(data?: INotificationSchemeEventDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.event = new NotificationSchemeEventTypeId();
            this.notifications = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.event = _data["event"] ? NotificationSchemeEventTypeId.fromJS(_data["event"]) : new NotificationSchemeEventTypeId();
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationSchemeNotificationDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationSchemeEventDetails {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSchemeEventDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["event"] = this.event ? this.event.toJSON() : <any>undefined;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of a notification scheme event. */
export interface INotificationSchemeEventDetails {
    /** The ID of the event. */
    event: NotificationSchemeEventTypeId;
    /** The list of notifications mapped to a specified event. */
    notifications: NotificationSchemeNotificationDetails[];

    [key: string]: any;
}

/** The event ID to use for reference in the payload */
export class NotificationSchemeEventIDPayload implements INotificationSchemeEventIDPayload {
    /** The event ID to use for reference in the payload */
    id?: string;

    constructor(data?: INotificationSchemeEventIDPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NotificationSchemeEventIDPayload {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSchemeEventIDPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** The event ID to use for reference in the payload */
export interface INotificationSchemeEventIDPayload {
    /** The event ID to use for reference in the payload */
    id?: string;
}

/** The payload for creating a notification scheme event. Defines which notifications should be sent for a specific event */
export class NotificationSchemeEventPayload implements INotificationSchemeEventPayload {
    event?: NotificationSchemeEventIDPayload;
    /** The configuration for notification recipents */
    notifications?: NotificationSchemeNotificationDetailsPayload[];

    constructor(data?: INotificationSchemeEventPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.event = _data["event"] ? NotificationSchemeEventIDPayload.fromJS(_data["event"]) : <any>undefined;
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationSchemeNotificationDetailsPayload.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationSchemeEventPayload {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSchemeEventPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["event"] = this.event ? this.event.toJSON() : <any>undefined;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

/** The payload for creating a notification scheme event. Defines which notifications should be sent for a specific event */
export interface INotificationSchemeEventPayload {
    event?: NotificationSchemeEventIDPayload;
    /** The configuration for notification recipents */
    notifications?: NotificationSchemeNotificationDetailsPayload[];
}

/** The ID of an event that is being mapped to notifications. */
export class NotificationSchemeEventTypeId implements INotificationSchemeEventTypeId {
    /** The ID of the notification scheme event. */
    id!: string;

    [key: string]: any;

    constructor(data?: INotificationSchemeEventTypeId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NotificationSchemeEventTypeId {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSchemeEventTypeId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }
}

/** The ID of an event that is being mapped to notifications. */
export interface INotificationSchemeEventTypeId {
    /** The ID of the notification scheme event. */
    id: string;

    [key: string]: any;
}

/** The ID of a notification scheme. */
export class NotificationSchemeId implements INotificationSchemeId {
    /** The ID of a notification scheme. */
    readonly id!: string;

    [key: string]: any;

    constructor(data?: INotificationSchemeId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).id = _data["id"];
        }
    }

    static fromJS(data: any): NotificationSchemeId {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSchemeId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }
}

/** The ID of a notification scheme. */
export interface INotificationSchemeId {
    /** The ID of a notification scheme. */
    id: string;

    [key: string]: any;
}

/** Details of a notification within a notification scheme. */
export class NotificationSchemeNotificationDetails implements INotificationSchemeNotificationDetails {
    /** The notification type, e.g `CurrentAssignee`, `Group`, `EmailAddress`. */
    notificationType!: string;
    /** The value corresponding to the specified notification type. */
    parameter?: string;

    [key: string]: any;

    constructor(data?: INotificationSchemeNotificationDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.notificationType = _data["notificationType"];
            this.parameter = _data["parameter"];
        }
    }

    static fromJS(data: any): NotificationSchemeNotificationDetails {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSchemeNotificationDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["notificationType"] = this.notificationType;
        data["parameter"] = this.parameter;
        return data;
    }
}

/** Details of a notification within a notification scheme. */
export interface INotificationSchemeNotificationDetails {
    /** The notification type, e.g `CurrentAssignee`, `Group`, `EmailAddress`. */
    notificationType: string;
    /** The value corresponding to the specified notification type. */
    parameter?: string;

    [key: string]: any;
}

/** The configuration for notification recipents */
export class NotificationSchemeNotificationDetailsPayload implements INotificationSchemeNotificationDetailsPayload {
    /** The type of notification. */
    notificationType?: string;
    /** The parameter of the notification, should be eiither null if not required, or PCRI. */
    parameter?: string;

    constructor(data?: INotificationSchemeNotificationDetailsPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationType = _data["notificationType"];
            this.parameter = _data["parameter"];
        }
    }

    static fromJS(data: any): NotificationSchemeNotificationDetailsPayload {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSchemeNotificationDetailsPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationType"] = this.notificationType;
        data["parameter"] = this.parameter;
        return data;
    }
}

/** The configuration for notification recipents */
export interface INotificationSchemeNotificationDetailsPayload {
    /** The type of notification. */
    notificationType?: string;
    /** The parameter of the notification, should be eiither null if not required, or PCRI. */
    parameter?: string;
}

/** The payload for creating a notification scheme. The user has to supply the ID for the default notification scheme. For CMP this is provided in the project payload and should be left empty, for TMP it's provided using this payload */
export class NotificationSchemePayload implements INotificationSchemePayload {
    /** The description of the notification scheme */
    description?: string;
    /** The name of the notification scheme */
    name?: string;
    /** The events and notifications for the notification scheme */
    notificationSchemeEvents?: NotificationSchemeEventPayload[];
    /** The strategy to use when there is a conflict with an existing entity */
    onConflict?: NotificationSchemePayloadOnConflict;
    pcri?: ProjectCreateResourceIdentifier;

    constructor(data?: INotificationSchemePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
            if (Array.isArray(_data["notificationSchemeEvents"])) {
                this.notificationSchemeEvents = [] as any;
                for (let item of _data["notificationSchemeEvents"])
                    this.notificationSchemeEvents!.push(NotificationSchemeEventPayload.fromJS(item));
            }
            this.onConflict = _data["onConflict"];
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationSchemePayload {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSchemePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        if (Array.isArray(this.notificationSchemeEvents)) {
            data["notificationSchemeEvents"] = [];
            for (let item of this.notificationSchemeEvents)
                data["notificationSchemeEvents"].push(item.toJSON());
        }
        data["onConflict"] = this.onConflict;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        return data;
    }
}

/** The payload for creating a notification scheme. The user has to supply the ID for the default notification scheme. For CMP this is provided in the project payload and should be left empty, for TMP it's provided using this payload */
export interface INotificationSchemePayload {
    /** The description of the notification scheme */
    description?: string;
    /** The name of the notification scheme */
    name?: string;
    /** The events and notifications for the notification scheme */
    notificationSchemeEvents?: NotificationSchemeEventPayload[];
    /** The strategy to use when there is a conflict with an existing entity */
    onConflict?: NotificationSchemePayloadOnConflict;
    pcri?: ProjectCreateResourceIdentifier;
}

export class OldToNewSecurityLevelMappingsBean implements IOldToNewSecurityLevelMappingsBean {
    /** The new issue security level ID. Providing null will clear the assigned old level from issues. */
    newLevelId!: string;
    /** The old issue security level ID. Providing null will remap all issues without any assigned levels. */
    oldLevelId!: string;

    constructor(data?: IOldToNewSecurityLevelMappingsBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newLevelId = _data["newLevelId"];
            this.oldLevelId = _data["oldLevelId"];
        }
    }

    static fromJS(data: any): OldToNewSecurityLevelMappingsBean {
        data = typeof data === 'object' ? data : {};
        let result = new OldToNewSecurityLevelMappingsBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newLevelId"] = this.newLevelId;
        data["oldLevelId"] = this.oldLevelId;
        return data;
    }
}

export interface IOldToNewSecurityLevelMappingsBean {
    /** The new issue security level ID. Providing null will clear the assigned old level from issues. */
    newLevelId: string;
    /** The old issue security level ID. Providing null will remap all issues without any assigned levels. */
    oldLevelId: string;
}

export class OperationMessage implements IOperationMessage {
    /** The human-readable message that describes the result. */
    message!: string;
    /** The status code of the response. */
    statusCode!: number;

    constructor(data?: IOperationMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): OperationMessage {
        data = typeof data === 'object' ? data : {};
        let result = new OperationMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface IOperationMessage {
    /** The human-readable message that describes the result. */
    message: string;
    /** The status code of the response. */
    statusCode: number;
}

/** Details of the operations that can be performed on the issue. */
export class Operations implements IOperations {
    /** Details of the link groups defining issue operations. */
    readonly linkGroups?: LinkGroup[];

    [key: string]: any;

    constructor(data?: IOperations) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["linkGroups"])) {
                (<any>this).linkGroups = [] as any;
                for (let item of _data["linkGroups"])
                    (<any>this).linkGroups!.push(LinkGroup.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Operations {
        data = typeof data === 'object' ? data : {};
        let result = new Operations();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.linkGroups)) {
            data["linkGroups"] = [];
            for (let item of this.linkGroups)
                data["linkGroups"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of the operations that can be performed on the issue. */
export interface IOperations {
    /** Details of the link groups defining issue operations. */
    linkGroups?: LinkGroup[];

    [key: string]: any;
}

/** An ordered list of custom field option IDs and information on where to move them. */
export class OrderOfCustomFieldOptions implements IOrderOfCustomFieldOptions {
    /** The ID of the custom field option or cascading option to place the moved options after. Required if `position` isn't provided. */
    after?: string;
    /** A list of IDs of custom field options to move. The order of the custom field option IDs in the list is the order they are given after the move. The list must contain custom field options or cascading options, but not both. */
    customFieldOptionIds!: string[];
    /** The position the custom field options should be moved to. Required if `after` isn't provided. */
    position?: OrderOfCustomFieldOptionsPosition;

    constructor(data?: IOrderOfCustomFieldOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.customFieldOptionIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.after = _data["after"];
            if (Array.isArray(_data["customFieldOptionIds"])) {
                this.customFieldOptionIds = [] as any;
                for (let item of _data["customFieldOptionIds"])
                    this.customFieldOptionIds!.push(item);
            }
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): OrderOfCustomFieldOptions {
        data = typeof data === 'object' ? data : {};
        let result = new OrderOfCustomFieldOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["after"] = this.after;
        if (Array.isArray(this.customFieldOptionIds)) {
            data["customFieldOptionIds"] = [];
            for (let item of this.customFieldOptionIds)
                data["customFieldOptionIds"].push(item);
        }
        data["position"] = this.position;
        return data;
    }
}

/** An ordered list of custom field option IDs and information on where to move them. */
export interface IOrderOfCustomFieldOptions {
    /** The ID of the custom field option or cascading option to place the moved options after. Required if `position` isn't provided. */
    after?: string;
    /** A list of IDs of custom field options to move. The order of the custom field option IDs in the list is the order they are given after the move. The list must contain custom field options or cascading options, but not both. */
    customFieldOptionIds: string[];
    /** The position the custom field options should be moved to. Required if `after` isn't provided. */
    position?: OrderOfCustomFieldOptionsPosition;
}

/** An ordered list of issue type IDs and information about where to move them. */
export class OrderOfIssueTypes implements IOrderOfIssueTypes {
    /** The ID of the issue type to place the moved issue types after. Required if `position` isn't provided. */
    after?: string;
    /** A list of the issue type IDs to move. The order of the issue type IDs in the list is the order they are given after the move. */
    issueTypeIds!: string[];
    /** The position the issue types should be moved to. Required if `after` isn't provided. */
    position?: OrderOfIssueTypesPosition;

    constructor(data?: IOrderOfIssueTypes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueTypeIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.after = _data["after"];
            if (Array.isArray(_data["issueTypeIds"])) {
                this.issueTypeIds = [] as any;
                for (let item of _data["issueTypeIds"])
                    this.issueTypeIds!.push(item);
            }
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): OrderOfIssueTypes {
        data = typeof data === 'object' ? data : {};
        let result = new OrderOfIssueTypes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["after"] = this.after;
        if (Array.isArray(this.issueTypeIds)) {
            data["issueTypeIds"] = [];
            for (let item of this.issueTypeIds)
                data["issueTypeIds"].push(item);
        }
        data["position"] = this.position;
        return data;
    }
}

/** An ordered list of issue type IDs and information about where to move them. */
export interface IOrderOfIssueTypes {
    /** The ID of the issue type to place the moved issue types after. Required if `position` isn't provided. */
    after?: string;
    /** A list of the issue type IDs to move. The order of the issue type IDs in the list is the order they are given after the move. */
    issueTypeIds: string[];
    /** The position the issue types should be moved to. Required if `after` isn't provided. */
    position?: OrderOfIssueTypesPosition;
}

/** A page of items. */
export class PageBean2ComponentJsonBean implements IPageBean2ComponentJsonBean {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: ComponentJsonBean[];

    constructor(data?: IPageBean2ComponentJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(ComponentJsonBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBean2ComponentJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new PageBean2ComponentJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBean2ComponentJsonBean {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: ComponentJsonBean[];
}

/** A page of items. */
export class PageBean2JqlFunctionPrecomputationBean implements IPageBean2JqlFunctionPrecomputationBean {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: JqlFunctionPrecomputationBean[];

    constructor(data?: IPageBean2JqlFunctionPrecomputationBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(JqlFunctionPrecomputationBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBean2JqlFunctionPrecomputationBean {
        data = typeof data === 'object' ? data : {};
        let result = new PageBean2JqlFunctionPrecomputationBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBean2JqlFunctionPrecomputationBean {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: JqlFunctionPrecomputationBean[];
}

/** A page of items. */
export class PageBeanBulkContextualConfiguration implements IPageBeanBulkContextualConfiguration {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: BulkContextualConfiguration[];

    constructor(data?: IPageBeanBulkContextualConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(BulkContextualConfiguration.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanBulkContextualConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanBulkContextualConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanBulkContextualConfiguration {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: BulkContextualConfiguration[];
}

/** A page of items. */
export class PageBeanChangelog implements IPageBeanChangelog {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: Changelog[];

    constructor(data?: IPageBeanChangelog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(Changelog.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanChangelog {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanChangelog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanChangelog {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: Changelog[];
}

/** A page of items. */
export class PageBeanComment implements IPageBeanComment {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: Comment[];

    constructor(data?: IPageBeanComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(Comment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanComment {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanComment {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: Comment[];
}

/** A page of items. */
export class PageBeanComponentWithIssueCount implements IPageBeanComponentWithIssueCount {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: ComponentWithIssueCount[];

    constructor(data?: IPageBeanComponentWithIssueCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(ComponentWithIssueCount.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanComponentWithIssueCount {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanComponentWithIssueCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanComponentWithIssueCount {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: ComponentWithIssueCount[];
}

/** A page of items. */
export class PageBeanContext implements IPageBeanContext {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: Context[];

    constructor(data?: IPageBeanContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(Context.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanContext {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanContext {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: Context[];
}

/** A page of items. */
export class PageBeanContextForProjectAndIssueType implements IPageBeanContextForProjectAndIssueType {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: ContextForProjectAndIssueType[];

    constructor(data?: IPageBeanContextForProjectAndIssueType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(ContextForProjectAndIssueType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanContextForProjectAndIssueType {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanContextForProjectAndIssueType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanContextForProjectAndIssueType {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: ContextForProjectAndIssueType[];
}

/** A page of items. */
export class PageBeanContextualConfiguration implements IPageBeanContextualConfiguration {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: ContextualConfiguration[];

    constructor(data?: IPageBeanContextualConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(ContextualConfiguration.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanContextualConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanContextualConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanContextualConfiguration {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: ContextualConfiguration[];
}

/** A page of items. */
export class PageBeanCustomFieldContext implements IPageBeanCustomFieldContext {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: CustomFieldContext[];

    constructor(data?: IPageBeanCustomFieldContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(CustomFieldContext.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanCustomFieldContext {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanCustomFieldContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanCustomFieldContext {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: CustomFieldContext[];
}

/** A page of items. */
export class PageBeanCustomFieldContextDefaultValue implements IPageBeanCustomFieldContextDefaultValue {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: DefaultValues[];

    constructor(data?: IPageBeanCustomFieldContextDefaultValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(DefaultValues.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanCustomFieldContextDefaultValue {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanCustomFieldContextDefaultValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanCustomFieldContextDefaultValue {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: DefaultValues[];
}

/** A page of items. */
export class PageBeanCustomFieldContextOption implements IPageBeanCustomFieldContextOption {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: CustomFieldContextOption[];

    constructor(data?: IPageBeanCustomFieldContextOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(CustomFieldContextOption.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanCustomFieldContextOption {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanCustomFieldContextOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanCustomFieldContextOption {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: CustomFieldContextOption[];
}

/** A page of items. */
export class PageBeanCustomFieldContextProjectMapping implements IPageBeanCustomFieldContextProjectMapping {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: CustomFieldContextProjectMapping[];

    constructor(data?: IPageBeanCustomFieldContextProjectMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(CustomFieldContextProjectMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanCustomFieldContextProjectMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanCustomFieldContextProjectMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanCustomFieldContextProjectMapping {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: CustomFieldContextProjectMapping[];
}

/** A page of items. */
export class PageBeanDashboard implements IPageBeanDashboard {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: Dashboard[];

    constructor(data?: IPageBeanDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(Dashboard.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanDashboard {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanDashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanDashboard {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: Dashboard[];
}

/** A page of items. */
export class PageBeanField implements IPageBeanField {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: Field[];

    constructor(data?: IPageBeanField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(Field.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanField {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanField {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: Field[];
}

/** A page of items. */
export class PageBeanFieldConfigurationDetails implements IPageBeanFieldConfigurationDetails {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: FieldConfigurationDetails[];

    constructor(data?: IPageBeanFieldConfigurationDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(FieldConfigurationDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanFieldConfigurationDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanFieldConfigurationDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanFieldConfigurationDetails {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: FieldConfigurationDetails[];
}

/** A page of items. */
export class PageBeanFieldConfigurationIssueTypeItem implements IPageBeanFieldConfigurationIssueTypeItem {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: FieldConfigurationIssueTypeItem[];

    constructor(data?: IPageBeanFieldConfigurationIssueTypeItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(FieldConfigurationIssueTypeItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanFieldConfigurationIssueTypeItem {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanFieldConfigurationIssueTypeItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanFieldConfigurationIssueTypeItem {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: FieldConfigurationIssueTypeItem[];
}

/** A page of items. */
export class PageBeanFieldConfigurationItem implements IPageBeanFieldConfigurationItem {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: FieldConfigurationItem[];

    constructor(data?: IPageBeanFieldConfigurationItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(FieldConfigurationItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanFieldConfigurationItem {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanFieldConfigurationItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanFieldConfigurationItem {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: FieldConfigurationItem[];
}

/** A page of items. */
export class PageBeanFieldConfigurationScheme implements IPageBeanFieldConfigurationScheme {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: FieldConfigurationScheme[];

    constructor(data?: IPageBeanFieldConfigurationScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(FieldConfigurationScheme.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanFieldConfigurationScheme {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanFieldConfigurationScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanFieldConfigurationScheme {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: FieldConfigurationScheme[];
}

/** A page of items. */
export class PageBeanFieldConfigurationSchemeProjects implements IPageBeanFieldConfigurationSchemeProjects {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: FieldConfigurationSchemeProjects[];

    constructor(data?: IPageBeanFieldConfigurationSchemeProjects) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(FieldConfigurationSchemeProjects.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanFieldConfigurationSchemeProjects {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanFieldConfigurationSchemeProjects();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanFieldConfigurationSchemeProjects {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: FieldConfigurationSchemeProjects[];
}

/** A page of items. */
export class PageBeanFilterDetails implements IPageBeanFilterDetails {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: FilterDetails[];

    constructor(data?: IPageBeanFilterDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(FilterDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanFilterDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanFilterDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanFilterDetails {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: FilterDetails[];
}

/** A page of items. */
export class PageBeanGroupDetails implements IPageBeanGroupDetails {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: GroupDetails[];

    constructor(data?: IPageBeanGroupDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(GroupDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanGroupDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanGroupDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanGroupDetails {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: GroupDetails[];
}

/** A page of items. */
export class PageBeanIssueFieldOption implements IPageBeanIssueFieldOption {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: IssueFieldOption[];

    constructor(data?: IPageBeanIssueFieldOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(IssueFieldOption.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanIssueFieldOption {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanIssueFieldOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanIssueFieldOption {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: IssueFieldOption[];
}

/** A page of items. */
export class PageBeanIssueSecurityLevelMember implements IPageBeanIssueSecurityLevelMember {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: IssueSecurityLevelMember[];

    constructor(data?: IPageBeanIssueSecurityLevelMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(IssueSecurityLevelMember.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanIssueSecurityLevelMember {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanIssueSecurityLevelMember();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanIssueSecurityLevelMember {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: IssueSecurityLevelMember[];
}

/** A page of items. */
export class PageBeanIssueSecuritySchemeToProjectMapping implements IPageBeanIssueSecuritySchemeToProjectMapping {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: IssueSecuritySchemeToProjectMapping[];

    constructor(data?: IPageBeanIssueSecuritySchemeToProjectMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(IssueSecuritySchemeToProjectMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanIssueSecuritySchemeToProjectMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanIssueSecuritySchemeToProjectMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanIssueSecuritySchemeToProjectMapping {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: IssueSecuritySchemeToProjectMapping[];
}

/** A page of items. */
export class PageBeanIssueTypeScheme implements IPageBeanIssueTypeScheme {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: IssueTypeScheme[];

    constructor(data?: IPageBeanIssueTypeScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(IssueTypeScheme.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanIssueTypeScheme {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanIssueTypeScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanIssueTypeScheme {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: IssueTypeScheme[];
}

/** A page of items. */
export class PageBeanIssueTypeSchemeMapping implements IPageBeanIssueTypeSchemeMapping {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: IssueTypeSchemeMapping[];

    constructor(data?: IPageBeanIssueTypeSchemeMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(IssueTypeSchemeMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanIssueTypeSchemeMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanIssueTypeSchemeMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanIssueTypeSchemeMapping {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: IssueTypeSchemeMapping[];
}

/** A page of items. */
export class PageBeanIssueTypeSchemeProjects implements IPageBeanIssueTypeSchemeProjects {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: IssueTypeSchemeProjects[];

    constructor(data?: IPageBeanIssueTypeSchemeProjects) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(IssueTypeSchemeProjects.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanIssueTypeSchemeProjects {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanIssueTypeSchemeProjects();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanIssueTypeSchemeProjects {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: IssueTypeSchemeProjects[];
}

/** A page of items. */
export class PageBeanIssueTypeScreenScheme implements IPageBeanIssueTypeScreenScheme {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: IssueTypeScreenScheme[];

    constructor(data?: IPageBeanIssueTypeScreenScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(IssueTypeScreenScheme.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanIssueTypeScreenScheme {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanIssueTypeScreenScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanIssueTypeScreenScheme {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: IssueTypeScreenScheme[];
}

/** A page of items. */
export class PageBeanIssueTypeScreenSchemeItem implements IPageBeanIssueTypeScreenSchemeItem {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: IssueTypeScreenSchemeItem[];

    constructor(data?: IPageBeanIssueTypeScreenSchemeItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(IssueTypeScreenSchemeItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanIssueTypeScreenSchemeItem {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanIssueTypeScreenSchemeItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanIssueTypeScreenSchemeItem {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: IssueTypeScreenSchemeItem[];
}

/** A page of items. */
export class PageBeanIssueTypeScreenSchemesProjects implements IPageBeanIssueTypeScreenSchemesProjects {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: IssueTypeScreenSchemesProjects[];

    constructor(data?: IPageBeanIssueTypeScreenSchemesProjects) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(IssueTypeScreenSchemesProjects.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanIssueTypeScreenSchemesProjects {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanIssueTypeScreenSchemesProjects();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanIssueTypeScreenSchemesProjects {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: IssueTypeScreenSchemesProjects[];
}

/** A page of items. */
export class PageBeanIssueTypeToContextMapping implements IPageBeanIssueTypeToContextMapping {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: IssueTypeToContextMapping[];

    constructor(data?: IPageBeanIssueTypeToContextMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(IssueTypeToContextMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanIssueTypeToContextMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanIssueTypeToContextMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanIssueTypeToContextMapping {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: IssueTypeToContextMapping[];
}

/** A page of items. */
export class PageBeanNotificationScheme implements IPageBeanNotificationScheme {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: NotificationScheme[];

    constructor(data?: IPageBeanNotificationScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(NotificationScheme.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanNotificationScheme {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanNotificationScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanNotificationScheme {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: NotificationScheme[];
}

/** A page of items. */
export class PageBeanNotificationSchemeAndProjectMappingJsonBean implements IPageBeanNotificationSchemeAndProjectMappingJsonBean {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: NotificationSchemeAndProjectMappingJsonBean[];

    constructor(data?: IPageBeanNotificationSchemeAndProjectMappingJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(NotificationSchemeAndProjectMappingJsonBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanNotificationSchemeAndProjectMappingJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanNotificationSchemeAndProjectMappingJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanNotificationSchemeAndProjectMappingJsonBean {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: NotificationSchemeAndProjectMappingJsonBean[];
}

/** A page of items. */
export class PageBeanPriority implements IPageBeanPriority {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: Priority[];

    constructor(data?: IPageBeanPriority) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(Priority.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanPriority {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanPriority();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanPriority {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: Priority[];
}

/** A page of items. */
export class PageBeanPrioritySchemeWithPaginatedPrioritiesAndProjects implements IPageBeanPrioritySchemeWithPaginatedPrioritiesAndProjects {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: PrioritySchemeWithPaginatedPrioritiesAndProjects[];

    constructor(data?: IPageBeanPrioritySchemeWithPaginatedPrioritiesAndProjects) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(PrioritySchemeWithPaginatedPrioritiesAndProjects.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanPrioritySchemeWithPaginatedPrioritiesAndProjects {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanPrioritySchemeWithPaginatedPrioritiesAndProjects();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanPrioritySchemeWithPaginatedPrioritiesAndProjects {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: PrioritySchemeWithPaginatedPrioritiesAndProjects[];
}

/** A page of items. */
export class PageBeanPriorityWithSequence implements IPageBeanPriorityWithSequence {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: PriorityWithSequence[];

    constructor(data?: IPageBeanPriorityWithSequence) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(PriorityWithSequence.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanPriorityWithSequence {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanPriorityWithSequence();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanPriorityWithSequence {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: PriorityWithSequence[];
}

/** A page of items. */
export class PageBeanProject implements IPageBeanProject {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: Project[];

    constructor(data?: IPageBeanProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(Project.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanProject {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanProject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanProject {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: Project[];
}

/** A page of items. */
export class PageBeanProjectDetails implements IPageBeanProjectDetails {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: ProjectDetails[];

    constructor(data?: IPageBeanProjectDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(ProjectDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanProjectDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanProjectDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanProjectDetails {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: ProjectDetails[];
}

/** A page of items. */
export class PageBeanResolutionJsonBean implements IPageBeanResolutionJsonBean {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: ResolutionJsonBean[];

    constructor(data?: IPageBeanResolutionJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(ResolutionJsonBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanResolutionJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanResolutionJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanResolutionJsonBean {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: ResolutionJsonBean[];
}

/** A page of items. */
export class PageBeanScreen implements IPageBeanScreen {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: Screen[];

    constructor(data?: IPageBeanScreen) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(Screen.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanScreen {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanScreen();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanScreen {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: Screen[];
}

/** A page of items. */
export class PageBeanScreenScheme implements IPageBeanScreenScheme {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: ScreenScheme[];

    constructor(data?: IPageBeanScreenScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(ScreenScheme.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanScreenScheme {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanScreenScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanScreenScheme {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: ScreenScheme[];
}

/** A page of items. */
export class PageBeanScreenWithTab implements IPageBeanScreenWithTab {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: ScreenWithTab[];

    constructor(data?: IPageBeanScreenWithTab) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(ScreenWithTab.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanScreenWithTab {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanScreenWithTab();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanScreenWithTab {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: ScreenWithTab[];
}

/** A page of items. */
export class PageBeanSecurityLevel implements IPageBeanSecurityLevel {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: SecurityLevel[];

    constructor(data?: IPageBeanSecurityLevel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(SecurityLevel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanSecurityLevel {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanSecurityLevel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanSecurityLevel {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: SecurityLevel[];
}

/** A page of items. */
export class PageBeanSecurityLevelMember implements IPageBeanSecurityLevelMember {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: SecurityLevelMember[];

    constructor(data?: IPageBeanSecurityLevelMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(SecurityLevelMember.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanSecurityLevelMember {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanSecurityLevelMember();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanSecurityLevelMember {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: SecurityLevelMember[];
}

/** A page of items. */
export class PageBeanSecuritySchemeWithProjects implements IPageBeanSecuritySchemeWithProjects {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: SecuritySchemeWithProjects[];

    constructor(data?: IPageBeanSecuritySchemeWithProjects) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(SecuritySchemeWithProjects.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanSecuritySchemeWithProjects {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanSecuritySchemeWithProjects();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanSecuritySchemeWithProjects {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: SecuritySchemeWithProjects[];
}

/** A page of items. */
export class PageBeanString implements IPageBeanString {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: string[];

    constructor(data?: IPageBeanString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(item);
            }
        }
    }

    static fromJS(data: any): PageBeanString {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanString {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: string[];
}

/** A page of items. */
export class PageBeanUiModificationDetails implements IPageBeanUiModificationDetails {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: UiModificationDetails[];

    constructor(data?: IPageBeanUiModificationDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(UiModificationDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanUiModificationDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanUiModificationDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanUiModificationDetails {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: UiModificationDetails[];
}

/** A page of items. */
export class PageBeanUser implements IPageBeanUser {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: User[];

    constructor(data?: IPageBeanUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanUser {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanUser {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: User[];
}

/** A page of items. */
export class PageBeanUserDetails implements IPageBeanUserDetails {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: UserDetails[];

    constructor(data?: IPageBeanUserDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(UserDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanUserDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanUserDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanUserDetails {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: UserDetails[];
}

/** A page of items. */
export class PageBeanUserKey implements IPageBeanUserKey {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: UserKey[];

    constructor(data?: IPageBeanUserKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(UserKey.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanUserKey {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanUserKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanUserKey {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: UserKey[];
}

/** A page of items. */
export class PageBeanVersion implements IPageBeanVersion {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: Version[];

    constructor(data?: IPageBeanVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(Version.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanVersion {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanVersion {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: Version[];
}

/** A page of items. */
export class PageBeanWebhook implements IPageBeanWebhook {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: Webhook[];

    constructor(data?: IPageBeanWebhook) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(Webhook.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanWebhook {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanWebhook();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanWebhook {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: Webhook[];
}

/** A page of items. */
export class PageBeanWorkflow implements IPageBeanWorkflow {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: Workflow[];

    constructor(data?: IPageBeanWorkflow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(Workflow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanWorkflow {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanWorkflow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanWorkflow {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: Workflow[];
}

/** A page of items. */
export class PageBeanWorkflowScheme implements IPageBeanWorkflowScheme {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: WorkflowScheme[];

    constructor(data?: IPageBeanWorkflowScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(WorkflowScheme.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanWorkflowScheme {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanWorkflowScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanWorkflowScheme {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: WorkflowScheme[];
}

/** A page of items. */
export class PageBeanWorkflowTransitionRules implements IPageBeanWorkflowTransitionRules {
    /** Whether this is the last page. */
    readonly isLast?: boolean;
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    readonly nextPage?: string;
    /** The URL of the page. */
    readonly self?: string;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;
    /** The list of items. */
    readonly values?: WorkflowTransitionRules[];

    constructor(data?: IPageBeanWorkflowTransitionRules) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isLast = _data["isLast"];
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).nextPage = _data["nextPage"];
            (<any>this).self = _data["self"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["values"])) {
                (<any>this).values = [] as any;
                for (let item of _data["values"])
                    (<any>this).values!.push(WorkflowTransitionRules.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageBeanWorkflowTransitionRules {
        data = typeof data === 'object' ? data : {};
        let result = new PageBeanWorkflowTransitionRules();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of items. */
export interface IPageBeanWorkflowTransitionRules {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;
    /** The list of items. */
    values?: WorkflowTransitionRules[];
}

/** A page of changelogs. */
export class PageOfChangelogs implements IPageOfChangelogs {
    /** The list of changelogs. */
    readonly histories?: Changelog[];
    /** The maximum number of results that could be on the page. */
    readonly maxResults?: number;
    /** The index of the first item returned on the page. */
    readonly startAt?: number;
    /** The number of results on the page. */
    readonly total?: number;

    constructor(data?: IPageOfChangelogs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["histories"])) {
                (<any>this).histories = [] as any;
                for (let item of _data["histories"])
                    (<any>this).histories!.push(Changelog.fromJS(item));
            }
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
        }
    }

    static fromJS(data: any): PageOfChangelogs {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfChangelogs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.histories)) {
            data["histories"] = [];
            for (let item of this.histories)
                data["histories"].push(item.toJSON());
        }
        data["maxResults"] = this.maxResults;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        return data;
    }
}

/** A page of changelogs. */
export interface IPageOfChangelogs {
    /** The list of changelogs. */
    histories?: Changelog[];
    /** The maximum number of results that could be on the page. */
    maxResults?: number;
    /** The index of the first item returned on the page. */
    startAt?: number;
    /** The number of results on the page. */
    total?: number;
}

/** A page of comments. */
export class PageOfComments implements IPageOfComments {
    /** The list of comments. */
    readonly comments?: Comment[];
    /** The maximum number of items that could be returned. */
    readonly maxResults?: number;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The number of items returned. */
    readonly total?: number;

    [key: string]: any;

    constructor(data?: IPageOfComments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["comments"])) {
                (<any>this).comments = [] as any;
                for (let item of _data["comments"])
                    (<any>this).comments!.push(Comment.fromJS(item));
            }
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
        }
    }

    static fromJS(data: any): PageOfComments {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfComments();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        data["maxResults"] = this.maxResults;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        return data;
    }
}

/** A page of comments. */
export interface IPageOfComments {
    /** The list of comments. */
    comments?: Comment[];
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** The index of the first item returned. */
    startAt?: number;
    /** The number of items returned. */
    total?: number;

    [key: string]: any;
}

/** A page of CreateMetaIssueType with Field. */
export class PageOfCreateMetaIssueTypeWithField implements IPageOfCreateMetaIssueTypeWithField {
    /** The collection of FieldCreateMetaBeans. */
    readonly fields?: FieldCreateMetadata[];
    /** The maximum number of items to return per page. */
    readonly maxResults?: number;
    results?: FieldCreateMetadata[];
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The total number of items in all pages. */
    readonly total?: number;

    [key: string]: any;

    constructor(data?: IPageOfCreateMetaIssueTypeWithField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["fields"])) {
                (<any>this).fields = [] as any;
                for (let item of _data["fields"])
                    (<any>this).fields!.push(FieldCreateMetadata.fromJS(item));
            }
            (<any>this).maxResults = _data["maxResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(FieldCreateMetadata.fromJS(item));
            }
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
        }
    }

    static fromJS(data: any): PageOfCreateMetaIssueTypeWithField {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfCreateMetaIssueTypeWithField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        data["maxResults"] = this.maxResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        return data;
    }
}

/** A page of CreateMetaIssueType with Field. */
export interface IPageOfCreateMetaIssueTypeWithField {
    /** The collection of FieldCreateMetaBeans. */
    fields?: FieldCreateMetadata[];
    /** The maximum number of items to return per page. */
    maxResults?: number;
    results?: FieldCreateMetadata[];
    /** The index of the first item returned. */
    startAt?: number;
    /** The total number of items in all pages. */
    total?: number;

    [key: string]: any;
}

/** A page of CreateMetaIssueTypes. */
export class PageOfCreateMetaIssueTypes implements IPageOfCreateMetaIssueTypes {
    createMetaIssueType?: IssueTypeIssueCreateMetadata[];
    /** The list of CreateMetaIssueType. */
    readonly issueTypes?: IssueTypeIssueCreateMetadata[];
    /** The maximum number of items to return per page. */
    readonly maxResults?: number;
    /** The index of the first item returned. */
    readonly startAt?: number;
    /** The total number of items in all pages. */
    readonly total?: number;

    [key: string]: any;

    constructor(data?: IPageOfCreateMetaIssueTypes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["createMetaIssueType"])) {
                this.createMetaIssueType = [] as any;
                for (let item of _data["createMetaIssueType"])
                    this.createMetaIssueType!.push(IssueTypeIssueCreateMetadata.fromJS(item));
            }
            if (Array.isArray(_data["issueTypes"])) {
                (<any>this).issueTypes = [] as any;
                for (let item of _data["issueTypes"])
                    (<any>this).issueTypes!.push(IssueTypeIssueCreateMetadata.fromJS(item));
            }
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
        }
    }

    static fromJS(data: any): PageOfCreateMetaIssueTypes {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfCreateMetaIssueTypes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.createMetaIssueType)) {
            data["createMetaIssueType"] = [];
            for (let item of this.createMetaIssueType)
                data["createMetaIssueType"].push(item.toJSON());
        }
        if (Array.isArray(this.issueTypes)) {
            data["issueTypes"] = [];
            for (let item of this.issueTypes)
                data["issueTypes"].push(item.toJSON());
        }
        data["maxResults"] = this.maxResults;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        return data;
    }
}

/** A page of CreateMetaIssueTypes. */
export interface IPageOfCreateMetaIssueTypes {
    createMetaIssueType?: IssueTypeIssueCreateMetadata[];
    /** The list of CreateMetaIssueType. */
    issueTypes?: IssueTypeIssueCreateMetadata[];
    /** The maximum number of items to return per page. */
    maxResults?: number;
    /** The index of the first item returned. */
    startAt?: number;
    /** The total number of items in all pages. */
    total?: number;

    [key: string]: any;
}

/** A page containing dashboard details. */
export class PageOfDashboards implements IPageOfDashboards {
    /** List of dashboards. */
    readonly dashboards?: Dashboard[];
    /** The maximum number of results that could be on the page. */
    readonly maxResults?: number;
    /** The URL of the next page of results, if any. */
    readonly next?: string;
    /** The URL of the previous page of results, if any. */
    readonly prev?: string;
    /** The index of the first item returned on the page. */
    readonly startAt?: number;
    /** The number of results on the page. */
    readonly total?: number;

    constructor(data?: IPageOfDashboards) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dashboards"])) {
                (<any>this).dashboards = [] as any;
                for (let item of _data["dashboards"])
                    (<any>this).dashboards!.push(Dashboard.fromJS(item));
            }
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).next = _data["next"];
            (<any>this).prev = _data["prev"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
        }
    }

    static fromJS(data: any): PageOfDashboards {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfDashboards();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dashboards)) {
            data["dashboards"] = [];
            for (let item of this.dashboards)
                data["dashboards"].push(item.toJSON());
        }
        data["maxResults"] = this.maxResults;
        data["next"] = this.next;
        data["prev"] = this.prev;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        return data;
    }
}

/** A page containing dashboard details. */
export interface IPageOfDashboards {
    /** List of dashboards. */
    dashboards?: Dashboard[];
    /** The maximum number of results that could be on the page. */
    maxResults?: number;
    /** The URL of the next page of results, if any. */
    next?: string;
    /** The URL of the previous page of results, if any. */
    prev?: string;
    /** The index of the first item returned on the page. */
    startAt?: number;
    /** The number of results on the page. */
    total?: number;
}

export class PageOfStatuses implements IPageOfStatuses {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** The URL of the next page of results, if any. */
    nextPage?: string;
    /** The URL of this page. */
    self?: string;
    /** The index of the first item returned on the page. */
    startAt?: number;
    /** Number of items that satisfy the search. */
    total?: number;
    /** The list of items. */
    values?: JiraStatus[];

    constructor(data?: IPageOfStatuses) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isLast = _data["isLast"];
            this.maxResults = _data["maxResults"];
            this.nextPage = _data["nextPage"];
            this.self = _data["self"];
            this.startAt = _data["startAt"];
            this.total = _data["total"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(JiraStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageOfStatuses {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfStatuses();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPageOfStatuses {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** The URL of the next page of results, if any. */
    nextPage?: string;
    /** The URL of this page. */
    self?: string;
    /** The index of the first item returned on the page. */
    startAt?: number;
    /** Number of items that satisfy the search. */
    total?: number;
    /** The list of items. */
    values?: JiraStatus[];
}

/** Paginated list of worklog details */
export class PageOfWorklogs implements IPageOfWorklogs {
    /** The maximum number of results that could be on the page. */
    readonly maxResults?: number;
    /** The index of the first item returned on the page. */
    readonly startAt?: number;
    /** The number of results on the page. */
    readonly total?: number;
    /** List of worklogs. */
    readonly worklogs?: Worklog[];

    [key: string]: any;

    constructor(data?: IPageOfWorklogs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).maxResults = _data["maxResults"];
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["worklogs"])) {
                (<any>this).worklogs = [] as any;
                for (let item of _data["worklogs"])
                    (<any>this).worklogs!.push(Worklog.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageOfWorklogs {
        data = typeof data === 'object' ? data : {};
        let result = new PageOfWorklogs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["maxResults"] = this.maxResults;
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.worklogs)) {
            data["worklogs"] = [];
            for (let item of this.worklogs)
                data["worklogs"].push(item.toJSON());
        }
        return data;
    }
}

/** Paginated list of worklog details */
export interface IPageOfWorklogs {
    /** The maximum number of results that could be on the page. */
    maxResults?: number;
    /** The index of the first item returned on the page. */
    startAt?: number;
    /** The number of results on the page. */
    total?: number;
    /** List of worklogs. */
    worklogs?: Worklog[];

    [key: string]: any;
}

export class PageWithCursorGetPlanResponseForPage implements IPageWithCursorGetPlanResponseForPage {
    cursor?: string;
    last?: boolean;
    nextPageCursor?: string;
    size?: number;
    total?: number;
    values?: GetPlanResponseForPage[];

    constructor(data?: IPageWithCursorGetPlanResponseForPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cursor = _data["cursor"];
            this.last = _data["last"];
            this.nextPageCursor = _data["nextPageCursor"];
            this.size = _data["size"];
            this.total = _data["total"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(GetPlanResponseForPage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageWithCursorGetPlanResponseForPage {
        data = typeof data === 'object' ? data : {};
        let result = new PageWithCursorGetPlanResponseForPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cursor"] = this.cursor;
        data["last"] = this.last;
        data["nextPageCursor"] = this.nextPageCursor;
        data["size"] = this.size;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPageWithCursorGetPlanResponseForPage {
    cursor?: string;
    last?: boolean;
    nextPageCursor?: string;
    size?: number;
    total?: number;
    values?: GetPlanResponseForPage[];
}

export class PageWithCursorGetTeamResponseForPage implements IPageWithCursorGetTeamResponseForPage {
    cursor?: string;
    last?: boolean;
    nextPageCursor?: string;
    size?: number;
    total?: number;
    values?: GetTeamResponseForPage[];

    constructor(data?: IPageWithCursorGetTeamResponseForPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cursor = _data["cursor"];
            this.last = _data["last"];
            this.nextPageCursor = _data["nextPageCursor"];
            this.size = _data["size"];
            this.total = _data["total"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(GetTeamResponseForPage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PageWithCursorGetTeamResponseForPage {
        data = typeof data === 'object' ? data : {};
        let result = new PageWithCursorGetTeamResponseForPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cursor"] = this.cursor;
        data["last"] = this.last;
        data["nextPageCursor"] = this.nextPageCursor;
        data["size"] = this.size;
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPageWithCursorGetTeamResponseForPage {
    cursor?: string;
    last?: boolean;
    nextPageCursor?: string;
    size?: number;
    total?: number;
    values?: GetTeamResponseForPage[];
}

/** A paged list. To access additional details append `[start-index:end-index]` to the expand request. For example, `?expand=sharedUsers[10:40]` returns a list starting at item 10 and finishing at item 40. */
export class PagedListUserDetailsApplicationUser implements IPagedListUserDetailsApplicationUser {
    /** The index of the last item returned on the page. */
    readonly endIndex?: number;
    /** The list of items. */
    readonly items?: UserDetails[];
    /** The maximum number of results that could be on the page. */
    readonly maxResults?: number;
    /** The number of items on the page. */
    readonly size?: number;
    /** The index of the first item returned on the page. */
    readonly startIndex?: number;

    constructor(data?: IPagedListUserDetailsApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).endIndex = _data["end-index"];
            if (Array.isArray(_data["items"])) {
                (<any>this).items = [] as any;
                for (let item of _data["items"])
                    (<any>this).items!.push(UserDetails.fromJS(item));
            }
            (<any>this).maxResults = _data["max-results"];
            (<any>this).size = _data["size"];
            (<any>this).startIndex = _data["start-index"];
        }
    }

    static fromJS(data: any): PagedListUserDetailsApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new PagedListUserDetailsApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["end-index"] = this.endIndex;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["max-results"] = this.maxResults;
        data["size"] = this.size;
        data["start-index"] = this.startIndex;
        return data;
    }
}

/** A paged list. To access additional details append `[start-index:end-index]` to the expand request. For example, `?expand=sharedUsers[10:40]` returns a list starting at item 10 and finishing at item 40. */
export interface IPagedListUserDetailsApplicationUser {
    /** The index of the last item returned on the page. */
    endIndex?: number;
    /** The list of items. */
    items?: UserDetails[];
    /** The maximum number of results that could be on the page. */
    maxResults?: number;
    /** The number of items on the page. */
    size?: number;
    /** The index of the first item returned on the page. */
    startIndex?: number;
}

export class PaginatedResponseComment implements IPaginatedResponseComment {
    maxResults?: number;
    results?: Comment[];
    startAt?: number;
    total?: number;

    constructor(data?: IPaginatedResponseComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResults = _data["maxResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Comment.fromJS(item));
            }
            this.startAt = _data["startAt"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): PaginatedResponseComment {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResults"] = this.maxResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        return data;
    }
}

export interface IPaginatedResponseComment {
    maxResults?: number;
    results?: Comment[];
    startAt?: number;
    total?: number;
}

export class PaginatedResponseFieldCreateMetadata implements IPaginatedResponseFieldCreateMetadata {
    maxResults?: number;
    results?: FieldCreateMetadata[];
    startAt?: number;
    total?: number;

    constructor(data?: IPaginatedResponseFieldCreateMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResults = _data["maxResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(FieldCreateMetadata.fromJS(item));
            }
            this.startAt = _data["startAt"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): PaginatedResponseFieldCreateMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseFieldCreateMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResults"] = this.maxResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        return data;
    }
}

export interface IPaginatedResponseFieldCreateMetadata {
    maxResults?: number;
    results?: FieldCreateMetadata[];
    startAt?: number;
    total?: number;
}

export class PaginatedResponseIssueTypeIssueCreateMetadata implements IPaginatedResponseIssueTypeIssueCreateMetadata {
    maxResults?: number;
    results?: IssueTypeIssueCreateMetadata[];
    startAt?: number;
    total?: number;

    constructor(data?: IPaginatedResponseIssueTypeIssueCreateMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResults = _data["maxResults"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(IssueTypeIssueCreateMetadata.fromJS(item));
            }
            this.startAt = _data["startAt"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): PaginatedResponseIssueTypeIssueCreateMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedResponseIssueTypeIssueCreateMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResults"] = this.maxResults;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        return data;
    }
}

export interface IPaginatedResponseIssueTypeIssueCreateMetadata {
    maxResults?: number;
    results?: IssueTypeIssueCreateMetadata[];
    startAt?: number;
    total?: number;
}

/** A list of parsed JQL queries. */
export class ParsedJqlQueries implements IParsedJqlQueries {
    /** A list of parsed JQL queries. */
    queries!: ParsedJqlQuery[];

    constructor(data?: IParsedJqlQueries) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.queries = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["queries"])) {
                this.queries = [] as any;
                for (let item of _data["queries"])
                    this.queries!.push(ParsedJqlQuery.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParsedJqlQueries {
        data = typeof data === 'object' ? data : {};
        let result = new ParsedJqlQueries();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queries)) {
            data["queries"] = [];
            for (let item of this.queries)
                data["queries"].push(item.toJSON());
        }
        return data;
    }
}

/** A list of parsed JQL queries. */
export interface IParsedJqlQueries {
    /** A list of parsed JQL queries. */
    queries: ParsedJqlQuery[];
}

/** Details of a parsed JQL query. */
export class ParsedJqlQuery implements IParsedJqlQuery {
    /** The list of syntax or validation errors. */
    errors?: string[];
    /** The JQL query that was parsed and validated. */
    query!: string;
    /** The syntax tree of the query. Empty if the query was invalid. */
    structure?: JqlQuery;
    /** The list of warning messages */
    warnings?: string[];

    constructor(data?: IParsedJqlQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.query = _data["query"];
            this.structure = _data["structure"] ? JqlQuery.fromJS(_data["structure"]) : <any>undefined;
            if (Array.isArray(_data["warnings"])) {
                this.warnings = [] as any;
                for (let item of _data["warnings"])
                    this.warnings!.push(item);
            }
        }
    }

    static fromJS(data: any): ParsedJqlQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ParsedJqlQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["query"] = this.query;
        data["structure"] = this.structure ? this.structure.toJSON() : <any>undefined;
        if (Array.isArray(this.warnings)) {
            data["warnings"] = [];
            for (let item of this.warnings)
                data["warnings"].push(item);
        }
        return data;
    }
}

/** Details of a parsed JQL query. */
export interface IParsedJqlQuery {
    /** The list of syntax or validation errors. */
    errors?: string[];
    /** The JQL query that was parsed and validated. */
    query: string;
    /** The syntax tree of the query. Empty if the query was invalid. */
    structure?: JqlQuery;
    /** The list of warning messages */
    warnings?: string[];
}

/** Details for permissions of shareable entities */
export class PermissionDetails implements IPermissionDetails {
    /** The edit permissions for the shareable entities. */
    editPermissions!: SharePermission[];
    /** The share permissions for the shareable entities. */
    sharePermissions!: SharePermission[];

    constructor(data?: IPermissionDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.editPermissions = [];
            this.sharePermissions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["editPermissions"])) {
                this.editPermissions = [] as any;
                for (let item of _data["editPermissions"])
                    this.editPermissions!.push(SharePermission.fromJS(item));
            }
            if (Array.isArray(_data["sharePermissions"])) {
                this.sharePermissions = [] as any;
                for (let item of _data["sharePermissions"])
                    this.sharePermissions!.push(SharePermission.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDetails {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.editPermissions)) {
            data["editPermissions"] = [];
            for (let item of this.editPermissions)
                data["editPermissions"].push(item.toJSON());
        }
        if (Array.isArray(this.sharePermissions)) {
            data["sharePermissions"] = [];
            for (let item of this.sharePermissions)
                data["sharePermissions"].push(item.toJSON());
        }
        return data;
    }
}

/** Details for permissions of shareable entities */
export interface IPermissionDetails {
    /** The edit permissions for the shareable entities. */
    editPermissions: SharePermission[];
    /** The share permissions for the shareable entities. */
    sharePermissions: SharePermission[];
}

/** Details about a permission granted to a user or group. */
export class PermissionGrant implements IPermissionGrant {
    /** The user or group being granted the permission. It consists of a `type`, a type-dependent `parameter` and a type-dependent `value`. See [Holder object](../api-group-permission-schemes/#holder-object) in *Get all permission schemes* for more information. */
    holder?: PermissionHolder;
    /** The ID of the permission granted details. */
    readonly id?: number;
    /** The permission to grant. This permission can be one of the built-in permissions or a custom permission added by an app. See [Built-in permissions](../api-group-permission-schemes/#built-in-permissions) in *Get all permission schemes* for more information about the built-in permissions. See the [project permission](https://developer.atlassian.com/cloud/jira/platform/modules/project-permission/) and [global permission](https://developer.atlassian.com/cloud/jira/platform/modules/global-permission/) module documentation for more information about custom permissions. */
    permission?: string;
    /** The URL of the permission granted details. */
    readonly self?: string;

    [key: string]: any;

    constructor(data?: IPermissionGrant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.holder = _data["holder"] ? PermissionHolder.fromJS(_data["holder"]) : <any>undefined;
            (<any>this).id = _data["id"];
            this.permission = _data["permission"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): PermissionGrant {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGrant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["holder"] = this.holder ? this.holder.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["permission"] = this.permission;
        data["self"] = this.self;
        return data;
    }
}

/** Details about a permission granted to a user or group. */
export interface IPermissionGrant {
    /** The user or group being granted the permission. It consists of a `type`, a type-dependent `parameter` and a type-dependent `value`. See [Holder object](../api-group-permission-schemes/#holder-object) in *Get all permission schemes* for more information. */
    holder?: PermissionHolder;
    /** The ID of the permission granted details. */
    id?: number;
    /** The permission to grant. This permission can be one of the built-in permissions or a custom permission added by an app. See [Built-in permissions](../api-group-permission-schemes/#built-in-permissions) in *Get all permission schemes* for more information about the built-in permissions. See the [project permission](https://developer.atlassian.com/cloud/jira/platform/modules/project-permission/) and [global permission](https://developer.atlassian.com/cloud/jira/platform/modules/global-permission/) module documentation for more information about custom permissions. */
    permission?: string;
    /** The URL of the permission granted details. */
    self?: string;

    [key: string]: any;
}

/** List of permission grants */
export class PermissionGrantDTO implements IPermissionGrantDTO {
    applicationAccess?: string[];
    groupCustomFields?: ProjectCreateResourceIdentifier[];
    groups?: ProjectCreateResourceIdentifier[];
    permissionKeys?: string[];
    projectRoles?: ProjectCreateResourceIdentifier[];
    specialGrants?: string[];
    userCustomFields?: ProjectCreateResourceIdentifier[];
    users?: ProjectCreateResourceIdentifier[];

    constructor(data?: IPermissionGrantDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["applicationAccess"])) {
                this.applicationAccess = [] as any;
                for (let item of _data["applicationAccess"])
                    this.applicationAccess!.push(item);
            }
            if (Array.isArray(_data["groupCustomFields"])) {
                this.groupCustomFields = [] as any;
                for (let item of _data["groupCustomFields"])
                    this.groupCustomFields!.push(ProjectCreateResourceIdentifier.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(ProjectCreateResourceIdentifier.fromJS(item));
            }
            if (Array.isArray(_data["permissionKeys"])) {
                this.permissionKeys = [] as any;
                for (let item of _data["permissionKeys"])
                    this.permissionKeys!.push(item);
            }
            if (Array.isArray(_data["projectRoles"])) {
                this.projectRoles = [] as any;
                for (let item of _data["projectRoles"])
                    this.projectRoles!.push(ProjectCreateResourceIdentifier.fromJS(item));
            }
            if (Array.isArray(_data["specialGrants"])) {
                this.specialGrants = [] as any;
                for (let item of _data["specialGrants"])
                    this.specialGrants!.push(item);
            }
            if (Array.isArray(_data["userCustomFields"])) {
                this.userCustomFields = [] as any;
                for (let item of _data["userCustomFields"])
                    this.userCustomFields!.push(ProjectCreateResourceIdentifier.fromJS(item));
            }
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(ProjectCreateResourceIdentifier.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionGrantDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGrantDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.applicationAccess)) {
            data["applicationAccess"] = [];
            for (let item of this.applicationAccess)
                data["applicationAccess"].push(item);
        }
        if (Array.isArray(this.groupCustomFields)) {
            data["groupCustomFields"] = [];
            for (let item of this.groupCustomFields)
                data["groupCustomFields"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item.toJSON());
        }
        if (Array.isArray(this.permissionKeys)) {
            data["permissionKeys"] = [];
            for (let item of this.permissionKeys)
                data["permissionKeys"].push(item);
        }
        if (Array.isArray(this.projectRoles)) {
            data["projectRoles"] = [];
            for (let item of this.projectRoles)
                data["projectRoles"].push(item.toJSON());
        }
        if (Array.isArray(this.specialGrants)) {
            data["specialGrants"] = [];
            for (let item of this.specialGrants)
                data["specialGrants"].push(item);
        }
        if (Array.isArray(this.userCustomFields)) {
            data["userCustomFields"] = [];
            for (let item of this.userCustomFields)
                data["userCustomFields"].push(item.toJSON());
        }
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

/** List of permission grants */
export interface IPermissionGrantDTO {
    applicationAccess?: string[];
    groupCustomFields?: ProjectCreateResourceIdentifier[];
    groups?: ProjectCreateResourceIdentifier[];
    permissionKeys?: string[];
    projectRoles?: ProjectCreateResourceIdentifier[];
    specialGrants?: string[];
    userCustomFields?: ProjectCreateResourceIdentifier[];
    users?: ProjectCreateResourceIdentifier[];
}

/** List of permission grants. */
export class PermissionGrants implements IPermissionGrants {
    /** Expand options that include additional permission grant details in the response. */
    readonly expand?: string;
    /** Permission grants list. */
    readonly permissions?: PermissionGrant[];

    constructor(data?: IPermissionGrants) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).expand = _data["expand"];
            if (Array.isArray(_data["permissions"])) {
                (<any>this).permissions = [] as any;
                for (let item of _data["permissions"])
                    (<any>this).permissions!.push(PermissionGrant.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionGrants {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGrants();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expand"] = this.expand;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

/** List of permission grants. */
export interface IPermissionGrants {
    /** Expand options that include additional permission grant details in the response. */
    expand?: string;
    /** Permission grants list. */
    permissions?: PermissionGrant[];
}

/** Details of a user, group, field, or project role that holds a permission. See [Holder object](../api-group-permission-schemes/#holder-object) in *Get all permission schemes* for more information. */
export class PermissionHolder implements IPermissionHolder {
    /** Expand options that include additional permission holder details in the response. */
    readonly expand?: string;
    /** As a group's name can change, use of `value` is recommended. The identifier associated withthe `type` value that defines the holder of the permission. */
    parameter?: string;
    /** The type of permission holder. */
    type!: string;
    /** The identifier associated with the `type` value that defines the holder of the permission. */
    value?: string;

    constructor(data?: IPermissionHolder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).expand = _data["expand"];
            this.parameter = _data["parameter"];
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PermissionHolder {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionHolder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expand"] = this.expand;
        data["parameter"] = this.parameter;
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

/** Details of a user, group, field, or project role that holds a permission. See [Holder object](../api-group-permission-schemes/#holder-object) in *Get all permission schemes* for more information. */
export interface IPermissionHolder {
    /** Expand options that include additional permission holder details in the response. */
    expand?: string;
    /** As a group's name can change, use of `value` is recommended. The identifier associated withthe `type` value that defines the holder of the permission. */
    parameter?: string;
    /** The type of permission holder. */
    type: string;
    /** The identifier associated with the `type` value that defines the holder of the permission. */
    value?: string;
}

/** The payload to create a permission scheme */
export class PermissionPayloadDTO implements IPermissionPayloadDTO {
    /** Configuration to generate addon role. Default is false if null */
    addAddonRole?: boolean;
    /** The description of the permission scheme */
    description?: string;
    /** List of permission grants */
    grants?: PermissionGrantDTO[];
    /** The name of the permission scheme */
    name?: string;
    /** The strategy to use when there is a conflict with an existing permission scheme. FAIL - Fail execution, this always needs to be unique; USE - Use the existing entity and ignore new entity parameters; NEW - If the entity exist, try and create a new one with a different name */
    onConflict?: PermissionPayloadDTOOnConflict;
    pcri?: ProjectCreateResourceIdentifier;

    constructor(data?: IPermissionPayloadDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.onConflict = PermissionPayloadDTOOnConflict.NEW;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addAddonRole = _data["addAddonRole"];
            this.description = _data["description"];
            if (Array.isArray(_data["grants"])) {
                this.grants = [] as any;
                for (let item of _data["grants"])
                    this.grants!.push(PermissionGrantDTO.fromJS(item));
            }
            this.name = _data["name"];
            this.onConflict = _data["onConflict"] !== undefined ? _data["onConflict"] : PermissionPayloadDTOOnConflict.NEW;
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PermissionPayloadDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionPayloadDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addAddonRole"] = this.addAddonRole;
        data["description"] = this.description;
        if (Array.isArray(this.grants)) {
            data["grants"] = [];
            for (let item of this.grants)
                data["grants"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["onConflict"] = this.onConflict;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        return data;
    }
}

/** The payload to create a permission scheme */
export interface IPermissionPayloadDTO {
    /** Configuration to generate addon role. Default is false if null */
    addAddonRole?: boolean;
    /** The description of the permission scheme */
    description?: string;
    /** List of permission grants */
    grants?: PermissionGrantDTO[];
    /** The name of the permission scheme */
    name?: string;
    /** The strategy to use when there is a conflict with an existing permission scheme. FAIL - Fail execution, this always needs to be unique; USE - Use the existing entity and ignore new entity parameters; NEW - If the entity exist, try and create a new one with a different name */
    onConflict?: PermissionPayloadDTOOnConflict;
    pcri?: ProjectCreateResourceIdentifier;
}

/** Details of a permission scheme. */
export class PermissionScheme implements IPermissionScheme {
    /** A description for the permission scheme. */
    description?: string;
    /** The expand options available for the permission scheme. */
    readonly expand?: string;
    /** The ID of the permission scheme. */
    readonly id?: number;
    /** The name of the permission scheme. Must be unique. */
    name!: string;
    /** The permission scheme to create or update. See [About permission schemes and grants](../api-group-permission-schemes/#about-permission-schemes-and-grants) for more information. */
    permissions?: PermissionGrant[];
    /** The scope of the permission scheme. */
    scope?: Scope;
    /** The URL of the permission scheme. */
    readonly self?: string;

    [key: string]: any;

    constructor(data?: IPermissionScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            (<any>this).expand = _data["expand"];
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionGrant.fromJS(item));
            }
            this.scope = _data["scope"] ? Scope.fromJS(_data["scope"]) : <any>undefined;
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): PermissionScheme {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["expand"] = this.expand;
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        data["self"] = this.self;
        return data;
    }
}

/** Details of a permission scheme. */
export interface IPermissionScheme {
    /** A description for the permission scheme. */
    description?: string;
    /** The expand options available for the permission scheme. */
    expand?: string;
    /** The ID of the permission scheme. */
    id?: number;
    /** The name of the permission scheme. Must be unique. */
    name: string;
    /** The permission scheme to create or update. See [About permission schemes and grants](../api-group-permission-schemes/#about-permission-schemes-and-grants) for more information. */
    permissions?: PermissionGrant[];
    /** The scope of the permission scheme. */
    scope?: Scope;
    /** The URL of the permission scheme. */
    self?: string;

    [key: string]: any;
}

/** List of all permission schemes. */
export class PermissionSchemes implements IPermissionSchemes {
    /** Permission schemes list. */
    readonly permissionSchemes?: PermissionScheme[];

    constructor(data?: IPermissionSchemes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissionSchemes"])) {
                (<any>this).permissionSchemes = [] as any;
                for (let item of _data["permissionSchemes"])
                    (<any>this).permissionSchemes!.push(PermissionScheme.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionSchemes {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionSchemes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissionSchemes)) {
            data["permissionSchemes"] = [];
            for (let item of this.permissionSchemes)
                data["permissionSchemes"].push(item.toJSON());
        }
        return data;
    }
}

/** List of all permission schemes. */
export interface IPermissionSchemes {
    /** Permission schemes list. */
    permissionSchemes?: PermissionScheme[];
}

/** Details about permissions. */
export class Permissions implements IPermissions {
    /** List of permissions. */
    readonly permissions?: { [key: string]: UserPermission; };

    constructor(data?: IPermissions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["permissions"]) {
                (<any>this).permissions = {} as any;
                for (let key in _data["permissions"]) {
                    if (_data["permissions"].hasOwnProperty(key))
                        (<any>(<any>this).permissions)![key] = _data["permissions"][key] ? UserPermission.fromJS(_data["permissions"][key]) : new UserPermission();
                }
            }
        }
    }

    static fromJS(data: any): Permissions {
        data = typeof data === 'object' ? data : {};
        let result = new Permissions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions) {
            data["permissions"] = {};
            for (let key in this.permissions) {
                if (this.permissions.hasOwnProperty(key))
                    (<any>data["permissions"])[key] = this.permissions[key] ? this.permissions[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Details about permissions. */
export interface IPermissions {
    /** List of permissions. */
    permissions?: { [key: string]: UserPermission; };
}

export class PermissionsKeysBean implements IPermissionsKeysBean {
    /** A list of permission keys. */
    permissions!: string[];

    constructor(data?: IPermissionsKeysBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.permissions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionsKeysBean {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionsKeysBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data;
    }
}

export interface IPermissionsKeysBean {
    /** A list of permission keys. */
    permissions: string[];
}

/** A list of projects in which a user is granted permissions. */
export class PermittedProjects implements IPermittedProjects {
    /** A list of projects. */
    readonly projects?: ProjectIdentifierBean[];

    constructor(data?: IPermittedProjects) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["projects"])) {
                (<any>this).projects = [] as any;
                for (let item of _data["projects"])
                    (<any>this).projects!.push(ProjectIdentifierBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermittedProjects {
        data = typeof data === 'object' ? data : {};
        let result = new PermittedProjects();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item.toJSON());
        }
        return data;
    }
}

/** A list of projects in which a user is granted permissions. */
export interface IPermittedProjects {
    /** A list of projects. */
    projects?: ProjectIdentifierBean[];
}

/** An issue priority. */
export class Priority implements IPriority {
    /** The avatarId of the avatar for the issue priority. This parameter is nullable and when set, this avatar references the universal avatar APIs. */
    avatarId?: number;
    /** The description of the issue priority. */
    description?: string;
    /** The URL of the icon for the issue priority. */
    iconUrl?: string;
    /** The ID of the issue priority. */
    id?: string;
    /** Whether this priority is the default. */
    isDefault?: boolean;
    /** The name of the issue priority. */
    name?: string;
    /** Priority schemes associated with the issue priority. */
    schemes?: ExpandPrioritySchemePage;
    /** The URL of the issue priority. */
    self?: string;
    /** The color used to indicate the issue priority. */
    statusColor?: string;

    [key: string]: any;

    constructor(data?: IPriority) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.avatarId = _data["avatarId"];
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
            this.id = _data["id"];
            this.isDefault = _data["isDefault"];
            this.name = _data["name"];
            this.schemes = _data["schemes"] ? ExpandPrioritySchemePage.fromJS(_data["schemes"]) : <any>undefined;
            this.self = _data["self"];
            this.statusColor = _data["statusColor"];
        }
    }

    static fromJS(data: any): Priority {
        data = typeof data === 'object' ? data : {};
        let result = new Priority();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["avatarId"] = this.avatarId;
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        data["id"] = this.id;
        data["isDefault"] = this.isDefault;
        data["name"] = this.name;
        data["schemes"] = this.schemes ? this.schemes.toJSON() : <any>undefined;
        data["self"] = this.self;
        data["statusColor"] = this.statusColor;
        return data;
    }
}

/** An issue priority. */
export interface IPriority {
    /** The avatarId of the avatar for the issue priority. This parameter is nullable and when set, this avatar references the universal avatar APIs. */
    avatarId?: number;
    /** The description of the issue priority. */
    description?: string;
    /** The URL of the icon for the issue priority. */
    iconUrl?: string;
    /** The ID of the issue priority. */
    id?: string;
    /** Whether this priority is the default. */
    isDefault?: boolean;
    /** The name of the issue priority. */
    name?: string;
    /** Priority schemes associated with the issue priority. */
    schemes?: ExpandPrioritySchemePage;
    /** The URL of the issue priority. */
    self?: string;
    /** The color used to indicate the issue priority. */
    statusColor?: string;

    [key: string]: any;
}

/** The ID of an issue priority. */
export class PriorityId implements IPriorityId {
    /** The ID of the issue priority. */
    readonly id!: string;

    [key: string]: any;

    constructor(data?: IPriorityId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).id = _data["id"];
        }
    }

    static fromJS(data: any): PriorityId {
        data = typeof data === 'object' ? data : {};
        let result = new PriorityId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }
}

/** The ID of an issue priority. */
export interface IPriorityId {
    /** The ID of the issue priority. */
    id: string;

    [key: string]: any;
}

/** Mapping of issue priorities for changes in priority schemes. */
export class PriorityMapping implements IPriorityMapping {
    /** The mapping of priorities for issues being migrated **into** this priority scheme. Key is the old priority ID, value is the new priority ID (must exist in this priority scheme).

E.g. The current priority scheme has priority ID `10001`. Issues with priority ID `10000` are being migrated into this priority scheme will need mapping to new priorities. The `in` mapping would be `{"10000": 10001}`. */
    in?: { [key: string]: number; };
    /** The mapping of priorities for issues being migrated **out of** this priority scheme. Key is the old priority ID (must exist in this priority scheme), value is the new priority ID (must exist in the default priority scheme). Required for updating an existing priority scheme. Not used when creating a new priority scheme.

E.g. The current priority scheme has priority ID `10001`. Issues with priority ID `10001` are being migrated out of this priority scheme will need mapping to new priorities. The `out` mapping would be `{"10001": 10000}`. */
    out?: { [key: string]: number; };

    constructor(data?: IPriorityMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["in"]) {
                this.in = {} as any;
                for (let key in _data["in"]) {
                    if (_data["in"].hasOwnProperty(key))
                        (<any>this.in)![key] = _data["in"][key];
                }
            }
            if (_data["out"]) {
                this.out = {} as any;
                for (let key in _data["out"]) {
                    if (_data["out"].hasOwnProperty(key))
                        (<any>this.out)![key] = _data["out"][key];
                }
            }
        }
    }

    static fromJS(data: any): PriorityMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PriorityMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.in) {
            data["in"] = {};
            for (let key in this.in) {
                if (this.in.hasOwnProperty(key))
                    (<any>data["in"])[key] = (<any>this.in)[key];
            }
        }
        if (this.out) {
            data["out"] = {};
            for (let key in this.out) {
                if (this.out.hasOwnProperty(key))
                    (<any>data["out"])[key] = (<any>this.out)[key];
            }
        }
        return data;
    }
}

/** Mapping of issue priorities for changes in priority schemes. */
export interface IPriorityMapping {
    /** The mapping of priorities for issues being migrated **into** this priority scheme. Key is the old priority ID, value is the new priority ID (must exist in this priority scheme).

E.g. The current priority scheme has priority ID `10001`. Issues with priority ID `10000` are being migrated into this priority scheme will need mapping to new priorities. The `in` mapping would be `{"10000": 10001}`. */
    in?: { [key: string]: number; };
    /** The mapping of priorities for issues being migrated **out of** this priority scheme. Key is the old priority ID (must exist in this priority scheme), value is the new priority ID (must exist in the default priority scheme). Required for updating an existing priority scheme. Not used when creating a new priority scheme.

E.g. The current priority scheme has priority ID `10001`. Issues with priority ID `10001` are being migrated out of this priority scheme will need mapping to new priorities. The `out` mapping would be `{"10001": 10000}`. */
    out?: { [key: string]: number; };
}

export class PrioritySchemeChangesWithoutMappings implements IPrioritySchemeChangesWithoutMappings {
    /** Affected entity ids. */
    ids!: number[];

    constructor(data?: IPrioritySchemeChangesWithoutMappings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): PrioritySchemeChangesWithoutMappings {
        data = typeof data === 'object' ? data : {};
        let result = new PrioritySchemeChangesWithoutMappings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }
}

export interface IPrioritySchemeChangesWithoutMappings {
    /** Affected entity ids. */
    ids: number[];
}

/** The ID of a priority scheme. */
export class PrioritySchemeId implements IPrioritySchemeId {
    /** The ID of the priority scheme. */
    readonly id?: string;
    /** The in-progress issue migration task. */
    readonly task?: TaskProgressBeanJsonNode;

    constructor(data?: IPrioritySchemeId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).task = _data["task"] ? TaskProgressBeanJsonNode.fromJS(_data["task"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PrioritySchemeId {
        data = typeof data === 'object' ? data : {};
        let result = new PrioritySchemeId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["task"] = this.task ? this.task.toJSON() : <any>undefined;
        return data;
    }
}

/** The ID of a priority scheme. */
export interface IPrioritySchemeId {
    /** The ID of the priority scheme. */
    id?: string;
    /** The in-progress issue migration task. */
    task?: TaskProgressBeanJsonNode;
}

/** A priority scheme with paginated priorities and projects. */
export class PrioritySchemeWithPaginatedPrioritiesAndProjects implements IPrioritySchemeWithPaginatedPrioritiesAndProjects {
    default?: boolean;
    /** The ID of the default issue priority. */
    defaultPriorityId?: string;
    /** The description of the priority scheme */
    description?: string;
    /** The ID of the priority scheme. */
    id!: string;
    isDefault?: boolean;
    /** The name of the priority scheme */
    name!: string;
    /** The paginated list of priorities. */
    priorities?: PageBeanPriorityWithSequence;
    /** The paginated list of projects. */
    projects?: PageBeanProjectDetails;
    /** The URL of the priority scheme. */
    self?: string;

    [key: string]: any;

    constructor(data?: IPrioritySchemeWithPaginatedPrioritiesAndProjects) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.default = _data["default"];
            this.defaultPriorityId = _data["defaultPriorityId"];
            this.description = _data["description"];
            this.id = _data["id"];
            this.isDefault = _data["isDefault"];
            this.name = _data["name"];
            this.priorities = _data["priorities"] ? PageBeanPriorityWithSequence.fromJS(_data["priorities"]) : <any>undefined;
            this.projects = _data["projects"] ? PageBeanProjectDetails.fromJS(_data["projects"]) : <any>undefined;
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): PrioritySchemeWithPaginatedPrioritiesAndProjects {
        data = typeof data === 'object' ? data : {};
        let result = new PrioritySchemeWithPaginatedPrioritiesAndProjects();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["default"] = this.default;
        data["defaultPriorityId"] = this.defaultPriorityId;
        data["description"] = this.description;
        data["id"] = this.id;
        data["isDefault"] = this.isDefault;
        data["name"] = this.name;
        data["priorities"] = this.priorities ? this.priorities.toJSON() : <any>undefined;
        data["projects"] = this.projects ? this.projects.toJSON() : <any>undefined;
        data["self"] = this.self;
        return data;
    }
}

/** A priority scheme with paginated priorities and projects. */
export interface IPrioritySchemeWithPaginatedPrioritiesAndProjects {
    default?: boolean;
    /** The ID of the default issue priority. */
    defaultPriorityId?: string;
    /** The description of the priority scheme */
    description?: string;
    /** The ID of the priority scheme. */
    id: string;
    isDefault?: boolean;
    /** The name of the priority scheme */
    name: string;
    /** The paginated list of priorities. */
    priorities?: PageBeanPriorityWithSequence;
    /** The paginated list of projects. */
    projects?: PageBeanProjectDetails;
    /** The URL of the priority scheme. */
    self?: string;

    [key: string]: any;
}

/** An issue priority with sequence information. */
export class PriorityWithSequence implements IPriorityWithSequence {
    /** The description of the issue priority. */
    description?: string;
    /** The URL of the icon for the issue priority. */
    iconUrl?: string;
    /** The ID of the issue priority. */
    id?: string;
    /** Whether this priority is the default. */
    isDefault?: boolean;
    /** The name of the issue priority. */
    name?: string;
    /** The URL of the issue priority. */
    self?: string;
    /** The sequence of the issue priority. */
    sequence?: string;
    /** The color used to indicate the issue priority. */
    statusColor?: string;

    constructor(data?: IPriorityWithSequence) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
            this.id = _data["id"];
            this.isDefault = _data["isDefault"];
            this.name = _data["name"];
            this.self = _data["self"];
            this.sequence = _data["sequence"];
            this.statusColor = _data["statusColor"];
        }
    }

    static fromJS(data: any): PriorityWithSequence {
        data = typeof data === 'object' ? data : {};
        let result = new PriorityWithSequence();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        data["id"] = this.id;
        data["isDefault"] = this.isDefault;
        data["name"] = this.name;
        data["self"] = this.self;
        data["sequence"] = this.sequence;
        data["statusColor"] = this.statusColor;
        return data;
    }
}

/** An issue priority with sequence information. */
export interface IPriorityWithSequence {
    /** The description of the issue priority. */
    description?: string;
    /** The URL of the icon for the issue priority. */
    iconUrl?: string;
    /** The ID of the issue priority. */
    id?: string;
    /** Whether this priority is the default. */
    isDefault?: boolean;
    /** The name of the issue priority. */
    name?: string;
    /** The URL of the issue priority. */
    self?: string;
    /** The sequence of the issue priority. */
    sequence?: string;
    /** The color used to indicate the issue priority. */
    statusColor?: string;
}

/** Details about a project. */
export class Project implements IProject {
    /** Whether the project is archived. */
    readonly archived?: boolean;
    /** The user who archived the project. */
    readonly archivedBy?: User;
    /** The date when the project was archived. */
    readonly archivedDate?: Date;
    /** The default assignee when creating issues for this project. */
    readonly assigneeType?: ProjectAssigneeType;
    /** The URLs of the project's avatars. */
    readonly avatarUrls?: AvatarUrlsBean;
    /** List of the components contained in the project. */
    readonly components?: ProjectComponent[];
    /** Whether the project is marked as deleted. */
    readonly deleted?: boolean;
    /** The user who marked the project as deleted. */
    readonly deletedBy?: User;
    /** The date when the project was marked as deleted. */
    readonly deletedDate?: Date;
    /** A brief description of the project. */
    readonly description?: string;
    /** An email address associated with the project. */
    email?: string;
    /** Expand options that include additional project details in the response. */
    readonly expand?: string;
    /** Whether the project is selected as a favorite. */
    favourite?: boolean;
    /** The ID of the project. */
    id?: string;
    /** Insights about the project. */
    readonly insight?: ProjectInsight;
    /** Whether the project is private from the user's perspective. This means the user can't see the project or any associated issues. */
    readonly isPrivate?: boolean;
    /** The issue type hierarchy for the project. */
    readonly issueTypeHierarchy?: Hierarchy;
    /** List of the issue types available in the project. */
    readonly issueTypes?: IssueTypeDetails[];
    /** The key of the project. */
    readonly key?: string;
    /** The project landing page info. */
    readonly landingPageInfo?: ProjectLandingPageInfo;
    /** The username of the project lead. */
    readonly lead?: User;
    /** The name of the project. */
    readonly name?: string;
    /** User permissions on the project */
    readonly permissions?: ProjectPermissions;
    /** The category the project belongs to. */
    readonly projectCategory?: ProjectCategory;
    /** The [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes) of the project. */
    readonly projectTypeKey?: projectTypeKey;
    /** Map of project properties */
    readonly properties?: { [key: string]: any; };
    /** The date when the project is deleted permanently. */
    readonly retentionTillDate?: Date;
    /** The name and self URL for each role defined in the project. For more information, see [Create project role](#api-rest-api-3-role-post). */
    readonly roles?: { [key: string]: string; };
    /** The URL of the project details. */
    readonly self?: string;
    /** Whether the project is simplified. */
    readonly simplified?: boolean;
    /** The type of the project. */
    readonly style?: ProjectStyle;
    /** A link to information about this project, such as project documentation. */
    readonly url?: string;
    /** Unique ID for next-gen projects. */
    readonly uuid?: string;
    /** The versions defined in the project. For more information, see [Create version](#api-rest-api-3-version-post). */
    readonly versions?: Version[];

    constructor(data?: IProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).archived = _data["archived"];
            (<any>this).archivedBy = _data["archivedBy"] ? User.fromJS(_data["archivedBy"]) : <any>undefined;
            (<any>this).archivedDate = _data["archivedDate"] ? new Date(_data["archivedDate"].toString()) : <any>undefined;
            (<any>this).assigneeType = _data["assigneeType"];
            (<any>this).avatarUrls = _data["avatarUrls"] ? AvatarUrlsBean.fromJS(_data["avatarUrls"]) : <any>undefined;
            if (Array.isArray(_data["components"])) {
                (<any>this).components = [] as any;
                for (let item of _data["components"])
                    (<any>this).components!.push(ProjectComponent.fromJS(item));
            }
            (<any>this).deleted = _data["deleted"];
            (<any>this).deletedBy = _data["deletedBy"] ? User.fromJS(_data["deletedBy"]) : <any>undefined;
            (<any>this).deletedDate = _data["deletedDate"] ? new Date(_data["deletedDate"].toString()) : <any>undefined;
            (<any>this).description = _data["description"];
            this.email = _data["email"];
            (<any>this).expand = _data["expand"];
            this.favourite = _data["favourite"];
            this.id = _data["id"];
            (<any>this).insight = _data["insight"] ? ProjectInsight.fromJS(_data["insight"]) : <any>undefined;
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).issueTypeHierarchy = _data["issueTypeHierarchy"] ? Hierarchy.fromJS(_data["issueTypeHierarchy"]) : <any>undefined;
            if (Array.isArray(_data["issueTypes"])) {
                (<any>this).issueTypes = [] as any;
                for (let item of _data["issueTypes"])
                    (<any>this).issueTypes!.push(IssueTypeDetails.fromJS(item));
            }
            (<any>this).key = _data["key"];
            (<any>this).landingPageInfo = _data["landingPageInfo"] ? ProjectLandingPageInfo.fromJS(_data["landingPageInfo"]) : <any>undefined;
            (<any>this).lead = _data["lead"] ? User.fromJS(_data["lead"]) : <any>undefined;
            (<any>this).name = _data["name"];
            (<any>this).permissions = _data["permissions"] ? ProjectPermissions.fromJS(_data["permissions"]) : <any>undefined;
            (<any>this).projectCategory = _data["projectCategory"] ? ProjectCategory.fromJS(_data["projectCategory"]) : <any>undefined;
            (<any>this).projectTypeKey = _data["projectTypeKey"];
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key];
                }
            }
            (<any>this).retentionTillDate = _data["retentionTillDate"] ? new Date(_data["retentionTillDate"].toString()) : <any>undefined;
            if (_data["roles"]) {
                (<any>this).roles = {} as any;
                for (let key in _data["roles"]) {
                    if (_data["roles"].hasOwnProperty(key))
                        (<any>(<any>this).roles)![key] = _data["roles"][key];
                }
            }
            (<any>this).self = _data["self"];
            (<any>this).simplified = _data["simplified"];
            (<any>this).style = _data["style"];
            (<any>this).url = _data["url"];
            (<any>this).uuid = _data["uuid"];
            if (Array.isArray(_data["versions"])) {
                (<any>this).versions = [] as any;
                for (let item of _data["versions"])
                    (<any>this).versions!.push(Version.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Project {
        data = typeof data === 'object' ? data : {};
        let result = new Project();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["archived"] = this.archived;
        data["archivedBy"] = this.archivedBy ? this.archivedBy.toJSON() : <any>undefined;
        data["archivedDate"] = this.archivedDate ? this.archivedDate.toISOString() : <any>undefined;
        data["assigneeType"] = this.assigneeType;
        data["avatarUrls"] = this.avatarUrls ? this.avatarUrls.toJSON() : <any>undefined;
        if (Array.isArray(this.components)) {
            data["components"] = [];
            for (let item of this.components)
                data["components"].push(item.toJSON());
        }
        data["deleted"] = this.deleted;
        data["deletedBy"] = this.deletedBy ? this.deletedBy.toJSON() : <any>undefined;
        data["deletedDate"] = this.deletedDate ? this.deletedDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["email"] = this.email;
        data["expand"] = this.expand;
        data["favourite"] = this.favourite;
        data["id"] = this.id;
        data["insight"] = this.insight ? this.insight.toJSON() : <any>undefined;
        data["isPrivate"] = this.isPrivate;
        data["issueTypeHierarchy"] = this.issueTypeHierarchy ? this.issueTypeHierarchy.toJSON() : <any>undefined;
        if (Array.isArray(this.issueTypes)) {
            data["issueTypes"] = [];
            for (let item of this.issueTypes)
                data["issueTypes"].push(item.toJSON());
        }
        data["key"] = this.key;
        data["landingPageInfo"] = this.landingPageInfo ? this.landingPageInfo.toJSON() : <any>undefined;
        data["lead"] = this.lead ? this.lead.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["permissions"] = this.permissions ? this.permissions.toJSON() : <any>undefined;
        data["projectCategory"] = this.projectCategory ? this.projectCategory.toJSON() : <any>undefined;
        data["projectTypeKey"] = this.projectTypeKey;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["retentionTillDate"] = this.retentionTillDate ? this.retentionTillDate.toISOString() : <any>undefined;
        if (this.roles) {
            data["roles"] = {};
            for (let key in this.roles) {
                if (this.roles.hasOwnProperty(key))
                    (<any>data["roles"])[key] = (<any>this.roles)[key];
            }
        }
        data["self"] = this.self;
        data["simplified"] = this.simplified;
        data["style"] = this.style;
        data["url"] = this.url;
        data["uuid"] = this.uuid;
        if (Array.isArray(this.versions)) {
            data["versions"] = [];
            for (let item of this.versions)
                data["versions"].push(item.toJSON());
        }
        return data;
    }
}

/** Details about a project. */
export interface IProject {
    /** Whether the project is archived. */
    archived?: boolean;
    /** The user who archived the project. */
    archivedBy?: User;
    /** The date when the project was archived. */
    archivedDate?: Date;
    /** The default assignee when creating issues for this project. */
    assigneeType?: ProjectAssigneeType;
    /** The URLs of the project's avatars. */
    avatarUrls?: AvatarUrlsBean;
    /** List of the components contained in the project. */
    components?: ProjectComponent[];
    /** Whether the project is marked as deleted. */
    deleted?: boolean;
    /** The user who marked the project as deleted. */
    deletedBy?: User;
    /** The date when the project was marked as deleted. */
    deletedDate?: Date;
    /** A brief description of the project. */
    description?: string;
    /** An email address associated with the project. */
    email?: string;
    /** Expand options that include additional project details in the response. */
    expand?: string;
    /** Whether the project is selected as a favorite. */
    favourite?: boolean;
    /** The ID of the project. */
    id?: string;
    /** Insights about the project. */
    insight?: ProjectInsight;
    /** Whether the project is private from the user's perspective. This means the user can't see the project or any associated issues. */
    isPrivate?: boolean;
    /** The issue type hierarchy for the project. */
    issueTypeHierarchy?: Hierarchy;
    /** List of the issue types available in the project. */
    issueTypes?: IssueTypeDetails[];
    /** The key of the project. */
    key?: string;
    /** The project landing page info. */
    landingPageInfo?: ProjectLandingPageInfo;
    /** The username of the project lead. */
    lead?: User;
    /** The name of the project. */
    name?: string;
    /** User permissions on the project */
    permissions?: ProjectPermissions;
    /** The category the project belongs to. */
    projectCategory?: ProjectCategory;
    /** The [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes) of the project. */
    projectTypeKey?: projectTypeKey;
    /** Map of project properties */
    properties?: { [key: string]: any; };
    /** The date when the project is deleted permanently. */
    retentionTillDate?: Date;
    /** The name and self URL for each role defined in the project. For more information, see [Create project role](#api-rest-api-3-role-post). */
    roles?: { [key: string]: string; };
    /** The URL of the project details. */
    self?: string;
    /** Whether the project is simplified. */
    simplified?: boolean;
    /** The type of the project. */
    style?: ProjectStyle;
    /** A link to information about this project, such as project documentation. */
    url?: string;
    /** Unique ID for next-gen projects. */
    uuid?: string;
    /** The versions defined in the project. For more information, see [Create version](#api-rest-api-3-version-post). */
    versions?: Version[];
}

/** A project and issueType ID pair that identifies a status mapping. */
export class ProjectAndIssueTypePair implements IProjectAndIssueTypePair {
    /** The ID of the issue type. */
    issueTypeId!: string;
    /** The ID of the project. */
    projectId!: string;

    constructor(data?: IProjectAndIssueTypePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueTypeId = _data["issueTypeId"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): ProjectAndIssueTypePair {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectAndIssueTypePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueTypeId"] = this.issueTypeId;
        data["projectId"] = this.projectId;
        return data;
    }
}

/** A project and issueType ID pair that identifies a status mapping. */
export interface IProjectAndIssueTypePair {
    /** The ID of the issue type. */
    issueTypeId: string;
    /** The ID of the project. */
    projectId: string;
}

/** List of project avatars. */
export class ProjectAvatars implements IProjectAvatars {
    /** List of avatars added to Jira. These avatars may be deleted. */
    readonly custom?: Avatar[];
    /** List of avatars included with Jira. These avatars cannot be deleted. */
    readonly system?: Avatar[];

    constructor(data?: IProjectAvatars) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["custom"])) {
                (<any>this).custom = [] as any;
                for (let item of _data["custom"])
                    (<any>this).custom!.push(Avatar.fromJS(item));
            }
            if (Array.isArray(_data["system"])) {
                (<any>this).system = [] as any;
                for (let item of _data["system"])
                    (<any>this).system!.push(Avatar.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectAvatars {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectAvatars();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.custom)) {
            data["custom"] = [];
            for (let item of this.custom)
                data["custom"].push(item.toJSON());
        }
        if (Array.isArray(this.system)) {
            data["system"] = [];
            for (let item of this.system)
                data["system"].push(item.toJSON());
        }
        return data;
    }
}

/** List of project avatars. */
export interface IProjectAvatars {
    /** List of avatars added to Jira. These avatars may be deleted. */
    custom?: Avatar[];
    /** List of avatars included with Jira. These avatars cannot be deleted. */
    system?: Avatar[];
}

/** A project category. */
export class ProjectCategory implements IProjectCategory {
    /** The description of the project category. */
    description?: string;
    /** The ID of the project category. */
    readonly id?: string;
    /** The name of the project category. Required on create, optional on update. */
    name?: string;
    /** The URL of the project category. */
    readonly self?: string;

    constructor(data?: IProjectCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): ProjectCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

/** A project category. */
export interface IProjectCategory {
    /** The description of the project category. */
    description?: string;
    /** The ID of the project category. */
    id?: string;
    /** The name of the project category. Required on create, optional on update. */
    name?: string;
    /** The URL of the project category. */
    self?: string;
}

/** Details about a project component. */
export class ProjectComponent implements IProjectComponent {
    /** Compass component's ID. Can't be updated. Not required for creating a Project Component. */
    readonly ari?: string;
    /** The details of the user associated with `assigneeType`, if any. See `realAssignee` for details of the user assigned to issues created with this component. */
    readonly assignee?: User;
    /** The nominal user type used to determine the assignee for issues created with this component. See `realAssigneeType` for details on how the type of the user, and hence the user, assigned to issues is determined. Can take the following values:

 *  `PROJECT_LEAD` the assignee to any issues created with this component is nominally the lead for the project the component is in.
 *  `COMPONENT_LEAD` the assignee to any issues created with this component is nominally the lead for the component.
 *  `UNASSIGNED` an assignee is not set for issues created with this component.
 *  `PROJECT_DEFAULT` the assignee to any issues created with this component is nominally the default assignee for the project that the component is in.

Default value: `PROJECT_DEFAULT`.  
Optional when creating or updating a component. */
    assigneeType?: ProjectComponentAssigneeType;
    /** The description for the component. Optional when creating or updating a component. */
    description?: string;
    /** The unique identifier for the component. */
    readonly id?: string;
    /** Whether a user is associated with `assigneeType`. For example, if the `assigneeType` is set to `COMPONENT_LEAD` but the component lead is not set, then `false` is returned. */
    readonly isAssigneeTypeValid?: boolean;
    /** The user details for the component's lead user. */
    readonly lead?: User;
    /** The accountId of the component's lead user. The accountId uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. */
    leadAccountId?: string;
    /** This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    leadUserName?: string;
    /** Compass component's metadata. Can't be updated. Not required for creating a Project Component. */
    readonly metadata?: { [key: string]: string; };
    /** The unique name for the component in the project. Required when creating a component. Optional when updating a component. The maximum length is 255 characters. */
    name?: string;
    /** The key of the project the component is assigned to. Required when creating a component. Can't be updated. */
    project?: string;
    /** The ID of the project the component is assigned to. */
    readonly projectId?: number;
    /** The user assigned to issues created with this component, when `assigneeType` does not identify a valid assignee. */
    readonly realAssignee?: User;
    /** The type of the assignee that is assigned to issues created with this component, when an assignee cannot be set from the `assigneeType`. For example, `assigneeType` is set to `COMPONENT_LEAD` but no component lead is set. This property is set to one of the following values:

 *  `PROJECT_LEAD` when `assigneeType` is `PROJECT_LEAD` and the project lead has permission to be assigned issues in the project that the component is in.
 *  `COMPONENT_LEAD` when `assignee`Type is `COMPONENT_LEAD` and the component lead has permission to be assigned issues in the project that the component is in.
 *  `UNASSIGNED` when `assigneeType` is `UNASSIGNED` and Jira is configured to allow unassigned issues.
 *  `PROJECT_DEFAULT` when none of the preceding cases are true. */
    readonly realAssigneeType?: ProjectComponentRealAssigneeType;
    /** The URL of the component. */
    readonly self?: string;

    constructor(data?: IProjectComponent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).ari = _data["ari"];
            (<any>this).assignee = _data["assignee"] ? User.fromJS(_data["assignee"]) : <any>undefined;
            this.assigneeType = _data["assigneeType"];
            this.description = _data["description"];
            (<any>this).id = _data["id"];
            (<any>this).isAssigneeTypeValid = _data["isAssigneeTypeValid"];
            (<any>this).lead = _data["lead"] ? User.fromJS(_data["lead"]) : <any>undefined;
            this.leadAccountId = _data["leadAccountId"];
            this.leadUserName = _data["leadUserName"];
            if (_data["metadata"]) {
                (<any>this).metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>(<any>this).metadata)![key] = _data["metadata"][key];
                }
            }
            this.name = _data["name"];
            this.project = _data["project"];
            (<any>this).projectId = _data["projectId"];
            (<any>this).realAssignee = _data["realAssignee"] ? User.fromJS(_data["realAssignee"]) : <any>undefined;
            (<any>this).realAssigneeType = _data["realAssigneeType"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): ProjectComponent {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectComponent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ari"] = this.ari;
        data["assignee"] = this.assignee ? this.assignee.toJSON() : <any>undefined;
        data["assigneeType"] = this.assigneeType;
        data["description"] = this.description;
        data["id"] = this.id;
        data["isAssigneeTypeValid"] = this.isAssigneeTypeValid;
        data["lead"] = this.lead ? this.lead.toJSON() : <any>undefined;
        data["leadAccountId"] = this.leadAccountId;
        data["leadUserName"] = this.leadUserName;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        data["name"] = this.name;
        data["project"] = this.project;
        data["projectId"] = this.projectId;
        data["realAssignee"] = this.realAssignee ? this.realAssignee.toJSON() : <any>undefined;
        data["realAssigneeType"] = this.realAssigneeType;
        data["self"] = this.self;
        return data;
    }
}

/** Details about a project component. */
export interface IProjectComponent {
    /** Compass component's ID. Can't be updated. Not required for creating a Project Component. */
    ari?: string;
    /** The details of the user associated with `assigneeType`, if any. See `realAssignee` for details of the user assigned to issues created with this component. */
    assignee?: User;
    /** The nominal user type used to determine the assignee for issues created with this component. See `realAssigneeType` for details on how the type of the user, and hence the user, assigned to issues is determined. Can take the following values:

 *  `PROJECT_LEAD` the assignee to any issues created with this component is nominally the lead for the project the component is in.
 *  `COMPONENT_LEAD` the assignee to any issues created with this component is nominally the lead for the component.
 *  `UNASSIGNED` an assignee is not set for issues created with this component.
 *  `PROJECT_DEFAULT` the assignee to any issues created with this component is nominally the default assignee for the project that the component is in.

Default value: `PROJECT_DEFAULT`.  
Optional when creating or updating a component. */
    assigneeType?: ProjectComponentAssigneeType;
    /** The description for the component. Optional when creating or updating a component. */
    description?: string;
    /** The unique identifier for the component. */
    id?: string;
    /** Whether a user is associated with `assigneeType`. For example, if the `assigneeType` is set to `COMPONENT_LEAD` but the component lead is not set, then `false` is returned. */
    isAssigneeTypeValid?: boolean;
    /** The user details for the component's lead user. */
    lead?: User;
    /** The accountId of the component's lead user. The accountId uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. */
    leadAccountId?: string;
    /** This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    leadUserName?: string;
    /** Compass component's metadata. Can't be updated. Not required for creating a Project Component. */
    metadata?: { [key: string]: string; };
    /** The unique name for the component in the project. Required when creating a component. Optional when updating a component. The maximum length is 255 characters. */
    name?: string;
    /** The key of the project the component is assigned to. Required when creating a component. Can't be updated. */
    project?: string;
    /** The ID of the project the component is assigned to. */
    projectId?: number;
    /** The user assigned to issues created with this component, when `assigneeType` does not identify a valid assignee. */
    realAssignee?: User;
    /** The type of the assignee that is assigned to issues created with this component, when an assignee cannot be set from the `assigneeType`. For example, `assigneeType` is set to `COMPONENT_LEAD` but no component lead is set. This property is set to one of the following values:

 *  `PROJECT_LEAD` when `assigneeType` is `PROJECT_LEAD` and the project lead has permission to be assigned issues in the project that the component is in.
 *  `COMPONENT_LEAD` when `assignee`Type is `COMPONENT_LEAD` and the component lead has permission to be assigned issues in the project that the component is in.
 *  `UNASSIGNED` when `assigneeType` is `UNASSIGNED` and Jira is configured to allow unassigned issues.
 *  `PROJECT_DEFAULT` when none of the preceding cases are true. */
    realAssigneeType?: ProjectComponentRealAssigneeType;
    /** The URL of the component. */
    self?: string;
}

/** Every project-created entity has an ID that must be unique within the scope of the project creation. PCRI (Project Create Resource Identifier) is a standard format for creating IDs and references to other project entities. PCRI format is defined as follows: pcri:\[entityType\]:\[type\]:\[entityId\] entityType - the type of an entity, e.g. status, role, workflow type - PCRI type, either `id` - The ID of an entity that already exists in the target site, or `ref` - A unique reference to an entity that is being created entityId - entity identifier, if type is `id` - must be an existing entity ID that exists in the Jira site, if `ref` - must be unique across all entities in the scope of this project template creation */
export class ProjectCreateResourceIdentifier implements IProjectCreateResourceIdentifier {
    anID?: boolean;
    areference?: boolean;
    entityId?: string;
    entityType?: string;
    id?: string;
    type?: ProjectCreateResourceIdentifierType;

    constructor(data?: IProjectCreateResourceIdentifier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.anID = _data["anID"];
            this.areference = _data["areference"];
            this.entityId = _data["entityId"];
            this.entityType = _data["entityType"];
            this.id = _data["id"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ProjectCreateResourceIdentifier {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectCreateResourceIdentifier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["anID"] = this.anID;
        data["areference"] = this.areference;
        data["entityId"] = this.entityId;
        data["entityType"] = this.entityType;
        data["id"] = this.id;
        data["type"] = this.type;
        return data;
    }
}

/** Every project-created entity has an ID that must be unique within the scope of the project creation. PCRI (Project Create Resource Identifier) is a standard format for creating IDs and references to other project entities. PCRI format is defined as follows: pcri:\[entityType\]:\[type\]:\[entityId\] entityType - the type of an entity, e.g. status, role, workflow type - PCRI type, either `id` - The ID of an entity that already exists in the target site, or `ref` - A unique reference to an entity that is being created entityId - entity identifier, if type is `id` - must be an existing entity ID that exists in the Jira site, if `ref` - must be unique across all entities in the scope of this project template creation */
export interface IProjectCreateResourceIdentifier {
    anID?: boolean;
    areference?: boolean;
    entityId?: string;
    entityType?: string;
    id?: string;
    type?: ProjectCreateResourceIdentifierType;
}

/** Request to create a project using a custom template */
export class ProjectCustomTemplateCreateRequestDTO implements IProjectCustomTemplateCreateRequestDTO {
    details?: CustomTemplatesProjectDetails;
    template?: CustomTemplateRequestDTO;

    constructor(data?: IProjectCustomTemplateCreateRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.details = _data["details"] ? CustomTemplatesProjectDetails.fromJS(_data["details"]) : <any>undefined;
            this.template = _data["template"] ? CustomTemplateRequestDTO.fromJS(_data["template"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectCustomTemplateCreateRequestDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectCustomTemplateCreateRequestDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details ? this.details.toJSON() : <any>undefined;
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        return data;
    }
}

/** Request to create a project using a custom template */
export interface IProjectCustomTemplateCreateRequestDTO {
    details?: CustomTemplatesProjectDetails;
    template?: CustomTemplateRequestDTO;
}

/** Details about data policies for a list of projects. */
export class ProjectDataPolicies implements IProjectDataPolicies {
    /** List of projects with data policies. */
    readonly projectDataPolicies?: ProjectWithDataPolicy[];

    constructor(data?: IProjectDataPolicies) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["projectDataPolicies"])) {
                (<any>this).projectDataPolicies = [] as any;
                for (let item of _data["projectDataPolicies"])
                    (<any>this).projectDataPolicies!.push(ProjectWithDataPolicy.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectDataPolicies {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDataPolicies();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.projectDataPolicies)) {
            data["projectDataPolicies"] = [];
            for (let item of this.projectDataPolicies)
                data["projectDataPolicies"].push(item.toJSON());
        }
        return data;
    }
}

/** Details about data policies for a list of projects. */
export interface IProjectDataPolicies {
    /** List of projects with data policies. */
    projectDataPolicies?: ProjectWithDataPolicy[];
}

/** Details about data policy. */
export class ProjectDataPolicy implements IProjectDataPolicy {
    /** Whether the project contains any content inaccessible to the requesting application. */
    readonly anyContentBlocked?: boolean;

    constructor(data?: IProjectDataPolicy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).anyContentBlocked = _data["anyContentBlocked"];
        }
    }

    static fromJS(data: any): ProjectDataPolicy {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDataPolicy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["anyContentBlocked"] = this.anyContentBlocked;
        return data;
    }
}

/** Details about data policy. */
export interface IProjectDataPolicy {
    /** Whether the project contains any content inaccessible to the requesting application. */
    anyContentBlocked?: boolean;
}

/** Details about a project. */
export class ProjectDetails implements IProjectDetails {
    /** The URLs of the project's avatars. */
    readonly avatarUrls?: AvatarUrlsBean;
    /** The ID of the project. */
    id?: string;
    /** The key of the project. */
    readonly key?: string;
    /** The name of the project. */
    readonly name?: string;
    /** The category the project belongs to. */
    readonly projectCategory?: UpdatedProjectCategory;
    /** The [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes) of the project. */
    readonly projectTypeKey?: ProjectDetailsProjectTypeKey;
    /** The URL of the project details. */
    readonly self?: string;
    /** Whether or not the project is simplified. */
    readonly simplified?: boolean;

    constructor(data?: IProjectDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).avatarUrls = _data["avatarUrls"] ? AvatarUrlsBean.fromJS(_data["avatarUrls"]) : <any>undefined;
            this.id = _data["id"];
            (<any>this).key = _data["key"];
            (<any>this).name = _data["name"];
            (<any>this).projectCategory = _data["projectCategory"] ? UpdatedProjectCategory.fromJS(_data["projectCategory"]) : <any>undefined;
            (<any>this).projectTypeKey = _data["projectTypeKey"];
            (<any>this).self = _data["self"];
            (<any>this).simplified = _data["simplified"];
        }
    }

    static fromJS(data: any): ProjectDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatarUrls"] = this.avatarUrls ? this.avatarUrls.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["key"] = this.key;
        data["name"] = this.name;
        data["projectCategory"] = this.projectCategory ? this.projectCategory.toJSON() : <any>undefined;
        data["projectTypeKey"] = this.projectTypeKey;
        data["self"] = this.self;
        data["simplified"] = this.simplified;
        return data;
    }
}

/** Details about a project. */
export interface IProjectDetails {
    /** The URLs of the project's avatars. */
    avatarUrls?: AvatarUrlsBean;
    /** The ID of the project. */
    id?: string;
    /** The key of the project. */
    key?: string;
    /** The name of the project. */
    name?: string;
    /** The category the project belongs to. */
    projectCategory?: UpdatedProjectCategory;
    /** The [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes) of the project. */
    projectTypeKey?: ProjectDetailsProjectTypeKey;
    /** The URL of the project details. */
    self?: string;
    /** Whether or not the project is simplified. */
    simplified?: boolean;
}

/** A project's sender email address. */
export class ProjectEmailAddress implements IProjectEmailAddress {
    /** The email address. */
    emailAddress?: string;
    /** When using a custom domain, the status of the email address. */
    emailAddressStatus?: string[];

    constructor(data?: IProjectEmailAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            if (Array.isArray(_data["emailAddressStatus"])) {
                this.emailAddressStatus = [] as any;
                for (let item of _data["emailAddressStatus"])
                    this.emailAddressStatus!.push(item);
            }
        }
    }

    static fromJS(data: any): ProjectEmailAddress {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectEmailAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        if (Array.isArray(this.emailAddressStatus)) {
            data["emailAddressStatus"] = [];
            for (let item of this.emailAddressStatus)
                data["emailAddressStatus"].push(item);
        }
        return data;
    }
}

/** A project's sender email address. */
export interface IProjectEmailAddress {
    /** The email address. */
    emailAddress?: string;
    /** When using a custom domain, the status of the email address. */
    emailAddressStatus?: string[];
}

/** Details of a project feature. */
export class ProjectFeature implements IProjectFeature {
    /** The key of the feature. */
    feature?: string;
    /** URI for the image representing the feature. */
    imageUri?: string;
    /** Localized display description for the feature. */
    localisedDescription?: string;
    /** Localized display name for the feature. */
    localisedName?: string;
    /** List of keys of the features required to enable the feature. */
    prerequisites?: string[];
    /** The ID of the project. */
    projectId?: number;
    /** The state of the feature. When updating the state of a feature, only ENABLED and DISABLED are supported. Responses can contain all values */
    state?: ProjectFeatureState2;
    /** Whether the state of the feature can be updated. */
    toggleLocked?: boolean;

    constructor(data?: IProjectFeature) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.feature = _data["feature"];
            this.imageUri = _data["imageUri"];
            this.localisedDescription = _data["localisedDescription"];
            this.localisedName = _data["localisedName"];
            if (Array.isArray(_data["prerequisites"])) {
                this.prerequisites = [] as any;
                for (let item of _data["prerequisites"])
                    this.prerequisites!.push(item);
            }
            this.projectId = _data["projectId"];
            this.state = _data["state"];
            this.toggleLocked = _data["toggleLocked"];
        }
    }

    static fromJS(data: any): ProjectFeature {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectFeature();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["feature"] = this.feature;
        data["imageUri"] = this.imageUri;
        data["localisedDescription"] = this.localisedDescription;
        data["localisedName"] = this.localisedName;
        if (Array.isArray(this.prerequisites)) {
            data["prerequisites"] = [];
            for (let item of this.prerequisites)
                data["prerequisites"].push(item);
        }
        data["projectId"] = this.projectId;
        data["state"] = this.state;
        data["toggleLocked"] = this.toggleLocked;
        return data;
    }
}

/** Details of a project feature. */
export interface IProjectFeature {
    /** The key of the feature. */
    feature?: string;
    /** URI for the image representing the feature. */
    imageUri?: string;
    /** Localized display description for the feature. */
    localisedDescription?: string;
    /** Localized display name for the feature. */
    localisedName?: string;
    /** List of keys of the features required to enable the feature. */
    prerequisites?: string[];
    /** The ID of the project. */
    projectId?: number;
    /** The state of the feature. When updating the state of a feature, only ENABLED and DISABLED are supported. Responses can contain all values */
    state?: ProjectFeatureState2;
    /** Whether the state of the feature can be updated. */
    toggleLocked?: boolean;
}

/** Details of the feature state. */
export class ProjectFeatureState implements IProjectFeatureState {
    /** The feature state. */
    state?: ProjectFeatureStateState;

    constructor(data?: IProjectFeatureState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): ProjectFeatureState {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectFeatureState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        return data;
    }
}

/** Details of the feature state. */
export interface IProjectFeatureState {
    /** The feature state. */
    state?: ProjectFeatureStateState;
}

/** Project ID details. */
export class ProjectId implements IProjectId {
    /** The ID of the project. */
    id!: string;

    constructor(data?: IProjectId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProjectId {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** Project ID details. */
export interface IProjectId {
    /** The ID of the project. */
    id: string;
}

export class ProjectIdAssociationContext extends AssociationContextObject implements IProjectIdAssociationContext {
    identifier?: number;

    [key: string]: any;

    constructor(data?: IProjectIdAssociationContext) {
        super(data);
        this._discriminator = "ProjectIdAssociationContext";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.identifier = _data["identifier"];
        }
    }

    static fromJS(data: any): ProjectIdAssociationContext {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectIdAssociationContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["identifier"] = this.identifier;
        super.toJSON(data);
        return data;
    }
}

export interface IProjectIdAssociationContext extends IAssociationContextObject {
    identifier?: number;

    [key: string]: any;
}

/** The identifiers for a project. */
export class ProjectIdentifierBean implements IProjectIdentifierBean {
    /** The ID of the project. */
    readonly id?: number;
    /** The key of the project. */
    readonly key?: string;

    constructor(data?: IProjectIdentifierBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).key = _data["key"];
        }
    }

    static fromJS(data: any): ProjectIdentifierBean {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectIdentifierBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        return data;
    }
}

/** The identifiers for a project. */
export interface IProjectIdentifierBean {
    /** The ID of the project. */
    id?: number;
    /** The key of the project. */
    key?: string;
}

/** Identifiers for a project. */
export class ProjectIdentifiers implements IProjectIdentifiers {
    /** The ID of the created project. */
    readonly id!: number;
    /** The key of the created project. */
    readonly key!: string;
    /** The URL of the created project. */
    readonly self!: string;

    constructor(data?: IProjectIdentifiers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).key = _data["key"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): ProjectIdentifiers {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectIdentifiers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["self"] = this.self;
        return data;
    }
}

/** Identifiers for a project. */
export interface IProjectIdentifiers {
    /** The ID of the created project. */
    id: number;
    /** The key of the created project. */
    key: string;
    /** The URL of the created project. */
    self: string;
}

/** A list of project IDs. */
export class ProjectIds implements IProjectIds {
    /** The IDs of projects. */
    projectIds!: string[];

    constructor(data?: IProjectIds) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.projectIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["projectIds"])) {
                this.projectIds = [] as any;
                for (let item of _data["projectIds"])
                    this.projectIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ProjectIds {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectIds();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.projectIds)) {
            data["projectIds"] = [];
            for (let item of this.projectIds)
                data["projectIds"].push(item);
        }
        return data;
    }
}

/** A list of project IDs. */
export interface IProjectIds {
    /** The IDs of projects. */
    projectIds: string[];
}

/** Additional details about a project. */
export class ProjectInsight implements IProjectInsight {
    /** The last issue update time. */
    readonly lastIssueUpdateTime?: Date;
    /** Total issue count. */
    readonly totalIssueCount?: number;

    constructor(data?: IProjectInsight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).lastIssueUpdateTime = _data["lastIssueUpdateTime"] ? new Date(_data["lastIssueUpdateTime"].toString()) : <any>undefined;
            (<any>this).totalIssueCount = _data["totalIssueCount"];
        }
    }

    static fromJS(data: any): ProjectInsight {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectInsight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastIssueUpdateTime"] = this.lastIssueUpdateTime ? this.lastIssueUpdateTime.toISOString() : <any>undefined;
        data["totalIssueCount"] = this.totalIssueCount;
        return data;
    }
}

/** Additional details about a project. */
export interface IProjectInsight {
    /** The last issue update time. */
    lastIssueUpdateTime?: Date;
    /** Total issue count. */
    totalIssueCount?: number;
}

/** Details of the issue creation metadata for a project. */
export class ProjectIssueCreateMetadata implements IProjectIssueCreateMetadata {
    /** List of the project's avatars, returning the avatar size and associated URL. */
    readonly avatarUrls?: AvatarUrlsBean;
    /** Expand options that include additional project issue create metadata details in the response. */
    readonly expand?: string;
    /** The ID of the project. */
    readonly id?: string;
    /** List of the issue types supported by the project. */
    readonly issuetypes?: IssueTypeIssueCreateMetadata[];
    /** The key of the project. */
    readonly key?: string;
    /** The name of the project. */
    readonly name?: string;
    /** The URL of the project. */
    readonly self?: string;

    constructor(data?: IProjectIssueCreateMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).avatarUrls = _data["avatarUrls"] ? AvatarUrlsBean.fromJS(_data["avatarUrls"]) : <any>undefined;
            (<any>this).expand = _data["expand"];
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["issuetypes"])) {
                (<any>this).issuetypes = [] as any;
                for (let item of _data["issuetypes"])
                    (<any>this).issuetypes!.push(IssueTypeIssueCreateMetadata.fromJS(item));
            }
            (<any>this).key = _data["key"];
            (<any>this).name = _data["name"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): ProjectIssueCreateMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectIssueCreateMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatarUrls"] = this.avatarUrls ? this.avatarUrls.toJSON() : <any>undefined;
        data["expand"] = this.expand;
        data["id"] = this.id;
        if (Array.isArray(this.issuetypes)) {
            data["issuetypes"] = [];
            for (let item of this.issuetypes)
                data["issuetypes"].push(item.toJSON());
        }
        data["key"] = this.key;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

/** Details of the issue creation metadata for a project. */
export interface IProjectIssueCreateMetadata {
    /** List of the project's avatars, returning the avatar size and associated URL. */
    avatarUrls?: AvatarUrlsBean;
    /** Expand options that include additional project issue create metadata details in the response. */
    expand?: string;
    /** The ID of the project. */
    id?: string;
    /** List of the issue types supported by the project. */
    issuetypes?: IssueTypeIssueCreateMetadata[];
    /** The key of the project. */
    key?: string;
    /** The name of the project. */
    name?: string;
    /** The URL of the project. */
    self?: string;
}

/** List of issue level security items in a project. */
export class ProjectIssueSecurityLevels implements IProjectIssueSecurityLevels {
    /** Issue level security items list. */
    readonly levels!: SecurityLevel[];

    constructor(data?: IProjectIssueSecurityLevels) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.levels = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["levels"])) {
                (<any>this).levels = [] as any;
                for (let item of _data["levels"])
                    (<any>this).levels!.push(SecurityLevel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectIssueSecurityLevels {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectIssueSecurityLevels();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.levels)) {
            data["levels"] = [];
            for (let item of this.levels)
                data["levels"].push(item.toJSON());
        }
        return data;
    }
}

/** List of issue level security items in a project. */
export interface IProjectIssueSecurityLevels {
    /** Issue level security items list. */
    levels: SecurityLevel[];
}

/** The hierarchy of issue types within a project. */
export class ProjectIssueTypeHierarchy implements IProjectIssueTypeHierarchy {
    /** Details of an issue type hierarchy level. */
    readonly hierarchy?: ProjectIssueTypesHierarchyLevel[];
    /** The ID of the project. */
    readonly projectId?: number;

    constructor(data?: IProjectIssueTypeHierarchy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["hierarchy"])) {
                (<any>this).hierarchy = [] as any;
                for (let item of _data["hierarchy"])
                    (<any>this).hierarchy!.push(ProjectIssueTypesHierarchyLevel.fromJS(item));
            }
            (<any>this).projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): ProjectIssueTypeHierarchy {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectIssueTypeHierarchy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.hierarchy)) {
            data["hierarchy"] = [];
            for (let item of this.hierarchy)
                data["hierarchy"].push(item.toJSON());
        }
        data["projectId"] = this.projectId;
        return data;
    }
}

/** The hierarchy of issue types within a project. */
export interface IProjectIssueTypeHierarchy {
    /** Details of an issue type hierarchy level. */
    hierarchy?: ProjectIssueTypesHierarchyLevel[];
    /** The ID of the project. */
    projectId?: number;
}

/** The project and issue type mapping. */
export class ProjectIssueTypeMapping implements IProjectIssueTypeMapping {
    /** The ID of the issue type. */
    issueTypeId!: string;
    /** The ID of the project. */
    projectId!: string;

    constructor(data?: IProjectIssueTypeMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueTypeId = _data["issueTypeId"];
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): ProjectIssueTypeMapping {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectIssueTypeMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueTypeId"] = this.issueTypeId;
        data["projectId"] = this.projectId;
        return data;
    }
}

/** The project and issue type mapping. */
export interface IProjectIssueTypeMapping {
    /** The ID of the issue type. */
    issueTypeId: string;
    /** The ID of the project. */
    projectId: string;
}

/** The project and issue type mappings. */
export class ProjectIssueTypeMappings implements IProjectIssueTypeMappings {
    /** The project and issue type mappings. */
    mappings!: ProjectIssueTypeMapping[];

    constructor(data?: IProjectIssueTypeMappings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.mappings = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["mappings"])) {
                this.mappings = [] as any;
                for (let item of _data["mappings"])
                    this.mappings!.push(ProjectIssueTypeMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectIssueTypeMappings {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectIssueTypeMappings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.mappings)) {
            data["mappings"] = [];
            for (let item of this.mappings)
                data["mappings"].push(item.toJSON());
        }
        return data;
    }
}

/** The project and issue type mappings. */
export interface IProjectIssueTypeMappings {
    /** The project and issue type mappings. */
    mappings: ProjectIssueTypeMapping[];
}

/** Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details. Use the optional `workflows.usages` expand to get additional information about the projects and issue types associated with the requested workflows. */
export class ProjectIssueTypes implements IProjectIssueTypes {
    /** IDs of the issue types */
    issueTypes?: (string | undefined)[] | undefined;
    project?: ProjectId | undefined;

    constructor(data?: IProjectIssueTypes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueTypes"])) {
                this.issueTypes = [] as any;
                for (let item of _data["issueTypes"])
                    this.issueTypes!.push(item);
            }
            this.project = _data["project"] ? ProjectId.fromJS(_data["project"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectIssueTypes {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectIssueTypes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueTypes)) {
            data["issueTypes"] = [];
            for (let item of this.issueTypes)
                data["issueTypes"].push(item);
        }
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        return data;
    }
}

/** Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details. Use the optional `workflows.usages` expand to get additional information about the projects and issue types associated with the requested workflows. */
export interface IProjectIssueTypes {
    /** IDs of the issue types */
    issueTypes?: (string | undefined)[] | undefined;
    project?: ProjectId | undefined;
}

/** Details of an issue type hierarchy level. */
export class ProjectIssueTypesHierarchyLevel implements IProjectIssueTypesHierarchyLevel {
    /** The ID of the issue type hierarchy level. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/). */
    readonly entityId?: string;
    /** The list of issue types in the hierarchy level. */
    readonly issueTypes?: IssueTypeInfo[];
    /** The level of the issue type hierarchy level. */
    readonly level?: number;
    /** The name of the issue type hierarchy level. */
    readonly name?: string;

    constructor(data?: IProjectIssueTypesHierarchyLevel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).entityId = _data["entityId"];
            if (Array.isArray(_data["issueTypes"])) {
                (<any>this).issueTypes = [] as any;
                for (let item of _data["issueTypes"])
                    (<any>this).issueTypes!.push(IssueTypeInfo.fromJS(item));
            }
            (<any>this).level = _data["level"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): ProjectIssueTypesHierarchyLevel {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectIssueTypesHierarchyLevel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        if (Array.isArray(this.issueTypes)) {
            data["issueTypes"] = [];
            for (let item of this.issueTypes)
                data["issueTypes"].push(item.toJSON());
        }
        data["level"] = this.level;
        data["name"] = this.name;
        return data;
    }
}

/** Details of an issue type hierarchy level. */
export interface IProjectIssueTypesHierarchyLevel {
    /** The ID of the issue type hierarchy level. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/). */
    entityId?: string;
    /** The list of issue types in the hierarchy level. */
    issueTypes?: IssueTypeInfo[];
    /** The level of the issue type hierarchy level. */
    level?: number;
    /** The name of the issue type hierarchy level. */
    name?: string;
}

export class ProjectLandingPageInfo implements IProjectLandingPageInfo {
    attributes?: { [key: string]: string; };
    boardId?: number;
    boardName?: string;
    projectKey?: string;
    projectType?: string;
    queueCategory?: string;
    queueId?: number;
    queueName?: string;
    simpleBoard?: boolean;
    simplified?: boolean;
    url?: string;

    constructor(data?: IProjectLandingPageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["attributes"]) {
                this.attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>this.attributes)![key] = _data["attributes"][key];
                }
            }
            this.boardId = _data["boardId"];
            this.boardName = _data["boardName"];
            this.projectKey = _data["projectKey"];
            this.projectType = _data["projectType"];
            this.queueCategory = _data["queueCategory"];
            this.queueId = _data["queueId"];
            this.queueName = _data["queueName"];
            this.simpleBoard = _data["simpleBoard"];
            this.simplified = _data["simplified"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): ProjectLandingPageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectLandingPageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = (<any>this.attributes)[key];
            }
        }
        data["boardId"] = this.boardId;
        data["boardName"] = this.boardName;
        data["projectKey"] = this.projectKey;
        data["projectType"] = this.projectType;
        data["queueCategory"] = this.queueCategory;
        data["queueId"] = this.queueId;
        data["queueName"] = this.queueName;
        data["simpleBoard"] = this.simpleBoard;
        data["simplified"] = this.simplified;
        data["url"] = this.url;
        return data;
    }
}

export interface IProjectLandingPageInfo {
    attributes?: { [key: string]: string; };
    boardId?: number;
    boardName?: string;
    projectKey?: string;
    projectType?: string;
    queueCategory?: string;
    queueId?: number;
    queueName?: string;
    simpleBoard?: boolean;
    simplified?: boolean;
    url?: string;
}

/** The payload for creating a project */
export class ProjectPayload implements IProjectPayload {
    fieldLayoutSchemeId?: ProjectCreateResourceIdentifier;
    issueSecuritySchemeId?: ProjectCreateResourceIdentifier;
    issueTypeSchemeId?: ProjectCreateResourceIdentifier;
    issueTypeScreenSchemeId?: ProjectCreateResourceIdentifier;
    notificationSchemeId?: ProjectCreateResourceIdentifier;
    pcri?: ProjectCreateResourceIdentifier;
    permissionSchemeId?: ProjectCreateResourceIdentifier;
    /** The [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes), which defines the application-specific feature set. If you don't specify the project template you have to specify the project type. */
    projectTypeKey?: ProjectPayloadProjectTypeKey;
    workflowSchemeId?: ProjectCreateResourceIdentifier;

    constructor(data?: IProjectPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldLayoutSchemeId = _data["fieldLayoutSchemeId"] ? ProjectCreateResourceIdentifier.fromJS(_data["fieldLayoutSchemeId"]) : <any>undefined;
            this.issueSecuritySchemeId = _data["issueSecuritySchemeId"] ? ProjectCreateResourceIdentifier.fromJS(_data["issueSecuritySchemeId"]) : <any>undefined;
            this.issueTypeSchemeId = _data["issueTypeSchemeId"] ? ProjectCreateResourceIdentifier.fromJS(_data["issueTypeSchemeId"]) : <any>undefined;
            this.issueTypeScreenSchemeId = _data["issueTypeScreenSchemeId"] ? ProjectCreateResourceIdentifier.fromJS(_data["issueTypeScreenSchemeId"]) : <any>undefined;
            this.notificationSchemeId = _data["notificationSchemeId"] ? ProjectCreateResourceIdentifier.fromJS(_data["notificationSchemeId"]) : <any>undefined;
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
            this.permissionSchemeId = _data["permissionSchemeId"] ? ProjectCreateResourceIdentifier.fromJS(_data["permissionSchemeId"]) : <any>undefined;
            this.projectTypeKey = _data["projectTypeKey"];
            this.workflowSchemeId = _data["workflowSchemeId"] ? ProjectCreateResourceIdentifier.fromJS(_data["workflowSchemeId"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectPayload {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldLayoutSchemeId"] = this.fieldLayoutSchemeId ? this.fieldLayoutSchemeId.toJSON() : <any>undefined;
        data["issueSecuritySchemeId"] = this.issueSecuritySchemeId ? this.issueSecuritySchemeId.toJSON() : <any>undefined;
        data["issueTypeSchemeId"] = this.issueTypeSchemeId ? this.issueTypeSchemeId.toJSON() : <any>undefined;
        data["issueTypeScreenSchemeId"] = this.issueTypeScreenSchemeId ? this.issueTypeScreenSchemeId.toJSON() : <any>undefined;
        data["notificationSchemeId"] = this.notificationSchemeId ? this.notificationSchemeId.toJSON() : <any>undefined;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        data["permissionSchemeId"] = this.permissionSchemeId ? this.permissionSchemeId.toJSON() : <any>undefined;
        data["projectTypeKey"] = this.projectTypeKey;
        data["workflowSchemeId"] = this.workflowSchemeId ? this.workflowSchemeId.toJSON() : <any>undefined;
        return data;
    }
}

/** The payload for creating a project */
export interface IProjectPayload {
    fieldLayoutSchemeId?: ProjectCreateResourceIdentifier;
    issueSecuritySchemeId?: ProjectCreateResourceIdentifier;
    issueTypeSchemeId?: ProjectCreateResourceIdentifier;
    issueTypeScreenSchemeId?: ProjectCreateResourceIdentifier;
    notificationSchemeId?: ProjectCreateResourceIdentifier;
    pcri?: ProjectCreateResourceIdentifier;
    permissionSchemeId?: ProjectCreateResourceIdentifier;
    /** The [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes), which defines the application-specific feature set. If you don't specify the project template you have to specify the project type. */
    projectTypeKey?: ProjectPayloadProjectTypeKey;
    workflowSchemeId?: ProjectCreateResourceIdentifier;
}

/** Permissions which a user has on a project. */
export class ProjectPermissions implements IProjectPermissions {
    /** Whether the logged user can edit the project. */
    readonly canEdit?: boolean;

    constructor(data?: IProjectPermissions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).canEdit = _data["canEdit"];
        }
    }

    static fromJS(data: any): ProjectPermissions {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectPermissions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canEdit"] = this.canEdit;
        return data;
    }
}

/** Permissions which a user has on a project. */
export interface IProjectPermissions {
    /** Whether the logged user can edit the project. */
    canEdit?: boolean;
}

/** Details about the roles in a project. */
export class ProjectRole implements IProjectRole {
    /** The list of users who act in this role. */
    readonly actors?: RoleActor[];
    /** Whether this role is the admin role for the project. */
    readonly admin?: boolean;
    /** Whether the calling user is part of this role. */
    currentUserRole?: boolean;
    /** Whether this role is the default role for the project */
    readonly default?: boolean;
    /** The description of the project role. */
    readonly description?: string;
    /** The ID of the project role. */
    readonly id?: number;
    /** The name of the project role. */
    name?: string;
    /** Whether the roles are configurable for this project. */
    readonly roleConfigurable?: boolean;
    /** The scope of the role. Indicated for roles associated with [next-gen projects](https://confluence.atlassian.com/x/loMyO). */
    readonly scope?: Scope;
    /** The URL the project role details. */
    readonly self?: string;
    /** The translated name of the project role. */
    translatedName?: string;

    constructor(data?: IProjectRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["actors"])) {
                (<any>this).actors = [] as any;
                for (let item of _data["actors"])
                    (<any>this).actors!.push(RoleActor.fromJS(item));
            }
            (<any>this).admin = _data["admin"];
            this.currentUserRole = _data["currentUserRole"];
            (<any>this).default = _data["default"];
            (<any>this).description = _data["description"];
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            (<any>this).roleConfigurable = _data["roleConfigurable"];
            (<any>this).scope = _data["scope"] ? Scope.fromJS(_data["scope"]) : <any>undefined;
            (<any>this).self = _data["self"];
            this.translatedName = _data["translatedName"];
        }
    }

    static fromJS(data: any): ProjectRole {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.actors)) {
            data["actors"] = [];
            for (let item of this.actors)
                data["actors"].push(item.toJSON());
        }
        data["admin"] = this.admin;
        data["currentUserRole"] = this.currentUserRole;
        data["default"] = this.default;
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["roleConfigurable"] = this.roleConfigurable;
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        data["self"] = this.self;
        data["translatedName"] = this.translatedName;
        return data;
    }
}

/** Details about the roles in a project. */
export interface IProjectRole {
    /** The list of users who act in this role. */
    actors?: RoleActor[];
    /** Whether this role is the admin role for the project. */
    admin?: boolean;
    /** Whether the calling user is part of this role. */
    currentUserRole?: boolean;
    /** Whether this role is the default role for the project */
    default?: boolean;
    /** The description of the project role. */
    description?: string;
    /** The ID of the project role. */
    id?: number;
    /** The name of the project role. */
    name?: string;
    /** Whether the roles are configurable for this project. */
    roleConfigurable?: boolean;
    /** The scope of the role. Indicated for roles associated with [next-gen projects](https://confluence.atlassian.com/x/loMyO). */
    scope?: Scope;
    /** The URL the project role details. */
    self?: string;
    /** The translated name of the project role. */
    translatedName?: string;
}

export class ProjectRoleActorsUpdateBean implements IProjectRoleActorsUpdateBean {
    /** The actors to add to the project role.

Add groups using:

 *  `atlassian-group-role-actor` and a list of group names.
 *  `atlassian-group-role-actor-id` and a list of group IDs.

As a group's name can change, use of `atlassian-group-role-actor-id` is recommended. For example, `"atlassian-group-role-actor-id":["eef79f81-0b89-4fca-a736-4be531a10869","77f6ab39-e755-4570-a6ae-2d7a8df0bcb8"]`.

Add users using `atlassian-user-role-actor` and a list of account IDs. For example, `"atlassian-user-role-actor":["12345678-9abc-def1-2345-6789abcdef12", "abcdef12-3456-789a-bcde-f123456789ab"]`. */
    categorisedActors?: { [key: string]: string[]; };
    /** The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs. */
    readonly id?: number;

    constructor(data?: IProjectRoleActorsUpdateBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["categorisedActors"]) {
                this.categorisedActors = {} as any;
                for (let key in _data["categorisedActors"]) {
                    if (_data["categorisedActors"].hasOwnProperty(key))
                        (<any>this.categorisedActors)![key] = _data["categorisedActors"][key] !== undefined ? _data["categorisedActors"][key] : [];
                }
            }
            (<any>this).id = _data["id"];
        }
    }

    static fromJS(data: any): ProjectRoleActorsUpdateBean {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectRoleActorsUpdateBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.categorisedActors) {
            data["categorisedActors"] = {};
            for (let key in this.categorisedActors) {
                if (this.categorisedActors.hasOwnProperty(key))
                    (<any>data["categorisedActors"])[key] = (<any>this.categorisedActors)[key];
            }
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IProjectRoleActorsUpdateBean {
    /** The actors to add to the project role.

Add groups using:

 *  `atlassian-group-role-actor` and a list of group names.
 *  `atlassian-group-role-actor-id` and a list of group IDs.

As a group's name can change, use of `atlassian-group-role-actor-id` is recommended. For example, `"atlassian-group-role-actor-id":["eef79f81-0b89-4fca-a736-4be531a10869","77f6ab39-e755-4570-a6ae-2d7a8df0bcb8"]`.

Add users using `atlassian-user-role-actor` and a list of account IDs. For example, `"atlassian-user-role-actor":["12345678-9abc-def1-2345-6789abcdef12", "abcdef12-3456-789a-bcde-f123456789ab"]`. */
    categorisedActors?: { [key: string]: string[]; };
    /** The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs. */
    id?: number;
}

/** Details about a project role. */
export class ProjectRoleDetails implements IProjectRoleDetails {
    /** Whether this role is the admin role for the project. */
    readonly admin?: boolean;
    /** Whether this role is the default role for the project. */
    readonly default?: boolean;
    /** The description of the project role. */
    readonly description?: string;
    /** The ID of the project role. */
    readonly id?: number;
    /** The name of the project role. */
    name?: string;
    /** Whether the roles are configurable for this project. */
    readonly roleConfigurable?: boolean;
    /** The scope of the role. Indicated for roles associated with [next-gen projects](https://confluence.atlassian.com/x/loMyO). */
    readonly scope?: Scope;
    /** The URL the project role details. */
    readonly self?: string;
    /** The translated name of the project role. */
    translatedName?: string;

    constructor(data?: IProjectRoleDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).admin = _data["admin"];
            (<any>this).default = _data["default"];
            (<any>this).description = _data["description"];
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            (<any>this).roleConfigurable = _data["roleConfigurable"];
            (<any>this).scope = _data["scope"] ? Scope.fromJS(_data["scope"]) : <any>undefined;
            (<any>this).self = _data["self"];
            this.translatedName = _data["translatedName"];
        }
    }

    static fromJS(data: any): ProjectRoleDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectRoleDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["admin"] = this.admin;
        data["default"] = this.default;
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["roleConfigurable"] = this.roleConfigurable;
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        data["self"] = this.self;
        data["translatedName"] = this.translatedName;
        return data;
    }
}

/** Details about a project role. */
export interface IProjectRoleDetails {
    /** Whether this role is the admin role for the project. */
    admin?: boolean;
    /** Whether this role is the default role for the project. */
    default?: boolean;
    /** The description of the project role. */
    description?: string;
    /** The ID of the project role. */
    id?: number;
    /** The name of the project role. */
    name?: string;
    /** Whether the roles are configurable for this project. */
    roleConfigurable?: boolean;
    /** The scope of the role. Indicated for roles associated with [next-gen projects](https://confluence.atlassian.com/x/loMyO). */
    scope?: Scope;
    /** The URL the project role details. */
    self?: string;
    /** The translated name of the project role. */
    translatedName?: string;
}

/** Details of the group associated with the role. */
export class ProjectRoleGroup implements IProjectRoleGroup {
    /** The display name of the group. */
    displayName?: string;
    /** The ID of the group. */
    groupId?: string;
    /** The name of the group. As a group's name can change, use of `groupId` is recommended to identify the group. */
    name?: string;

    constructor(data?: IProjectRoleGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.groupId = _data["groupId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProjectRoleGroup {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectRoleGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["groupId"] = this.groupId;
        data["name"] = this.name;
        return data;
    }
}

/** Details of the group associated with the role. */
export interface IProjectRoleGroup {
    /** The display name of the group. */
    displayName?: string;
    /** The ID of the group. */
    groupId?: string;
    /** The name of the group. As a group's name can change, use of `groupId` is recommended to identify the group. */
    name?: string;
}

/** Details of the user associated with the role. */
export class ProjectRoleUser implements IProjectRoleUser {
    /** The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Returns *unknown* if the record is deleted and corrupted, for example, as the result of a server import. */
    readonly accountId?: string;

    constructor(data?: IProjectRoleUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).accountId = _data["accountId"];
        }
    }

    static fromJS(data: any): ProjectRoleUser {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectRoleUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        return data;
    }
}

/** Details of the user associated with the role. */
export interface IProjectRoleUser {
    /** The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Returns *unknown* if the record is deleted and corrupted, for example, as the result of a server import. */
    accountId?: string;
}

export class ProjectScopeBean implements IProjectScopeBean {
    /** Defines the behavior of the option in the project.If notSelectable is set, the option cannot be set as the field's value. This is useful for archiving an option that has previously been selected but shouldn't be used anymore.If defaultValue is set, the option is selected by default. */
    attributes?: Attributes2[];
    /** The ID of the project that the option's behavior applies to. */
    id?: number;

    constructor(data?: IProjectScopeBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProjectScopeBean {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectScopeBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item);
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IProjectScopeBean {
    /** Defines the behavior of the option in the project.If notSelectable is set, the option cannot be set as the field's value. This is useful for archiving an option that has previously been selected but shouldn't be used anymore.If defaultValue is set, the option is selected by default. */
    attributes?: Attributes2[];
    /** The ID of the project that the option's behavior applies to. */
    id?: number;
}

/** Details about a project type. */
export class ProjectType implements IProjectType {
    /** The color of the project type. */
    readonly color?: string;
    /** The key of the project type's description. */
    readonly descriptionI18nKey?: string;
    /** The formatted key of the project type. */
    readonly formattedKey?: string;
    /** The icon of the project type. */
    readonly icon?: string;
    /** The key of the project type. */
    readonly key?: string;

    constructor(data?: IProjectType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).color = _data["color"];
            (<any>this).descriptionI18nKey = _data["descriptionI18nKey"];
            (<any>this).formattedKey = _data["formattedKey"];
            (<any>this).icon = _data["icon"];
            (<any>this).key = _data["key"];
        }
    }

    static fromJS(data: any): ProjectType {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["color"] = this.color;
        data["descriptionI18nKey"] = this.descriptionI18nKey;
        data["formattedKey"] = this.formattedKey;
        data["icon"] = this.icon;
        data["key"] = this.key;
        return data;
    }
}

/** Details about a project type. */
export interface IProjectType {
    /** The color of the project type. */
    color?: string;
    /** The key of the project type's description. */
    descriptionI18nKey?: string;
    /** The formatted key of the project type. */
    formattedKey?: string;
    /** The icon of the project type. */
    icon?: string;
    /** The key of the project type. */
    key?: string;
}

/** The project. */
export class ProjectUsage implements IProjectUsage {
    /** The project ID. */
    id?: string;

    constructor(data?: IProjectUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProjectUsage {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectUsage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** The project. */
export interface IProjectUsage {
    /** The project ID. */
    id?: string;
}

/** A page of projects. */
export class ProjectUsagePage implements IProjectUsagePage {
    /** Page token for the next page of project usages. */
    nextPageToken?: string;
    /** The list of projects. */
    values?: ProjectUsage[];

    constructor(data?: IProjectUsagePage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nextPageToken = _data["nextPageToken"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(ProjectUsage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectUsagePage {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectUsagePage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nextPageToken"] = this.nextPageToken;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of projects. */
export interface IProjectUsagePage {
    /** Page token for the next page of project usages. */
    nextPageToken?: string;
    /** The list of projects. */
    values?: ProjectUsage[];
}

/** Details about data policies for a project. */
export class ProjectWithDataPolicy implements IProjectWithDataPolicy {
    /** Data policy. */
    readonly dataPolicy?: ProjectDataPolicy;
    /** The project ID. */
    readonly id?: number;

    constructor(data?: IProjectWithDataPolicy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).dataPolicy = _data["dataPolicy"] ? ProjectDataPolicy.fromJS(_data["dataPolicy"]) : <any>undefined;
            (<any>this).id = _data["id"];
        }
    }

    static fromJS(data: any): ProjectWithDataPolicy {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectWithDataPolicy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataPolicy"] = this.dataPolicy ? this.dataPolicy.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

/** Details about data policies for a project. */
export interface IProjectWithDataPolicy {
    /** Data policy. */
    dataPolicy?: ProjectDataPolicy;
    /** The project ID. */
    id?: number;
}

/** Property key details. */
export class PropertyKey implements IPropertyKey {
    /** The key of the property. */
    readonly key?: string;
    /** The URL of the property. */
    readonly self?: string;

    constructor(data?: IPropertyKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).key = _data["key"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): PropertyKey {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["self"] = this.self;
        return data;
    }
}

/** Property key details. */
export interface IPropertyKey {
    /** The key of the property. */
    key?: string;
    /** The URL of the property. */
    self?: string;
}

/** List of property keys. */
export class PropertyKeys implements IPropertyKeys {
    /** Property key details. */
    readonly keys?: PropertyKey[];

    constructor(data?: IPropertyKeys) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["keys"])) {
                (<any>this).keys = [] as any;
                for (let item of _data["keys"])
                    (<any>this).keys!.push(PropertyKey.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PropertyKeys {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyKeys();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.keys)) {
            data["keys"] = [];
            for (let item of this.keys)
                data["keys"].push(item.toJSON());
        }
        return data;
    }
}

/** List of property keys. */
export interface IPropertyKeys {
    /** Property key details. */
    keys?: PropertyKey[];
}

/** Details about the status mappings for publishing a draft workflow scheme. */
export class PublishDraftWorkflowScheme implements IPublishDraftWorkflowScheme {
    /** Mappings of statuses to new statuses for issue types. */
    statusMappings?: StatusMapping[];

    constructor(data?: IPublishDraftWorkflowScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["statusMappings"])) {
                this.statusMappings = [] as any;
                for (let item of _data["statusMappings"])
                    this.statusMappings!.push(StatusMapping.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PublishDraftWorkflowScheme {
        data = typeof data === 'object' ? data : {};
        let result = new PublishDraftWorkflowScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.statusMappings)) {
            data["statusMappings"] = [];
            for (let item of this.statusMappings)
                data["statusMappings"].push(item.toJSON());
        }
        return data;
    }
}

/** Details about the status mappings for publishing a draft workflow scheme. */
export interface IPublishDraftWorkflowScheme {
    /** Mappings of statuses to new statuses for issue types. */
    statusMappings?: StatusMapping[];
}

/** Properties that identify a published workflow. */
export class PublishedWorkflowId implements IPublishedWorkflowId {
    /** The entity ID of the workflow. */
    entityId?: string;
    /** The name of the workflow. */
    name!: string;

    constructor(data?: IPublishedWorkflowId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PublishedWorkflowId {
        data = typeof data === 'object' ? data : {};
        let result = new PublishedWorkflowId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["name"] = this.name;
        return data;
    }
}

/** Properties that identify a published workflow. */
export interface IPublishedWorkflowId {
    /** The entity ID of the workflow. */
    entityId?: string;
    /** The name of the workflow. */
    name: string;
}

/** The payload for defining quick filters */
export class QuickFilterPayload implements IQuickFilterPayload {
    /** The description of the quick filter */
    description?: string;
    /** The jql query for the quick filter */
    jqlQuery?: string;
    /** The name of the quick filter */
    name?: string;

    constructor(data?: IQuickFilterPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.jqlQuery = _data["jqlQuery"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): QuickFilterPayload {
        data = typeof data === 'object' ? data : {};
        let result = new QuickFilterPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["jqlQuery"] = this.jqlQuery;
        data["name"] = this.name;
        return data;
    }
}

/** The payload for defining quick filters */
export interface IQuickFilterPayload {
    /** The description of the quick filter */
    description?: string;
    /** The jql query for the quick filter */
    jqlQuery?: string;
    /** The name of the quick filter */
    name?: string;
}

/** ID of a registered webhook or error messages explaining why a webhook wasn't registered. */
export class RegisteredWebhook implements IRegisteredWebhook {
    /** The ID of the webhook. Returned if the webhook is created. */
    createdWebhookId?: number;
    /** Error messages specifying why the webhook creation failed. */
    errors?: string[];

    constructor(data?: IRegisteredWebhook) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdWebhookId = _data["createdWebhookId"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): RegisteredWebhook {
        data = typeof data === 'object' ? data : {};
        let result = new RegisteredWebhook();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdWebhookId"] = this.createdWebhookId;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

/** ID of a registered webhook or error messages explaining why a webhook wasn't registered. */
export interface IRegisteredWebhook {
    /** The ID of the webhook. Returned if the webhook is created. */
    createdWebhookId?: number;
    /** Error messages specifying why the webhook creation failed. */
    errors?: string[];
}

/** Details of an issue remote link. */
export class RemoteIssueLink implements IRemoteIssueLink {
    /** Details of the remote application the linked item is in. */
    application?: Application;
    /** The global ID of the link, such as the ID of the item on the remote system. */
    globalId?: string;
    /** The ID of the link. */
    id?: number;
    /** Details of the item linked to. */
    object?: RemoteObject;
    /** Description of the relationship between the issue and the linked item. */
    relationship?: string;
    /** The URL of the link. */
    self?: string;

    constructor(data?: IRemoteIssueLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? Application.fromJS(_data["application"]) : <any>undefined;
            this.globalId = _data["globalId"];
            this.id = _data["id"];
            this.object = _data["object"] ? RemoteObject.fromJS(_data["object"]) : <any>undefined;
            this.relationship = _data["relationship"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): RemoteIssueLink {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteIssueLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["globalId"] = this.globalId;
        data["id"] = this.id;
        data["object"] = this.object ? this.object.toJSON() : <any>undefined;
        data["relationship"] = this.relationship;
        data["self"] = this.self;
        return data;
    }
}

/** Details of an issue remote link. */
export interface IRemoteIssueLink {
    /** Details of the remote application the linked item is in. */
    application?: Application;
    /** The global ID of the link, such as the ID of the item on the remote system. */
    globalId?: string;
    /** The ID of the link. */
    id?: number;
    /** Details of the item linked to. */
    object?: RemoteObject;
    /** Description of the relationship between the issue and the linked item. */
    relationship?: string;
    /** The URL of the link. */
    self?: string;
}

/** Details of the identifiers for a created or updated remote issue link. */
export class RemoteIssueLinkIdentifies implements IRemoteIssueLinkIdentifies {
    /** The ID of the remote issue link, such as the ID of the item on the remote system. */
    readonly id?: number;
    /** The URL of the remote issue link. */
    readonly self?: string;

    constructor(data?: IRemoteIssueLinkIdentifies) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): RemoteIssueLinkIdentifies {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteIssueLinkIdentifies();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["self"] = this.self;
        return data;
    }
}

/** Details of the identifiers for a created or updated remote issue link. */
export interface IRemoteIssueLinkIdentifies {
    /** The ID of the remote issue link, such as the ID of the item on the remote system. */
    id?: number;
    /** The URL of the remote issue link. */
    self?: string;
}

/** Details of a remote issue link. */
export class RemoteIssueLinkRequest implements IRemoteIssueLinkRequest {
    /** Details of the remote application the linked item is in. For example, trello. */
    application?: Application;
    /** An identifier for the remote item in the remote system. For example, the global ID for a remote item in Confluence would consist of the app ID and page ID, like this: `appId=456&pageId=123`.

Setting this field enables the remote issue link details to be updated or deleted using remote system and item details as the record identifier, rather than using the record's Jira ID.

The maximum length is 255 characters. */
    globalId?: string;
    /** Details of the item linked to. */
    object!: RemoteObject;
    /** Description of the relationship between the issue and the linked item. If not set, the relationship description "links to" is used in Jira. */
    relationship?: string;

    [key: string]: any;

    constructor(data?: IRemoteIssueLinkRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.object = new RemoteObject();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.application = _data["application"] ? Application.fromJS(_data["application"]) : <any>undefined;
            this.globalId = _data["globalId"];
            this.object = _data["object"] ? RemoteObject.fromJS(_data["object"]) : new RemoteObject();
            this.relationship = _data["relationship"];
        }
    }

    static fromJS(data: any): RemoteIssueLinkRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteIssueLinkRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["globalId"] = this.globalId;
        data["object"] = this.object ? this.object.toJSON() : <any>undefined;
        data["relationship"] = this.relationship;
        return data;
    }
}

/** Details of a remote issue link. */
export interface IRemoteIssueLinkRequest {
    /** Details of the remote application the linked item is in. For example, trello. */
    application?: Application;
    /** An identifier for the remote item in the remote system. For example, the global ID for a remote item in Confluence would consist of the app ID and page ID, like this: `appId=456&pageId=123`.

Setting this field enables the remote issue link details to be updated or deleted using remote system and item details as the record identifier, rather than using the record's Jira ID.

The maximum length is 255 characters. */
    globalId?: string;
    /** Details of the item linked to. */
    object: RemoteObject;
    /** Description of the relationship between the issue and the linked item. If not set, the relationship description "links to" is used in Jira. */
    relationship?: string;

    [key: string]: any;
}

/** The linked item. */
export class RemoteObject implements IRemoteObject {
    /** Details of the icon for the item. If no icon is defined, the default link icon is used in Jira. */
    icon?: Icon;
    /** The status of the item. */
    status?: Status;
    /** The summary details of the item. */
    summary?: string;
    /** The title of the item. */
    title!: string;
    /** The URL of the item. */
    url!: string;

    [key: string]: any;

    constructor(data?: IRemoteObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.icon = _data["icon"] ? Icon.fromJS(_data["icon"]) : <any>undefined;
            this.status = _data["status"] ? Status.fromJS(_data["status"]) : <any>undefined;
            this.summary = _data["summary"];
            this.title = _data["title"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): RemoteObject {
        data = typeof data === 'object' ? data : {};
        let result = new RemoteObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["icon"] = this.icon ? this.icon.toJSON() : <any>undefined;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["summary"] = this.summary;
        data["title"] = this.title;
        data["url"] = this.url;
        return data;
    }
}

/** The linked item. */
export interface IRemoteObject {
    /** Details of the icon for the item. If no icon is defined, the default link icon is used in Jira. */
    icon?: Icon;
    /** The status of the item. */
    status?: Status;
    /** The summary details of the item. */
    summary?: string;
    /** The title of the item. */
    title: string;
    /** The URL of the item. */
    url: string;

    [key: string]: any;
}

export class RemoveOptionFromIssuesResult implements IRemoveOptionFromIssuesResult {
    /** A collection of errors related to unchanged issues. The collection size is limited, which means not all errors may be returned. */
    errors?: SimpleErrorCollection;
    /** The IDs of the modified issues. */
    modifiedIssues?: number[];
    /** The IDs of the unchanged issues, those issues where errors prevent modification. */
    unmodifiedIssues?: number[];

    constructor(data?: IRemoveOptionFromIssuesResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errors = _data["errors"] ? SimpleErrorCollection.fromJS(_data["errors"]) : <any>undefined;
            if (Array.isArray(_data["modifiedIssues"])) {
                this.modifiedIssues = [] as any;
                for (let item of _data["modifiedIssues"])
                    this.modifiedIssues!.push(item);
            }
            if (Array.isArray(_data["unmodifiedIssues"])) {
                this.unmodifiedIssues = [] as any;
                for (let item of _data["unmodifiedIssues"])
                    this.unmodifiedIssues!.push(item);
            }
        }
    }

    static fromJS(data: any): RemoveOptionFromIssuesResult {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveOptionFromIssuesResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errors"] = this.errors ? this.errors.toJSON() : <any>undefined;
        if (Array.isArray(this.modifiedIssues)) {
            data["modifiedIssues"] = [];
            for (let item of this.modifiedIssues)
                data["modifiedIssues"].push(item);
        }
        if (Array.isArray(this.unmodifiedIssues)) {
            data["unmodifiedIssues"] = [];
            for (let item of this.unmodifiedIssues)
                data["unmodifiedIssues"].push(item);
        }
        return data;
    }
}

export interface IRemoveOptionFromIssuesResult {
    /** A collection of errors related to unchanged issues. The collection size is limited, which means not all errors may be returned. */
    errors?: SimpleErrorCollection;
    /** The IDs of the modified issues. */
    modifiedIssues?: number[];
    /** The IDs of the unchanged issues, those issues where errors prevent modification. */
    unmodifiedIssues?: number[];
}

/** Change the order of issue priorities. */
export class ReorderIssuePriorities implements IReorderIssuePriorities {
    /** The ID of the priority. Required if `position` isn't provided. */
    after?: string;
    /** The list of issue IDs to be reordered. Cannot contain duplicates nor after ID. */
    ids!: string[];
    /** The position for issue priorities to be moved to. Required if `after` isn't provided. */
    position?: string;

    constructor(data?: IReorderIssuePriorities) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.after = _data["after"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): ReorderIssuePriorities {
        data = typeof data === 'object' ? data : {};
        let result = new ReorderIssuePriorities();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["after"] = this.after;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["position"] = this.position;
        return data;
    }
}

/** Change the order of issue priorities. */
export interface IReorderIssuePriorities {
    /** The ID of the priority. Required if `position` isn't provided. */
    after?: string;
    /** The list of issue IDs to be reordered. Cannot contain duplicates nor after ID. */
    ids: string[];
    /** The position for issue priorities to be moved to. Required if `after` isn't provided. */
    position?: string;
}

/** Change the order of issue resolutions. */
export class ReorderIssueResolutionsRequest implements IReorderIssueResolutionsRequest {
    /** The ID of the resolution. Required if `position` isn't provided. */
    after?: string;
    /** The list of resolution IDs to be reordered. Cannot contain duplicates nor after ID. */
    ids!: string[];
    /** The position for issue resolutions to be moved to. Required if `after` isn't provided. */
    position?: string;

    constructor(data?: IReorderIssueResolutionsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.after = _data["after"];
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): ReorderIssueResolutionsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ReorderIssueResolutionsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["after"] = this.after;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["position"] = this.position;
        return data;
    }
}

/** Change the order of issue resolutions. */
export interface IReorderIssueResolutionsRequest {
    /** The ID of the resolution. Required if `position` isn't provided. */
    after?: string;
    /** The list of resolution IDs to be reordered. Cannot contain duplicates nor after ID. */
    ids: string[];
    /** The position for issue resolutions to be moved to. Required if `after` isn't provided. */
    position?: string;
}

/** The list of required status mappings by issue type. */
export class RequiredMappingByIssueType implements IRequiredMappingByIssueType {
    /** The ID of the issue type. */
    issueTypeId?: string;
    /** The status IDs requiring mapping. */
    statusIds?: string[];

    constructor(data?: IRequiredMappingByIssueType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueTypeId = _data["issueTypeId"];
            if (Array.isArray(_data["statusIds"])) {
                this.statusIds = [] as any;
                for (let item of _data["statusIds"])
                    this.statusIds!.push(item);
            }
        }
    }

    static fromJS(data: any): RequiredMappingByIssueType {
        data = typeof data === 'object' ? data : {};
        let result = new RequiredMappingByIssueType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueTypeId"] = this.issueTypeId;
        if (Array.isArray(this.statusIds)) {
            data["statusIds"] = [];
            for (let item of this.statusIds)
                data["statusIds"].push(item);
        }
        return data;
    }
}

/** The list of required status mappings by issue type. */
export interface IRequiredMappingByIssueType {
    /** The ID of the issue type. */
    issueTypeId?: string;
    /** The status IDs requiring mapping. */
    statusIds?: string[];
}

/** The list of required status mappings by workflow. */
export class RequiredMappingByWorkflows implements IRequiredMappingByWorkflows {
    /** The ID of the source workflow. */
    sourceWorkflowId?: string;
    /** The status IDs requiring mapping. */
    statusIds?: string[];
    /** The ID of the target workflow. */
    targetWorkflowId?: string;

    constructor(data?: IRequiredMappingByWorkflows) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceWorkflowId = _data["sourceWorkflowId"];
            if (Array.isArray(_data["statusIds"])) {
                this.statusIds = [] as any;
                for (let item of _data["statusIds"])
                    this.statusIds!.push(item);
            }
            this.targetWorkflowId = _data["targetWorkflowId"];
        }
    }

    static fromJS(data: any): RequiredMappingByWorkflows {
        data = typeof data === 'object' ? data : {};
        let result = new RequiredMappingByWorkflows();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceWorkflowId"] = this.sourceWorkflowId;
        if (Array.isArray(this.statusIds)) {
            data["statusIds"] = [];
            for (let item of this.statusIds)
                data["statusIds"].push(item);
        }
        data["targetWorkflowId"] = this.targetWorkflowId;
        return data;
    }
}

/** The list of required status mappings by workflow. */
export interface IRequiredMappingByWorkflows {
    /** The ID of the source workflow. */
    sourceWorkflowId?: string;
    /** The status IDs requiring mapping. */
    statusIds?: string[];
    /** The ID of the target workflow. */
    targetWorkflowId?: string;
}

/** Details of an issue resolution. */
export class Resolution implements IResolution {
    /** The description of the issue resolution. */
    description?: string;
    /** The ID of the issue resolution. */
    id?: string;
    /** The name of the issue resolution. */
    name?: string;
    /** The URL of the issue resolution. */
    self?: string;

    constructor(data?: IResolution) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): Resolution {
        data = typeof data === 'object' ? data : {};
        let result = new Resolution();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

/** Details of an issue resolution. */
export interface IResolution {
    /** The description of the issue resolution. */
    description?: string;
    /** The ID of the issue resolution. */
    id?: string;
    /** The name of the issue resolution. */
    name?: string;
    /** The URL of the issue resolution. */
    self?: string;
}

/** The ID of an issue resolution. */
export class ResolutionId implements IResolutionId {
    /** The ID of the issue resolution. */
    readonly id!: string;

    [key: string]: any;

    constructor(data?: IResolutionId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).id = _data["id"];
        }
    }

    static fromJS(data: any): ResolutionId {
        data = typeof data === 'object' ? data : {};
        let result = new ResolutionId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }
}

/** The ID of an issue resolution. */
export interface IResolutionId {
    /** The ID of the issue resolution. */
    id: string;

    [key: string]: any;
}

export class ResolutionJsonBean implements IResolutionJsonBean {
    default?: boolean;
    description?: string;
    iconUrl?: string;
    id?: string;
    name?: string;
    self?: string;

    constructor(data?: IResolutionJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.default = _data["default"];
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): ResolutionJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new ResolutionJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["default"] = this.default;
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

export interface IResolutionJsonBean {
    default?: boolean;
    description?: string;
    iconUrl?: string;
    id?: string;
    name?: string;
    self?: string;
}

export class Resource implements IResource {
    description?: string;
    file?: string;
    filename?: string;
    inputStream?: any;
    open?: boolean;
    readable?: boolean;
    uri?: string;
    url?: string;

    constructor(data?: IResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.file = _data["file"];
            this.filename = _data["filename"];
            this.inputStream = _data["inputStream"];
            this.open = _data["open"];
            this.readable = _data["readable"];
            this.uri = _data["uri"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): Resource {
        data = typeof data === 'object' ? data : {};
        let result = new Resource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["file"] = this.file;
        data["filename"] = this.filename;
        data["inputStream"] = this.inputStream;
        data["open"] = this.open;
        data["readable"] = this.readable;
        data["uri"] = this.uri;
        data["url"] = this.url;
        return data;
    }
}

export interface IResource {
    description?: string;
    file?: string;
    filename?: string;
    inputStream?: any;
    open?: boolean;
    readable?: boolean;
    uri?: string;
    url?: string;
}

/** Details of the permission. */
export class RestrictedPermission implements IRestrictedPermission {
    /** The ID of the permission. Either `id` or `key` must be specified. Use [Get all permissions](#api-rest-api-3-permissions-get) to get the list of permissions. */
    id?: string;
    /** The key of the permission. Either `id` or `key` must be specified. Use [Get all permissions](#api-rest-api-3-permissions-get) to get the list of permissions. */
    key?: string;

    [key: string]: any;

    constructor(data?: IRestrictedPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): RestrictedPermission {
        data = typeof data === 'object' ? data : {};
        let result = new RestrictedPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["key"] = this.key;
        return data;
    }
}

/** Details of the permission. */
export interface IRestrictedPermission {
    /** The ID of the permission. Either `id` or `key` must be specified. Use [Get all permissions](#api-rest-api-3-permissions-get) to get the list of permissions. */
    id?: string;
    /** The key of the permission. Either `id` or `key` must be specified. Use [Get all permissions](#api-rest-api-3-permissions-get) to get the list of permissions. */
    key?: string;

    [key: string]: any;
}

export class RichText implements IRichText {
    empty?: boolean;
    emptyAdf?: boolean;
    finalised?: boolean;
    valueSet?: boolean;

    [key: string]: any;

    constructor(data?: IRichText) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.empty = _data["empty"];
            this.emptyAdf = _data["emptyAdf"];
            this.finalised = _data["finalised"];
            this.valueSet = _data["valueSet"];
        }
    }

    static fromJS(data: any): RichText {
        data = typeof data === 'object' ? data : {};
        let result = new RichText();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["empty"] = this.empty;
        data["emptyAdf"] = this.emptyAdf;
        data["finalised"] = this.finalised;
        data["valueSet"] = this.valueSet;
        return data;
    }
}

export interface IRichText {
    empty?: boolean;
    emptyAdf?: boolean;
    finalised?: boolean;
    valueSet?: boolean;

    [key: string]: any;
}

/** Details about a user assigned to a project role. */
export class RoleActor implements IRoleActor {
    readonly actorGroup?: ProjectRoleGroup;
    readonly actorUser?: ProjectRoleUser;
    /** The avatar of the role actor. */
    readonly avatarUrl?: string;
    /** The display name of the role actor. For users, depending on the user’s privacy setting, this may return an alternative value for the user's name. */
    readonly displayName?: string;
    /** The ID of the role actor. */
    readonly id?: number;
    /** This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    readonly name?: string;
    /** The type of role actor. */
    readonly type?: RoleActorType;

    constructor(data?: IRoleActor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).actorGroup = _data["actorGroup"] ? ProjectRoleGroup.fromJS(_data["actorGroup"]) : <any>undefined;
            (<any>this).actorUser = _data["actorUser"] ? ProjectRoleUser.fromJS(_data["actorUser"]) : <any>undefined;
            (<any>this).avatarUrl = _data["avatarUrl"];
            (<any>this).displayName = _data["displayName"];
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            (<any>this).type = _data["type"];
        }
    }

    static fromJS(data: any): RoleActor {
        data = typeof data === 'object' ? data : {};
        let result = new RoleActor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actorGroup"] = this.actorGroup ? this.actorGroup.toJSON() : <any>undefined;
        data["actorUser"] = this.actorUser ? this.actorUser.toJSON() : <any>undefined;
        data["avatarUrl"] = this.avatarUrl;
        data["displayName"] = this.displayName;
        data["id"] = this.id;
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

/** Details about a user assigned to a project role. */
export interface IRoleActor {
    actorGroup?: ProjectRoleGroup;
    actorUser?: ProjectRoleUser;
    /** The avatar of the role actor. */
    avatarUrl?: string;
    /** The display name of the role actor. For users, depending on the user’s privacy setting, this may return an alternative value for the user's name. */
    displayName?: string;
    /** The ID of the role actor. */
    id?: number;
    /** This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    name?: string;
    /** The type of role actor. */
    type?: RoleActorType;
}

/** The payload used to create a project role. It is optional for CMP projects, as a default role actor will be provided. TMP will add new role actors to the table. */
export class RolePayload implements IRolePayload {
    /** The default actors for the role. By adding default actors, the role will be added to any future projects created */
    defaultActors?: ProjectCreateResourceIdentifier[];
    /** The description of the role */
    description?: string;
    /** The name of the role */
    name?: string;
    /** The strategy to use when there is a conflict with an existing project role. FAIL - Fail execution, this always needs to be unique; USE - Use the existing entity and ignore new entity parameters */
    onConflict?: RolePayloadOnConflict;
    pcri?: ProjectCreateResourceIdentifier;
    /** The type of the role. Only used by project-scoped project */
    type?: RolePayloadType;

    constructor(data?: IRolePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.onConflict = RolePayloadOnConflict.USE;
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["defaultActors"])) {
                this.defaultActors = [] as any;
                for (let item of _data["defaultActors"])
                    this.defaultActors!.push(ProjectCreateResourceIdentifier.fromJS(item));
            }
            this.description = _data["description"];
            this.name = _data["name"];
            this.onConflict = _data["onConflict"] !== undefined ? _data["onConflict"] : RolePayloadOnConflict.USE;
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): RolePayload {
        data = typeof data === 'object' ? data : {};
        let result = new RolePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.defaultActors)) {
            data["defaultActors"] = [];
            for (let item of this.defaultActors)
                data["defaultActors"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["name"] = this.name;
        data["onConflict"] = this.onConflict;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

/** The payload used to create a project role. It is optional for CMP projects, as a default role actor will be provided. TMP will add new role actors to the table. */
export interface IRolePayload {
    /** The default actors for the role. By adding default actors, the role will be added to any future projects created */
    defaultActors?: ProjectCreateResourceIdentifier[];
    /** The description of the role */
    description?: string;
    /** The name of the role */
    name?: string;
    /** The strategy to use when there is a conflict with an existing project role. FAIL - Fail execution, this always needs to be unique; USE - Use the existing entity and ignore new entity parameters */
    onConflict?: RolePayloadOnConflict;
    pcri?: ProjectCreateResourceIdentifier;
    /** The type of the role. Only used by project-scoped project */
    type?: RolePayloadType;
}

export class RolesCapabilityPayload implements IRolesCapabilityPayload {
    /** A map of role PCRI (can be ID or REF) to a list of user or group PCRI IDs to associate with the role and project. */
    roleToProjectActors?: { [key: string]: ProjectCreateResourceIdentifier[]; };
    /** The list of roles to create. */
    roles?: RolePayload[];

    constructor(data?: IRolesCapabilityPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["roleToProjectActors"]) {
                this.roleToProjectActors = {} as any;
                for (let key in _data["roleToProjectActors"]) {
                    if (_data["roleToProjectActors"].hasOwnProperty(key))
                        (<any>this.roleToProjectActors)![key] = _data["roleToProjectActors"][key] ? _data["roleToProjectActors"][key].map((i: any) => ProjectCreateResourceIdentifier.fromJS(i)) : [];
                }
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(RolePayload.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RolesCapabilityPayload {
        data = typeof data === 'object' ? data : {};
        let result = new RolesCapabilityPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.roleToProjectActors) {
            data["roleToProjectActors"] = {};
            for (let key in this.roleToProjectActors) {
                if (this.roleToProjectActors.hasOwnProperty(key))
                    (<any>data["roleToProjectActors"])[key] = (<any>this.roleToProjectActors)[key];
            }
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRolesCapabilityPayload {
    /** A map of role PCRI (can be ID or REF) to a list of user or group PCRI IDs to associate with the role and project. */
    roleToProjectActors?: { [key: string]: ProjectCreateResourceIdentifier[]; };
    /** The list of roles to create. */
    roles?: RolePayload[];
}

/** A rule configuration. */
export class RuleConfiguration implements IRuleConfiguration {
    /** Whether the rule is disabled. */
    disabled?: boolean;
    /** A tag used to filter rules in [Get workflow transition rule configurations](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-workflow-transition-rules/#api-rest-api-3-workflow-rule-config-get). */
    tag?: string;
    /** Configuration of the rule, as it is stored by the Connect or the Forge app on the rule configuration page. */
    value!: string;

    constructor(data?: IRuleConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.disabled = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.disabled = _data["disabled"] !== undefined ? _data["disabled"] : false;
            this.tag = _data["tag"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): RuleConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new RuleConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["disabled"] = this.disabled;
        data["tag"] = this.tag;
        data["value"] = this.value;
        return data;
    }
}

/** A rule configuration. */
export interface IRuleConfiguration {
    /** Whether the rule is disabled. */
    disabled?: boolean;
    /** A tag used to filter rules in [Get workflow transition rule configurations](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-workflow-transition-rules/#api-rest-api-3-workflow-rule-config-get). */
    tag?: string;
    /** Configuration of the rule, as it is stored by the Connect or the Forge app on the rule configuration page. */
    value: string;
}

/** The payload for creating rules in a workflow */
export class RulePayload implements IRulePayload {
    /** The parameters of the rule */
    parameters?: { [key: string]: string; };
    /** The key of the rule. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-workflows/\#api-rest-api-3-workflows-capabilities-get */
    ruleKey?: string;

    constructor(data?: IRulePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["parameters"]) {
                this.parameters = {} as any;
                for (let key in _data["parameters"]) {
                    if (_data["parameters"].hasOwnProperty(key))
                        (<any>this.parameters)![key] = _data["parameters"][key];
                }
            }
            this.ruleKey = _data["ruleKey"];
        }
    }

    static fromJS(data: any): RulePayload {
        data = typeof data === 'object' ? data : {};
        let result = new RulePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.parameters) {
            data["parameters"] = {};
            for (let key in this.parameters) {
                if (this.parameters.hasOwnProperty(key))
                    (<any>data["parameters"])[key] = (<any>this.parameters)[key];
            }
        }
        data["ruleKey"] = this.ruleKey;
        return data;
    }
}

/** The payload for creating rules in a workflow */
export interface IRulePayload {
    /** The parameters of the rule */
    parameters?: { [key: string]: string; };
    /** The key of the rule. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-workflows/\#api-rest-api-3-workflows-capabilities-get */
    ruleKey?: string;
}

/** The sanitized JQL queries for the given account IDs. */
export class SanitizedJqlQueries implements ISanitizedJqlQueries {
    /** The list of sanitized JQL queries. */
    queries?: SanitizedJqlQuery[];

    constructor(data?: ISanitizedJqlQueries) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["queries"])) {
                this.queries = [] as any;
                for (let item of _data["queries"])
                    this.queries!.push(SanitizedJqlQuery.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SanitizedJqlQueries {
        data = typeof data === 'object' ? data : {};
        let result = new SanitizedJqlQueries();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queries)) {
            data["queries"] = [];
            for (let item of this.queries)
                data["queries"].push(item.toJSON());
        }
        return data;
    }
}

/** The sanitized JQL queries for the given account IDs. */
export interface ISanitizedJqlQueries {
    /** The list of sanitized JQL queries. */
    queries?: SanitizedJqlQuery[];
}

/** Details of the sanitized JQL query. */
export class SanitizedJqlQuery implements ISanitizedJqlQuery {
    /** The account ID of the user for whom sanitization was performed. */
    accountId?: string | undefined;
    /** The list of errors. */
    errors?: ErrorCollection;
    /** The initial query. */
    initialQuery?: string;
    /** The sanitized query, if there were no errors. */
    sanitizedQuery?: string | undefined;

    constructor(data?: ISanitizedJqlQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.errors = _data["errors"] ? ErrorCollection.fromJS(_data["errors"]) : <any>undefined;
            this.initialQuery = _data["initialQuery"];
            this.sanitizedQuery = _data["sanitizedQuery"];
        }
    }

    static fromJS(data: any): SanitizedJqlQuery {
        data = typeof data === 'object' ? data : {};
        let result = new SanitizedJqlQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["errors"] = this.errors ? this.errors.toJSON() : <any>undefined;
        data["initialQuery"] = this.initialQuery;
        data["sanitizedQuery"] = this.sanitizedQuery;
        return data;
    }
}

/** Details of the sanitized JQL query. */
export interface ISanitizedJqlQuery {
    /** The account ID of the user for whom sanitization was performed. */
    accountId?: string | undefined;
    /** The list of errors. */
    errors?: ErrorCollection;
    /** The initial query. */
    initialQuery?: string;
    /** The sanitized query, if there were no errors. */
    sanitizedQuery?: string | undefined;
}

/** The projects the item is associated with. Indicated for items associated with [next-gen projects](https://confluence.atlassian.com/x/loMyO). */
export class Scope implements IScope {
    /** The project the item has scope in. */
    readonly project?: ProjectDetails;
    /** The type of scope. */
    readonly type?: ScopeType;

    [key: string]: any;

    constructor(data?: IScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).project = _data["project"] ? ProjectDetails.fromJS(_data["project"]) : <any>undefined;
            (<any>this).type = _data["type"];
        }
    }

    static fromJS(data: any): Scope {
        data = typeof data === 'object' ? data : {};
        let result = new Scope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

/** The projects the item is associated with. Indicated for items associated with [next-gen projects](https://confluence.atlassian.com/x/loMyO). */
export interface IScope {
    /** The project the item has scope in. */
    project?: ProjectDetails;
    /** The type of scope. */
    type?: ScopeType;

    [key: string]: any;
}

/** The payload for creating a scope. Defines if a project is team-managed project or company-managed project */
export class ScopePayload implements IScopePayload {
    /** The type of the scope. Use `GLOBAL` or empty for company-managed project, and `PROJECT` for team-managed project */
    type?: ScopePayloadType;

    constructor(data?: IScopePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ScopePayload {
        data = typeof data === 'object' ? data : {};
        let result = new ScopePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        return data;
    }
}

/** The payload for creating a scope. Defines if a project is team-managed project or company-managed project */
export interface IScopePayload {
    /** The type of the scope. Use `GLOBAL` or empty for company-managed project, and `PROJECT` for team-managed project */
    type?: ScopePayloadType;
}

/** A screen. */
export class Screen implements IScreen {
    /** The description of the screen. */
    readonly description?: string;
    /** The ID of the screen. */
    readonly id?: number;
    /** The name of the screen. */
    readonly name?: string;
    /** The scope of the screen. */
    scope?: Scope;

    constructor(data?: IScreen) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).description = _data["description"];
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            this.scope = _data["scope"] ? Scope.fromJS(_data["scope"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Screen {
        data = typeof data === 'object' ? data : {};
        let result = new Screen();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        return data;
    }
}

/** A screen. */
export interface IScreen {
    /** The description of the screen. */
    description?: string;
    /** The ID of the screen. */
    id?: number;
    /** The name of the screen. */
    name?: string;
    /** The scope of the screen. */
    scope?: Scope;
}

/** Details of a screen. */
export class ScreenDetails implements IScreenDetails {
    /** The description of the screen. The maximum length is 255 characters. */
    description?: string;
    /** The name of the screen. The name must be unique. The maximum length is 255 characters. */
    name!: string;

    constructor(data?: IScreenDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ScreenDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ScreenDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

/** Details of a screen. */
export interface IScreenDetails {
    /** The description of the screen. The maximum length is 255 characters. */
    description?: string;
    /** The name of the screen. The name must be unique. The maximum length is 255 characters. */
    name: string;
}

/** Defines the payload for the field screens. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-screens/\#api-rest-api-3-screens-post */
export class ScreenPayload implements IScreenPayload {
    /** The description of the screen */
    description?: string;
    /** The name of the screen */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;
    /** The tabs of the screen. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-screen-tab-fields/\#api-rest-api-3-screens-screenid-tabs-tabid-fields-post */
    tabs?: TabPayload[];

    constructor(data?: IScreenPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
            if (Array.isArray(_data["tabs"])) {
                this.tabs = [] as any;
                for (let item of _data["tabs"])
                    this.tabs!.push(TabPayload.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ScreenPayload {
        data = typeof data === 'object' ? data : {};
        let result = new ScreenPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        if (Array.isArray(this.tabs)) {
            data["tabs"] = [];
            for (let item of this.tabs)
                data["tabs"].push(item.toJSON());
        }
        return data;
    }
}

/** Defines the payload for the field screens. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-screens/\#api-rest-api-3-screens-post */
export interface IScreenPayload {
    /** The description of the screen */
    description?: string;
    /** The name of the screen */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;
    /** The tabs of the screen. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-screen-tab-fields/\#api-rest-api-3-screens-screenid-tabs-tabid-fields-post */
    tabs?: TabPayload[];
}

/** A screen scheme. */
export class ScreenScheme implements IScreenScheme {
    /** The description of the screen scheme. */
    description?: string;
    /** The ID of the screen scheme. */
    id?: number;
    /** Details of the issue type screen schemes associated with the screen scheme. */
    issueTypeScreenSchemes?: PageBeanIssueTypeScreenScheme;
    /** The name of the screen scheme. */
    name?: string;
    /** The IDs of the screens for the screen types of the screen scheme. */
    screens?: ScreenTypes;

    constructor(data?: IScreenScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.id = _data["id"];
            this.issueTypeScreenSchemes = _data["issueTypeScreenSchemes"] ? PageBeanIssueTypeScreenScheme.fromJS(_data["issueTypeScreenSchemes"]) : <any>undefined;
            this.name = _data["name"];
            this.screens = _data["screens"] ? ScreenTypes.fromJS(_data["screens"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ScreenScheme {
        data = typeof data === 'object' ? data : {};
        let result = new ScreenScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["issueTypeScreenSchemes"] = this.issueTypeScreenSchemes ? this.issueTypeScreenSchemes.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["screens"] = this.screens ? this.screens.toJSON() : <any>undefined;
        return data;
    }
}

/** A screen scheme. */
export interface IScreenScheme {
    /** The description of the screen scheme. */
    description?: string;
    /** The ID of the screen scheme. */
    id?: number;
    /** Details of the issue type screen schemes associated with the screen scheme. */
    issueTypeScreenSchemes?: PageBeanIssueTypeScreenScheme;
    /** The name of the screen scheme. */
    name?: string;
    /** The IDs of the screens for the screen types of the screen scheme. */
    screens?: ScreenTypes;
}

/** Details of a screen scheme. */
export class ScreenSchemeDetails implements IScreenSchemeDetails {
    /** The description of the screen scheme. The maximum length is 255 characters. */
    description?: string;
    /** The name of the screen scheme. The name must be unique. The maximum length is 255 characters. */
    name!: string;
    /** The IDs of the screens for the screen types of the screen scheme. Only screens used in classic projects are accepted. */
    screens!: ScreenTypes;

    constructor(data?: IScreenSchemeDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.screens = new ScreenTypes();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
            this.screens = _data["screens"] ? ScreenTypes.fromJS(_data["screens"]) : new ScreenTypes();
        }
    }

    static fromJS(data: any): ScreenSchemeDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ScreenSchemeDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        data["screens"] = this.screens ? this.screens.toJSON() : <any>undefined;
        return data;
    }
}

/** Details of a screen scheme. */
export interface IScreenSchemeDetails {
    /** The description of the screen scheme. The maximum length is 255 characters. */
    description?: string;
    /** The name of the screen scheme. The name must be unique. The maximum length is 255 characters. */
    name: string;
    /** The IDs of the screens for the screen types of the screen scheme. Only screens used in classic projects are accepted. */
    screens: ScreenTypes;
}

/** The ID of a screen scheme. */
export class ScreenSchemeId implements IScreenSchemeId {
    /** The ID of the screen scheme. */
    readonly id!: number;

    constructor(data?: IScreenSchemeId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
        }
    }

    static fromJS(data: any): ScreenSchemeId {
        data = typeof data === 'object' ? data : {};
        let result = new ScreenSchemeId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** The ID of a screen scheme. */
export interface IScreenSchemeId {
    /** The ID of the screen scheme. */
    id: number;
}

/** Defines the payload for the screen schemes. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-screen-schemes/\#api-rest-api-3-screenscheme-post */
export class ScreenSchemePayload implements IScreenSchemePayload {
    defaultScreen?: ProjectCreateResourceIdentifier;
    /** The description of the screen scheme */
    description?: string;
    /** The name of the screen scheme */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;
    /** Similar to the field layout scheme those mappings allow users to set different screens for different operations: default - always there, applied to all operations that don't have an explicit mapping `create`, `view`, `edit` - specific operations that are available and users can assign a different screen for each one of them https://support.atlassian.com/jira-cloud-administration/docs/manage-screen-schemes/\#Associating-a-screen-with-an-issue-operation */
    screens?: { [key: string]: ProjectCreateResourceIdentifier; };

    constructor(data?: IScreenSchemePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultScreen = _data["defaultScreen"] ? ProjectCreateResourceIdentifier.fromJS(_data["defaultScreen"]) : <any>undefined;
            this.description = _data["description"];
            this.name = _data["name"];
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
            if (_data["screens"]) {
                this.screens = {} as any;
                for (let key in _data["screens"]) {
                    if (_data["screens"].hasOwnProperty(key))
                        (<any>this.screens)![key] = _data["screens"][key] ? ProjectCreateResourceIdentifier.fromJS(_data["screens"][key]) : new ProjectCreateResourceIdentifier();
                }
            }
        }
    }

    static fromJS(data: any): ScreenSchemePayload {
        data = typeof data === 'object' ? data : {};
        let result = new ScreenSchemePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultScreen"] = this.defaultScreen ? this.defaultScreen.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["name"] = this.name;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        if (this.screens) {
            data["screens"] = {};
            for (let key in this.screens) {
                if (this.screens.hasOwnProperty(key))
                    (<any>data["screens"])[key] = this.screens[key] ? this.screens[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Defines the payload for the screen schemes. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-screen-schemes/\#api-rest-api-3-screenscheme-post */
export interface IScreenSchemePayload {
    defaultScreen?: ProjectCreateResourceIdentifier;
    /** The description of the screen scheme */
    description?: string;
    /** The name of the screen scheme */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;
    /** Similar to the field layout scheme those mappings allow users to set different screens for different operations: default - always there, applied to all operations that don't have an explicit mapping `create`, `view`, `edit` - specific operations that are available and users can assign a different screen for each one of them https://support.atlassian.com/jira-cloud-administration/docs/manage-screen-schemes/\#Associating-a-screen-with-an-issue-operation */
    screens?: { [key: string]: ProjectCreateResourceIdentifier; };
}

/** The IDs of the screens for the screen types of the screen scheme. */
export class ScreenTypes implements IScreenTypes {
    /** The ID of the create screen. */
    create?: number;
    /** The ID of the default screen. Required when creating a screen scheme. */
    default!: number;
    /** The ID of the edit screen. */
    edit?: number;
    /** The ID of the view screen. */
    view?: number;

    constructor(data?: IScreenTypes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.create = _data["create"];
            this.default = _data["default"];
            this.edit = _data["edit"];
            this.view = _data["view"];
        }
    }

    static fromJS(data: any): ScreenTypes {
        data = typeof data === 'object' ? data : {};
        let result = new ScreenTypes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["create"] = this.create;
        data["default"] = this.default;
        data["edit"] = this.edit;
        data["view"] = this.view;
        return data;
    }
}

/** The IDs of the screens for the screen types of the screen scheme. */
export interface IScreenTypes {
    /** The ID of the create screen. */
    create?: number;
    /** The ID of the default screen. Required when creating a screen scheme. */
    default: number;
    /** The ID of the edit screen. */
    edit?: number;
    /** The ID of the view screen. */
    view?: number;
}

/** A screen with tab details. */
export class ScreenWithTab implements IScreenWithTab {
    /** The description of the screen. */
    readonly description?: string;
    /** The ID of the screen. */
    readonly id?: number;
    /** The name of the screen. */
    readonly name?: string;
    /** The scope of the screen. */
    scope?: Scope;
    /** The tab for the screen. */
    tab?: ScreenableTab;

    constructor(data?: IScreenWithTab) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).description = _data["description"];
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            this.scope = _data["scope"] ? Scope.fromJS(_data["scope"]) : <any>undefined;
            this.tab = _data["tab"] ? ScreenableTab.fromJS(_data["tab"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ScreenWithTab {
        data = typeof data === 'object' ? data : {};
        let result = new ScreenWithTab();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        data["tab"] = this.tab ? this.tab.toJSON() : <any>undefined;
        return data;
    }
}

/** A screen with tab details. */
export interface IScreenWithTab {
    /** The description of the screen. */
    description?: string;
    /** The ID of the screen. */
    id?: number;
    /** The name of the screen. */
    name?: string;
    /** The scope of the screen. */
    scope?: Scope;
    /** The tab for the screen. */
    tab?: ScreenableTab;
}

/** A screen tab field. */
export class ScreenableField implements IScreenableField {
    /** The ID of the screen tab field. */
    readonly id?: string;
    /** The name of the screen tab field. Required on create and update. The maximum length is 255 characters. */
    name?: string;

    constructor(data?: IScreenableField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ScreenableField {
        data = typeof data === 'object' ? data : {};
        let result = new ScreenableField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** A screen tab field. */
export interface IScreenableField {
    /** The ID of the screen tab field. */
    id?: string;
    /** The name of the screen tab field. Required on create and update. The maximum length is 255 characters. */
    name?: string;
}

/** A screen tab. */
export class ScreenableTab implements IScreenableTab {
    /** The ID of the screen tab. */
    readonly id?: number;
    /** The name of the screen tab. The maximum length is 255 characters. */
    name!: string;

    constructor(data?: IScreenableTab) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ScreenableTab {
        data = typeof data === 'object' ? data : {};
        let result = new ScreenableTab();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** A screen tab. */
export interface IScreenableTab {
    /** The ID of the screen tab. */
    id?: number;
    /** The name of the screen tab. The maximum length is 255 characters. */
    name: string;
}

export class SearchAndReconcileRequestBean implements ISearchAndReconcileRequestBean {
    /** Use [expand](#expansion) to include additional information about issues in the response. Note that, unlike the majority of instances where `expand` is specified, `expand` is defined as a comma-delimited string of values. The expand options are:

 *  `renderedFields` Returns field values rendered in HTML format.
 *  `names` Returns the display name of each field.
 *  `schema` Returns the schema describing a field type.
 *  `transitions` Returns all possible transitions for the issue.
 *  `operations` Returns all possible operations for the issue.
 *  `editmeta` Returns information about how each field can be edited.
 *  `changelog` Returns a list of recent updates to an issue, sorted by date, starting from the most recent.
 *  `versionedRepresentations` Instead of `fields`, returns `versionedRepresentations` a JSON array containing each version of a field's value, with the highest numbered item representing the most recent version.

Examples: `"names,changelog"` Returns the display name of each field as well as a list of recent updates to an issue. */
    expand?: string;
    /** A list of fields to return for each issue. Use it to retrieve a subset of fields. This parameter accepts a comma-separated list. Expand options include:

 *  `*all` Returns all fields.
 *  `*navigable` Returns navigable fields.
 *  `id` Returns only issue IDs.
 *  Any issue field, prefixed with a dash to exclude.

The default is `id`.

Examples:

 *  `summary,comment` Returns the summary and comments fields only.
 *  `*all,-comment` Returns all fields except comments.

Multiple `fields` parameters can be included in a request.

Note: By default, this resource returns IDs only. This differs from [GET issue](#api-rest-api-3-issue-issueIdOrKey-get) where the default is all fields. */
    fields?: string[];
    /** Reference fields by their key (rather than ID). The default is `false`. */
    fieldsByKeys?: boolean;
    /** A [JQL](https://confluence.atlassian.com/x/egORLQ) expression. For performance reasons, this parameter requires a bounded query. A bounded query is a query with a search restriction.

 *  Example of an unbounded query: `order by key desc`.
 *  Example of a bounded query: `assignee = currentUser() order by key`.

Additionally, `orderBy` clause can contain a maximum of 7 fields. */
    jql?: string;
    /** The maximum number of items to return per page. To manage page size, API may return fewer items per page where a large number of fields are requested. The greatest number of items returned per page is achieved when requesting `id` or `key` only. It returns max 5000 issues. */
    maxResults?: number;
    /** The token for a page to fetch that is not the first page. The first page has a `nextPageToken` of `null`. Use the `nextPageToken` to fetch the next page of issues. */
    nextPageToken?: string;
    /** A list of up to 5 issue properties to include in the results. This parameter accepts a comma-separated list. */
    properties?: string[];
    /** Strong consistency issue ids to be reconciled with search results. Accepts max 50 ids */
    reconcileIssues?: number[];

    constructor(data?: ISearchAndReconcileRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.maxResults = 50;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expand = _data["expand"];
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(item);
            }
            this.fieldsByKeys = _data["fieldsByKeys"];
            this.jql = _data["jql"];
            this.maxResults = _data["maxResults"] !== undefined ? _data["maxResults"] : 50;
            this.nextPageToken = _data["nextPageToken"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(item);
            }
            if (Array.isArray(_data["reconcileIssues"])) {
                this.reconcileIssues = [] as any;
                for (let item of _data["reconcileIssues"])
                    this.reconcileIssues!.push(item);
            }
        }
    }

    static fromJS(data: any): SearchAndReconcileRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new SearchAndReconcileRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expand"] = this.expand;
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item);
        }
        data["fieldsByKeys"] = this.fieldsByKeys;
        data["jql"] = this.jql;
        data["maxResults"] = this.maxResults;
        data["nextPageToken"] = this.nextPageToken;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item);
        }
        if (Array.isArray(this.reconcileIssues)) {
            data["reconcileIssues"] = [];
            for (let item of this.reconcileIssues)
                data["reconcileIssues"].push(item);
        }
        return data;
    }
}

export interface ISearchAndReconcileRequestBean {
    /** Use [expand](#expansion) to include additional information about issues in the response. Note that, unlike the majority of instances where `expand` is specified, `expand` is defined as a comma-delimited string of values. The expand options are:

 *  `renderedFields` Returns field values rendered in HTML format.
 *  `names` Returns the display name of each field.
 *  `schema` Returns the schema describing a field type.
 *  `transitions` Returns all possible transitions for the issue.
 *  `operations` Returns all possible operations for the issue.
 *  `editmeta` Returns information about how each field can be edited.
 *  `changelog` Returns a list of recent updates to an issue, sorted by date, starting from the most recent.
 *  `versionedRepresentations` Instead of `fields`, returns `versionedRepresentations` a JSON array containing each version of a field's value, with the highest numbered item representing the most recent version.

Examples: `"names,changelog"` Returns the display name of each field as well as a list of recent updates to an issue. */
    expand?: string;
    /** A list of fields to return for each issue. Use it to retrieve a subset of fields. This parameter accepts a comma-separated list. Expand options include:

 *  `*all` Returns all fields.
 *  `*navigable` Returns navigable fields.
 *  `id` Returns only issue IDs.
 *  Any issue field, prefixed with a dash to exclude.

The default is `id`.

Examples:

 *  `summary,comment` Returns the summary and comments fields only.
 *  `*all,-comment` Returns all fields except comments.

Multiple `fields` parameters can be included in a request.

Note: By default, this resource returns IDs only. This differs from [GET issue](#api-rest-api-3-issue-issueIdOrKey-get) where the default is all fields. */
    fields?: string[];
    /** Reference fields by their key (rather than ID). The default is `false`. */
    fieldsByKeys?: boolean;
    /** A [JQL](https://confluence.atlassian.com/x/egORLQ) expression. For performance reasons, this parameter requires a bounded query. A bounded query is a query with a search restriction.

 *  Example of an unbounded query: `order by key desc`.
 *  Example of a bounded query: `assignee = currentUser() order by key`.

Additionally, `orderBy` clause can contain a maximum of 7 fields. */
    jql?: string;
    /** The maximum number of items to return per page. To manage page size, API may return fewer items per page where a large number of fields are requested. The greatest number of items returned per page is achieved when requesting `id` or `key` only. It returns max 5000 issues. */
    maxResults?: number;
    /** The token for a page to fetch that is not the first page. The first page has a `nextPageToken` of `null`. Use the `nextPageToken` to fetch the next page of issues. */
    nextPageToken?: string;
    /** A list of up to 5 issue properties to include in the results. This parameter accepts a comma-separated list. */
    properties?: string[];
    /** Strong consistency issue ids to be reconciled with search results. Accepts max 50 ids */
    reconcileIssues?: number[];
}

/** The result of a JQL search with issues reconsilation. */
export class SearchAndReconcileResults implements ISearchAndReconcileResults {
    /** The list of issues found by the search or reconsiliation. */
    readonly issues?: IssueBean[];
    /** The ID and name of each field in the search results. */
    readonly names?: { [key: string]: string; };
    /** Continuation token to fetch the next page. If this result represents the last or the only page this token will be null. This token will expire in 7 days. */
    readonly nextPageToken?: string;
    /** The schema describing the field types in the search results. */
    readonly schema?: { [key: string]: JsonTypeBean; };

    constructor(data?: ISearchAndReconcileResults) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issues"])) {
                (<any>this).issues = [] as any;
                for (let item of _data["issues"])
                    (<any>this).issues!.push(IssueBean.fromJS(item));
            }
            if (_data["names"]) {
                (<any>this).names = {} as any;
                for (let key in _data["names"]) {
                    if (_data["names"].hasOwnProperty(key))
                        (<any>(<any>this).names)![key] = _data["names"][key];
                }
            }
            (<any>this).nextPageToken = _data["nextPageToken"];
            if (_data["schema"]) {
                (<any>this).schema = {} as any;
                for (let key in _data["schema"]) {
                    if (_data["schema"].hasOwnProperty(key))
                        (<any>(<any>this).schema)![key] = _data["schema"][key] ? JsonTypeBean.fromJS(_data["schema"][key]) : new JsonTypeBean();
                }
            }
        }
    }

    static fromJS(data: any): SearchAndReconcileResults {
        data = typeof data === 'object' ? data : {};
        let result = new SearchAndReconcileResults();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item.toJSON());
        }
        if (this.names) {
            data["names"] = {};
            for (let key in this.names) {
                if (this.names.hasOwnProperty(key))
                    (<any>data["names"])[key] = (<any>this.names)[key];
            }
        }
        data["nextPageToken"] = this.nextPageToken;
        if (this.schema) {
            data["schema"] = {};
            for (let key in this.schema) {
                if (this.schema.hasOwnProperty(key))
                    (<any>data["schema"])[key] = this.schema[key] ? this.schema[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** The result of a JQL search with issues reconsilation. */
export interface ISearchAndReconcileResults {
    /** The list of issues found by the search or reconsiliation. */
    issues?: IssueBean[];
    /** The ID and name of each field in the search results. */
    names?: { [key: string]: string; };
    /** Continuation token to fetch the next page. If this result represents the last or the only page this token will be null. This token will expire in 7 days. */
    nextPageToken?: string;
    /** The schema describing the field types in the search results. */
    schema?: { [key: string]: JsonTypeBean; };
}

/** Details of how to filter and list search auto complete information. */
export class SearchAutoCompleteFilter implements ISearchAutoCompleteFilter {
    /** Include collapsed fields for fields that have non-unique names. */
    includeCollapsedFields?: boolean;
    /** List of project IDs used to filter the visible field details returned. */
    projectIds?: number[];

    constructor(data?: ISearchAutoCompleteFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.includeCollapsedFields = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.includeCollapsedFields = _data["includeCollapsedFields"] !== undefined ? _data["includeCollapsedFields"] : false;
            if (Array.isArray(_data["projectIds"])) {
                this.projectIds = [] as any;
                for (let item of _data["projectIds"])
                    this.projectIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SearchAutoCompleteFilter {
        data = typeof data === 'object' ? data : {};
        let result = new SearchAutoCompleteFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["includeCollapsedFields"] = this.includeCollapsedFields;
        if (Array.isArray(this.projectIds)) {
            data["projectIds"] = [];
            for (let item of this.projectIds)
                data["projectIds"].push(item);
        }
        return data;
    }
}

/** Details of how to filter and list search auto complete information. */
export interface ISearchAutoCompleteFilter {
    /** Include collapsed fields for fields that have non-unique names. */
    includeCollapsedFields?: boolean;
    /** List of project IDs used to filter the visible field details returned. */
    projectIds?: number[];
}

export class SearchRequestBean implements ISearchRequestBean {
    /** Use [expand](#expansion) to include additional information about issues in the response. Note that, unlike the majority of instances where `expand` is specified, `expand` is defined as a list of values. The expand options are:

 *  `renderedFields` Returns field values rendered in HTML format.
 *  `names` Returns the display name of each field.
 *  `schema` Returns the schema describing a field type.
 *  `transitions` Returns all possible transitions for the issue.
 *  `operations` Returns all possible operations for the issue.
 *  `editmeta` Returns information about how each field can be edited.
 *  `changelog` Returns a list of recent updates to an issue, sorted by date, starting from the most recent.
 *  `versionedRepresentations` Instead of `fields`, returns `versionedRepresentations` a JSON array containing each version of a field's value, with the highest numbered item representing the most recent version. */
    expand?: string[];
    /** A list of fields to return for each issue, use it to retrieve a subset of fields. This parameter accepts a comma-separated list. Expand options include:

 *  `*all` Returns all fields.
 *  `*navigable` Returns navigable fields.
 *  Any issue field, prefixed with a minus to exclude.

The default is `*navigable`.

Examples:

 *  `summary,comment` Returns the summary and comments fields only.
 *  `-description` Returns all navigable (default) fields except description.
 *  `*all,-comment` Returns all fields except comments.

Multiple `fields` parameters can be included in a request.

Note: All navigable fields are returned by default. This differs from [GET issue](#api-rest-api-3-issue-issueIdOrKey-get) where the default is all fields. */
    fields?: string[];
    /** Reference fields by their key (rather than ID). The default is `false`. */
    fieldsByKeys?: boolean;
    /** A [JQL](https://confluence.atlassian.com/x/egORLQ) expression. */
    jql?: string;
    /** The maximum number of items to return per page. */
    maxResults?: number;
    /** A list of up to 5 issue properties to include in the results. This parameter accepts a comma-separated list. */
    properties?: string[];
    /** The index of the first item to return in the page of results (page offset). The base index is `0`. */
    startAt?: number;
    /** Determines how to validate the JQL query and treat the validation results. Supported values:

 *  `strict` Returns a 400 response code if any errors are found, along with a list of all errors (and warnings).
 *  `warn` Returns all errors as warnings.
 *  `none` No validation is performed.
 *  `true` *Deprecated* A legacy synonym for `strict`.
 *  `false` *Deprecated* A legacy synonym for `warn`.

The default is `strict`.

Note: If the JQL is not correctly formed a 400 response code is returned, regardless of the `validateQuery` value. */
    validateQuery?: SearchRequestBeanValidateQuery;

    constructor(data?: ISearchRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.maxResults = 50;
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["expand"])) {
                this.expand = [] as any;
                for (let item of _data["expand"])
                    this.expand!.push(item);
            }
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(item);
            }
            this.fieldsByKeys = _data["fieldsByKeys"];
            this.jql = _data["jql"];
            this.maxResults = _data["maxResults"] !== undefined ? _data["maxResults"] : 50;
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(item);
            }
            this.startAt = _data["startAt"];
            this.validateQuery = _data["validateQuery"];
        }
    }

    static fromJS(data: any): SearchRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new SearchRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.expand)) {
            data["expand"] = [];
            for (let item of this.expand)
                data["expand"].push(item);
        }
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item);
        }
        data["fieldsByKeys"] = this.fieldsByKeys;
        data["jql"] = this.jql;
        data["maxResults"] = this.maxResults;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item);
        }
        data["startAt"] = this.startAt;
        data["validateQuery"] = this.validateQuery;
        return data;
    }
}

export interface ISearchRequestBean {
    /** Use [expand](#expansion) to include additional information about issues in the response. Note that, unlike the majority of instances where `expand` is specified, `expand` is defined as a list of values. The expand options are:

 *  `renderedFields` Returns field values rendered in HTML format.
 *  `names` Returns the display name of each field.
 *  `schema` Returns the schema describing a field type.
 *  `transitions` Returns all possible transitions for the issue.
 *  `operations` Returns all possible operations for the issue.
 *  `editmeta` Returns information about how each field can be edited.
 *  `changelog` Returns a list of recent updates to an issue, sorted by date, starting from the most recent.
 *  `versionedRepresentations` Instead of `fields`, returns `versionedRepresentations` a JSON array containing each version of a field's value, with the highest numbered item representing the most recent version. */
    expand?: string[];
    /** A list of fields to return for each issue, use it to retrieve a subset of fields. This parameter accepts a comma-separated list. Expand options include:

 *  `*all` Returns all fields.
 *  `*navigable` Returns navigable fields.
 *  Any issue field, prefixed with a minus to exclude.

The default is `*navigable`.

Examples:

 *  `summary,comment` Returns the summary and comments fields only.
 *  `-description` Returns all navigable (default) fields except description.
 *  `*all,-comment` Returns all fields except comments.

Multiple `fields` parameters can be included in a request.

Note: All navigable fields are returned by default. This differs from [GET issue](#api-rest-api-3-issue-issueIdOrKey-get) where the default is all fields. */
    fields?: string[];
    /** Reference fields by their key (rather than ID). The default is `false`. */
    fieldsByKeys?: boolean;
    /** A [JQL](https://confluence.atlassian.com/x/egORLQ) expression. */
    jql?: string;
    /** The maximum number of items to return per page. */
    maxResults?: number;
    /** A list of up to 5 issue properties to include in the results. This parameter accepts a comma-separated list. */
    properties?: string[];
    /** The index of the first item to return in the page of results (page offset). The base index is `0`. */
    startAt?: number;
    /** Determines how to validate the JQL query and treat the validation results. Supported values:

 *  `strict` Returns a 400 response code if any errors are found, along with a list of all errors (and warnings).
 *  `warn` Returns all errors as warnings.
 *  `none` No validation is performed.
 *  `true` *Deprecated* A legacy synonym for `strict`.
 *  `false` *Deprecated* A legacy synonym for `warn`.

The default is `strict`.

Note: If the JQL is not correctly formed a 400 response code is returned, regardless of the `validateQuery` value. */
    validateQuery?: SearchRequestBeanValidateQuery;
}

/** The result of a JQL search. */
export class SearchResults implements ISearchResults {
    /** Expand options that include additional search result details in the response. */
    readonly expand?: string;
    /** The list of issues found by the search. */
    readonly issues?: IssueBean[];
    /** The maximum number of results that could be on the page. */
    readonly maxResults?: number;
    /** The ID and name of each field in the search results. */
    readonly names?: { [key: string]: string; };
    /** The schema describing the field types in the search results. */
    readonly schema?: { [key: string]: JsonTypeBean; };
    /** The index of the first item returned on the page. */
    readonly startAt?: number;
    /** The number of results on the page. */
    readonly total?: number;
    /** Any warnings related to the JQL query. */
    readonly warningMessages?: string[];

    constructor(data?: ISearchResults) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).expand = _data["expand"];
            if (Array.isArray(_data["issues"])) {
                (<any>this).issues = [] as any;
                for (let item of _data["issues"])
                    (<any>this).issues!.push(IssueBean.fromJS(item));
            }
            (<any>this).maxResults = _data["maxResults"];
            if (_data["names"]) {
                (<any>this).names = {} as any;
                for (let key in _data["names"]) {
                    if (_data["names"].hasOwnProperty(key))
                        (<any>(<any>this).names)![key] = _data["names"][key];
                }
            }
            if (_data["schema"]) {
                (<any>this).schema = {} as any;
                for (let key in _data["schema"]) {
                    if (_data["schema"].hasOwnProperty(key))
                        (<any>(<any>this).schema)![key] = _data["schema"][key] ? JsonTypeBean.fromJS(_data["schema"][key]) : new JsonTypeBean();
                }
            }
            (<any>this).startAt = _data["startAt"];
            (<any>this).total = _data["total"];
            if (Array.isArray(_data["warningMessages"])) {
                (<any>this).warningMessages = [] as any;
                for (let item of _data["warningMessages"])
                    (<any>this).warningMessages!.push(item);
            }
        }
    }

    static fromJS(data: any): SearchResults {
        data = typeof data === 'object' ? data : {};
        let result = new SearchResults();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expand"] = this.expand;
        if (Array.isArray(this.issues)) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item.toJSON());
        }
        data["maxResults"] = this.maxResults;
        if (this.names) {
            data["names"] = {};
            for (let key in this.names) {
                if (this.names.hasOwnProperty(key))
                    (<any>data["names"])[key] = (<any>this.names)[key];
            }
        }
        if (this.schema) {
            data["schema"] = {};
            for (let key in this.schema) {
                if (this.schema.hasOwnProperty(key))
                    (<any>data["schema"])[key] = this.schema[key] ? this.schema[key].toJSON() : <any>undefined;
            }
        }
        data["startAt"] = this.startAt;
        data["total"] = this.total;
        if (Array.isArray(this.warningMessages)) {
            data["warningMessages"] = [];
            for (let item of this.warningMessages)
                data["warningMessages"].push(item);
        }
        return data;
    }
}

/** The result of a JQL search. */
export interface ISearchResults {
    /** Expand options that include additional search result details in the response. */
    expand?: string;
    /** The list of issues found by the search. */
    issues?: IssueBean[];
    /** The maximum number of results that could be on the page. */
    maxResults?: number;
    /** The ID and name of each field in the search results. */
    names?: { [key: string]: string; };
    /** The schema describing the field types in the search results. */
    schema?: { [key: string]: JsonTypeBean; };
    /** The index of the first item returned on the page. */
    startAt?: number;
    /** The number of results on the page. */
    total?: number;
    /** Any warnings related to the JQL query. */
    warningMessages?: string[];
}

/** Details of an issue level security item. */
export class SecurityLevel implements ISecurityLevel {
    /** The description of the issue level security item. */
    readonly description?: string;
    /** The ID of the issue level security item. */
    readonly id?: string;
    /** Whether the issue level security item is the default. */
    readonly isDefault?: boolean;
    /** The ID of the issue level security scheme. */
    readonly issueSecuritySchemeId?: string;
    /** The name of the issue level security item. */
    readonly name?: string;
    /** The URL of the issue level security item. */
    readonly self?: string;

    constructor(data?: ISecurityLevel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).description = _data["description"];
            (<any>this).id = _data["id"];
            (<any>this).isDefault = _data["isDefault"];
            (<any>this).issueSecuritySchemeId = _data["issueSecuritySchemeId"];
            (<any>this).name = _data["name"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): SecurityLevel {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityLevel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["isDefault"] = this.isDefault;
        data["issueSecuritySchemeId"] = this.issueSecuritySchemeId;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

/** Details of an issue level security item. */
export interface ISecurityLevel {
    /** The description of the issue level security item. */
    description?: string;
    /** The ID of the issue level security item. */
    id?: string;
    /** Whether the issue level security item is the default. */
    isDefault?: boolean;
    /** The ID of the issue level security scheme. */
    issueSecuritySchemeId?: string;
    /** The name of the issue level security item. */
    name?: string;
    /** The URL of the issue level security item. */
    self?: string;
}

/** Issue security level member. */
export class SecurityLevelMember implements ISecurityLevelMember {
    /** The user or group being granted the permission. It consists of a `type` and a type-dependent `parameter`. See [Holder object](../api-group-permission-schemes/#holder-object) in *Get all permission schemes* for more information. */
    readonly holder!: PermissionHolder;
    /** The ID of the issue security level member. */
    readonly id!: string;
    /** The ID of the issue security level. */
    readonly issueSecurityLevelId!: string;
    /** The ID of the issue security scheme. */
    readonly issueSecuritySchemeId!: string;
    managed?: boolean;

    [key: string]: any;

    constructor(data?: ISecurityLevelMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.holder = new PermissionHolder();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).holder = _data["holder"] ? PermissionHolder.fromJS(_data["holder"]) : new PermissionHolder();
            (<any>this).id = _data["id"];
            (<any>this).issueSecurityLevelId = _data["issueSecurityLevelId"];
            (<any>this).issueSecuritySchemeId = _data["issueSecuritySchemeId"];
            this.managed = _data["managed"];
        }
    }

    static fromJS(data: any): SecurityLevelMember {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityLevelMember();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["holder"] = this.holder ? this.holder.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["issueSecurityLevelId"] = this.issueSecurityLevelId;
        data["issueSecuritySchemeId"] = this.issueSecuritySchemeId;
        data["managed"] = this.managed;
        return data;
    }
}

/** Issue security level member. */
export interface ISecurityLevelMember {
    /** The user or group being granted the permission. It consists of a `type` and a type-dependent `parameter`. See [Holder object](../api-group-permission-schemes/#holder-object) in *Get all permission schemes* for more information. */
    holder: PermissionHolder;
    /** The ID of the issue security level member. */
    id: string;
    /** The ID of the issue security level. */
    issueSecurityLevelId: string;
    /** The ID of the issue security scheme. */
    issueSecuritySchemeId: string;
    managed?: boolean;

    [key: string]: any;
}

/** The payload for creating a security level member. See https://support.atlassian.com/jira-cloud-administration/docs/configure-issue-security-schemes/ */
export class SecurityLevelMemberPayload implements ISecurityLevelMemberPayload {
    /** Defines the value associated with the type. For reporter this would be \{"null"\}; for users this would be the names of specific users); for group this would be group names like \{"administrators", "jira-administrators", "jira-users"\} */
    parameter?: string;
    /** The type of the security level member */
    type?: SecurityLevelMemberPayloadType;

    constructor(data?: ISecurityLevelMemberPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parameter = _data["parameter"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): SecurityLevelMemberPayload {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityLevelMemberPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parameter"] = this.parameter;
        data["type"] = this.type;
        return data;
    }
}

/** The payload for creating a security level member. See https://support.atlassian.com/jira-cloud-administration/docs/configure-issue-security-schemes/ */
export interface ISecurityLevelMemberPayload {
    /** Defines the value associated with the type. For reporter this would be \{"null"\}; for users this would be the names of specific users); for group this would be group names like \{"administrators", "jira-administrators", "jira-users"\} */
    parameter?: string;
    /** The type of the security level member */
    type?: SecurityLevelMemberPayloadType;
}

/** The payload for creating a security level. See https://support.atlassian.com/jira-cloud-administration/docs/configure-issue-security-schemes/ */
export class SecurityLevelPayload implements ISecurityLevelPayload {
    /** The description of the security level */
    description?: string;
    /** Whether the security level is default for the security scheme */
    isDefault?: boolean;
    /** The name of the security level */
    name?: string;
    /** The members of the security level */
    securityLevelMembers?: SecurityLevelMemberPayload[];

    constructor(data?: ISecurityLevelPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.isDefault = _data["isDefault"];
            this.name = _data["name"];
            if (Array.isArray(_data["securityLevelMembers"])) {
                this.securityLevelMembers = [] as any;
                for (let item of _data["securityLevelMembers"])
                    this.securityLevelMembers!.push(SecurityLevelMemberPayload.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SecurityLevelPayload {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityLevelPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["isDefault"] = this.isDefault;
        data["name"] = this.name;
        if (Array.isArray(this.securityLevelMembers)) {
            data["securityLevelMembers"] = [];
            for (let item of this.securityLevelMembers)
                data["securityLevelMembers"].push(item.toJSON());
        }
        return data;
    }
}

/** The payload for creating a security level. See https://support.atlassian.com/jira-cloud-administration/docs/configure-issue-security-schemes/ */
export interface ISecurityLevelPayload {
    /** The description of the security level */
    description?: string;
    /** Whether the security level is default for the security scheme */
    isDefault?: boolean;
    /** The name of the security level */
    name?: string;
    /** The members of the security level */
    securityLevelMembers?: SecurityLevelMemberPayload[];
}

/** Details about a security scheme. */
export class SecurityScheme implements ISecurityScheme {
    /** The ID of the default security level. */
    readonly defaultSecurityLevelId?: number;
    /** The description of the issue security scheme. */
    readonly description?: string;
    /** The ID of the issue security scheme. */
    readonly id?: number;
    levels?: SecurityLevel[];
    /** The name of the issue security scheme. */
    readonly name?: string;
    /** The URL of the issue security scheme. */
    readonly self?: string;

    constructor(data?: ISecurityScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).defaultSecurityLevelId = _data["defaultSecurityLevelId"];
            (<any>this).description = _data["description"];
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["levels"])) {
                this.levels = [] as any;
                for (let item of _data["levels"])
                    this.levels!.push(SecurityLevel.fromJS(item));
            }
            (<any>this).name = _data["name"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): SecurityScheme {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultSecurityLevelId"] = this.defaultSecurityLevelId;
        data["description"] = this.description;
        data["id"] = this.id;
        if (Array.isArray(this.levels)) {
            data["levels"] = [];
            for (let item of this.levels)
                data["levels"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

/** Details about a security scheme. */
export interface ISecurityScheme {
    /** The ID of the default security level. */
    defaultSecurityLevelId?: number;
    /** The description of the issue security scheme. */
    description?: string;
    /** The ID of the issue security scheme. */
    id?: number;
    levels?: SecurityLevel[];
    /** The name of the issue security scheme. */
    name?: string;
    /** The URL of the issue security scheme. */
    self?: string;
}

/** The ID of the issue security scheme. */
export class SecuritySchemeId implements ISecuritySchemeId {
    /** The ID of the issue security scheme. */
    readonly id!: string;

    [key: string]: any;

    constructor(data?: ISecuritySchemeId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).id = _data["id"];
        }
    }

    static fromJS(data: any): SecuritySchemeId {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySchemeId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        return data;
    }
}

/** The ID of the issue security scheme. */
export interface ISecuritySchemeId {
    /** The ID of the issue security scheme. */
    id: string;

    [key: string]: any;
}

export class SecuritySchemeLevelBean implements ISecuritySchemeLevelBean {
    /** The description of the issue security scheme level. */
    description?: string;
    /** Specifies whether the level is the default level. False by default. */
    isDefault?: boolean;
    /** The list of level members which should be added to the issue security scheme level. */
    members?: SecuritySchemeLevelMemberBean[];
    /** The name of the issue security scheme level. Must be unique. */
    name!: string;

    constructor(data?: ISecuritySchemeLevelBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(SecuritySchemeLevelMemberBean.fromJS(item));
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SecuritySchemeLevelBean {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySchemeLevelBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item.toJSON());
        }
        data["name"] = this.name;
        return data;
    }
}

export interface ISecuritySchemeLevelBean {
    /** The description of the issue security scheme level. */
    description?: string;
    /** Specifies whether the level is the default level. False by default. */
    isDefault?: boolean;
    /** The list of level members which should be added to the issue security scheme level. */
    members?: SecuritySchemeLevelMemberBean[];
    /** The name of the issue security scheme level. Must be unique. */
    name: string;
}

export class SecuritySchemeLevelMemberBean implements ISecuritySchemeLevelMemberBean {
    /** The value corresponding to the specified member type. */
    parameter?: string;
    /** The issue security level member type, e.g `reporter`, `group`, `user`, `projectrole`, `applicationRole`. */
    type!: string;

    constructor(data?: ISecuritySchemeLevelMemberBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parameter = _data["parameter"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): SecuritySchemeLevelMemberBean {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySchemeLevelMemberBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parameter"] = this.parameter;
        data["type"] = this.type;
        return data;
    }
}

export interface ISecuritySchemeLevelMemberBean {
    /** The value corresponding to the specified member type. */
    parameter?: string;
    /** The issue security level member type, e.g `reporter`, `group`, `user`, `projectrole`, `applicationRole`. */
    type: string;
}

/** Details of issue security scheme level new members. */
export class SecuritySchemeMembersRequest implements ISecuritySchemeMembersRequest {
    /** The list of level members which should be added to the issue security scheme level. */
    members?: SecuritySchemeLevelMemberBean[];

    constructor(data?: ISecuritySchemeMembersRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(SecuritySchemeLevelMemberBean.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SecuritySchemeMembersRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySchemeMembersRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of issue security scheme level new members. */
export interface ISecuritySchemeMembersRequest {
    /** The list of level members which should be added to the issue security scheme level. */
    members?: SecuritySchemeLevelMemberBean[];
}

/** The payload for creating a security scheme. See https://support.atlassian.com/jira-cloud-administration/docs/configure-issue-security-schemes/ */
export class SecuritySchemePayload implements ISecuritySchemePayload {
    /** The description of the security scheme */
    description?: string;
    /** The name of the security scheme */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;
    /** The security levels for the security scheme */
    securityLevels?: SecurityLevelPayload[];

    constructor(data?: ISecuritySchemePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
            if (Array.isArray(_data["securityLevels"])) {
                this.securityLevels = [] as any;
                for (let item of _data["securityLevels"])
                    this.securityLevels!.push(SecurityLevelPayload.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SecuritySchemePayload {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySchemePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        if (Array.isArray(this.securityLevels)) {
            data["securityLevels"] = [];
            for (let item of this.securityLevels)
                data["securityLevels"].push(item.toJSON());
        }
        return data;
    }
}

/** The payload for creating a security scheme. See https://support.atlassian.com/jira-cloud-administration/docs/configure-issue-security-schemes/ */
export interface ISecuritySchemePayload {
    /** The description of the security scheme */
    description?: string;
    /** The name of the security scheme */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;
    /** The security levels for the security scheme */
    securityLevels?: SecurityLevelPayload[];
}

/** Details about an issue security scheme. */
export class SecuritySchemeWithProjects implements ISecuritySchemeWithProjects {
    /** The default level ID of the issue security scheme. */
    readonly defaultLevel?: number;
    /** The description of the issue security scheme. */
    readonly description?: string;
    /** The ID of the issue security scheme. */
    readonly id!: number;
    /** The name of the issue security scheme. */
    readonly name!: string;
    /** The list of project IDs associated with the issue security scheme. */
    readonly projectIds?: number[];
    /** The URL of the issue security scheme. */
    readonly self!: string;

    [key: string]: any;

    constructor(data?: ISecuritySchemeWithProjects) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).defaultLevel = _data["defaultLevel"];
            (<any>this).description = _data["description"];
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            if (Array.isArray(_data["projectIds"])) {
                (<any>this).projectIds = [] as any;
                for (let item of _data["projectIds"])
                    (<any>this).projectIds!.push(item);
            }
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): SecuritySchemeWithProjects {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySchemeWithProjects();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["defaultLevel"] = this.defaultLevel;
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.projectIds)) {
            data["projectIds"] = [];
            for (let item of this.projectIds)
                data["projectIds"].push(item);
        }
        data["self"] = this.self;
        return data;
    }
}

/** Details about an issue security scheme. */
export interface ISecuritySchemeWithProjects {
    /** The default level ID of the issue security scheme. */
    defaultLevel?: number;
    /** The description of the issue security scheme. */
    description?: string;
    /** The ID of the issue security scheme. */
    id: number;
    /** The name of the issue security scheme. */
    name: string;
    /** The list of project IDs associated with the issue security scheme. */
    projectIds?: number[];
    /** The URL of the issue security scheme. */
    self: string;

    [key: string]: any;
}

/** List of security schemes. */
export class SecuritySchemes implements ISecuritySchemes {
    /** List of security schemes. */
    readonly issueSecuritySchemes?: SecurityScheme[];

    constructor(data?: ISecuritySchemes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueSecuritySchemes"])) {
                (<any>this).issueSecuritySchemes = [] as any;
                for (let item of _data["issueSecuritySchemes"])
                    (<any>this).issueSecuritySchemes!.push(SecurityScheme.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SecuritySchemes {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySchemes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueSecuritySchemes)) {
            data["issueSecuritySchemes"] = [];
            for (let item of this.issueSecuritySchemes)
                data["issueSecuritySchemes"].push(item.toJSON());
        }
        return data;
    }
}

/** List of security schemes. */
export interface ISecuritySchemes {
    /** List of security schemes. */
    issueSecuritySchemes?: SecurityScheme[];
}

/** Details about the Jira instance. */
export class ServerInformation implements IServerInformation {
    /** The base URL of the Jira instance. */
    baseUrl?: string;
    /** The timestamp when the Jira version was built. */
    buildDate?: Date;
    /** The build number of the Jira version. */
    buildNumber?: number;
    /** The type of server deployment. This is always returned as *Cloud*. */
    deploymentType?: string;
    /** The display URL of the Jira instance. */
    displayUrl?: string;
    /** The display URL of Confluence. */
    displayUrlConfluence?: string;
    /** The display URL of the Servicedesk Help Center. */
    displayUrlServicedeskHelpCenter?: string;
    /** Jira instance health check results. Deprecated and no longer returned. */
    healthChecks?: HealthCheckResult[];
    /** The unique identifier of the Jira version. */
    scmInfo?: string;
    /** The time in Jira when this request was responded to. */
    serverTime?: Date;
    /** The default timezone of the Jira server. In a format known as Olson Time Zones, IANA Time Zones or TZ Database Time Zones. */
    serverTimeZone?: string;
    /** The name of the Jira instance. */
    serverTitle?: string;
    /** The version of Jira. */
    version?: string;
    /** The major, minor, and revision version numbers of the Jira version. */
    versionNumbers?: number[];

    constructor(data?: IServerInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseUrl = _data["baseUrl"];
            this.buildDate = _data["buildDate"] ? new Date(_data["buildDate"].toString()) : <any>undefined;
            this.buildNumber = _data["buildNumber"];
            this.deploymentType = _data["deploymentType"];
            this.displayUrl = _data["displayUrl"];
            this.displayUrlConfluence = _data["displayUrlConfluence"];
            this.displayUrlServicedeskHelpCenter = _data["displayUrlServicedeskHelpCenter"];
            if (Array.isArray(_data["healthChecks"])) {
                this.healthChecks = [] as any;
                for (let item of _data["healthChecks"])
                    this.healthChecks!.push(HealthCheckResult.fromJS(item));
            }
            this.scmInfo = _data["scmInfo"];
            this.serverTime = _data["serverTime"] ? new Date(_data["serverTime"].toString()) : <any>undefined;
            this.serverTimeZone = _data["serverTimeZone"];
            this.serverTitle = _data["serverTitle"];
            this.version = _data["version"];
            if (Array.isArray(_data["versionNumbers"])) {
                this.versionNumbers = [] as any;
                for (let item of _data["versionNumbers"])
                    this.versionNumbers!.push(item);
            }
        }
    }

    static fromJS(data: any): ServerInformation {
        data = typeof data === 'object' ? data : {};
        let result = new ServerInformation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseUrl"] = this.baseUrl;
        data["buildDate"] = this.buildDate ? this.buildDate.toISOString() : <any>undefined;
        data["buildNumber"] = this.buildNumber;
        data["deploymentType"] = this.deploymentType;
        data["displayUrl"] = this.displayUrl;
        data["displayUrlConfluence"] = this.displayUrlConfluence;
        data["displayUrlServicedeskHelpCenter"] = this.displayUrlServicedeskHelpCenter;
        if (Array.isArray(this.healthChecks)) {
            data["healthChecks"] = [];
            for (let item of this.healthChecks)
                data["healthChecks"].push(item.toJSON());
        }
        data["scmInfo"] = this.scmInfo;
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        data["serverTimeZone"] = this.serverTimeZone;
        data["serverTitle"] = this.serverTitle;
        data["version"] = this.version;
        if (Array.isArray(this.versionNumbers)) {
            data["versionNumbers"] = [];
            for (let item of this.versionNumbers)
                data["versionNumbers"].push(item);
        }
        return data;
    }
}

/** Details about the Jira instance. */
export interface IServerInformation {
    /** The base URL of the Jira instance. */
    baseUrl?: string;
    /** The timestamp when the Jira version was built. */
    buildDate?: Date;
    /** The build number of the Jira version. */
    buildNumber?: number;
    /** The type of server deployment. This is always returned as *Cloud*. */
    deploymentType?: string;
    /** The display URL of the Jira instance. */
    displayUrl?: string;
    /** The display URL of Confluence. */
    displayUrlConfluence?: string;
    /** The display URL of the Servicedesk Help Center. */
    displayUrlServicedeskHelpCenter?: string;
    /** Jira instance health check results. Deprecated and no longer returned. */
    healthChecks?: HealthCheckResult[];
    /** The unique identifier of the Jira version. */
    scmInfo?: string;
    /** The time in Jira when this request was responded to. */
    serverTime?: Date;
    /** The default timezone of the Jira server. In a format known as Olson Time Zones, IANA Time Zones or TZ Database Time Zones. */
    serverTimeZone?: string;
    /** The name of the Jira instance. */
    serverTitle?: string;
    /** The version of Jira. */
    version?: string;
    /** The major, minor, and revision version numbers of the Jira version. */
    versionNumbers?: number[];
}

export class ServiceManagementNavigationInfo implements IServiceManagementNavigationInfo {
    queueCategory?: string;
    queueId?: number;
    queueName?: string;

    [key: string]: any;

    constructor(data?: IServiceManagementNavigationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.queueCategory = _data["queueCategory"];
            this.queueId = _data["queueId"];
            this.queueName = _data["queueName"];
        }
    }

    static fromJS(data: any): ServiceManagementNavigationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceManagementNavigationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["queueCategory"] = this.queueCategory;
        data["queueId"] = this.queueId;
        data["queueName"] = this.queueName;
        return data;
    }
}

export interface IServiceManagementNavigationInfo {
    queueCategory?: string;
    queueId?: number;
    queueName?: string;

    [key: string]: any;
}

export class ServiceRegistry implements IServiceRegistry {
    /** service description */
    description?: string | undefined;
    /** service ID */
    id?: string;
    /** service name */
    name?: string;
    /** organization ID */
    organizationId?: string;
    /** service revision */
    revision?: string;
    serviceTier?: ServiceRegistryTier;

    [key: string]: any;

    constructor(data?: IServiceRegistry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.organizationId = _data["organizationId"];
            this.revision = _data["revision"];
            this.serviceTier = _data["serviceTier"] ? ServiceRegistryTier.fromJS(_data["serviceTier"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServiceRegistry {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceRegistry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["organizationId"] = this.organizationId;
        data["revision"] = this.revision;
        data["serviceTier"] = this.serviceTier ? this.serviceTier.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServiceRegistry {
    /** service description */
    description?: string | undefined;
    /** service ID */
    id?: string;
    /** service name */
    name?: string;
    /** organization ID */
    organizationId?: string;
    /** service revision */
    revision?: string;
    serviceTier?: ServiceRegistryTier;

    [key: string]: any;
}

export class ServiceRegistryTier implements IServiceRegistryTier {
    /** tier description */
    description?: string | undefined;
    /** tier ID */
    id?: string;
    /** tier level */
    level?: number;
    /** tier name */
    name?: string | undefined;
    /** name key of the tier */
    nameKey?: string;

    [key: string]: any;

    constructor(data?: IServiceRegistryTier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.id = _data["id"];
            this.level = _data["level"];
            this.name = _data["name"];
            this.nameKey = _data["nameKey"];
        }
    }

    static fromJS(data: any): ServiceRegistryTier {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceRegistryTier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["id"] = this.id;
        data["level"] = this.level;
        data["name"] = this.name;
        data["nameKey"] = this.nameKey;
        return data;
    }
}

export interface IServiceRegistryTier {
    /** tier description */
    description?: string | undefined;
    /** tier ID */
    id?: string;
    /** tier level */
    level?: number;
    /** tier name */
    name?: string | undefined;
    /** name key of the tier */
    nameKey?: string;

    [key: string]: any;
}

/** Details of new default levels. */
export class SetDefaultLevelsRequest implements ISetDefaultLevelsRequest {
    /** List of objects with issue security scheme ID and new default level ID. */
    defaultValues!: DefaultLevelValue[];

    [key: string]: any;

    constructor(data?: ISetDefaultLevelsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.defaultValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["defaultValues"])) {
                this.defaultValues = [] as any;
                for (let item of _data["defaultValues"])
                    this.defaultValues!.push(DefaultLevelValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SetDefaultLevelsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLevelsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.defaultValues)) {
            data["defaultValues"] = [];
            for (let item of this.defaultValues)
                data["defaultValues"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of new default levels. */
export interface ISetDefaultLevelsRequest {
    /** List of objects with issue security scheme ID and new default level ID. */
    defaultValues: DefaultLevelValue[];

    [key: string]: any;
}

/** The new default issue priority. */
export class SetDefaultPriorityRequest implements ISetDefaultPriorityRequest {
    /** The ID of the new default issue priority. Must be an existing ID or null. Setting this to null erases the default priority setting. */
    id!: string;

    constructor(data?: ISetDefaultPriorityRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SetDefaultPriorityRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultPriorityRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** The new default issue priority. */
export interface ISetDefaultPriorityRequest {
    /** The ID of the new default issue priority. Must be an existing ID or null. Setting this to null erases the default priority setting. */
    id: string;
}

/** The new default issue resolution. */
export class SetDefaultResolutionRequest implements ISetDefaultResolutionRequest {
    /** The ID of the new default issue resolution. Must be an existing ID or null. Setting this to null erases the default resolution setting. */
    id!: string;

    constructor(data?: ISetDefaultResolutionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SetDefaultResolutionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultResolutionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** The new default issue resolution. */
export interface ISetDefaultResolutionRequest {
    /** The ID of the new default issue resolution. Must be an existing ID or null. Setting this to null erases the default resolution setting. */
    id: string;
}

/** Details of a share permission for the filter. */
export class SharePermission implements ISharePermission {
    /** The group that the filter is shared with. For a request, specify the `groupId` or `name` property for the group. As a group's name can change, use of `groupId` is recommended. */
    group?: GroupName;
    /** The unique identifier of the share permission. */
    readonly id?: number;
    /** The project that the filter is shared with. This is similar to the project object returned by [Get project](#api-rest-api-3-project-projectIdOrKey-get) but it contains a subset of the properties, which are: `self`, `id`, `key`, `assigneeType`, `name`, `roles`, `avatarUrls`, `projectType`, `simplified`.  
For a request, specify the `id` for the project. */
    project?: Project;
    /** The project role that the filter is shared with.  
For a request, specify the `id` for the role. You must also specify the `project` object and `id` for the project that the role is in. */
    role?: ProjectRole;
    /** The type of share permission:

 *  `user` Shared with a user.
 *  `group` Shared with a group. If set in a request, then specify `sharePermission.group` as well.
 *  `project` Shared with a project. If set in a request, then specify `sharePermission.project` as well.
 *  `projectRole` Share with a project role in a project. This value is not returned in responses. It is used in requests, where it needs to be specify with `projectId` and `projectRoleId`.
 *  `global` Shared globally. If set in a request, no other `sharePermission` properties need to be specified.
 *  `loggedin` Shared with all logged-in users. Note: This value is set in a request by specifying `authenticated` as the `type`.
 *  `project-unknown` Shared with a project that the user does not have access to. Cannot be set in a request. */
    type!: SharePermissionType;
    /** The user account ID that the filter is shared with. For a request, specify the `accountId` property for the user. */
    user?: UserBean;

    constructor(data?: ISharePermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"] ? GroupName.fromJS(_data["group"]) : <any>undefined;
            (<any>this).id = _data["id"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
            this.role = _data["role"] ? ProjectRole.fromJS(_data["role"]) : <any>undefined;
            this.type = _data["type"];
            this.user = _data["user"] ? UserBean.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SharePermission {
        data = typeof data === 'object' ? data : {};
        let result = new SharePermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

/** Details of a share permission for the filter. */
export interface ISharePermission {
    /** The group that the filter is shared with. For a request, specify the `groupId` or `name` property for the group. As a group's name can change, use of `groupId` is recommended. */
    group?: GroupName;
    /** The unique identifier of the share permission. */
    id?: number;
    /** The project that the filter is shared with. This is similar to the project object returned by [Get project](#api-rest-api-3-project-projectIdOrKey-get) but it contains a subset of the properties, which are: `self`, `id`, `key`, `assigneeType`, `name`, `roles`, `avatarUrls`, `projectType`, `simplified`.  
For a request, specify the `id` for the project. */
    project?: Project;
    /** The project role that the filter is shared with.  
For a request, specify the `id` for the role. You must also specify the `project` object and `id` for the project that the role is in. */
    role?: ProjectRole;
    /** The type of share permission:

 *  `user` Shared with a user.
 *  `group` Shared with a group. If set in a request, then specify `sharePermission.group` as well.
 *  `project` Shared with a project. If set in a request, then specify `sharePermission.project` as well.
 *  `projectRole` Share with a project role in a project. This value is not returned in responses. It is used in requests, where it needs to be specify with `projectId` and `projectRoleId`.
 *  `global` Shared globally. If set in a request, no other `sharePermission` properties need to be specified.
 *  `loggedin` Shared with all logged-in users. Note: This value is set in a request by specifying `authenticated` as the `type`.
 *  `project-unknown` Shared with a project that the user does not have access to. Cannot be set in a request. */
    type: SharePermissionType;
    /** The user account ID that the filter is shared with. For a request, specify the `accountId` property for the user. */
    user?: UserBean;
}

export class SharePermissionInputBean implements ISharePermissionInputBean {
    /** The user account ID that the filter is shared with. For a request, specify the `accountId` property for the user. */
    accountId?: string;
    /** The ID of the group, which uniquely identifies the group across all Atlassian products.For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*. Cannot be provided with `groupname`. */
    groupId?: string;
    /** The name of the group to share the filter with. Set `type` to `group`. Please note that the name of a group is mutable, to reliably identify a group use `groupId`. */
    groupname?: string;
    /** The ID of the project to share the filter with. Set `type` to `project`. */
    projectId?: string;
    /** The ID of the project role to share the filter with. Set `type` to `projectRole` and the `projectId` for the project that the role is in. */
    projectRoleId?: string;
    /** The rights for the share permission. */
    rights?: number;
    /** The type of the share permission.Specify the type as follows:

 *  `user` Share with a user.
 *  `group` Share with a group. Specify `groupname` as well.
 *  `project` Share with a project. Specify `projectId` as well.
 *  `projectRole` Share with a project role in a project. Specify `projectId` and `projectRoleId` as well.
 *  `global` Share globally, including anonymous users. If set, this type overrides all existing share permissions and must be deleted before any non-global share permissions is set.
 *  `authenticated` Share with all logged-in users. This shows as `loggedin` in the response. If set, this type overrides all existing share permissions and must be deleted before any non-global share permissions is set. */
    type!: SharePermissionInputBeanType;

    constructor(data?: ISharePermissionInputBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.groupId = _data["groupId"];
            this.groupname = _data["groupname"];
            this.projectId = _data["projectId"];
            this.projectRoleId = _data["projectRoleId"];
            this.rights = _data["rights"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): SharePermissionInputBean {
        data = typeof data === 'object' ? data : {};
        let result = new SharePermissionInputBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["groupId"] = this.groupId;
        data["groupname"] = this.groupname;
        data["projectId"] = this.projectId;
        data["projectRoleId"] = this.projectRoleId;
        data["rights"] = this.rights;
        data["type"] = this.type;
        return data;
    }
}

export interface ISharePermissionInputBean {
    /** The user account ID that the filter is shared with. For a request, specify the `accountId` property for the user. */
    accountId?: string;
    /** The ID of the group, which uniquely identifies the group across all Atlassian products.For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*. Cannot be provided with `groupname`. */
    groupId?: string;
    /** The name of the group to share the filter with. Set `type` to `group`. Please note that the name of a group is mutable, to reliably identify a group use `groupId`. */
    groupname?: string;
    /** The ID of the project to share the filter with. Set `type` to `project`. */
    projectId?: string;
    /** The ID of the project role to share the filter with. Set `type` to `projectRole` and the `projectId` for the project that the role is in. */
    projectRoleId?: string;
    /** The rights for the share permission. */
    rights?: number;
    /** The type of the share permission.Specify the type as follows:

 *  `user` Share with a user.
 *  `group` Share with a group. Specify `groupname` as well.
 *  `project` Share with a project. Specify `projectId` as well.
 *  `projectRole` Share with a project role in a project. Specify `projectId` and `projectRoleId` as well.
 *  `global` Share globally, including anonymous users. If set, this type overrides all existing share permissions and must be deleted before any non-global share permissions is set.
 *  `authenticated` Share with all logged-in users. This shows as `loggedin` in the response. If set, this type overrides all existing share permissions and must be deleted before any non-global share permissions is set. */
    type: SharePermissionInputBeanType;
}

export class SimpleApplicationPropertyBean implements ISimpleApplicationPropertyBean {
    /** The ID of the application property. */
    id?: string;
    /** The new value. */
    value?: string;

    constructor(data?: ISimpleApplicationPropertyBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): SimpleApplicationPropertyBean {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleApplicationPropertyBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data;
    }
}

export interface ISimpleApplicationPropertyBean {
    /** The ID of the application property. */
    id?: string;
    /** The new value. */
    value?: string;
}

export class SimpleErrorCollection implements ISimpleErrorCollection {
    /** The list of error messages produced by this operation. For example, "input parameter 'key' must be provided" */
    errorMessages?: string[];
    /** The list of errors by parameter returned by the operation. For example,"projectKey": "Project keys must start with an uppercase letter, followed by one or more uppercase alphanumeric characters." */
    errors?: { [key: string]: string; };
    httpStatusCode?: number;

    constructor(data?: ISimpleErrorCollection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errorMessages"])) {
                this.errorMessages = [] as any;
                for (let item of _data["errorMessages"])
                    this.errorMessages!.push(item);
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key];
                }
            }
            this.httpStatusCode = _data["httpStatusCode"];
        }
    }

    static fromJS(data: any): SimpleErrorCollection {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleErrorCollection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errorMessages)) {
            data["errorMessages"] = [];
            for (let item of this.errorMessages)
                data["errorMessages"].push(item);
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        data["httpStatusCode"] = this.httpStatusCode;
        return data;
    }
}

export interface ISimpleErrorCollection {
    /** The list of error messages produced by this operation. For example, "input parameter 'key' must be provided" */
    errorMessages?: string[];
    /** The list of errors by parameter returned by the operation. For example,"projectKey": "Project keys must start with an uppercase letter, followed by one or more uppercase alphanumeric characters." */
    errors?: { [key: string]: string; };
    httpStatusCode?: number;
}

/** Details about the operations available in this version. */
export class SimpleLink implements ISimpleLink {
    href?: string;
    iconClass?: string;
    id?: string;
    label?: string;
    styleClass?: string;
    title?: string;
    weight?: number;

    constructor(data?: ISimpleLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.href = _data["href"];
            this.iconClass = _data["iconClass"];
            this.id = _data["id"];
            this.label = _data["label"];
            this.styleClass = _data["styleClass"];
            this.title = _data["title"];
            this.weight = _data["weight"];
        }
    }

    static fromJS(data: any): SimpleLink {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        data["iconClass"] = this.iconClass;
        data["id"] = this.id;
        data["label"] = this.label;
        data["styleClass"] = this.styleClass;
        data["title"] = this.title;
        data["weight"] = this.weight;
        return data;
    }
}

/** Details about the operations available in this version. */
export interface ISimpleLink {
    href?: string;
    iconClass?: string;
    id?: string;
    label?: string;
    styleClass?: string;
    title?: string;
    weight?: number;
}

export class SimpleListWrapperApplicationRole implements ISimpleListWrapperApplicationRole {
    callback?: ListWrapperCallbackApplicationRole;
    items?: ApplicationRole[];
    maxResults?: number;
    pagingCallback?: ListWrapperCallbackApplicationRole;
    size?: number;

    constructor(data?: ISimpleListWrapperApplicationRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.callback = _data["callback"] ? ListWrapperCallbackApplicationRole.fromJS(_data["callback"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplicationRole.fromJS(item));
            }
            this.maxResults = _data["max-results"];
            this.pagingCallback = _data["pagingCallback"] ? ListWrapperCallbackApplicationRole.fromJS(_data["pagingCallback"]) : <any>undefined;
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): SimpleListWrapperApplicationRole {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleListWrapperApplicationRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["callback"] = this.callback ? this.callback.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["max-results"] = this.maxResults;
        data["pagingCallback"] = this.pagingCallback ? this.pagingCallback.toJSON() : <any>undefined;
        data["size"] = this.size;
        return data;
    }
}

export interface ISimpleListWrapperApplicationRole {
    callback?: ListWrapperCallbackApplicationRole;
    items?: ApplicationRole[];
    maxResults?: number;
    pagingCallback?: ListWrapperCallbackApplicationRole;
    size?: number;
}

export class SimpleListWrapperGroupName implements ISimpleListWrapperGroupName {
    callback?: ListWrapperCallbackGroupName;
    items?: GroupName[];
    maxResults?: number;
    pagingCallback?: ListWrapperCallbackGroupName;
    size?: number;

    constructor(data?: ISimpleListWrapperGroupName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.callback = _data["callback"] ? ListWrapperCallbackGroupName.fromJS(_data["callback"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GroupName.fromJS(item));
            }
            this.maxResults = _data["max-results"];
            this.pagingCallback = _data["pagingCallback"] ? ListWrapperCallbackGroupName.fromJS(_data["pagingCallback"]) : <any>undefined;
            this.size = _data["size"];
        }
    }

    static fromJS(data: any): SimpleListWrapperGroupName {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleListWrapperGroupName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["callback"] = this.callback ? this.callback.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["max-results"] = this.maxResults;
        data["pagingCallback"] = this.pagingCallback ? this.pagingCallback.toJSON() : <any>undefined;
        data["size"] = this.size;
        return data;
    }
}

export interface ISimpleListWrapperGroupName {
    callback?: ListWrapperCallbackGroupName;
    items?: GroupName[];
    maxResults?: number;
    pagingCallback?: ListWrapperCallbackGroupName;
    size?: number;
}

/** Represents a usage of an entity by a project ID and related issue type IDs. */
export class SimpleUsage implements ISimpleUsage {
    /** The issue type IDs for the usage. */
    issueTypeIds!: string[];
    /** The project ID for the usage. */
    projectId!: string;

    constructor(data?: ISimpleUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueTypeIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueTypeIds"])) {
                this.issueTypeIds = [] as any;
                for (let item of _data["issueTypeIds"])
                    this.issueTypeIds!.push(item);
            }
            this.projectId = _data["projectId"];
        }
    }

    static fromJS(data: any): SimpleUsage {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleUsage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueTypeIds)) {
            data["issueTypeIds"] = [];
            for (let item of this.issueTypeIds)
                data["issueTypeIds"].push(item);
        }
        data["projectId"] = this.projectId;
        return data;
    }
}

/** Represents a usage of an entity by a project ID and related issue type IDs. */
export interface ISimpleUsage {
    /** The issue type IDs for the usage. */
    issueTypeIds: string[];
    /** The project ID for the usage. */
    projectId: string;
}

export class SimplifiedHierarchyLevel implements ISimplifiedHierarchyLevel {
    /** The ID of the level above this one in the hierarchy. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/). */
    aboveLevelId?: number;
    /** The ID of the level below this one in the hierarchy. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/). */
    belowLevelId?: number;
    /** The external UUID of the hierarchy level. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/). */
    externalUuid?: string;
    hierarchyLevelNumber?: number;
    /** The ID of the hierarchy level. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/). */
    id?: number;
    /** The issue types available in this hierarchy level. */
    issueTypeIds?: number[];
    /** The level of this item in the hierarchy. */
    level?: number;
    /** The name of this hierarchy level. */
    name?: string;
    /** The ID of the project configuration. This property is deprecated, see [Change oticen: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/). */
    projectConfigurationId?: number;

    constructor(data?: ISimplifiedHierarchyLevel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aboveLevelId = _data["aboveLevelId"];
            this.belowLevelId = _data["belowLevelId"];
            this.externalUuid = _data["externalUuid"];
            this.hierarchyLevelNumber = _data["hierarchyLevelNumber"];
            this.id = _data["id"];
            if (Array.isArray(_data["issueTypeIds"])) {
                this.issueTypeIds = [] as any;
                for (let item of _data["issueTypeIds"])
                    this.issueTypeIds!.push(item);
            }
            this.level = _data["level"];
            this.name = _data["name"];
            this.projectConfigurationId = _data["projectConfigurationId"];
        }
    }

    static fromJS(data: any): SimplifiedHierarchyLevel {
        data = typeof data === 'object' ? data : {};
        let result = new SimplifiedHierarchyLevel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aboveLevelId"] = this.aboveLevelId;
        data["belowLevelId"] = this.belowLevelId;
        data["externalUuid"] = this.externalUuid;
        data["hierarchyLevelNumber"] = this.hierarchyLevelNumber;
        data["id"] = this.id;
        if (Array.isArray(this.issueTypeIds)) {
            data["issueTypeIds"] = [];
            for (let item of this.issueTypeIds)
                data["issueTypeIds"].push(item);
        }
        data["level"] = this.level;
        data["name"] = this.name;
        data["projectConfigurationId"] = this.projectConfigurationId;
        return data;
    }
}

export interface ISimplifiedHierarchyLevel {
    /** The ID of the level above this one in the hierarchy. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/). */
    aboveLevelId?: number;
    /** The ID of the level below this one in the hierarchy. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/). */
    belowLevelId?: number;
    /** The external UUID of the hierarchy level. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/). */
    externalUuid?: string;
    hierarchyLevelNumber?: number;
    /** The ID of the hierarchy level. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/). */
    id?: number;
    /** The issue types available in this hierarchy level. */
    issueTypeIds?: number[];
    /** The level of this item in the hierarchy. */
    level?: number;
    /** The name of this hierarchy level. */
    name?: string;
    /** The ID of the project configuration. This property is deprecated, see [Change oticen: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/). */
    projectConfigurationId?: number;
}

export class SimplifiedIssueTransition implements ISimplifiedIssueTransition {
    /** The issue status change of the transition. */
    readonly to?: IssueTransitionStatus;
    /** The unique ID of the transition. */
    readonly transitionId?: number;
    /** The name of the transition. */
    readonly transitionName?: string;

    constructor(data?: ISimplifiedIssueTransition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).to = _data["to"] ? IssueTransitionStatus.fromJS(_data["to"]) : <any>undefined;
            (<any>this).transitionId = _data["transitionId"];
            (<any>this).transitionName = _data["transitionName"];
        }
    }

    static fromJS(data: any): SimplifiedIssueTransition {
        data = typeof data === 'object' ? data : {};
        let result = new SimplifiedIssueTransition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["to"] = this.to ? this.to.toJSON() : <any>undefined;
        data["transitionId"] = this.transitionId;
        data["transitionName"] = this.transitionName;
        return data;
    }
}

export interface ISimplifiedIssueTransition {
    /** The issue status change of the transition. */
    to?: IssueTransitionStatus;
    /** The unique ID of the transition. */
    transitionId?: number;
    /** The name of the transition. */
    transitionName?: string;
}

export class SoftwareNavigationInfo implements ISoftwareNavigationInfo {
    boardId?: number;
    boardName?: string;
    simpleBoard?: boolean;
    totalBoardsInProject?: number;

    [key: string]: any;

    constructor(data?: ISoftwareNavigationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.boardId = _data["boardId"];
            this.boardName = _data["boardName"];
            this.simpleBoard = _data["simpleBoard"];
            this.totalBoardsInProject = _data["totalBoardsInProject"];
        }
    }

    static fromJS(data: any): SoftwareNavigationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SoftwareNavigationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["boardId"] = this.boardId;
        data["boardName"] = this.boardName;
        data["simpleBoard"] = this.simpleBoard;
        data["totalBoardsInProject"] = this.totalBoardsInProject;
        return data;
    }
}

export interface ISoftwareNavigationInfo {
    boardId?: number;
    boardName?: string;
    simpleBoard?: boolean;
    totalBoardsInProject?: number;

    [key: string]: any;
}

/** The status of the item. */
export class Status implements IStatus {
    /** Details of the icon representing the status. If not provided, no status icon displays in Jira. */
    icon?: Icon;
    /** Whether the item is resolved. If set to "true", the link to the issue is displayed in a strikethrough font, otherwise the link displays in normal font. */
    resolved?: boolean;

    [key: string]: any;

    constructor(data?: IStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.icon = _data["icon"] ? Icon.fromJS(_data["icon"]) : <any>undefined;
            this.resolved = _data["resolved"];
        }
    }

    static fromJS(data: any): Status {
        data = typeof data === 'object' ? data : {};
        let result = new Status();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["icon"] = this.icon ? this.icon.toJSON() : <any>undefined;
        data["resolved"] = this.resolved;
        return data;
    }
}

/** The status of the item. */
export interface IStatus {
    /** Details of the icon representing the status. If not provided, no status icon displays in Jira. */
    icon?: Icon;
    /** Whether the item is resolved. If set to "true", the link to the issue is displayed in a strikethrough font, otherwise the link displays in normal font. */
    resolved?: boolean;

    [key: string]: any;
}

/** A status category. */
export class StatusCategory implements IStatusCategory {
    /** The name of the color used to represent the status category. */
    readonly colorName?: string;
    /** The ID of the status category. */
    readonly id?: number;
    /** The key of the status category. */
    readonly key?: string;
    /** The name of the status category. */
    readonly name?: string;
    /** The URL of the status category. */
    readonly self?: string;

    [key: string]: any;

    constructor(data?: IStatusCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).colorName = _data["colorName"];
            (<any>this).id = _data["id"];
            (<any>this).key = _data["key"];
            (<any>this).name = _data["name"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): StatusCategory {
        data = typeof data === 'object' ? data : {};
        let result = new StatusCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["colorName"] = this.colorName;
        data["id"] = this.id;
        data["key"] = this.key;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

/** A status category. */
export interface IStatusCategory {
    /** The name of the color used to represent the status category. */
    colorName?: string;
    /** The ID of the status category. */
    id?: number;
    /** The key of the status category. */
    key?: string;
    /** The name of the status category. */
    name?: string;
    /** The URL of the status category. */
    self?: string;

    [key: string]: any;
}

/** Details of the status being created. */
export class StatusCreate implements IStatusCreate {
    /** The description of the status. */
    description?: string;
    /** The name of the status. */
    name!: string;
    /** The category of the status. */
    statusCategory!: StatusCreateStatusCategory;

    constructor(data?: IStatusCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
            this.statusCategory = _data["statusCategory"];
        }
    }

    static fromJS(data: any): StatusCreate {
        data = typeof data === 'object' ? data : {};
        let result = new StatusCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        data["statusCategory"] = this.statusCategory;
        return data;
    }
}

/** Details of the status being created. */
export interface IStatusCreate {
    /** The description of the status. */
    description?: string;
    /** The name of the status. */
    name: string;
    /** The category of the status. */
    statusCategory: StatusCreateStatusCategory;
}

/** Details of the statuses being created and their scope. */
export class StatusCreateRequest implements IStatusCreateRequest {
    scope!: StatusScope;
    /** Details of the statuses being created. */
    statuses!: StatusCreate[];

    constructor(data?: IStatusCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.scope = new StatusScope();
            this.statuses = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scope = _data["scope"] ? StatusScope.fromJS(_data["scope"]) : new StatusScope();
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(StatusCreate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatusCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StatusCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of the statuses being created and their scope. */
export interface IStatusCreateRequest {
    scope: StatusScope;
    /** Details of the statuses being created. */
    statuses: StatusCreate[];
}

/** A status. */
export class StatusDetails implements IStatusDetails {
    /** The description of the status. */
    readonly description?: string;
    /** The URL of the icon used to represent the status. */
    readonly iconUrl?: string;
    /** The ID of the status. */
    readonly id?: string;
    /** The name of the status. */
    readonly name?: string;
    /** The scope of the field. */
    readonly scope?: Scope;
    /** The URL of the status. */
    readonly self?: string;
    /** The category assigned to the status. */
    readonly statusCategory?: StatusCategory;

    [key: string]: any;

    constructor(data?: IStatusDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).description = _data["description"];
            (<any>this).iconUrl = _data["iconUrl"];
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            (<any>this).scope = _data["scope"] ? Scope.fromJS(_data["scope"]) : <any>undefined;
            (<any>this).self = _data["self"];
            (<any>this).statusCategory = _data["statusCategory"] ? StatusCategory.fromJS(_data["statusCategory"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StatusDetails {
        data = typeof data === 'object' ? data : {};
        let result = new StatusDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        data["id"] = this.id;
        data["name"] = this.name;
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        data["self"] = this.self;
        data["statusCategory"] = this.statusCategory ? this.statusCategory.toJSON() : <any>undefined;
        return data;
    }
}

/** A status. */
export interface IStatusDetails {
    /** The description of the status. */
    description?: string;
    /** The URL of the icon used to represent the status. */
    iconUrl?: string;
    /** The ID of the status. */
    id?: string;
    /** The name of the status. */
    name?: string;
    /** The scope of the field. */
    scope?: Scope;
    /** The URL of the status. */
    self?: string;
    /** The category assigned to the status. */
    statusCategory?: StatusCategory;

    [key: string]: any;
}

/** The statuses associated with this workflow. */
export class StatusLayoutUpdate implements IStatusLayoutUpdate {
    approvalConfiguration?: ApprovalConfiguration | undefined;
    layout?: WorkflowLayout | undefined;
    /** The properties for this status layout. */
    properties!: { [key: string]: string; };
    /** A unique ID which the status will use to refer to this layout configuration. */
    statusReference!: string;

    [key: string]: any;

    constructor(data?: IStatusLayoutUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.properties = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.approvalConfiguration = _data["approvalConfiguration"] ? ApprovalConfiguration.fromJS(_data["approvalConfiguration"]) : <any>undefined;
            this.layout = _data["layout"] ? WorkflowLayout.fromJS(_data["layout"]) : <any>undefined;
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.statusReference = _data["statusReference"];
        }
    }

    static fromJS(data: any): StatusLayoutUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new StatusLayoutUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["approvalConfiguration"] = this.approvalConfiguration ? this.approvalConfiguration.toJSON() : <any>undefined;
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["statusReference"] = this.statusReference;
        return data;
    }
}

/** The statuses associated with this workflow. */
export interface IStatusLayoutUpdate {
    approvalConfiguration?: ApprovalConfiguration | undefined;
    layout?: WorkflowLayout | undefined;
    /** The properties for this status layout. */
    properties: { [key: string]: string; };
    /** A unique ID which the status will use to refer to this layout configuration. */
    statusReference: string;

    [key: string]: any;
}

/** Details about the mapping from a status to a new status for an issue type. */
export class StatusMapping implements IStatusMapping {
    /** The ID of the issue type. */
    issueTypeId!: string;
    /** The ID of the new status. */
    newStatusId!: string;
    /** The ID of the status. */
    statusId!: string;

    constructor(data?: IStatusMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueTypeId = _data["issueTypeId"];
            this.newStatusId = _data["newStatusId"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): StatusMapping {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueTypeId"] = this.issueTypeId;
        data["newStatusId"] = this.newStatusId;
        data["statusId"] = this.statusId;
        return data;
    }
}

/** Details about the mapping from a status to a new status for an issue type. */
export interface IStatusMapping {
    /** The ID of the issue type. */
    issueTypeId: string;
    /** The ID of the new status. */
    newStatusId: string;
    /** The ID of the status. */
    statusId: string;
}

/** The mapping of old to new status ID for a specific project and issue type. */
export class StatusMappingDTO implements IStatusMappingDTO {
    /** The issue type for the status mapping. */
    issueTypeId!: string;
    /** The project for the status mapping. */
    projectId!: string;
    /** The list of old and new status ID mappings for the specified project and issue type. */
    statusMigrations!: StatusMigration[];

    [key: string]: any;

    constructor(data?: IStatusMappingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.statusMigrations = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.issueTypeId = _data["issueTypeId"];
            this.projectId = _data["projectId"];
            if (Array.isArray(_data["statusMigrations"])) {
                this.statusMigrations = [] as any;
                for (let item of _data["statusMigrations"])
                    this.statusMigrations!.push(StatusMigration.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatusMappingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMappingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["issueTypeId"] = this.issueTypeId;
        data["projectId"] = this.projectId;
        if (Array.isArray(this.statusMigrations)) {
            data["statusMigrations"] = [];
            for (let item of this.statusMigrations)
                data["statusMigrations"].push(item.toJSON());
        }
        return data;
    }
}

/** The mapping of old to new status ID for a specific project and issue type. */
export interface IStatusMappingDTO {
    /** The issue type for the status mapping. */
    issueTypeId: string;
    /** The project for the status mapping. */
    projectId: string;
    /** The list of old and new status ID mappings for the specified project and issue type. */
    statusMigrations: StatusMigration[];

    [key: string]: any;
}

/** The details of the statuses in the associated workflows. */
export class StatusMetadata implements IStatusMetadata {
    /** The category of the status. */
    category?: StatusMetadataCategory;
    /** The ID of the status. */
    id?: string;
    /** The name of the status. */
    name?: string;

    constructor(data?: IStatusMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): StatusMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** The details of the statuses in the associated workflows. */
export interface IStatusMetadata {
    /** The category of the status. */
    category?: StatusMetadataCategory;
    /** The ID of the status. */
    id?: string;
    /** The name of the status. */
    name?: string;
}

/** The mapping of old to new status ID. */
export class StatusMigration implements IStatusMigration {
    /** The new status ID. */
    newStatusReference!: string;
    /** The old status ID. */
    oldStatusReference!: string;

    [key: string]: any;

    constructor(data?: IStatusMigration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.newStatusReference = _data["newStatusReference"];
            this.oldStatusReference = _data["oldStatusReference"];
        }
    }

    static fromJS(data: any): StatusMigration {
        data = typeof data === 'object' ? data : {};
        let result = new StatusMigration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["newStatusReference"] = this.newStatusReference;
        data["oldStatusReference"] = this.oldStatusReference;
        return data;
    }
}

/** The mapping of old to new status ID. */
export interface IStatusMigration {
    /** The new status ID. */
    newStatusReference: string;
    /** The old status ID. */
    oldStatusReference: string;

    [key: string]: any;
}

/** The payload for creating a status */
export class StatusPayload implements IStatusPayload {
    /** The description of the status */
    description?: string;
    /** The name of the status */
    name?: string;
    /** The conflict strategy for the status already exists. FAIL - Fail execution, this always needs to be unique; USE - Use the existing entity and ignore new entity parameters; NEW - Create a new entity */
    onConflict?: StatusPayloadOnConflict;
    pcri?: ProjectCreateResourceIdentifier;
    /** The status category of the status. The value is case-sensitive. */
    statusCategory?: StatusPayloadStatusCategory;

    constructor(data?: IStatusPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
            this.onConflict = _data["onConflict"];
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
            this.statusCategory = _data["statusCategory"];
        }
    }

    static fromJS(data: any): StatusPayload {
        data = typeof data === 'object' ? data : {};
        let result = new StatusPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        data["onConflict"] = this.onConflict;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        data["statusCategory"] = this.statusCategory;
        return data;
    }
}

/** The payload for creating a status */
export interface IStatusPayload {
    /** The description of the status */
    description?: string;
    /** The name of the status */
    name?: string;
    /** The conflict strategy for the status already exists. FAIL - Fail execution, this always needs to be unique; USE - Use the existing entity and ignore new entity parameters; NEW - Create a new entity */
    onConflict?: StatusPayloadOnConflict;
    pcri?: ProjectCreateResourceIdentifier;
    /** The status category of the status. The value is case-sensitive. */
    statusCategory?: StatusPayloadStatusCategory;
}

/** The list of issue types. */
export class StatusProjectIssueTypeUsage implements IStatusProjectIssueTypeUsage {
    /** The issue type ID. */
    id?: string;

    constructor(data?: IStatusProjectIssueTypeUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StatusProjectIssueTypeUsage {
        data = typeof data === 'object' ? data : {};
        let result = new StatusProjectIssueTypeUsage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** The list of issue types. */
export interface IStatusProjectIssueTypeUsage {
    /** The issue type ID. */
    id?: string;
}

/** The issue types using this status in a project. */
export class StatusProjectIssueTypeUsageDTO implements IStatusProjectIssueTypeUsageDTO {
    issueTypes?: StatusProjectIssueTypeUsagePage;
    /** The project ID. */
    projectId?: string;
    /** The status ID. */
    statusId?: string;

    constructor(data?: IStatusProjectIssueTypeUsageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueTypes = _data["issueTypes"] ? StatusProjectIssueTypeUsagePage.fromJS(_data["issueTypes"]) : <any>undefined;
            this.projectId = _data["projectId"];
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): StatusProjectIssueTypeUsageDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StatusProjectIssueTypeUsageDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueTypes"] = this.issueTypes ? this.issueTypes.toJSON() : <any>undefined;
        data["projectId"] = this.projectId;
        data["statusId"] = this.statusId;
        return data;
    }
}

/** The issue types using this status in a project. */
export interface IStatusProjectIssueTypeUsageDTO {
    issueTypes?: StatusProjectIssueTypeUsagePage;
    /** The project ID. */
    projectId?: string;
    /** The status ID. */
    statusId?: string;
}

/** A page of issue types. */
export class StatusProjectIssueTypeUsagePage implements IStatusProjectIssueTypeUsagePage {
    /** Page token for the next page of issue type usages. */
    nextPageToken?: string;
    /** The list of issue types. */
    values?: StatusProjectIssueTypeUsage[];

    constructor(data?: IStatusProjectIssueTypeUsagePage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nextPageToken = _data["nextPageToken"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(StatusProjectIssueTypeUsage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatusProjectIssueTypeUsagePage {
        data = typeof data === 'object' ? data : {};
        let result = new StatusProjectIssueTypeUsagePage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nextPageToken"] = this.nextPageToken;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of issue types. */
export interface IStatusProjectIssueTypeUsagePage {
    /** Page token for the next page of issue type usages. */
    nextPageToken?: string;
    /** The list of issue types. */
    values?: StatusProjectIssueTypeUsage[];
}

/** The project. */
export class StatusProjectUsage implements IStatusProjectUsage {
    /** The project ID. */
    id?: string;

    constructor(data?: IStatusProjectUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StatusProjectUsage {
        data = typeof data === 'object' ? data : {};
        let result = new StatusProjectUsage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** The project. */
export interface IStatusProjectUsage {
    /** The project ID. */
    id?: string;
}

/** The projects using this status. */
export class StatusProjectUsageDTO implements IStatusProjectUsageDTO {
    projects?: StatusProjectUsagePage;
    /** The status ID. */
    statusId?: string;

    constructor(data?: IStatusProjectUsageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projects = _data["projects"] ? StatusProjectUsagePage.fromJS(_data["projects"]) : <any>undefined;
            this.statusId = _data["statusId"];
        }
    }

    static fromJS(data: any): StatusProjectUsageDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StatusProjectUsageDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projects"] = this.projects ? this.projects.toJSON() : <any>undefined;
        data["statusId"] = this.statusId;
        return data;
    }
}

/** The projects using this status. */
export interface IStatusProjectUsageDTO {
    projects?: StatusProjectUsagePage;
    /** The status ID. */
    statusId?: string;
}

/** A page of projects. */
export class StatusProjectUsagePage implements IStatusProjectUsagePage {
    /** Page token for the next page of issue type usages. */
    nextPageToken?: string;
    /** The list of projects. */
    values?: StatusProjectUsage[];

    constructor(data?: IStatusProjectUsagePage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nextPageToken = _data["nextPageToken"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(StatusProjectUsage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatusProjectUsagePage {
        data = typeof data === 'object' ? data : {};
        let result = new StatusProjectUsagePage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nextPageToken"] = this.nextPageToken;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of projects. */
export interface IStatusProjectUsagePage {
    /** Page token for the next page of issue type usages. */
    nextPageToken?: string;
    /** The list of projects. */
    values?: StatusProjectUsage[];
}

/** The scope of the status. */
export class StatusScope implements IStatusScope {
    project?: ProjectId | undefined;
    /** The scope of the status. `GLOBAL` for company-managed projects and `PROJECT` for team-managed projects. */
    type!: StatusScopeType;

    constructor(data?: IStatusScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.project = _data["project"] ? ProjectId.fromJS(_data["project"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): StatusScope {
        data = typeof data === 'object' ? data : {};
        let result = new StatusScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

/** The scope of the status. */
export interface IStatusScope {
    project?: ProjectId | undefined;
    /** The scope of the status. `GLOBAL` for company-managed projects and `PROJECT` for team-managed projects. */
    type: StatusScopeType;
}

/** Details of the status being updated. */
export class StatusUpdate implements IStatusUpdate {
    /** The description of the status. */
    description?: string;
    /** The ID of the status. */
    id!: string;
    /** The name of the status. */
    name!: string;
    /** The category of the status. */
    statusCategory!: StatusUpdateStatusCategory;

    [key: string]: any;

    constructor(data?: IStatusUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.statusCategory = _data["statusCategory"];
        }
    }

    static fromJS(data: any): StatusUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new StatusUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["statusCategory"] = this.statusCategory;
        return data;
    }
}

/** Details of the status being updated. */
export interface IStatusUpdate {
    /** The description of the status. */
    description?: string;
    /** The ID of the status. */
    id: string;
    /** The name of the status. */
    name: string;
    /** The category of the status. */
    statusCategory: StatusUpdateStatusCategory;

    [key: string]: any;
}

/** The list of statuses that will be updated. */
export class StatusUpdateRequest implements IStatusUpdateRequest {
    /** The list of statuses that will be updated. */
    statuses!: StatusUpdate[];

    constructor(data?: IStatusUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.statuses = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(StatusUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatusUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StatusUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        return data;
    }
}

/** The list of statuses that will be updated. */
export interface IStatusUpdateRequest {
    /** The list of statuses that will be updated. */
    statuses: StatusUpdate[];
}

/** Workflows using the status. */
export class StatusWorkflowUsageDTO implements IStatusWorkflowUsageDTO {
    /** The status ID. */
    statusId?: string;
    workflows?: StatusWorkflowUsagePage;

    constructor(data?: IStatusWorkflowUsageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusId = _data["statusId"];
            this.workflows = _data["workflows"] ? StatusWorkflowUsagePage.fromJS(_data["workflows"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StatusWorkflowUsageDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StatusWorkflowUsageDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusId"] = this.statusId;
        data["workflows"] = this.workflows ? this.workflows.toJSON() : <any>undefined;
        return data;
    }
}

/** Workflows using the status. */
export interface IStatusWorkflowUsageDTO {
    /** The status ID. */
    statusId?: string;
    workflows?: StatusWorkflowUsagePage;
}

/** A page of workflows. */
export class StatusWorkflowUsagePage implements IStatusWorkflowUsagePage {
    /** Page token for the next page of issue type usages. */
    nextPageToken?: string;
    /** The list of statuses. */
    values?: StatusWorkflowUsageWorkflow[];

    constructor(data?: IStatusWorkflowUsagePage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nextPageToken = _data["nextPageToken"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(StatusWorkflowUsageWorkflow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatusWorkflowUsagePage {
        data = typeof data === 'object' ? data : {};
        let result = new StatusWorkflowUsagePage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nextPageToken"] = this.nextPageToken;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of workflows. */
export interface IStatusWorkflowUsagePage {
    /** Page token for the next page of issue type usages. */
    nextPageToken?: string;
    /** The list of statuses. */
    values?: StatusWorkflowUsageWorkflow[];
}

/** The worflow. */
export class StatusWorkflowUsageWorkflow implements IStatusWorkflowUsageWorkflow {
    /** The workflow ID. */
    id?: string;

    constructor(data?: IStatusWorkflowUsageWorkflow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): StatusWorkflowUsageWorkflow {
        data = typeof data === 'object' ? data : {};
        let result = new StatusWorkflowUsageWorkflow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** The worflow. */
export interface IStatusWorkflowUsageWorkflow {
    /** The workflow ID. */
    id?: string;
}

/** The statuses associated with each workflow. */
export class StatusesPerWorkflow implements IStatusesPerWorkflow {
    /** The ID of the initial status for the workflow. */
    initialStatusId?: string;
    /** The status IDs associated with the workflow. */
    statuses?: string[];
    /** The ID of the workflow. */
    workflowId?: string;

    constructor(data?: IStatusesPerWorkflow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.initialStatusId = _data["initialStatusId"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(item);
            }
            this.workflowId = _data["workflowId"];
        }
    }

    static fromJS(data: any): StatusesPerWorkflow {
        data = typeof data === 'object' ? data : {};
        let result = new StatusesPerWorkflow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["initialStatusId"] = this.initialStatusId;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item);
        }
        data["workflowId"] = this.workflowId;
        return data;
    }
}

/** The statuses associated with each workflow. */
export interface IStatusesPerWorkflow {
    /** The ID of the initial status for the workflow. */
    initialStatusId?: string;
    /** The status IDs associated with the workflow. */
    statuses?: string[];
    /** The ID of the workflow. */
    workflowId?: string;
}

export class StreamingResponseBody implements IStreamingResponseBody {

    constructor(data?: IStreamingResponseBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): StreamingResponseBody {
        data = typeof data === 'object' ? data : {};
        let result = new StreamingResponseBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IStreamingResponseBody {
}

export class StringList implements IStringList {

    constructor(data?: IStringList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): StringList {
        data = typeof data === 'object' ? data : {};
        let result = new StringList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IStringList {
}

export class SubmittedBulkOperation implements ISubmittedBulkOperation {
    taskId?: string;

    constructor(data?: ISubmittedBulkOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
        }
    }

    static fromJS(data: any): SubmittedBulkOperation {
        data = typeof data === 'object' ? data : {};
        let result = new SubmittedBulkOperation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        return data;
    }
}

export interface ISubmittedBulkOperation {
    taskId?: string;
}

/** An issue suggested for use in the issue picker auto-completion. */
export class SuggestedIssue implements ISuggestedIssue {
    /** The ID of the issue. */
    readonly id?: number;
    /** The URL of the issue type's avatar. */
    readonly img?: string;
    /** The key of the issue. */
    readonly key?: string;
    /** The key of the issue in HTML format. */
    readonly keyHtml?: string;
    /** The phrase containing the query string in HTML format, with the string highlighted with HTML bold tags. */
    readonly summary?: string;
    /** The phrase containing the query string, as plain text. */
    readonly summaryText?: string;

    constructor(data?: ISuggestedIssue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).img = _data["img"];
            (<any>this).key = _data["key"];
            (<any>this).keyHtml = _data["keyHtml"];
            (<any>this).summary = _data["summary"];
            (<any>this).summaryText = _data["summaryText"];
        }
    }

    static fromJS(data: any): SuggestedIssue {
        data = typeof data === 'object' ? data : {};
        let result = new SuggestedIssue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["img"] = this.img;
        data["key"] = this.key;
        data["keyHtml"] = this.keyHtml;
        data["summary"] = this.summary;
        data["summaryText"] = this.summaryText;
        return data;
    }
}

/** An issue suggested for use in the issue picker auto-completion. */
export interface ISuggestedIssue {
    /** The ID of the issue. */
    id?: number;
    /** The URL of the issue type's avatar. */
    img?: string;
    /** The key of the issue. */
    key?: string;
    /** The key of the issue in HTML format. */
    keyHtml?: string;
    /** The phrase containing the query string in HTML format, with the string highlighted with HTML bold tags. */
    summary?: string;
    /** The phrase containing the query string, as plain text. */
    summaryText?: string;
}

/** Details of changes to a priority scheme's priorities that require suggested priority mappings. */
export class SuggestedMappingsForPrioritiesRequestBean implements ISuggestedMappingsForPrioritiesRequestBean {
    /** The ids of priorities being removed from the scheme. */
    add?: number[];
    /** The ids of priorities being removed from the scheme. */
    remove?: number[];

    constructor(data?: ISuggestedMappingsForPrioritiesRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["add"])) {
                this.add = [] as any;
                for (let item of _data["add"])
                    this.add!.push(item);
            }
            if (Array.isArray(_data["remove"])) {
                this.remove = [] as any;
                for (let item of _data["remove"])
                    this.remove!.push(item);
            }
        }
    }

    static fromJS(data: any): SuggestedMappingsForPrioritiesRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new SuggestedMappingsForPrioritiesRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.add)) {
            data["add"] = [];
            for (let item of this.add)
                data["add"].push(item);
        }
        if (Array.isArray(this.remove)) {
            data["remove"] = [];
            for (let item of this.remove)
                data["remove"].push(item);
        }
        return data;
    }
}

/** Details of changes to a priority scheme's priorities that require suggested priority mappings. */
export interface ISuggestedMappingsForPrioritiesRequestBean {
    /** The ids of priorities being removed from the scheme. */
    add?: number[];
    /** The ids of priorities being removed from the scheme. */
    remove?: number[];
}

/** Details of changes to a priority scheme's projects that require suggested priority mappings. */
export class SuggestedMappingsForProjectsRequestBean implements ISuggestedMappingsForProjectsRequestBean {
    /** The ids of projects being added to the scheme. */
    add?: number[];

    constructor(data?: ISuggestedMappingsForProjectsRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["add"])) {
                this.add = [] as any;
                for (let item of _data["add"])
                    this.add!.push(item);
            }
        }
    }

    static fromJS(data: any): SuggestedMappingsForProjectsRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new SuggestedMappingsForProjectsRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.add)) {
            data["add"] = [];
            for (let item of this.add)
                data["add"].push(item);
        }
        return data;
    }
}

/** Details of changes to a priority scheme's projects that require suggested priority mappings. */
export interface ISuggestedMappingsForProjectsRequestBean {
    /** The ids of projects being added to the scheme. */
    add?: number[];
}

/** Details of changes to a priority scheme that require suggested priority mappings. */
export class SuggestedMappingsRequestBean implements ISuggestedMappingsRequestBean {
    /** The maximum number of results that could be on the page. */
    maxResults?: number;
    /** The priority changes in the scheme. */
    priorities?: SuggestedMappingsForPrioritiesRequestBean;
    /** The project changes in the scheme. */
    projects?: SuggestedMappingsForProjectsRequestBean;
    /** The id of the priority scheme. */
    schemeId?: number;
    /** The index of the first item returned on the page. */
    startAt?: number;

    constructor(data?: ISuggestedMappingsRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResults = _data["maxResults"];
            this.priorities = _data["priorities"] ? SuggestedMappingsForPrioritiesRequestBean.fromJS(_data["priorities"]) : <any>undefined;
            this.projects = _data["projects"] ? SuggestedMappingsForProjectsRequestBean.fromJS(_data["projects"]) : <any>undefined;
            this.schemeId = _data["schemeId"];
            this.startAt = _data["startAt"];
        }
    }

    static fromJS(data: any): SuggestedMappingsRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new SuggestedMappingsRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResults"] = this.maxResults;
        data["priorities"] = this.priorities ? this.priorities.toJSON() : <any>undefined;
        data["projects"] = this.projects ? this.projects.toJSON() : <any>undefined;
        data["schemeId"] = this.schemeId;
        data["startAt"] = this.startAt;
        return data;
    }
}

/** Details of changes to a priority scheme that require suggested priority mappings. */
export interface ISuggestedMappingsRequestBean {
    /** The maximum number of results that could be on the page. */
    maxResults?: number;
    /** The priority changes in the scheme. */
    priorities?: SuggestedMappingsForPrioritiesRequestBean;
    /** The project changes in the scheme. */
    projects?: SuggestedMappingsForProjectsRequestBean;
    /** The id of the priority scheme. */
    schemeId?: number;
    /** The index of the first item returned on the page. */
    startAt?: number;
}

/** The payload for custom swimlanes */
export enum SwimlanePayload {
    None__custom__parentChild__assignee__assigneeUnassignedFirst__epic__project__issueparent__issuechildren__request_type = "none, custom, parentChild, assignee, assigneeUnassignedFirst, epic, project, issueparent, issuechildren, request_type",
}

/** The payload for customising a swimlanes on a board */
export class SwimlanesPayload implements ISwimlanesPayload {
    /** The custom swimlane definitions. */
    customSwimlanes?: SwimlanesPayloadCustomSwimlanes;
    /** The name of the custom swimlane to use for work items that don't match any other swimlanes. */
    defaultCustomSwimlaneName?: string;
    /** The swimlane strategy for the board. */
    swimlaneStrategy?: SwimlanesPayloadSwimlaneStrategy;

    constructor(data?: ISwimlanesPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["customSwimlanes"])) {
                this.customSwimlanes = [] as any;
                for (let item of _data["customSwimlanes"])
                    this.customSwimlanes!.push(item);
            }
            this.defaultCustomSwimlaneName = _data["defaultCustomSwimlaneName"];
            this.swimlaneStrategy = _data["swimlaneStrategy"];
        }
    }

    static fromJS(data: any): SwimlanesPayload {
        data = typeof data === 'object' ? data : {};
        let result = new SwimlanesPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customSwimlanes)) {
            data["customSwimlanes"] = [];
            for (let item of this.customSwimlanes)
                data["customSwimlanes"].push(item);
        }
        data["defaultCustomSwimlaneName"] = this.defaultCustomSwimlaneName;
        data["swimlaneStrategy"] = this.swimlaneStrategy;
        return data;
    }
}

/** The payload for customising a swimlanes on a board */
export interface ISwimlanesPayload {
    /** The custom swimlane definitions. */
    customSwimlanes?: SwimlanesPayloadCustomSwimlanes;
    /** The name of the custom swimlane to use for work items that don't match any other swimlanes. */
    defaultCustomSwimlaneName?: string;
    /** The swimlane strategy for the board. */
    swimlaneStrategy?: SwimlanesPayloadSwimlaneStrategy;
}

/** List of system avatars. */
export class SystemAvatars implements ISystemAvatars {
    /** A list of avatar details. */
    readonly system?: Avatar[];

    constructor(data?: ISystemAvatars) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["system"])) {
                (<any>this).system = [] as any;
                for (let item of _data["system"])
                    (<any>this).system!.push(Avatar.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SystemAvatars {
        data = typeof data === 'object' ? data : {};
        let result = new SystemAvatars();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.system)) {
            data["system"] = [];
            for (let item of this.system)
                data["system"].push(item.toJSON());
        }
        return data;
    }
}

/** List of system avatars. */
export interface ISystemAvatars {
    /** A list of avatar details. */
    system?: Avatar[];
}

/** Defines the payload for the tabs of the screen. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-screen-tab-fields/\#api-rest-api-3-screens-screenid-tabs-tabid-fields-post */
export class TabPayload implements ITabPayload {
    /** The list of resource identifier of the field associated to the tab. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-screen-tab-fields/\#api-rest-api-3-screens-screenid-tabs-tabid-fields-post */
    fields?: ProjectCreateResourceIdentifier[];
    /** The name of the tab */
    name?: string;

    constructor(data?: ITabPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(ProjectCreateResourceIdentifier.fromJS(item));
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TabPayload {
        data = typeof data === 'object' ? data : {};
        let result = new TabPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        data["name"] = this.name;
        return data;
    }
}

/** Defines the payload for the tabs of the screen. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-screen-tab-fields/\#api-rest-api-3-screens-screenid-tabs-tabid-fields-post */
export interface ITabPayload {
    /** The list of resource identifier of the field associated to the tab. See https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-screen-tab-fields/\#api-rest-api-3-screens-screenid-tabs-tabid-fields-post */
    fields?: ProjectCreateResourceIdentifier[];
    /** The name of the tab */
    name?: string;
}

/** Details about a task. */
export class TaskProgressBeanJsonNode implements ITaskProgressBeanJsonNode {
    /** The description of the task. */
    description?: string;
    /** The execution time of the task, in milliseconds. */
    elapsedRuntime!: number;
    /** A timestamp recording when the task was finished. */
    finished?: number;
    /** The ID of the task. */
    id!: string;
    /** A timestamp recording when the task progress was last updated. */
    lastUpdate!: number;
    /** Information about the progress of the task. */
    message?: string;
    /** The progress of the task, as a percentage complete. */
    progress!: number;
    /** The result of the task execution. */
    result?: JsonNode;
    /** The URL of the task. */
    self!: string;
    /** A timestamp recording when the task was started. */
    started?: number;
    /** The status of the task. */
    status!: TaskProgressBeanJsonNodeStatus;
    /** A timestamp recording when the task was submitted. */
    submitted!: number;
    /** The ID of the user who submitted the task. */
    submittedBy!: number;

    constructor(data?: ITaskProgressBeanJsonNode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.elapsedRuntime = _data["elapsedRuntime"];
            this.finished = _data["finished"];
            this.id = _data["id"];
            this.lastUpdate = _data["lastUpdate"];
            this.message = _data["message"];
            this.progress = _data["progress"];
            this.result = _data["result"] ? JsonNode.fromJS(_data["result"]) : <any>undefined;
            this.self = _data["self"];
            this.started = _data["started"];
            this.status = _data["status"];
            this.submitted = _data["submitted"];
            this.submittedBy = _data["submittedBy"];
        }
    }

    static fromJS(data: any): TaskProgressBeanJsonNode {
        data = typeof data === 'object' ? data : {};
        let result = new TaskProgressBeanJsonNode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["elapsedRuntime"] = this.elapsedRuntime;
        data["finished"] = this.finished;
        data["id"] = this.id;
        data["lastUpdate"] = this.lastUpdate;
        data["message"] = this.message;
        data["progress"] = this.progress;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["self"] = this.self;
        data["started"] = this.started;
        data["status"] = this.status;
        data["submitted"] = this.submitted;
        data["submittedBy"] = this.submittedBy;
        return data;
    }
}

/** Details about a task. */
export interface ITaskProgressBeanJsonNode {
    /** The description of the task. */
    description?: string;
    /** The execution time of the task, in milliseconds. */
    elapsedRuntime: number;
    /** A timestamp recording when the task was finished. */
    finished?: number;
    /** The ID of the task. */
    id: string;
    /** A timestamp recording when the task progress was last updated. */
    lastUpdate: number;
    /** Information about the progress of the task. */
    message?: string;
    /** The progress of the task, as a percentage complete. */
    progress: number;
    /** The result of the task execution. */
    result?: JsonNode;
    /** The URL of the task. */
    self: string;
    /** A timestamp recording when the task was started. */
    started?: number;
    /** The status of the task. */
    status: TaskProgressBeanJsonNodeStatus;
    /** A timestamp recording when the task was submitted. */
    submitted: number;
    /** The ID of the user who submitted the task. */
    submittedBy: number;
}

/** Details about a task. */
export class TaskProgressBeanObject implements ITaskProgressBeanObject {
    /** The description of the task. */
    description?: string;
    /** The execution time of the task, in milliseconds. */
    elapsedRuntime!: number;
    /** A timestamp recording when the task was finished. */
    finished?: number;
    /** The ID of the task. */
    id!: string;
    /** A timestamp recording when the task progress was last updated. */
    lastUpdate!: number;
    /** Information about the progress of the task. */
    message?: string;
    /** The progress of the task, as a percentage complete. */
    progress!: number;
    /** The result of the task execution. */
    result?: any;
    /** The URL of the task. */
    self!: string;
    /** A timestamp recording when the task was started. */
    started?: number;
    /** The status of the task. */
    status!: TaskProgressBeanObjectStatus;
    /** A timestamp recording when the task was submitted. */
    submitted!: number;
    /** The ID of the user who submitted the task. */
    submittedBy!: number;

    constructor(data?: ITaskProgressBeanObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.elapsedRuntime = _data["elapsedRuntime"];
            this.finished = _data["finished"];
            this.id = _data["id"];
            this.lastUpdate = _data["lastUpdate"];
            this.message = _data["message"];
            this.progress = _data["progress"];
            this.result = _data["result"];
            this.self = _data["self"];
            this.started = _data["started"];
            this.status = _data["status"];
            this.submitted = _data["submitted"];
            this.submittedBy = _data["submittedBy"];
        }
    }

    static fromJS(data: any): TaskProgressBeanObject {
        data = typeof data === 'object' ? data : {};
        let result = new TaskProgressBeanObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["elapsedRuntime"] = this.elapsedRuntime;
        data["finished"] = this.finished;
        data["id"] = this.id;
        data["lastUpdate"] = this.lastUpdate;
        data["message"] = this.message;
        data["progress"] = this.progress;
        data["result"] = this.result;
        data["self"] = this.self;
        data["started"] = this.started;
        data["status"] = this.status;
        data["submitted"] = this.submitted;
        data["submittedBy"] = this.submittedBy;
        return data;
    }
}

/** Details about a task. */
export interface ITaskProgressBeanObject {
    /** The description of the task. */
    description?: string;
    /** The execution time of the task, in milliseconds. */
    elapsedRuntime: number;
    /** A timestamp recording when the task was finished. */
    finished?: number;
    /** The ID of the task. */
    id: string;
    /** A timestamp recording when the task progress was last updated. */
    lastUpdate: number;
    /** Information about the progress of the task. */
    message?: string;
    /** The progress of the task, as a percentage complete. */
    progress: number;
    /** The result of the task execution. */
    result?: any;
    /** The URL of the task. */
    self: string;
    /** A timestamp recording when the task was started. */
    started?: number;
    /** The status of the task. */
    status: TaskProgressBeanObjectStatus;
    /** A timestamp recording when the task was submitted. */
    submitted: number;
    /** The ID of the user who submitted the task. */
    submittedBy: number;
}

/** Details about a task. */
export class TaskProgressBeanRemoveOptionFromIssuesResult implements ITaskProgressBeanRemoveOptionFromIssuesResult {
    /** The description of the task. */
    description?: string;
    /** The execution time of the task, in milliseconds. */
    elapsedRuntime!: number;
    /** A timestamp recording when the task was finished. */
    finished?: number;
    /** The ID of the task. */
    id!: string;
    /** A timestamp recording when the task progress was last updated. */
    lastUpdate!: number;
    /** Information about the progress of the task. */
    message?: string;
    /** The progress of the task, as a percentage complete. */
    progress!: number;
    /** The result of the task execution. */
    result?: RemoveOptionFromIssuesResult;
    /** The URL of the task. */
    self!: string;
    /** A timestamp recording when the task was started. */
    started?: number;
    /** The status of the task. */
    status!: TaskProgressBeanRemoveOptionFromIssuesResultStatus;
    /** A timestamp recording when the task was submitted. */
    submitted!: number;
    /** The ID of the user who submitted the task. */
    submittedBy!: number;

    constructor(data?: ITaskProgressBeanRemoveOptionFromIssuesResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.elapsedRuntime = _data["elapsedRuntime"];
            this.finished = _data["finished"];
            this.id = _data["id"];
            this.lastUpdate = _data["lastUpdate"];
            this.message = _data["message"];
            this.progress = _data["progress"];
            this.result = _data["result"] ? RemoveOptionFromIssuesResult.fromJS(_data["result"]) : <any>undefined;
            this.self = _data["self"];
            this.started = _data["started"];
            this.status = _data["status"];
            this.submitted = _data["submitted"];
            this.submittedBy = _data["submittedBy"];
        }
    }

    static fromJS(data: any): TaskProgressBeanRemoveOptionFromIssuesResult {
        data = typeof data === 'object' ? data : {};
        let result = new TaskProgressBeanRemoveOptionFromIssuesResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["elapsedRuntime"] = this.elapsedRuntime;
        data["finished"] = this.finished;
        data["id"] = this.id;
        data["lastUpdate"] = this.lastUpdate;
        data["message"] = this.message;
        data["progress"] = this.progress;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["self"] = this.self;
        data["started"] = this.started;
        data["status"] = this.status;
        data["submitted"] = this.submitted;
        data["submittedBy"] = this.submittedBy;
        return data;
    }
}

/** Details about a task. */
export interface ITaskProgressBeanRemoveOptionFromIssuesResult {
    /** The description of the task. */
    description?: string;
    /** The execution time of the task, in milliseconds. */
    elapsedRuntime: number;
    /** A timestamp recording when the task was finished. */
    finished?: number;
    /** The ID of the task. */
    id: string;
    /** A timestamp recording when the task progress was last updated. */
    lastUpdate: number;
    /** Information about the progress of the task. */
    message?: string;
    /** The progress of the task, as a percentage complete. */
    progress: number;
    /** The result of the task execution. */
    result?: RemoveOptionFromIssuesResult;
    /** The URL of the task. */
    self: string;
    /** A timestamp recording when the task was started. */
    started?: number;
    /** The status of the task. */
    status: TaskProgressBeanRemoveOptionFromIssuesResultStatus;
    /** A timestamp recording when the task was submitted. */
    submitted: number;
    /** The ID of the user who submitted the task. */
    submittedBy: number;
}

/** Details of the time tracking configuration. */
export class TimeTrackingConfiguration implements ITimeTrackingConfiguration {
    /** The default unit of time applied to logged time. */
    defaultUnit!: TimeTrackingConfigurationDefaultUnit;
    /** The format that will appear on an issue's *Time Spent* field. */
    timeFormat!: TimeTrackingConfigurationTimeFormat;
    /** The number of days in a working week. */
    workingDaysPerWeek!: number;
    /** The number of hours in a working day. */
    workingHoursPerDay!: number;

    constructor(data?: ITimeTrackingConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultUnit = _data["defaultUnit"];
            this.timeFormat = _data["timeFormat"];
            this.workingDaysPerWeek = _data["workingDaysPerWeek"];
            this.workingHoursPerDay = _data["workingHoursPerDay"];
        }
    }

    static fromJS(data: any): TimeTrackingConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new TimeTrackingConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultUnit"] = this.defaultUnit;
        data["timeFormat"] = this.timeFormat;
        data["workingDaysPerWeek"] = this.workingDaysPerWeek;
        data["workingHoursPerDay"] = this.workingHoursPerDay;
        return data;
    }
}

/** Details of the time tracking configuration. */
export interface ITimeTrackingConfiguration {
    /** The default unit of time applied to logged time. */
    defaultUnit: TimeTrackingConfigurationDefaultUnit;
    /** The format that will appear on an issue's *Time Spent* field. */
    timeFormat: TimeTrackingConfigurationTimeFormat;
    /** The number of days in a working week. */
    workingDaysPerWeek: number;
    /** The number of hours in a working day. */
    workingHoursPerDay: number;
}

/** Time tracking details. */
export class TimeTrackingDetails implements ITimeTrackingDetails {
    /** The original estimate of time needed for this issue in readable format. */
    readonly originalEstimate?: string;
    /** The original estimate of time needed for this issue in seconds. */
    readonly originalEstimateSeconds?: number;
    /** The remaining estimate of time needed for this issue in readable format. */
    readonly remainingEstimate?: string;
    /** The remaining estimate of time needed for this issue in seconds. */
    readonly remainingEstimateSeconds?: number;
    /** Time worked on this issue in readable format. */
    readonly timeSpent?: string;
    /** Time worked on this issue in seconds. */
    readonly timeSpentSeconds?: number;

    constructor(data?: ITimeTrackingDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).originalEstimate = _data["originalEstimate"];
            (<any>this).originalEstimateSeconds = _data["originalEstimateSeconds"];
            (<any>this).remainingEstimate = _data["remainingEstimate"];
            (<any>this).remainingEstimateSeconds = _data["remainingEstimateSeconds"];
            (<any>this).timeSpent = _data["timeSpent"];
            (<any>this).timeSpentSeconds = _data["timeSpentSeconds"];
        }
    }

    static fromJS(data: any): TimeTrackingDetails {
        data = typeof data === 'object' ? data : {};
        let result = new TimeTrackingDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originalEstimate"] = this.originalEstimate;
        data["originalEstimateSeconds"] = this.originalEstimateSeconds;
        data["remainingEstimate"] = this.remainingEstimate;
        data["remainingEstimateSeconds"] = this.remainingEstimateSeconds;
        data["timeSpent"] = this.timeSpent;
        data["timeSpentSeconds"] = this.timeSpentSeconds;
        return data;
    }
}

/** Time tracking details. */
export interface ITimeTrackingDetails {
    /** The original estimate of time needed for this issue in readable format. */
    originalEstimate?: string;
    /** The original estimate of time needed for this issue in seconds. */
    originalEstimateSeconds?: number;
    /** The remaining estimate of time needed for this issue in readable format. */
    remainingEstimate?: string;
    /** The remaining estimate of time needed for this issue in seconds. */
    remainingEstimateSeconds?: number;
    /** Time worked on this issue in readable format. */
    timeSpent?: string;
    /** Time worked on this issue in seconds. */
    timeSpentSeconds?: number;
}

/** Details about the time tracking provider. */
export class TimeTrackingProvider implements ITimeTrackingProvider {
    /** The key for the time tracking provider. For example, *JIRA*. */
    key!: string;
    /** The name of the time tracking provider. For example, *JIRA provided time tracking*. */
    name?: string;
    /** The URL of the configuration page for the time tracking provider app. For example, */example/config/url*. This property is only returned if the `adminPageKey` property is set in the module descriptor of the time tracking provider app. */
    readonly url?: string;

    constructor(data?: ITimeTrackingProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.name = _data["name"];
            (<any>this).url = _data["url"];
        }
    }

    static fromJS(data: any): TimeTrackingProvider {
        data = typeof data === 'object' ? data : {};
        let result = new TimeTrackingProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["name"] = this.name;
        data["url"] = this.url;
        return data;
    }
}

/** Details about the time tracking provider. */
export interface ITimeTrackingProvider {
    /** The key for the time tracking provider. For example, *JIRA*. */
    key: string;
    /** The name of the time tracking provider. For example, *JIRA provided time tracking*. */
    name?: string;
    /** The URL of the configuration page for the time tracking provider app. For example, */example/config/url*. This property is only returned if the `adminPageKey` property is set in the module descriptor of the time tracking provider app. */
    url?: string;
}

/** The payload for the layout details for the destination end of a transition */
export class ToLayoutPayload implements IToLayoutPayload {
    /** Defines where the transition line will be connected to a status. Port 0 to 7 are acceptable values. */
    port?: number;
    status?: ProjectCreateResourceIdentifier;

    constructor(data?: IToLayoutPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.port = _data["port"];
            this.status = _data["status"] ? ProjectCreateResourceIdentifier.fromJS(_data["status"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ToLayoutPayload {
        data = typeof data === 'object' ? data : {};
        let result = new ToLayoutPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["port"] = this.port;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        return data;
    }
}

/** The payload for the layout details for the destination end of a transition */
export interface IToLayoutPayload {
    /** Defines where the transition line will be connected to a status. Port 0 to 7 are acceptable values. */
    port?: number;
    status?: ProjectCreateResourceIdentifier;
}

/** Details of a workflow transition. */
export class Transition implements ITransition {
    /** The description of the transition. */
    description!: string;
    /** The statuses the transition can start from. */
    from!: string[];
    /** The ID of the transition. */
    id!: string;
    /** The name of the transition. */
    name!: string;
    /** The properties of the transition. */
    properties?: { [key: string]: any; };
    rules?: WorkflowRules;
    screen?: TransitionScreenDetails;
    /** The status the transition goes to. */
    to!: string;
    /** The type of the transition. */
    type!: TransitionType;

    constructor(data?: ITransition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.from = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            if (Array.isArray(_data["from"])) {
                this.from = [] as any;
                for (let item of _data["from"])
                    this.from!.push(item);
            }
            this.id = _data["id"];
            this.name = _data["name"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.rules = _data["rules"] ? WorkflowRules.fromJS(_data["rules"]) : <any>undefined;
            this.screen = _data["screen"] ? TransitionScreenDetails.fromJS(_data["screen"]) : <any>undefined;
            this.to = _data["to"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Transition {
        data = typeof data === 'object' ? data : {};
        let result = new Transition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        if (Array.isArray(this.from)) {
            data["from"] = [];
            for (let item of this.from)
                data["from"].push(item);
        }
        data["id"] = this.id;
        data["name"] = this.name;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["rules"] = this.rules ? this.rules.toJSON() : <any>undefined;
        data["screen"] = this.screen ? this.screen.toJSON() : <any>undefined;
        data["to"] = this.to;
        data["type"] = this.type;
        return data;
    }
}

/** Details of a workflow transition. */
export interface ITransition {
    /** The description of the transition. */
    description: string;
    /** The statuses the transition can start from. */
    from: string[];
    /** The ID of the transition. */
    id: string;
    /** The name of the transition. */
    name: string;
    /** The properties of the transition. */
    properties?: { [key: string]: any; };
    rules?: WorkflowRules;
    screen?: TransitionScreenDetails;
    /** The status the transition goes to. */
    to: string;
    /** The type of the transition. */
    type: TransitionType;
}

/** The payload for creating a transition in a workflow. Can be DIRECTED, GLOBAL, SELF-LOOPED, GLOBAL LOOPED */
export class TransitionPayload implements ITransitionPayload {
    /** The actions that are performed when the transition is made */
    actions?: RulePayload[];
    conditions?: ConditionGroupPayload;
    /** Mechanism in Jira for triggering certain actions, like notifications, automations, etc. Unless a custom notification scheme is configure, it's better not to provide any value here */
    customIssueEventId?: string;
    /** The description of the transition */
    description?: string;
    /** The statuses that the transition can be made from */
    from?: FromLayoutPayload[];
    /** The id of the transition */
    id?: number;
    /** The name of the transition */
    name?: string;
    /** The properties of the transition */
    properties?: { [key: string]: string; };
    to?: ToLayoutPayload;
    transitionScreen?: RulePayload;
    /** The triggers that are performed when the transition is made */
    triggers?: RulePayload[];
    /** The type of the transition */
    type?: TransitionPayloadType;
    /** The validators that are performed when the transition is made */
    validators?: RulePayload[];

    constructor(data?: ITransitionPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(RulePayload.fromJS(item));
            }
            this.conditions = _data["conditions"] ? ConditionGroupPayload.fromJS(_data["conditions"]) : <any>undefined;
            this.customIssueEventId = _data["customIssueEventId"];
            this.description = _data["description"];
            if (Array.isArray(_data["from"])) {
                this.from = [] as any;
                for (let item of _data["from"])
                    this.from!.push(FromLayoutPayload.fromJS(item));
            }
            this.id = _data["id"];
            this.name = _data["name"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.to = _data["to"] ? ToLayoutPayload.fromJS(_data["to"]) : <any>undefined;
            this.transitionScreen = _data["transitionScreen"] ? RulePayload.fromJS(_data["transitionScreen"]) : <any>undefined;
            if (Array.isArray(_data["triggers"])) {
                this.triggers = [] as any;
                for (let item of _data["triggers"])
                    this.triggers!.push(RulePayload.fromJS(item));
            }
            this.type = _data["type"];
            if (Array.isArray(_data["validators"])) {
                this.validators = [] as any;
                for (let item of _data["validators"])
                    this.validators!.push(RulePayload.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransitionPayload {
        data = typeof data === 'object' ? data : {};
        let result = new TransitionPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        data["conditions"] = this.conditions ? this.conditions.toJSON() : <any>undefined;
        data["customIssueEventId"] = this.customIssueEventId;
        data["description"] = this.description;
        if (Array.isArray(this.from)) {
            data["from"] = [];
            for (let item of this.from)
                data["from"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["to"] = this.to ? this.to.toJSON() : <any>undefined;
        data["transitionScreen"] = this.transitionScreen ? this.transitionScreen.toJSON() : <any>undefined;
        if (Array.isArray(this.triggers)) {
            data["triggers"] = [];
            for (let item of this.triggers)
                data["triggers"].push(item.toJSON());
        }
        data["type"] = this.type;
        if (Array.isArray(this.validators)) {
            data["validators"] = [];
            for (let item of this.validators)
                data["validators"].push(item.toJSON());
        }
        return data;
    }
}

/** The payload for creating a transition in a workflow. Can be DIRECTED, GLOBAL, SELF-LOOPED, GLOBAL LOOPED */
export interface ITransitionPayload {
    /** The actions that are performed when the transition is made */
    actions?: RulePayload[];
    conditions?: ConditionGroupPayload;
    /** Mechanism in Jira for triggering certain actions, like notifications, automations, etc. Unless a custom notification scheme is configure, it's better not to provide any value here */
    customIssueEventId?: string;
    /** The description of the transition */
    description?: string;
    /** The statuses that the transition can be made from */
    from?: FromLayoutPayload[];
    /** The id of the transition */
    id?: number;
    /** The name of the transition */
    name?: string;
    /** The properties of the transition */
    properties?: { [key: string]: string; };
    to?: ToLayoutPayload;
    transitionScreen?: RulePayload;
    /** The triggers that are performed when the transition is made */
    triggers?: RulePayload[];
    /** The type of the transition */
    type?: TransitionPayloadType;
    /** The validators that are performed when the transition is made */
    validators?: RulePayload[];
}

/** The details of a transition screen. */
export class TransitionScreenDetails implements ITransitionScreenDetails {
    /** The ID of the screen. */
    id!: string;
    /** The name of the screen. */
    name?: string;

    constructor(data?: ITransitionScreenDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TransitionScreenDetails {
        data = typeof data === 'object' ? data : {};
        let result = new TransitionScreenDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** The details of a transition screen. */
export interface ITransitionScreenDetails {
    /** The ID of the screen. */
    id: string;
    /** The name of the screen. */
    name?: string;
}

/** The transition update data. */
export class TransitionUpdateDTO implements ITransitionUpdateDTO {
    /** The post-functions of the transition. */
    actions?: (WorkflowRuleConfiguration | undefined)[];
    conditions?: ConditionGroupUpdate | undefined;
    /** The custom event ID of the transition. */
    customIssueEventId?: string;
    /** The description of the transition. */
    description?: string;
    /** The ID of the transition. */
    id?: string;
    /** The statuses the transition can start from, and the mapping of ports between the statuses. */
    links?: (WorkflowTransitionLinks | undefined)[];
    /** The name of the transition. */
    name?: string;
    /** The properties of the transition. */
    properties?: { [key: string]: string; };
    /** The status the transition goes to. */
    toStatusReference?: string;
    transitionScreen?: WorkflowRuleConfiguration | undefined;
    /** The triggers of the transition. */
    triggers?: WorkflowTrigger[];
    /** The transition type. */
    type?: TransitionUpdateDTOType;
    /** The validators of the transition. */
    validators?: (WorkflowRuleConfiguration | undefined)[];

    [key: string]: any;

    constructor(data?: ITransitionUpdateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(WorkflowRuleConfiguration.fromJS(item));
            }
            this.conditions = _data["conditions"] ? ConditionGroupUpdate.fromJS(_data["conditions"]) : <any>undefined;
            this.customIssueEventId = _data["customIssueEventId"];
            this.description = _data["description"];
            this.id = _data["id"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(WorkflowTransitionLinks.fromJS(item));
            }
            this.name = _data["name"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.toStatusReference = _data["toStatusReference"];
            this.transitionScreen = _data["transitionScreen"] ? WorkflowRuleConfiguration.fromJS(_data["transitionScreen"]) : <any>undefined;
            if (Array.isArray(_data["triggers"])) {
                this.triggers = [] as any;
                for (let item of _data["triggers"])
                    this.triggers!.push(WorkflowTrigger.fromJS(item));
            }
            this.type = _data["type"];
            if (Array.isArray(_data["validators"])) {
                this.validators = [] as any;
                for (let item of _data["validators"])
                    this.validators!.push(WorkflowRuleConfiguration.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransitionUpdateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TransitionUpdateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        data["conditions"] = this.conditions ? this.conditions.toJSON() : <any>undefined;
        data["customIssueEventId"] = this.customIssueEventId;
        data["description"] = this.description;
        data["id"] = this.id;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["name"] = this.name;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["toStatusReference"] = this.toStatusReference;
        data["transitionScreen"] = this.transitionScreen ? this.transitionScreen.toJSON() : <any>undefined;
        if (Array.isArray(this.triggers)) {
            data["triggers"] = [];
            for (let item of this.triggers)
                data["triggers"].push(item.toJSON());
        }
        data["type"] = this.type;
        if (Array.isArray(this.validators)) {
            data["validators"] = [];
            for (let item of this.validators)
                data["validators"].push(item.toJSON());
        }
        return data;
    }
}

/** The transition update data. */
export interface ITransitionUpdateDTO {
    /** The post-functions of the transition. */
    actions?: (WorkflowRuleConfiguration | undefined)[];
    conditions?: ConditionGroupUpdate | undefined;
    /** The custom event ID of the transition. */
    customIssueEventId?: string;
    /** The description of the transition. */
    description?: string;
    /** The ID of the transition. */
    id?: string;
    /** The statuses the transition can start from, and the mapping of ports between the statuses. */
    links?: (WorkflowTransitionLinks | undefined)[];
    /** The name of the transition. */
    name?: string;
    /** The properties of the transition. */
    properties?: { [key: string]: string; };
    /** The status the transition goes to. */
    toStatusReference?: string;
    transitionScreen?: WorkflowRuleConfiguration | undefined;
    /** The triggers of the transition. */
    triggers?: WorkflowTrigger[];
    /** The transition type. */
    type?: TransitionUpdateDTOType;
    /** The validators of the transition. */
    validators?: (WorkflowRuleConfiguration | undefined)[];

    [key: string]: any;
}

/** List of issue transitions. */
export class Transitions implements ITransitions {
    /** Expand options that include additional transitions details in the response. */
    readonly expand?: string;
    /** List of issue transitions. */
    readonly transitions?: IssueTransition[];

    constructor(data?: ITransitions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).expand = _data["expand"];
            if (Array.isArray(_data["transitions"])) {
                (<any>this).transitions = [] as any;
                for (let item of _data["transitions"])
                    (<any>this).transitions!.push(IssueTransition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Transitions {
        data = typeof data === 'object' ? data : {};
        let result = new Transitions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expand"] = this.expand;
        if (Array.isArray(this.transitions)) {
            data["transitions"] = [];
            for (let item of this.transitions)
                data["transitions"].push(item.toJSON());
        }
        return data;
    }
}

/** List of issue transitions. */
export interface ITransitions {
    /** Expand options that include additional transitions details in the response. */
    expand?: string;
    /** List of issue transitions. */
    transitions?: IssueTransition[];
}

/** The details of a UI modification's context, which define where to activate the UI modification. */
export class UiModificationContextDetails implements IUiModificationContextDetails {
    /** The ID of the UI modification context. */
    readonly id?: string;
    /** Whether a context is available. For example, when a project is deleted the context becomes unavailable. */
    readonly isAvailable?: boolean;
    /** The issue type ID of the context. Null is treated as a wildcard, meaning the UI modification will be applied to all issue types. Each UI modification context can have a maximum of one wildcard. */
    issueTypeId?: string;
    /** The project ID of the context. Null is treated as a wildcard, meaning the UI modification will be applied to all projects. Each UI modification context can have a maximum of one wildcard. */
    projectId?: string;
    /** The view type of the context. Only `GIC`(Global Issue Create), `IssueView` and `IssueTransition` are supported. Null is treated as a wildcard, meaning the UI modification will be applied to all view types. Each UI modification context can have a maximum of one wildcard. */
    viewType?: UiModificationContextDetailsViewType;

    constructor(data?: IUiModificationContextDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).isAvailable = _data["isAvailable"];
            this.issueTypeId = _data["issueTypeId"];
            this.projectId = _data["projectId"];
            this.viewType = _data["viewType"];
        }
    }

    static fromJS(data: any): UiModificationContextDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UiModificationContextDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isAvailable"] = this.isAvailable;
        data["issueTypeId"] = this.issueTypeId;
        data["projectId"] = this.projectId;
        data["viewType"] = this.viewType;
        return data;
    }
}

/** The details of a UI modification's context, which define where to activate the UI modification. */
export interface IUiModificationContextDetails {
    /** The ID of the UI modification context. */
    id?: string;
    /** Whether a context is available. For example, when a project is deleted the context becomes unavailable. */
    isAvailable?: boolean;
    /** The issue type ID of the context. Null is treated as a wildcard, meaning the UI modification will be applied to all issue types. Each UI modification context can have a maximum of one wildcard. */
    issueTypeId?: string;
    /** The project ID of the context. Null is treated as a wildcard, meaning the UI modification will be applied to all projects. Each UI modification context can have a maximum of one wildcard. */
    projectId?: string;
    /** The view type of the context. Only `GIC`(Global Issue Create), `IssueView` and `IssueTransition` are supported. Null is treated as a wildcard, meaning the UI modification will be applied to all view types. Each UI modification context can have a maximum of one wildcard. */
    viewType?: UiModificationContextDetailsViewType;
}

/** The details of a UI modification. */
export class UiModificationDetails implements IUiModificationDetails {
    /** List of contexts of the UI modification. The maximum number of contexts is 1000. */
    readonly contexts?: UiModificationContextDetails[];
    /** The data of the UI modification. The maximum size of the data is 50000 characters. */
    readonly data?: string;
    /** The description of the UI modification. The maximum length is 255 characters. */
    readonly description?: string;
    /** The ID of the UI modification. */
    readonly id!: string;
    /** The name of the UI modification. The maximum length is 255 characters. */
    readonly name!: string;
    /** The URL of the UI modification. */
    readonly self!: string;

    constructor(data?: IUiModificationDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contexts"])) {
                (<any>this).contexts = [] as any;
                for (let item of _data["contexts"])
                    (<any>this).contexts!.push(UiModificationContextDetails.fromJS(item));
            }
            (<any>this).data = _data["data"];
            (<any>this).description = _data["description"];
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): UiModificationDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UiModificationDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contexts)) {
            data["contexts"] = [];
            for (let item of this.contexts)
                data["contexts"].push(item.toJSON());
        }
        data["data"] = this.data;
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

/** The details of a UI modification. */
export interface IUiModificationDetails {
    /** List of contexts of the UI modification. The maximum number of contexts is 1000. */
    contexts?: UiModificationContextDetails[];
    /** The data of the UI modification. The maximum size of the data is 50000 characters. */
    data?: string;
    /** The description of the UI modification. The maximum length is 255 characters. */
    description?: string;
    /** The ID of the UI modification. */
    id: string;
    /** The name of the UI modification. The maximum length is 255 characters. */
    name: string;
    /** The URL of the UI modification. */
    self: string;
}

/** Identifiers for a UI modification. */
export class UiModificationIdentifiers implements IUiModificationIdentifiers {
    /** The ID of the UI modification. */
    readonly id!: string;
    /** The URL of the UI modification. */
    readonly self!: string;

    constructor(data?: IUiModificationIdentifiers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): UiModificationIdentifiers {
        data = typeof data === 'object' ? data : {};
        let result = new UiModificationIdentifiers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["self"] = this.self;
        return data;
    }
}

/** Identifiers for a UI modification. */
export interface IUiModificationIdentifiers {
    /** The ID of the UI modification. */
    id: string;
    /** The URL of the UI modification. */
    self: string;
}

export class UnrestrictedUserEmail implements IUnrestrictedUserEmail {
    /** The accountId of the user */
    accountId?: string;
    /** The email of the user */
    email?: string;

    [key: string]: any;

    constructor(data?: IUnrestrictedUserEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accountId = _data["accountId"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UnrestrictedUserEmail {
        data = typeof data === 'object' ? data : {};
        let result = new UnrestrictedUserEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accountId"] = this.accountId;
        data["email"] = this.email;
        return data;
    }
}

export interface IUnrestrictedUserEmail {
    /** The accountId of the user */
    accountId?: string;
    /** The email of the user */
    email?: string;

    [key: string]: any;
}

/** Details of a custom field. */
export class UpdateCustomFieldDetails implements IUpdateCustomFieldDetails {
    /** The description of the custom field. The maximum length is 40000 characters. */
    description?: string;
    /** The name of the custom field. It doesn't have to be unique. The maximum length is 255 characters. */
    name?: string;
    /** The searcher that defines the way the field is searched in Jira. It can be set to `null`, otherwise you must specify the valid searcher for the field type, as listed below (abbreviated values shown):

 *  `cascadingselect`: `cascadingselectsearcher`
 *  `datepicker`: `daterange`
 *  `datetime`: `datetimerange`
 *  `float`: `exactnumber` or `numberrange`
 *  `grouppicker`: `grouppickersearcher`
 *  `importid`: `exactnumber` or `numberrange`
 *  `labels`: `labelsearcher`
 *  `multicheckboxes`: `multiselectsearcher`
 *  `multigrouppicker`: `multiselectsearcher`
 *  `multiselect`: `multiselectsearcher`
 *  `multiuserpicker`: `userpickergroupsearcher`
 *  `multiversion`: `versionsearcher`
 *  `project`: `projectsearcher`
 *  `radiobuttons`: `multiselectsearcher`
 *  `readonlyfield`: `textsearcher`
 *  `select`: `multiselectsearcher`
 *  `textarea`: `textsearcher`
 *  `textfield`: `textsearcher`
 *  `url`: `exacttextsearcher`
 *  `userpicker`: `userpickergroupsearcher`
 *  `version`: `versionsearcher` */
    searcherKey?: UpdateCustomFieldDetailsSearcherKey;

    constructor(data?: IUpdateCustomFieldDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
            this.searcherKey = _data["searcherKey"];
        }
    }

    static fromJS(data: any): UpdateCustomFieldDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCustomFieldDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        data["searcherKey"] = this.searcherKey;
        return data;
    }
}

/** Details of a custom field. */
export interface IUpdateCustomFieldDetails {
    /** The description of the custom field. The maximum length is 40000 characters. */
    description?: string;
    /** The name of the custom field. It doesn't have to be unique. The maximum length is 255 characters. */
    name?: string;
    /** The searcher that defines the way the field is searched in Jira. It can be set to `null`, otherwise you must specify the valid searcher for the field type, as listed below (abbreviated values shown):

 *  `cascadingselect`: `cascadingselectsearcher`
 *  `datepicker`: `daterange`
 *  `datetime`: `datetimerange`
 *  `float`: `exactnumber` or `numberrange`
 *  `grouppicker`: `grouppickersearcher`
 *  `importid`: `exactnumber` or `numberrange`
 *  `labels`: `labelsearcher`
 *  `multicheckboxes`: `multiselectsearcher`
 *  `multigrouppicker`: `multiselectsearcher`
 *  `multiselect`: `multiselectsearcher`
 *  `multiuserpicker`: `userpickergroupsearcher`
 *  `multiversion`: `versionsearcher`
 *  `project`: `projectsearcher`
 *  `radiobuttons`: `multiselectsearcher`
 *  `readonlyfield`: `textsearcher`
 *  `select`: `multiselectsearcher`
 *  `textarea`: `textsearcher`
 *  `textfield`: `textsearcher`
 *  `url`: `exacttextsearcher`
 *  `userpicker`: `userpickergroupsearcher`
 *  `version`: `versionsearcher` */
    searcherKey?: UpdateCustomFieldDetailsSearcherKey;
}

/** The request for updating the default project classification level. */
export class UpdateDefaultProjectClassificationBean implements IUpdateDefaultProjectClassificationBean {
    /** The ID of the project classification. */
    id!: string;

    constructor(data?: IUpdateDefaultProjectClassificationBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateDefaultProjectClassificationBean {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDefaultProjectClassificationBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** The request for updating the default project classification level. */
export interface IUpdateDefaultProjectClassificationBean {
    /** The ID of the project classification. */
    id: string;
}

/** The ID of a screen scheme. */
export class UpdateDefaultScreenScheme implements IUpdateDefaultScreenScheme {
    /** The ID of the screen scheme. */
    screenSchemeId!: string;

    constructor(data?: IUpdateDefaultScreenScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.screenSchemeId = _data["screenSchemeId"];
        }
    }

    static fromJS(data: any): UpdateDefaultScreenScheme {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDefaultScreenScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["screenSchemeId"] = this.screenSchemeId;
        return data;
    }
}

/** The ID of a screen scheme. */
export interface IUpdateDefaultScreenScheme {
    /** The ID of the screen scheme. */
    screenSchemeId: string;
}

/** The details of the field configuration scheme. */
export class UpdateFieldConfigurationSchemeDetails implements IUpdateFieldConfigurationSchemeDetails {
    /** The description of the field configuration scheme. */
    description?: string;
    /** The name of the field configuration scheme. The name must be unique. */
    name!: string;

    constructor(data?: IUpdateFieldConfigurationSchemeDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateFieldConfigurationSchemeDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFieldConfigurationSchemeDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

/** The details of the field configuration scheme. */
export interface IUpdateFieldConfigurationSchemeDetails {
    /** The description of the field configuration scheme. */
    description?: string;
    /** The name of the field configuration scheme. The name must be unique. */
    name: string;
}

/** Details of issue security scheme level. */
export class UpdateIssueSecurityLevelDetails implements IUpdateIssueSecurityLevelDetails {
    /** The description of the issue security scheme level. */
    description?: string;
    /** The name of the issue security scheme level. Must be unique. */
    name?: string;

    [key: string]: any;

    constructor(data?: IUpdateIssueSecurityLevelDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateIssueSecurityLevelDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateIssueSecurityLevelDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

/** Details of issue security scheme level. */
export interface IUpdateIssueSecurityLevelDetails {
    /** The description of the issue security scheme level. */
    description?: string;
    /** The name of the issue security scheme level. Must be unique. */
    name?: string;

    [key: string]: any;
}

export class UpdateIssueSecuritySchemeRequestBean implements IUpdateIssueSecuritySchemeRequestBean {
    /** The description of the security scheme scheme. */
    description?: string;
    /** The name of the security scheme scheme. Must be unique. */
    name?: string;

    constructor(data?: IUpdateIssueSecuritySchemeRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateIssueSecuritySchemeRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateIssueSecuritySchemeRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateIssueSecuritySchemeRequestBean {
    /** The description of the security scheme scheme. */
    description?: string;
    /** The name of the security scheme scheme. Must be unique. */
    name?: string;
}

/** Details of a notification scheme. */
export class UpdateNotificationSchemeDetails implements IUpdateNotificationSchemeDetails {
    /** The description of the notification scheme. */
    description?: string;
    /** The name of the notification scheme. Must be unique. */
    name?: string;

    [key: string]: any;

    constructor(data?: IUpdateNotificationSchemeDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateNotificationSchemeDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSchemeDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

/** Details of a notification scheme. */
export interface IUpdateNotificationSchemeDetails {
    /** The description of the notification scheme. */
    description?: string;
    /** The name of the notification scheme. Must be unique. */
    name?: string;

    [key: string]: any;
}

/** Update priorities in a scheme */
export class UpdatePrioritiesInSchemeRequestBean implements IUpdatePrioritiesInSchemeRequestBean {
    /** Priorities to add to a scheme */
    add?: PrioritySchemeChangesWithoutMappings;
    /** Priorities to remove from a scheme */
    remove?: PrioritySchemeChangesWithoutMappings;

    [key: string]: any;

    constructor(data?: IUpdatePrioritiesInSchemeRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.add = _data["add"] ? PrioritySchemeChangesWithoutMappings.fromJS(_data["add"]) : <any>undefined;
            this.remove = _data["remove"] ? PrioritySchemeChangesWithoutMappings.fromJS(_data["remove"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdatePrioritiesInSchemeRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePrioritiesInSchemeRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["add"] = this.add ? this.add.toJSON() : <any>undefined;
        data["remove"] = this.remove ? this.remove.toJSON() : <any>undefined;
        return data;
    }
}

/** Update priorities in a scheme */
export interface IUpdatePrioritiesInSchemeRequestBean {
    /** Priorities to add to a scheme */
    add?: PrioritySchemeChangesWithoutMappings;
    /** Priorities to remove from a scheme */
    remove?: PrioritySchemeChangesWithoutMappings;

    [key: string]: any;
}

/** Details of an issue priority. */
export class UpdatePriorityDetails implements IUpdatePriorityDetails {
    /** The ID for the avatar for the priority. This parameter is nullable and both iconUrl and avatarId cannot be defined. */
    avatarId?: number;
    /** The description of the priority. */
    description?: string | undefined;
    /** The URL of an icon for the priority. Accepted protocols are HTTP and HTTPS. Built in icons can also be used. Both iconUrl and avatarId cannot be defined. */
    iconUrl?: UpdatePriorityDetailsIconUrl | undefined;
    /** The name of the priority. Must be unique. */
    name?: string | undefined;
    /** The status color of the priority in 3-digit or 6-digit hexadecimal format. */
    statusColor?: string | undefined;

    [key: string]: any;

    constructor(data?: IUpdatePriorityDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.avatarId = _data["avatarId"];
            this.description = _data["description"];
            this.iconUrl = _data["iconUrl"];
            this.name = _data["name"];
            this.statusColor = _data["statusColor"];
        }
    }

    static fromJS(data: any): UpdatePriorityDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePriorityDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["avatarId"] = this.avatarId;
        data["description"] = this.description;
        data["iconUrl"] = this.iconUrl;
        data["name"] = this.name;
        data["statusColor"] = this.statusColor;
        return data;
    }
}

/** Details of an issue priority. */
export interface IUpdatePriorityDetails {
    /** The ID for the avatar for the priority. This parameter is nullable and both iconUrl and avatarId cannot be defined. */
    avatarId?: number;
    /** The description of the priority. */
    description?: string | undefined;
    /** The URL of an icon for the priority. Accepted protocols are HTTP and HTTPS. Built in icons can also be used. Both iconUrl and avatarId cannot be defined. */
    iconUrl?: UpdatePriorityDetailsIconUrl | undefined;
    /** The name of the priority. Must be unique. */
    name?: string | undefined;
    /** The status color of the priority in 3-digit or 6-digit hexadecimal format. */
    statusColor?: string | undefined;

    [key: string]: any;
}

/** Details of a priority scheme. */
export class UpdatePrioritySchemeRequestBean implements IUpdatePrioritySchemeRequestBean {
    /** The default priority of the scheme. */
    defaultPriorityId?: number;
    /** The description of the priority scheme. */
    description?: string;
    /** Instructions to migrate the priorities of issues.

`in` mappings are used to migrate the priorities of issues to priorities used within the priority scheme.

`out` mappings are used to migrate the priorities of issues to priorities not used within the priority scheme.

 *  When **priorities** are **added** to the priority scheme, no mapping needs to be provided as the new priorities are not used by any issues.
 *  When **priorities** are **removed** from the priority scheme, issues that are using those priorities must be migrated to new priorities used by the priority scheme.
    
     *  An `in` mapping must be provided for each of these priorities.
 *  When **projects** are **added** to the priority scheme, the priorities of issues in those projects might need to be migrated to new priorities used by the priority scheme. This can occur when the current scheme does not use all the priorities in the project(s)' priority scheme(s).
    
     *  An `in` mapping must be provided for each of these priorities.
 *  When **projects** are **removed** from the priority scheme, the priorities of issues in those projects might need to be migrated to new priorities within the **Default Priority Scheme** that are not used by the priority scheme. This can occur when the **Default Priority Scheme** does not use all the priorities within the current scheme.
    
     *  An `out` mapping must be provided for each of these priorities.

For more information on `in` and `out` mappings, see the child properties documentation for the `PriorityMapping` object below. */
    mappings?: PriorityMapping;
    /** The name of the priority scheme. Must be unique. */
    name?: string;
    /** The priorities in the scheme. */
    priorities?: UpdatePrioritiesInSchemeRequestBean;
    /** The projects in the scheme. */
    projects?: UpdateProjectsInSchemeRequestBean;

    constructor(data?: IUpdatePrioritySchemeRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultPriorityId = _data["defaultPriorityId"];
            this.description = _data["description"];
            this.mappings = _data["mappings"] ? PriorityMapping.fromJS(_data["mappings"]) : <any>undefined;
            this.name = _data["name"];
            this.priorities = _data["priorities"] ? UpdatePrioritiesInSchemeRequestBean.fromJS(_data["priorities"]) : <any>undefined;
            this.projects = _data["projects"] ? UpdateProjectsInSchemeRequestBean.fromJS(_data["projects"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdatePrioritySchemeRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePrioritySchemeRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultPriorityId"] = this.defaultPriorityId;
        data["description"] = this.description;
        data["mappings"] = this.mappings ? this.mappings.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["priorities"] = this.priorities ? this.priorities.toJSON() : <any>undefined;
        data["projects"] = this.projects ? this.projects.toJSON() : <any>undefined;
        return data;
    }
}

/** Details of a priority scheme. */
export interface IUpdatePrioritySchemeRequestBean {
    /** The default priority of the scheme. */
    defaultPriorityId?: number;
    /** The description of the priority scheme. */
    description?: string;
    /** Instructions to migrate the priorities of issues.

`in` mappings are used to migrate the priorities of issues to priorities used within the priority scheme.

`out` mappings are used to migrate the priorities of issues to priorities not used within the priority scheme.

 *  When **priorities** are **added** to the priority scheme, no mapping needs to be provided as the new priorities are not used by any issues.
 *  When **priorities** are **removed** from the priority scheme, issues that are using those priorities must be migrated to new priorities used by the priority scheme.
    
     *  An `in` mapping must be provided for each of these priorities.
 *  When **projects** are **added** to the priority scheme, the priorities of issues in those projects might need to be migrated to new priorities used by the priority scheme. This can occur when the current scheme does not use all the priorities in the project(s)' priority scheme(s).
    
     *  An `in` mapping must be provided for each of these priorities.
 *  When **projects** are **removed** from the priority scheme, the priorities of issues in those projects might need to be migrated to new priorities within the **Default Priority Scheme** that are not used by the priority scheme. This can occur when the **Default Priority Scheme** does not use all the priorities within the current scheme.
    
     *  An `out` mapping must be provided for each of these priorities.

For more information on `in` and `out` mappings, see the child properties documentation for the `PriorityMapping` object below. */
    mappings?: PriorityMapping;
    /** The name of the priority scheme. Must be unique. */
    name?: string;
    /** The priorities in the scheme. */
    priorities?: UpdatePrioritiesInSchemeRequestBean;
    /** The projects in the scheme. */
    projects?: UpdateProjectsInSchemeRequestBean;
}

/** Details of the updated priority scheme. */
export class UpdatePrioritySchemeResponseBean implements IUpdatePrioritySchemeResponseBean {
    priorityScheme?: PrioritySchemeWithPaginatedPrioritiesAndProjects;
    /** The in-progress issue migration task. */
    readonly task?: TaskProgressBeanJsonNode;

    [key: string]: any;

    constructor(data?: IUpdatePrioritySchemeResponseBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.priorityScheme = _data["priorityScheme"] ? PrioritySchemeWithPaginatedPrioritiesAndProjects.fromJS(_data["priorityScheme"]) : <any>undefined;
            (<any>this).task = _data["task"] ? TaskProgressBeanJsonNode.fromJS(_data["task"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdatePrioritySchemeResponseBean {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePrioritySchemeResponseBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["priorityScheme"] = this.priorityScheme ? this.priorityScheme.toJSON() : <any>undefined;
        data["task"] = this.task ? this.task.toJSON() : <any>undefined;
        return data;
    }
}

/** Details of the updated priority scheme. */
export interface IUpdatePrioritySchemeResponseBean {
    priorityScheme?: PrioritySchemeWithPaginatedPrioritiesAndProjects;
    /** The in-progress issue migration task. */
    task?: TaskProgressBeanJsonNode;

    [key: string]: any;
}

/** Details about the project. */
export class UpdateProjectDetails implements IUpdateProjectDetails {
    /** The default assignee when creating issues for this project. */
    assigneeType?: UpdateProjectDetailsAssigneeType;
    /** An integer value for the project's avatar. */
    avatarId?: number;
    /** The ID of the project's category. A complete list of category IDs is found using the [Get all project categories](#api-rest-api-3-projectCategory-get) operation. To remove the project category from the project, set the value to `-1.` */
    categoryId?: number;
    /** A brief description of the project. */
    description?: string;
    /** The ID of the issue security scheme for the project, which enables you to control who can and cannot view issues. Use the [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get) resource to get all issue security scheme IDs. */
    issueSecurityScheme?: number;
    /** Project keys must be unique and start with an uppercase letter followed by one or more uppercase alphanumeric characters. The maximum length is 10 characters. */
    key?: string;
    /** This parameter is deprecated because of privacy changes. Use `leadAccountId` instead. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. The user name of the project lead. Cannot be provided with `leadAccountId`. */
    lead?: string;
    /** The account ID of the project lead. Cannot be provided with `lead`. */
    leadAccountId?: string;
    /** The name of the project. */
    name?: string;
    /** The ID of the notification scheme for the project. Use the [Get notification schemes](#api-rest-api-3-notificationscheme-get) resource to get a list of notification scheme IDs. */
    notificationScheme?: number;
    /** The ID of the permission scheme for the project. Use the [Get all permission schemes](#api-rest-api-3-permissionscheme-get) resource to see a list of all permission scheme IDs. */
    permissionScheme?: number;
    /** Previous project keys to be released from the current project. Released keys must belong to the current project and not contain the current project key */
    releasedProjectKeys?: string[];
    /** A link to information about this project, such as project documentation */
    url?: string;

    constructor(data?: IUpdateProjectDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.assigneeType = _data["assigneeType"];
            this.avatarId = _data["avatarId"];
            this.categoryId = _data["categoryId"];
            this.description = _data["description"];
            this.issueSecurityScheme = _data["issueSecurityScheme"];
            this.key = _data["key"];
            this.lead = _data["lead"];
            this.leadAccountId = _data["leadAccountId"];
            this.name = _data["name"];
            this.notificationScheme = _data["notificationScheme"];
            this.permissionScheme = _data["permissionScheme"];
            if (Array.isArray(_data["releasedProjectKeys"])) {
                this.releasedProjectKeys = [] as any;
                for (let item of _data["releasedProjectKeys"])
                    this.releasedProjectKeys!.push(item);
            }
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): UpdateProjectDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProjectDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assigneeType"] = this.assigneeType;
        data["avatarId"] = this.avatarId;
        data["categoryId"] = this.categoryId;
        data["description"] = this.description;
        data["issueSecurityScheme"] = this.issueSecurityScheme;
        data["key"] = this.key;
        data["lead"] = this.lead;
        data["leadAccountId"] = this.leadAccountId;
        data["name"] = this.name;
        data["notificationScheme"] = this.notificationScheme;
        data["permissionScheme"] = this.permissionScheme;
        if (Array.isArray(this.releasedProjectKeys)) {
            data["releasedProjectKeys"] = [];
            for (let item of this.releasedProjectKeys)
                data["releasedProjectKeys"].push(item);
        }
        data["url"] = this.url;
        return data;
    }
}

/** Details about the project. */
export interface IUpdateProjectDetails {
    /** The default assignee when creating issues for this project. */
    assigneeType?: UpdateProjectDetailsAssigneeType;
    /** An integer value for the project's avatar. */
    avatarId?: number;
    /** The ID of the project's category. A complete list of category IDs is found using the [Get all project categories](#api-rest-api-3-projectCategory-get) operation. To remove the project category from the project, set the value to `-1.` */
    categoryId?: number;
    /** A brief description of the project. */
    description?: string;
    /** The ID of the issue security scheme for the project, which enables you to control who can and cannot view issues. Use the [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get) resource to get all issue security scheme IDs. */
    issueSecurityScheme?: number;
    /** Project keys must be unique and start with an uppercase letter followed by one or more uppercase alphanumeric characters. The maximum length is 10 characters. */
    key?: string;
    /** This parameter is deprecated because of privacy changes. Use `leadAccountId` instead. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. The user name of the project lead. Cannot be provided with `leadAccountId`. */
    lead?: string;
    /** The account ID of the project lead. Cannot be provided with `lead`. */
    leadAccountId?: string;
    /** The name of the project. */
    name?: string;
    /** The ID of the notification scheme for the project. Use the [Get notification schemes](#api-rest-api-3-notificationscheme-get) resource to get a list of notification scheme IDs. */
    notificationScheme?: number;
    /** The ID of the permission scheme for the project. Use the [Get all permission schemes](#api-rest-api-3-permissionscheme-get) resource to see a list of all permission scheme IDs. */
    permissionScheme?: number;
    /** Previous project keys to be released from the current project. Released keys must belong to the current project and not contain the current project key */
    releasedProjectKeys?: string[];
    /** A link to information about this project, such as project documentation */
    url?: string;
}

/** Update projects in a scheme */
export class UpdateProjectsInSchemeRequestBean implements IUpdateProjectsInSchemeRequestBean {
    /** Projects to add to a scheme */
    add?: PrioritySchemeChangesWithoutMappings;
    /** Projects to remove from a scheme */
    remove?: PrioritySchemeChangesWithoutMappings;

    [key: string]: any;

    constructor(data?: IUpdateProjectsInSchemeRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.add = _data["add"] ? PrioritySchemeChangesWithoutMappings.fromJS(_data["add"]) : <any>undefined;
            this.remove = _data["remove"] ? PrioritySchemeChangesWithoutMappings.fromJS(_data["remove"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProjectsInSchemeRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProjectsInSchemeRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["add"] = this.add ? this.add.toJSON() : <any>undefined;
        data["remove"] = this.remove ? this.remove.toJSON() : <any>undefined;
        return data;
    }
}

/** Update projects in a scheme */
export interface IUpdateProjectsInSchemeRequestBean {
    /** Projects to add to a scheme */
    add?: PrioritySchemeChangesWithoutMappings;
    /** Projects to remove from a scheme */
    remove?: PrioritySchemeChangesWithoutMappings;

    [key: string]: any;
}

/** Details of an issue resolution. */
export class UpdateResolutionDetails implements IUpdateResolutionDetails {
    /** The description of the resolution. */
    description?: string;
    /** The name of the resolution. Must be unique. */
    name!: string;

    [key: string]: any;

    constructor(data?: IUpdateResolutionDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateResolutionDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateResolutionDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

/** Details of an issue resolution. */
export interface IUpdateResolutionDetails {
    /** The description of the resolution. */
    description?: string;
    /** The name of the resolution. Must be unique. */
    name: string;

    [key: string]: any;
}

/** Details of a screen. */
export class UpdateScreenDetails implements IUpdateScreenDetails {
    /** The description of the screen. The maximum length is 255 characters. */
    description?: string;
    /** The name of the screen. The name must be unique. The maximum length is 255 characters. */
    name?: string;

    constructor(data?: IUpdateScreenDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateScreenDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateScreenDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

/** Details of a screen. */
export interface IUpdateScreenDetails {
    /** The description of the screen. The maximum length is 255 characters. */
    description?: string;
    /** The name of the screen. The name must be unique. The maximum length is 255 characters. */
    name?: string;
}

/** Details of a screen scheme. */
export class UpdateScreenSchemeDetails implements IUpdateScreenSchemeDetails {
    /** The description of the screen scheme. The maximum length is 255 characters. */
    description?: string;
    /** The name of the screen scheme. The name must be unique. The maximum length is 255 characters. */
    name?: string;
    /** The IDs of the screens for the screen types of the screen scheme. Only screens used in classic projects are accepted. */
    screens?: UpdateScreenTypes;

    constructor(data?: IUpdateScreenSchemeDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.name = _data["name"];
            this.screens = _data["screens"] ? UpdateScreenTypes.fromJS(_data["screens"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateScreenSchemeDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateScreenSchemeDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["name"] = this.name;
        data["screens"] = this.screens ? this.screens.toJSON() : <any>undefined;
        return data;
    }
}

/** Details of a screen scheme. */
export interface IUpdateScreenSchemeDetails {
    /** The description of the screen scheme. The maximum length is 255 characters. */
    description?: string;
    /** The name of the screen scheme. The name must be unique. The maximum length is 255 characters. */
    name?: string;
    /** The IDs of the screens for the screen types of the screen scheme. Only screens used in classic projects are accepted. */
    screens?: UpdateScreenTypes;
}

/** The IDs of the screens for the screen types of the screen scheme. */
export class UpdateScreenTypes implements IUpdateScreenTypes {
    /** The ID of the create screen. To remove the screen association, pass a null. */
    create?: string;
    /** The ID of the default screen. When specified, must include a screen ID as a default screen is required. */
    default?: string;
    /** The ID of the edit screen. To remove the screen association, pass a null. */
    edit?: string;
    /** The ID of the view screen. To remove the screen association, pass a null. */
    view?: string;

    constructor(data?: IUpdateScreenTypes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.create = _data["create"];
            this.default = _data["default"];
            this.edit = _data["edit"];
            this.view = _data["view"];
        }
    }

    static fromJS(data: any): UpdateScreenTypes {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateScreenTypes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["create"] = this.create;
        data["default"] = this.default;
        data["edit"] = this.edit;
        data["view"] = this.view;
        return data;
    }
}

/** The IDs of the screens for the screen types of the screen scheme. */
export interface IUpdateScreenTypes {
    /** The ID of the create screen. To remove the screen association, pass a null. */
    create?: string;
    /** The ID of the default screen. When specified, must include a screen ID as a default screen is required. */
    default?: string;
    /** The ID of the edit screen. To remove the screen association, pass a null. */
    edit?: string;
    /** The ID of the view screen. To remove the screen association, pass a null. */
    view?: string;
}

/** The details of a UI modification. */
export class UpdateUiModificationDetails implements IUpdateUiModificationDetails {
    /** List of contexts of the UI modification. The maximum number of contexts is 1000. If provided, replaces all existing contexts. */
    contexts?: UiModificationContextDetails[];
    /** The data of the UI modification. The maximum size of the data is 50000 characters. */
    data?: string;
    /** The description of the UI modification. The maximum length is 255 characters. */
    description?: string;
    /** The name of the UI modification. The maximum length is 255 characters. */
    name?: string;

    constructor(data?: IUpdateUiModificationDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contexts"])) {
                this.contexts = [] as any;
                for (let item of _data["contexts"])
                    this.contexts!.push(UiModificationContextDetails.fromJS(item));
            }
            this.data = _data["data"];
            this.description = _data["description"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateUiModificationDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUiModificationDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contexts)) {
            data["contexts"] = [];
            for (let item of this.contexts)
                data["contexts"].push(item.toJSON());
        }
        data["data"] = this.data;
        data["description"] = this.description;
        data["name"] = this.name;
        return data;
    }
}

/** The details of a UI modification. */
export interface IUpdateUiModificationDetails {
    /** List of contexts of the UI modification. The maximum number of contexts is 1000. If provided, replaces all existing contexts. */
    contexts?: UiModificationContextDetails[];
    /** The data of the UI modification. The maximum size of the data is 50000 characters. */
    data?: string;
    /** The description of the UI modification. The maximum length is 255 characters. */
    description?: string;
    /** The name of the UI modification. The maximum length is 255 characters. */
    name?: string;
}

export class UpdateUserToGroupBean implements IUpdateUserToGroupBean {
    /** The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. */
    accountId?: string;
    /** This property is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    name?: string;

    [key: string]: any;

    constructor(data?: IUpdateUserToGroupBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accountId = _data["accountId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UpdateUserToGroupBean {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserToGroupBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accountId"] = this.accountId;
        data["name"] = this.name;
        return data;
    }
}

export interface IUpdateUserToGroupBean {
    /** The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. */
    accountId?: string;
    /** This property is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    name?: string;

    [key: string]: any;
}

/** A project category. */
export class UpdatedProjectCategory implements IUpdatedProjectCategory {
    /** The name of the project category. */
    readonly description?: string;
    /** The ID of the project category. */
    readonly id?: string;
    /** The description of the project category. */
    readonly name?: string;
    /** The URL of the project category. */
    readonly self?: string;

    constructor(data?: IUpdatedProjectCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).description = _data["description"];
            (<any>this).id = _data["id"];
            (<any>this).name = _data["name"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): UpdatedProjectCategory {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatedProjectCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

/** A project category. */
export interface IUpdatedProjectCategory {
    /** The name of the project category. */
    description?: string;
    /** The ID of the project category. */
    id?: string;
    /** The description of the project category. */
    name?: string;
    /** The URL of the project category. */
    self?: string;
}

/** A user with details as permitted by the user's Atlassian Account privacy settings. However, be aware of these exceptions: *  User record deleted from Atlassian: This occurs as the result of a right to be forgotten request. In this case, `displayName` provides an indication and other parameters have default values or are blank (for example, email is blank). *  User record corrupted: This occurs as a results of events such as a server import and can only happen to deleted users. In this case, `accountId` returns *unknown* and all other parameters have fallback values. *  User record unavailable: This usually occurs due to an internal service outage. In this case, all parameters have fallback values. */
export class User implements IUser {
    /** The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Required in requests. */
    accountId?: string;
    /** The user account type. Can take the following values:

 *  `atlassian` regular Atlassian user account
 *  `app` system account used for Connect applications and OAuth to represent external systems
 *  `customer` Jira Service Desk account representing an external service desk */
    readonly accountType?: UserAccountType;
    /** Whether the user is active. */
    readonly active?: boolean;
    /** The application roles the user is assigned to. */
    readonly applicationRoles?: SimpleListWrapperApplicationRole;
    /** The avatars of the user. */
    readonly avatarUrls?: AvatarUrlsBean;
    /** The display name of the user. Depending on the user’s privacy setting, this may return an alternative value. */
    readonly displayName?: string;
    /** The email address of the user. Depending on the user’s privacy setting, this may be returned as null. */
    readonly emailAddress?: string;
    /** Expand options that include additional user details in the response. */
    readonly expand?: string;
    /** The groups that the user belongs to. */
    readonly groups?: SimpleListWrapperGroupName;
    /** This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    key?: string;
    /** The locale of the user. Depending on the user’s privacy setting, this may be returned as null. */
    readonly locale?: string;
    /** This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    name?: string;
    /** The URL of the user. */
    readonly self?: string;
    /** The time zone specified in the user's profile. If the user's time zone is not visible to the current user (due to user's profile setting), or if a time zone has not been set, the instance's default time zone will be returned. */
    readonly timeZone?: string;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            (<any>this).accountType = _data["accountType"];
            (<any>this).active = _data["active"];
            (<any>this).applicationRoles = _data["applicationRoles"] ? SimpleListWrapperApplicationRole.fromJS(_data["applicationRoles"]) : <any>undefined;
            (<any>this).avatarUrls = _data["avatarUrls"] ? AvatarUrlsBean.fromJS(_data["avatarUrls"]) : <any>undefined;
            (<any>this).displayName = _data["displayName"];
            (<any>this).emailAddress = _data["emailAddress"];
            (<any>this).expand = _data["expand"];
            (<any>this).groups = _data["groups"] ? SimpleListWrapperGroupName.fromJS(_data["groups"]) : <any>undefined;
            this.key = _data["key"];
            (<any>this).locale = _data["locale"];
            this.name = _data["name"];
            (<any>this).self = _data["self"];
            (<any>this).timeZone = _data["timeZone"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["accountType"] = this.accountType;
        data["active"] = this.active;
        data["applicationRoles"] = this.applicationRoles ? this.applicationRoles.toJSON() : <any>undefined;
        data["avatarUrls"] = this.avatarUrls ? this.avatarUrls.toJSON() : <any>undefined;
        data["displayName"] = this.displayName;
        data["emailAddress"] = this.emailAddress;
        data["expand"] = this.expand;
        data["groups"] = this.groups ? this.groups.toJSON() : <any>undefined;
        data["key"] = this.key;
        data["locale"] = this.locale;
        data["name"] = this.name;
        data["self"] = this.self;
        data["timeZone"] = this.timeZone;
        return data;
    }
}

/** A user with details as permitted by the user's Atlassian Account privacy settings. However, be aware of these exceptions: *  User record deleted from Atlassian: This occurs as the result of a right to be forgotten request. In this case, `displayName` provides an indication and other parameters have default values or are blank (for example, email is blank). *  User record corrupted: This occurs as a results of events such as a server import and can only happen to deleted users. In this case, `accountId` returns *unknown* and all other parameters have fallback values. *  User record unavailable: This usually occurs due to an internal service outage. In this case, all parameters have fallback values. */
export interface IUser {
    /** The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Required in requests. */
    accountId?: string;
    /** The user account type. Can take the following values:

 *  `atlassian` regular Atlassian user account
 *  `app` system account used for Connect applications and OAuth to represent external systems
 *  `customer` Jira Service Desk account representing an external service desk */
    accountType?: UserAccountType;
    /** Whether the user is active. */
    active?: boolean;
    /** The application roles the user is assigned to. */
    applicationRoles?: SimpleListWrapperApplicationRole;
    /** The avatars of the user. */
    avatarUrls?: AvatarUrlsBean;
    /** The display name of the user. Depending on the user’s privacy setting, this may return an alternative value. */
    displayName?: string;
    /** The email address of the user. Depending on the user’s privacy setting, this may be returned as null. */
    emailAddress?: string;
    /** Expand options that include additional user details in the response. */
    expand?: string;
    /** The groups that the user belongs to. */
    groups?: SimpleListWrapperGroupName;
    /** This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    key?: string;
    /** The locale of the user. Depending on the user’s privacy setting, this may be returned as null. */
    locale?: string;
    /** This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    name?: string;
    /** The URL of the user. */
    self?: string;
    /** The time zone specified in the user's profile. If the user's time zone is not visible to the current user (due to user's profile setting), or if a time zone has not been set, the instance's default time zone will be returned. */
    timeZone?: string;
}

export class UserBean implements IUserBean {
    /** The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. */
    accountId?: string;
    /** Whether the user is active. */
    active?: boolean;
    /** The avatars of the user. */
    avatarUrls?: UserBeanAvatarUrls;
    /** The display name of the user. Depending on the user’s privacy setting, this may return an alternative value. */
    displayName?: string;
    /** This property is deprecated in favor of `accountId` because of privacy changes. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.  
The key of the user. */
    key?: string;
    /** This property is deprecated in favor of `accountId` because of privacy changes. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.  
The username of the user. */
    name?: string;
    /** The URL of the user. */
    self?: string;

    constructor(data?: IUserBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.active = _data["active"];
            this.avatarUrls = _data["avatarUrls"] ? UserBeanAvatarUrls.fromJS(_data["avatarUrls"]) : <any>undefined;
            this.displayName = _data["displayName"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.self = _data["self"];
        }
    }

    static fromJS(data: any): UserBean {
        data = typeof data === 'object' ? data : {};
        let result = new UserBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["active"] = this.active;
        data["avatarUrls"] = this.avatarUrls ? this.avatarUrls.toJSON() : <any>undefined;
        data["displayName"] = this.displayName;
        data["key"] = this.key;
        data["name"] = this.name;
        data["self"] = this.self;
        return data;
    }
}

export interface IUserBean {
    /** The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. */
    accountId?: string;
    /** Whether the user is active. */
    active?: boolean;
    /** The avatars of the user. */
    avatarUrls?: UserBeanAvatarUrls;
    /** The display name of the user. Depending on the user’s privacy setting, this may return an alternative value. */
    displayName?: string;
    /** This property is deprecated in favor of `accountId` because of privacy changes. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.  
The key of the user. */
    key?: string;
    /** This property is deprecated in favor of `accountId` because of privacy changes. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.  
The username of the user. */
    name?: string;
    /** The URL of the user. */
    self?: string;
}

export class UserBeanAvatarUrls implements IUserBeanAvatarUrls {
    /** The URL of the user's 16x16 pixel avatar. */
    _16x16?: string;
    /** The URL of the user's 24x24 pixel avatar. */
    _24x24?: string;
    /** The URL of the user's 32x32 pixel avatar. */
    _32x32?: string;
    /** The URL of the user's 48x48 pixel avatar. */
    _48x48?: string;

    constructor(data?: IUserBeanAvatarUrls) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this._16x16 = _data["16x16"];
            this._24x24 = _data["24x24"];
            this._32x32 = _data["32x32"];
            this._48x48 = _data["48x48"];
        }
    }

    static fromJS(data: any): UserBeanAvatarUrls {
        data = typeof data === 'object' ? data : {};
        let result = new UserBeanAvatarUrls();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["16x16"] = this._16x16;
        data["24x24"] = this._24x24;
        data["32x32"] = this._32x32;
        data["48x48"] = this._48x48;
        return data;
    }
}

export interface IUserBeanAvatarUrls {
    /** The URL of the user's 16x16 pixel avatar. */
    _16x16?: string;
    /** The URL of the user's 24x24 pixel avatar. */
    _24x24?: string;
    /** The URL of the user's 32x32 pixel avatar. */
    _32x32?: string;
    /** The URL of the user's 48x48 pixel avatar. */
    _48x48?: string;
}

export class UserColumnRequestBody implements IUserColumnRequestBody {
    columns?: string[];

    constructor(data?: IUserColumnRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(item);
            }
        }
    }

    static fromJS(data: any): UserColumnRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new UserColumnRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item);
        }
        return data;
    }
}

export interface IUserColumnRequestBody {
    columns?: string[];
}

/** User details permitted by the user's Atlassian Account privacy settings. However, be aware of these exceptions: *  User record deleted from Atlassian: This occurs as the result of a right to be forgotten request. In this case, `displayName` provides an indication and other parameters have default values or are blank (for example, email is blank). *  User record corrupted: This occurs as a results of events such as a server import and can only happen to deleted users. In this case, `accountId` returns *unknown* and all other parameters have fallback values. *  User record unavailable: This usually occurs due to an internal service outage. In this case, all parameters have fallback values. */
export class UserDetails implements IUserDetails {
    /** The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. */
    accountId?: string;
    /** The type of account represented by this user. This will be one of 'atlassian' (normal users), 'app' (application user) or 'customer' (Jira Service Desk customer user) */
    readonly accountType?: string;
    /** Whether the user is active. */
    readonly active?: boolean;
    /** The avatars of the user. */
    readonly avatarUrls?: AvatarUrlsBean;
    /** The display name of the user. Depending on the user’s privacy settings, this may return an alternative value. */
    readonly displayName?: string;
    /** The email address of the user. Depending on the user’s privacy settings, this may be returned as null. */
    readonly emailAddress?: string;
    /** This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    readonly key?: string;
    /** This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    readonly name?: string;
    /** The URL of the user. */
    readonly self?: string;
    /** The time zone specified in the user's profile. Depending on the user’s privacy settings, this may be returned as null. */
    readonly timeZone?: string;

    constructor(data?: IUserDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            (<any>this).accountType = _data["accountType"];
            (<any>this).active = _data["active"];
            (<any>this).avatarUrls = _data["avatarUrls"] ? AvatarUrlsBean.fromJS(_data["avatarUrls"]) : <any>undefined;
            (<any>this).displayName = _data["displayName"];
            (<any>this).emailAddress = _data["emailAddress"];
            (<any>this).key = _data["key"];
            (<any>this).name = _data["name"];
            (<any>this).self = _data["self"];
            (<any>this).timeZone = _data["timeZone"];
        }
    }

    static fromJS(data: any): UserDetails {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["accountType"] = this.accountType;
        data["active"] = this.active;
        data["avatarUrls"] = this.avatarUrls ? this.avatarUrls.toJSON() : <any>undefined;
        data["displayName"] = this.displayName;
        data["emailAddress"] = this.emailAddress;
        data["key"] = this.key;
        data["name"] = this.name;
        data["self"] = this.self;
        data["timeZone"] = this.timeZone;
        return data;
    }
}

/** User details permitted by the user's Atlassian Account privacy settings. However, be aware of these exceptions: *  User record deleted from Atlassian: This occurs as the result of a right to be forgotten request. In this case, `displayName` provides an indication and other parameters have default values or are blank (for example, email is blank). *  User record corrupted: This occurs as a results of events such as a server import and can only happen to deleted users. In this case, `accountId` returns *unknown* and all other parameters have fallback values. *  User record unavailable: This usually occurs due to an internal service outage. In this case, all parameters have fallback values. */
export interface IUserDetails {
    /** The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. */
    accountId?: string;
    /** The type of account represented by this user. This will be one of 'atlassian' (normal users), 'app' (application user) or 'customer' (Jira Service Desk customer user) */
    accountType?: string;
    /** Whether the user is active. */
    active?: boolean;
    /** The avatars of the user. */
    avatarUrls?: AvatarUrlsBean;
    /** The display name of the user. Depending on the user’s privacy settings, this may return an alternative value. */
    displayName?: string;
    /** The email address of the user. Depending on the user’s privacy settings, this may be returned as null. */
    emailAddress?: string;
    /** This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    key?: string;
    /** This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    name?: string;
    /** The URL of the user. */
    self?: string;
    /** The time zone specified in the user's profile. Depending on the user’s privacy settings, this may be returned as null. */
    timeZone?: string;
}

/** Filter for a User Picker (single) custom field. */
export class UserFilter implements IUserFilter {
    /** Whether the filter is enabled. */
    enabled!: boolean;
    /** User groups autocomplete suggestion users must belong to. If not provided, the default values are used. A maximum of 10 groups can be provided. */
    groups?: string[];
    /** Roles that autocomplete suggestion users must belong to. If not provided, the default values are used. A maximum of 10 roles can be provided. */
    roleIds?: number[];

    [key: string]: any;

    constructor(data?: IUserFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UserFilter {
        data = typeof data === 'object' ? data : {};
        let result = new UserFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["enabled"] = this.enabled;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        return data;
    }
}

/** Filter for a User Picker (single) custom field. */
export interface IUserFilter {
    /** Whether the filter is enabled. */
    enabled: boolean;
    /** User groups autocomplete suggestion users must belong to. If not provided, the default values are used. A maximum of 10 groups can be provided. */
    groups?: string[];
    /** Roles that autocomplete suggestion users must belong to. If not provided, the default values are used. A maximum of 10 roles can be provided. */
    roleIds?: number[];

    [key: string]: any;
}

/** List of user account IDs. */
export class UserKey implements IUserKey {
    /** The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Returns *unknown* if the record is deleted and corrupted, for example, as the result of a server import. */
    accountId?: string;
    /** This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    key?: string;

    constructor(data?: IUserKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): UserKey {
        data = typeof data === 'object' ? data : {};
        let result = new UserKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["key"] = this.key;
        return data;
    }
}

/** List of user account IDs. */
export interface IUserKey {
    /** The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Returns *unknown* if the record is deleted and corrupted, for example, as the result of a server import. */
    accountId?: string;
    /** This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    key?: string;
}

/** A paginated list of users sharing the filter. This includes users that are members of the groups or can browse the projects that the filter is shared with. */
export class UserList implements IUserList {
    /** The index of the last item returned on the page. */
    readonly endIndex?: number;
    /** The list of items. */
    readonly items?: User[];
    /** The maximum number of results that could be on the page. */
    readonly maxResults?: number;
    /** The number of items on the page. */
    readonly size?: number;
    /** The index of the first item returned on the page. */
    readonly startIndex?: number;

    constructor(data?: IUserList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).endIndex = _data["end-index"];
            if (Array.isArray(_data["items"])) {
                (<any>this).items = [] as any;
                for (let item of _data["items"])
                    (<any>this).items!.push(User.fromJS(item));
            }
            (<any>this).maxResults = _data["max-results"];
            (<any>this).size = _data["size"];
            (<any>this).startIndex = _data["start-index"];
        }
    }

    static fromJS(data: any): UserList {
        data = typeof data === 'object' ? data : {};
        let result = new UserList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["end-index"] = this.endIndex;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["max-results"] = this.maxResults;
        data["size"] = this.size;
        data["start-index"] = this.startIndex;
        return data;
    }
}

/** A paginated list of users sharing the filter. This includes users that are members of the groups or can browse the projects that the filter is shared with. */
export interface IUserList {
    /** The index of the last item returned on the page. */
    endIndex?: number;
    /** The list of items. */
    items?: User[];
    /** The maximum number of results that could be on the page. */
    maxResults?: number;
    /** The number of items on the page. */
    size?: number;
    /** The index of the first item returned on the page. */
    startIndex?: number;
}

export class UserMigrationBean implements IUserMigrationBean {
    accountId?: string;
    key?: string;
    username?: string;

    constructor(data?: IUserMigrationBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.key = _data["key"];
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): UserMigrationBean {
        data = typeof data === 'object' ? data : {};
        let result = new UserMigrationBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["key"] = this.key;
        data["username"] = this.username;
        return data;
    }
}

export interface IUserMigrationBean {
    accountId?: string;
    key?: string;
    username?: string;
}

export class UserNavPropertyJsonBean implements IUserNavPropertyJsonBean {
    key?: string;
    value?: string;

    constructor(data?: IUserNavPropertyJsonBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UserNavPropertyJsonBean {
        data = typeof data === 'object' ? data : {};
        let result = new UserNavPropertyJsonBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IUserNavPropertyJsonBean {
    key?: string;
    value?: string;
}

/** Details of a permission and its availability to a user. */
export class UserPermission implements IUserPermission {
    /** Indicate whether the permission key is deprecated. Note that deprecated keys cannot be used in the `permissions parameter of Get my permissions. Deprecated keys are not returned by Get all permissions.` */
    deprecatedKey?: boolean;
    /** The description of the permission. */
    description?: string;
    /** Whether the permission is available to the user in the queried context. */
    havePermission?: boolean;
    /** The ID of the permission. Either `id` or `key` must be specified. Use [Get all permissions](#api-rest-api-3-permissions-get) to get the list of permissions. */
    id?: string;
    /** The key of the permission. Either `id` or `key` must be specified. Use [Get all permissions](#api-rest-api-3-permissions-get) to get the list of permissions. */
    key?: string;
    /** The name of the permission. */
    name?: string;
    /** The type of the permission. */
    type?: UserPermissionType;

    [key: string]: any;

    constructor(data?: IUserPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.deprecatedKey = _data["deprecatedKey"];
            this.description = _data["description"];
            this.havePermission = _data["havePermission"];
            this.id = _data["id"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): UserPermission {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["deprecatedKey"] = this.deprecatedKey;
        data["description"] = this.description;
        data["havePermission"] = this.havePermission;
        data["id"] = this.id;
        data["key"] = this.key;
        data["name"] = this.name;
        data["type"] = this.type;
        return data;
    }
}

/** Details of a permission and its availability to a user. */
export interface IUserPermission {
    /** Indicate whether the permission key is deprecated. Note that deprecated keys cannot be used in the `permissions parameter of Get my permissions. Deprecated keys are not returned by Get all permissions.` */
    deprecatedKey?: boolean;
    /** The description of the permission. */
    description?: string;
    /** Whether the permission is available to the user in the queried context. */
    havePermission?: boolean;
    /** The ID of the permission. Either `id` or `key` must be specified. Use [Get all permissions](#api-rest-api-3-permissions-get) to get the list of permissions. */
    id?: string;
    /** The key of the permission. Either `id` or `key` must be specified. Use [Get all permissions](#api-rest-api-3-permissions-get) to get the list of permissions. */
    key?: string;
    /** The name of the permission. */
    name?: string;
    /** The type of the permission. */
    type?: UserPermissionType;

    [key: string]: any;
}

/** A user found in a search. */
export class UserPickerUser implements IUserPickerUser {
    /** The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. */
    accountId?: string;
    /** The avatar URL of the user. */
    avatarUrl?: string;
    /** The display name of the user. Depending on the user’s privacy setting, this may be returned as null. */
    displayName?: string;
    /** The display name, email address, and key of the user with the matched query string highlighted with the HTML bold tag. */
    html?: string;
    /** This property is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    key?: string;
    /** This property is no longer available . See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    name?: string;

    constructor(data?: IUserPickerUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["accountId"];
            this.avatarUrl = _data["avatarUrl"];
            this.displayName = _data["displayName"];
            this.html = _data["html"];
            this.key = _data["key"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): UserPickerUser {
        data = typeof data === 'object' ? data : {};
        let result = new UserPickerUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountId"] = this.accountId;
        data["avatarUrl"] = this.avatarUrl;
        data["displayName"] = this.displayName;
        data["html"] = this.html;
        data["key"] = this.key;
        data["name"] = this.name;
        return data;
    }
}

/** A user found in a search. */
export interface IUserPickerUser {
    /** The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. */
    accountId?: string;
    /** The avatar URL of the user. */
    avatarUrl?: string;
    /** The display name of the user. Depending on the user’s privacy setting, this may be returned as null. */
    displayName?: string;
    /** The display name, email address, and key of the user with the matched query string highlighted with the HTML bold tag. */
    html?: string;
    /** This property is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    key?: string;
    /** This property is no longer available . See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. */
    name?: string;
}

/** The level of validation to return from the API. If no values are provided, the default would return `WARNING` and `ERROR` level validation results. */
export class ValidationOptionsForCreate implements IValidationOptionsForCreate {
    levels?: Levels[];

    constructor(data?: IValidationOptionsForCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["levels"])) {
                this.levels = [] as any;
                for (let item of _data["levels"])
                    this.levels!.push(item);
            }
        }
    }

    static fromJS(data: any): ValidationOptionsForCreate {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationOptionsForCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.levels)) {
            data["levels"] = [];
            for (let item of this.levels)
                data["levels"].push(item);
        }
        return data;
    }
}

/** The level of validation to return from the API. If no values are provided, the default would return `WARNING` and `ERROR` level validation results. */
export interface IValidationOptionsForCreate {
    levels?: Levels[];
}

/** The level of validation to return from the API. If no values are provided, the default would return `WARNING` and `ERROR` level validation results. */
export class ValidationOptionsForUpdate implements IValidationOptionsForUpdate {
    levels?: levels[];

    constructor(data?: IValidationOptionsForUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["levels"])) {
                this.levels = [] as any;
                for (let item of _data["levels"])
                    this.levels!.push(item);
            }
        }
    }

    static fromJS(data: any): ValidationOptionsForUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationOptionsForUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.levels)) {
            data["levels"] = [];
            for (let item of this.levels)
                data["levels"].push(item);
        }
        return data;
    }
}

/** The level of validation to return from the API. If no values are provided, the default would return `WARNING` and `ERROR` level validation results. */
export interface IValidationOptionsForUpdate {
    levels?: levels[];
}

/** An operand that is a user-provided value. */
export class ValueOperand implements IValueOperand {
    /** Encoded value, which can be used directly in a JQL query. */
    encodedValue?: string;
    /** The operand value. */
    value!: string;

    [key: string]: any;

    constructor(data?: IValueOperand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.encodedValue = _data["encodedValue"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ValueOperand {
        data = typeof data === 'object' ? data : {};
        let result = new ValueOperand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["encodedValue"] = this.encodedValue;
        data["value"] = this.value;
        return data;
    }
}

/** An operand that is a user-provided value. */
export interface IValueOperand {
    /** Encoded value, which can be used directly in a JQL query. */
    encodedValue?: string;
    /** The operand value. */
    value: string;

    [key: string]: any;
}

/** Details about a project version. */
export class Version implements IVersion {
    /** If the expand option `approvers` is used, returns a list containing the approvers for this version. */
    readonly approvers?: VersionApprover[];
    /** Indicates that the version is archived. Optional when creating or updating a version. */
    archived?: boolean;
    /** The description of the version. Optional when creating or updating a version. The maximum size is 16,384 bytes. */
    description?: string;
    /** If the expand option `driver` is used, returns the Atlassian account ID of the driver. */
    readonly driver?: string;
    /** Use [expand](em>#expansion) to include additional information about version in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `operations` Returns the list of operations available for this version.
 *  `issuesstatus` Returns the count of issues in this version for each of the status categories *to do*, *in progress*, *done*, and *unmapped*. The *unmapped* property contains a count of issues with a status other than *to do*, *in progress*, and *done*.
 *  `driver` Returns the Atlassian account ID of the version driver.
 *  `approvers` Returns a list containing approvers for this version.

Optional for create and update. */
    expand?: string;
    /** The ID of the version. */
    readonly id?: string;
    /** If the expand option `issuesstatus` is used, returns the count of issues in this version for each of the status categories *to do*, *in progress*, *done*, and *unmapped*. The *unmapped* property contains a count of issues with a status other than *to do*, *in progress*, and *done*. */
    readonly issuesStatusForFixVersion?: VersionIssuesStatus;
    /** The URL of the self link to the version to which all unfixed issues are moved when a version is released. Not applicable when creating a version. Optional when updating a version. */
    moveUnfixedIssuesTo?: string;
    /** The unique name of the version. Required when creating a version. Optional when updating a version. The maximum length is 255 characters. */
    name?: string;
    /** If the expand option `operations` is used, returns the list of operations available for this version. */
    readonly operations?: SimpleLink[];
    /** Indicates that the version is overdue. */
    readonly overdue?: boolean;
    /** Deprecated. Use `projectId`. */
    project?: string;
    /** The ID of the project to which this version is attached. Required when creating a version. Not applicable when updating a version. */
    projectId?: number;
    /** The release date of the version. Expressed in ISO 8601 format (yyyy-mm-dd). Optional when creating or updating a version. */
    releaseDate?: Date;
    /** Indicates that the version is released. If the version is released a request to release again is ignored. Not applicable when creating a version. Optional when updating a version. */
    released?: boolean;
    /** The URL of the version. */
    readonly self?: string;
    /** The start date of the version. Expressed in ISO 8601 format (yyyy-mm-dd). Optional when creating or updating a version. */
    startDate?: Date;
    /** The date on which work on this version is expected to finish, expressed in the instance's *Day/Month/Year Format* date format. */
    readonly userReleaseDate?: string;
    /** The date on which work on this version is expected to start, expressed in the instance's *Day/Month/Year Format* date format. */
    readonly userStartDate?: string;

    constructor(data?: IVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["approvers"])) {
                (<any>this).approvers = [] as any;
                for (let item of _data["approvers"])
                    (<any>this).approvers!.push(VersionApprover.fromJS(item));
            }
            this.archived = _data["archived"];
            this.description = _data["description"];
            (<any>this).driver = _data["driver"];
            this.expand = _data["expand"];
            (<any>this).id = _data["id"];
            (<any>this).issuesStatusForFixVersion = _data["issuesStatusForFixVersion"] ? VersionIssuesStatus.fromJS(_data["issuesStatusForFixVersion"]) : <any>undefined;
            this.moveUnfixedIssuesTo = _data["moveUnfixedIssuesTo"];
            this.name = _data["name"];
            if (Array.isArray(_data["operations"])) {
                (<any>this).operations = [] as any;
                for (let item of _data["operations"])
                    (<any>this).operations!.push(SimpleLink.fromJS(item));
            }
            (<any>this).overdue = _data["overdue"];
            this.project = _data["project"];
            this.projectId = _data["projectId"];
            this.releaseDate = _data["releaseDate"] ? new Date(_data["releaseDate"].toString()) : <any>undefined;
            this.released = _data["released"];
            (<any>this).self = _data["self"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            (<any>this).userReleaseDate = _data["userReleaseDate"];
            (<any>this).userStartDate = _data["userStartDate"];
        }
    }

    static fromJS(data: any): Version {
        data = typeof data === 'object' ? data : {};
        let result = new Version();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.approvers)) {
            data["approvers"] = [];
            for (let item of this.approvers)
                data["approvers"].push(item.toJSON());
        }
        data["archived"] = this.archived;
        data["description"] = this.description;
        data["driver"] = this.driver;
        data["expand"] = this.expand;
        data["id"] = this.id;
        data["issuesStatusForFixVersion"] = this.issuesStatusForFixVersion ? this.issuesStatusForFixVersion.toJSON() : <any>undefined;
        data["moveUnfixedIssuesTo"] = this.moveUnfixedIssuesTo;
        data["name"] = this.name;
        if (Array.isArray(this.operations)) {
            data["operations"] = [];
            for (let item of this.operations)
                data["operations"].push(item.toJSON());
        }
        data["overdue"] = this.overdue;
        data["project"] = this.project;
        data["projectId"] = this.projectId;
        data["releaseDate"] = this.releaseDate ? formatDate(this.releaseDate) : <any>undefined;
        data["released"] = this.released;
        data["self"] = this.self;
        data["startDate"] = this.startDate ? formatDate(this.startDate) : <any>undefined;
        data["userReleaseDate"] = this.userReleaseDate;
        data["userStartDate"] = this.userStartDate;
        return data;
    }
}

/** Details about a project version. */
export interface IVersion {
    /** If the expand option `approvers` is used, returns a list containing the approvers for this version. */
    approvers?: VersionApprover[];
    /** Indicates that the version is archived. Optional when creating or updating a version. */
    archived?: boolean;
    /** The description of the version. Optional when creating or updating a version. The maximum size is 16,384 bytes. */
    description?: string;
    /** If the expand option `driver` is used, returns the Atlassian account ID of the driver. */
    driver?: string;
    /** Use [expand](em>#expansion) to include additional information about version in the response. This parameter accepts a comma-separated list. Expand options include:

 *  `operations` Returns the list of operations available for this version.
 *  `issuesstatus` Returns the count of issues in this version for each of the status categories *to do*, *in progress*, *done*, and *unmapped*. The *unmapped* property contains a count of issues with a status other than *to do*, *in progress*, and *done*.
 *  `driver` Returns the Atlassian account ID of the version driver.
 *  `approvers` Returns a list containing approvers for this version.

Optional for create and update. */
    expand?: string;
    /** The ID of the version. */
    id?: string;
    /** If the expand option `issuesstatus` is used, returns the count of issues in this version for each of the status categories *to do*, *in progress*, *done*, and *unmapped*. The *unmapped* property contains a count of issues with a status other than *to do*, *in progress*, and *done*. */
    issuesStatusForFixVersion?: VersionIssuesStatus;
    /** The URL of the self link to the version to which all unfixed issues are moved when a version is released. Not applicable when creating a version. Optional when updating a version. */
    moveUnfixedIssuesTo?: string;
    /** The unique name of the version. Required when creating a version. Optional when updating a version. The maximum length is 255 characters. */
    name?: string;
    /** If the expand option `operations` is used, returns the list of operations available for this version. */
    operations?: SimpleLink[];
    /** Indicates that the version is overdue. */
    overdue?: boolean;
    /** Deprecated. Use `projectId`. */
    project?: string;
    /** The ID of the project to which this version is attached. Required when creating a version. Not applicable when updating a version. */
    projectId?: number;
    /** The release date of the version. Expressed in ISO 8601 format (yyyy-mm-dd). Optional when creating or updating a version. */
    releaseDate?: Date;
    /** Indicates that the version is released. If the version is released a request to release again is ignored. Not applicable when creating a version. Optional when updating a version. */
    released?: boolean;
    /** The URL of the version. */
    self?: string;
    /** The start date of the version. Expressed in ISO 8601 format (yyyy-mm-dd). Optional when creating or updating a version. */
    startDate?: Date;
    /** The date on which work on this version is expected to finish, expressed in the instance's *Day/Month/Year Format* date format. */
    userReleaseDate?: string;
    /** The date on which work on this version is expected to start, expressed in the instance's *Day/Month/Year Format* date format. */
    userStartDate?: string;
}

/** Contains details about a version approver. */
export class VersionApprover implements IVersionApprover {
    /** The Atlassian account ID of the approver. */
    readonly accountId?: string;
    /** A description of why the user is declining the approval. */
    readonly declineReason?: string;
    /** A description of what the user is approving within the specified version. */
    readonly description?: string;
    /** The status of the approval, which can be *PENDING*, *APPROVED*, or *DECLINED* */
    readonly status?: string;

    [key: string]: any;

    constructor(data?: IVersionApprover) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).accountId = _data["accountId"];
            (<any>this).declineReason = _data["declineReason"];
            (<any>this).description = _data["description"];
            (<any>this).status = _data["status"];
        }
    }

    static fromJS(data: any): VersionApprover {
        data = typeof data === 'object' ? data : {};
        let result = new VersionApprover();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accountId"] = this.accountId;
        data["declineReason"] = this.declineReason;
        data["description"] = this.description;
        data["status"] = this.status;
        return data;
    }
}

/** Contains details about a version approver. */
export interface IVersionApprover {
    /** The Atlassian account ID of the approver. */
    accountId?: string;
    /** A description of why the user is declining the approval. */
    declineReason?: string;
    /** A description of what the user is approving within the specified version. */
    description?: string;
    /** The status of the approval, which can be *PENDING*, *APPROVED*, or *DECLINED* */
    status?: string;

    [key: string]: any;
}

/** Various counts of issues within a version. */
export class VersionIssueCounts implements IVersionIssueCounts {
    /** List of custom fields using the version. */
    readonly customFieldUsage?: VersionUsageInCustomField[];
    /** Count of issues where a version custom field is set to the version. */
    readonly issueCountWithCustomFieldsShowingVersion?: number;
    /** Count of issues where the `affectedVersion` is set to the version. */
    readonly issuesAffectedCount?: number;
    /** Count of issues where the `fixVersion` is set to the version. */
    readonly issuesFixedCount?: number;
    /** The URL of these count details. */
    readonly self?: string;

    constructor(data?: IVersionIssueCounts) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["customFieldUsage"])) {
                (<any>this).customFieldUsage = [] as any;
                for (let item of _data["customFieldUsage"])
                    (<any>this).customFieldUsage!.push(VersionUsageInCustomField.fromJS(item));
            }
            (<any>this).issueCountWithCustomFieldsShowingVersion = _data["issueCountWithCustomFieldsShowingVersion"];
            (<any>this).issuesAffectedCount = _data["issuesAffectedCount"];
            (<any>this).issuesFixedCount = _data["issuesFixedCount"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): VersionIssueCounts {
        data = typeof data === 'object' ? data : {};
        let result = new VersionIssueCounts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customFieldUsage)) {
            data["customFieldUsage"] = [];
            for (let item of this.customFieldUsage)
                data["customFieldUsage"].push(item.toJSON());
        }
        data["issueCountWithCustomFieldsShowingVersion"] = this.issueCountWithCustomFieldsShowingVersion;
        data["issuesAffectedCount"] = this.issuesAffectedCount;
        data["issuesFixedCount"] = this.issuesFixedCount;
        data["self"] = this.self;
        return data;
    }
}

/** Various counts of issues within a version. */
export interface IVersionIssueCounts {
    /** List of custom fields using the version. */
    customFieldUsage?: VersionUsageInCustomField[];
    /** Count of issues where a version custom field is set to the version. */
    issueCountWithCustomFieldsShowingVersion?: number;
    /** Count of issues where the `affectedVersion` is set to the version. */
    issuesAffectedCount?: number;
    /** Count of issues where the `fixVersion` is set to the version. */
    issuesFixedCount?: number;
    /** The URL of these count details. */
    self?: string;
}

/** Counts of the number of issues in various statuses. */
export class VersionIssuesStatus implements IVersionIssuesStatus {
    /** Count of issues with status *done*. */
    readonly done?: number;
    /** Count of issues with status *in progress*. */
    readonly inProgress?: number;
    /** Count of issues with status *to do*. */
    readonly toDo?: number;
    /** Count of issues with a status other than *to do*, *in progress*, and *done*. */
    readonly unmapped?: number;

    [key: string]: any;

    constructor(data?: IVersionIssuesStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).done = _data["done"];
            (<any>this).inProgress = _data["inProgress"];
            (<any>this).toDo = _data["toDo"];
            (<any>this).unmapped = _data["unmapped"];
        }
    }

    static fromJS(data: any): VersionIssuesStatus {
        data = typeof data === 'object' ? data : {};
        let result = new VersionIssuesStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["done"] = this.done;
        data["inProgress"] = this.inProgress;
        data["toDo"] = this.toDo;
        data["unmapped"] = this.unmapped;
        return data;
    }
}

/** Counts of the number of issues in various statuses. */
export interface IVersionIssuesStatus {
    /** Count of issues with status *done*. */
    done?: number;
    /** Count of issues with status *in progress*. */
    inProgress?: number;
    /** Count of issues with status *to do*. */
    toDo?: number;
    /** Count of issues with a status other than *to do*, *in progress*, and *done*. */
    unmapped?: number;

    [key: string]: any;
}

export class VersionMoveBean implements IVersionMoveBean {
    /** The URL (self link) of the version after which to place the moved version. Cannot be used with `position`. */
    after?: string;
    /** An absolute position in which to place the moved version. Cannot be used with `after`. */
    position?: VersionMoveBeanPosition;

    constructor(data?: IVersionMoveBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.after = _data["after"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): VersionMoveBean {
        data = typeof data === 'object' ? data : {};
        let result = new VersionMoveBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["after"] = this.after;
        data["position"] = this.position;
        return data;
    }
}

export interface IVersionMoveBean {
    /** The URL (self link) of the version after which to place the moved version. Cannot be used with `position`. */
    after?: string;
    /** An absolute position in which to place the moved version. Cannot be used with `after`. */
    position?: VersionMoveBeanPosition;
}

/** Associated related work to a version */
export class VersionRelatedWork implements IVersionRelatedWork {
    /** The category of the related work */
    category!: string;
    /** The ID of the issue associated with the related work (if there is one). Cannot be updated via the Rest API. */
    readonly issueId?: number;
    /** The id of the related work. For the native release note related work item, this will be null, and Rest API does not support updating it. */
    readonly relatedWorkId?: string;
    /** The title of the related work */
    title?: string;
    /** The URL of the related work. Will be null for the native release note related work item, but is otherwise required. */
    url?: string;

    constructor(data?: IVersionRelatedWork) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            (<any>this).issueId = _data["issueId"];
            (<any>this).relatedWorkId = _data["relatedWorkId"];
            this.title = _data["title"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): VersionRelatedWork {
        data = typeof data === 'object' ? data : {};
        let result = new VersionRelatedWork();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["issueId"] = this.issueId;
        data["relatedWorkId"] = this.relatedWorkId;
        data["title"] = this.title;
        data["url"] = this.url;
        return data;
    }
}

/** Associated related work to a version */
export interface IVersionRelatedWork {
    /** The category of the related work */
    category: string;
    /** The ID of the issue associated with the related work (if there is one). Cannot be updated via the Rest API. */
    issueId?: number;
    /** The id of the related work. For the native release note related work item, this will be null, and Rest API does not support updating it. */
    relatedWorkId?: string;
    /** The title of the related work */
    title?: string;
    /** The URL of the related work. Will be null for the native release note related work item, but is otherwise required. */
    url?: string;
}

/** Count of a version's unresolved issues. */
export class VersionUnresolvedIssuesCount implements IVersionUnresolvedIssuesCount {
    /** Count of issues. */
    readonly issuesCount?: number;
    /** Count of unresolved issues. */
    readonly issuesUnresolvedCount?: number;
    /** The URL of these count details. */
    readonly self?: string;

    constructor(data?: IVersionUnresolvedIssuesCount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).issuesCount = _data["issuesCount"];
            (<any>this).issuesUnresolvedCount = _data["issuesUnresolvedCount"];
            (<any>this).self = _data["self"];
        }
    }

    static fromJS(data: any): VersionUnresolvedIssuesCount {
        data = typeof data === 'object' ? data : {};
        let result = new VersionUnresolvedIssuesCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issuesCount"] = this.issuesCount;
        data["issuesUnresolvedCount"] = this.issuesUnresolvedCount;
        data["self"] = this.self;
        return data;
    }
}

/** Count of a version's unresolved issues. */
export interface IVersionUnresolvedIssuesCount {
    /** Count of issues. */
    issuesCount?: number;
    /** Count of unresolved issues. */
    issuesUnresolvedCount?: number;
    /** The URL of these count details. */
    self?: string;
}

/** List of custom fields using the version. */
export class VersionUsageInCustomField implements IVersionUsageInCustomField {
    /** The ID of the custom field. */
    readonly customFieldId?: number;
    /** The name of the custom field. */
    readonly fieldName?: string;
    /** Count of the issues where the custom field contains the version. */
    readonly issueCountWithVersionInCustomField?: number;

    constructor(data?: IVersionUsageInCustomField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).customFieldId = _data["customFieldId"];
            (<any>this).fieldName = _data["fieldName"];
            (<any>this).issueCountWithVersionInCustomField = _data["issueCountWithVersionInCustomField"];
        }
    }

    static fromJS(data: any): VersionUsageInCustomField {
        data = typeof data === 'object' ? data : {};
        let result = new VersionUsageInCustomField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customFieldId"] = this.customFieldId;
        data["fieldName"] = this.fieldName;
        data["issueCountWithVersionInCustomField"] = this.issueCountWithVersionInCustomField;
        return data;
    }
}

/** List of custom fields using the version. */
export interface IVersionUsageInCustomField {
    /** The ID of the custom field. */
    customFieldId?: number;
    /** The name of the custom field. */
    fieldName?: string;
    /** Count of the issues where the custom field contains the version. */
    issueCountWithVersionInCustomField?: number;
}

/** The group or role to which this item is visible. */
export class Visibility implements IVisibility {
    /** The ID of the group or the name of the role that visibility of this item is restricted to. */
    identifier?: string | undefined;
    /** Whether visibility of this item is restricted to a group or role. */
    type?: VisibilityType;
    /** The name of the group or role that visibility of this item is restricted to. Please note that the name of a group is mutable, to reliably identify a group use `identifier`. */
    value?: string;

    [key: string]: any;

    constructor(data?: IVisibility) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.identifier = _data["identifier"];
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Visibility {
        data = typeof data === 'object' ? data : {};
        let result = new Visibility();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["identifier"] = this.identifier;
        data["type"] = this.type;
        data["value"] = this.value;
        return data;
    }
}

/** The group or role to which this item is visible. */
export interface IVisibility {
    /** The ID of the group or the name of the role that visibility of this item is restricted to. */
    identifier?: string | undefined;
    /** Whether visibility of this item is restricted to a group or role. */
    type?: VisibilityType;
    /** The name of the group or role that visibility of this item is restricted to. Please note that the name of a group is mutable, to reliably identify a group use `identifier`. */
    value?: string;

    [key: string]: any;
}

/** The details of votes on an issue. */
export class Votes implements IVotes {
    /** Whether the user making this request has voted on the issue. */
    readonly hasVoted?: boolean;
    /** The URL of these issue vote details. */
    readonly self?: string;
    /** List of the users who have voted on this issue. An empty list is returned when the calling user doesn't have the *View voters and watchers* project permission. */
    readonly voters?: User[];
    /** The number of votes on the issue. */
    readonly votes?: number;

    constructor(data?: IVotes) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).hasVoted = _data["hasVoted"];
            (<any>this).self = _data["self"];
            if (Array.isArray(_data["voters"])) {
                (<any>this).voters = [] as any;
                for (let item of _data["voters"])
                    (<any>this).voters!.push(User.fromJS(item));
            }
            (<any>this).votes = _data["votes"];
        }
    }

    static fromJS(data: any): Votes {
        data = typeof data === 'object' ? data : {};
        let result = new Votes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hasVoted"] = this.hasVoted;
        data["self"] = this.self;
        if (Array.isArray(this.voters)) {
            data["voters"] = [];
            for (let item of this.voters)
                data["voters"].push(item.toJSON());
        }
        data["votes"] = this.votes;
        return data;
    }
}

/** The details of votes on an issue. */
export interface IVotes {
    /** Whether the user making this request has voted on the issue. */
    hasVoted?: boolean;
    /** The URL of these issue vote details. */
    self?: string;
    /** List of the users who have voted on this issue. An empty list is returned when the calling user doesn't have the *View voters and watchers* project permission. */
    voters?: User[];
    /** The number of votes on the issue. */
    votes?: number;
}

export class WarningCollection implements IWarningCollection {
    warnings?: string[];

    constructor(data?: IWarningCollection) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["warnings"])) {
                this.warnings = [] as any;
                for (let item of _data["warnings"])
                    this.warnings!.push(item);
            }
        }
    }

    static fromJS(data: any): WarningCollection {
        data = typeof data === 'object' ? data : {};
        let result = new WarningCollection();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.warnings)) {
            data["warnings"] = [];
            for (let item of this.warnings)
                data["warnings"].push(item);
        }
        return data;
    }
}

export interface IWarningCollection {
    warnings?: string[];
}

/** The details of watchers on an issue. */
export class Watchers implements IWatchers {
    /** Whether the calling user is watching this issue. */
    readonly isWatching?: boolean;
    /** The URL of these issue watcher details. */
    readonly self?: string;
    /** The number of users watching this issue. */
    readonly watchCount?: number;
    /** Details of the users watching this issue. */
    readonly watchers?: UserDetails[];

    constructor(data?: IWatchers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isWatching = _data["isWatching"];
            (<any>this).self = _data["self"];
            (<any>this).watchCount = _data["watchCount"];
            if (Array.isArray(_data["watchers"])) {
                (<any>this).watchers = [] as any;
                for (let item of _data["watchers"])
                    (<any>this).watchers!.push(UserDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Watchers {
        data = typeof data === 'object' ? data : {};
        let result = new Watchers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isWatching"] = this.isWatching;
        data["self"] = this.self;
        data["watchCount"] = this.watchCount;
        if (Array.isArray(this.watchers)) {
            data["watchers"] = [];
            for (let item of this.watchers)
                data["watchers"].push(item.toJSON());
        }
        return data;
    }
}

/** The details of watchers on an issue. */
export interface IWatchers {
    /** Whether the calling user is watching this issue. */
    isWatching?: boolean;
    /** The URL of these issue watcher details. */
    self?: string;
    /** The number of users watching this issue. */
    watchCount?: number;
    /** Details of the users watching this issue. */
    watchers?: UserDetails[];
}

/** A webhook. */
export class Webhook implements IWebhook {
    /** The Jira events that trigger the webhook. */
    events!: Events[];
    /** The date after which the webhook is no longer sent. Use [Extend webhook life](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-webhooks/#api-rest-api-3-webhook-refresh-put) to extend the date. */
    readonly expirationDate?: number;
    /** A list of field IDs. When the issue changelog contains any of the fields, the webhook `jira:issue_updated` is sent. If this parameter is not present, the app is notified about all field updates. */
    fieldIdsFilter?: string[];
    /** The ID of the webhook. */
    id!: number;
    /** A list of issue property keys. A change of those issue properties triggers the `issue_property_set` or `issue_property_deleted` webhooks. If this parameter is not present, the app is notified about all issue property updates. */
    issuePropertyKeysFilter?: string[];
    /** The JQL filter that specifies which issues the webhook is sent for. */
    jqlFilter!: string;

    constructor(data?: IWebhook) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.events = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["events"])) {
                this.events = [] as any;
                for (let item of _data["events"])
                    this.events!.push(item);
            }
            (<any>this).expirationDate = _data["expirationDate"];
            if (Array.isArray(_data["fieldIdsFilter"])) {
                this.fieldIdsFilter = [] as any;
                for (let item of _data["fieldIdsFilter"])
                    this.fieldIdsFilter!.push(item);
            }
            this.id = _data["id"];
            if (Array.isArray(_data["issuePropertyKeysFilter"])) {
                this.issuePropertyKeysFilter = [] as any;
                for (let item of _data["issuePropertyKeysFilter"])
                    this.issuePropertyKeysFilter!.push(item);
            }
            this.jqlFilter = _data["jqlFilter"];
        }
    }

    static fromJS(data: any): Webhook {
        data = typeof data === 'object' ? data : {};
        let result = new Webhook();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.events)) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item);
        }
        data["expirationDate"] = this.expirationDate;
        if (Array.isArray(this.fieldIdsFilter)) {
            data["fieldIdsFilter"] = [];
            for (let item of this.fieldIdsFilter)
                data["fieldIdsFilter"].push(item);
        }
        data["id"] = this.id;
        if (Array.isArray(this.issuePropertyKeysFilter)) {
            data["issuePropertyKeysFilter"] = [];
            for (let item of this.issuePropertyKeysFilter)
                data["issuePropertyKeysFilter"].push(item);
        }
        data["jqlFilter"] = this.jqlFilter;
        return data;
    }
}

/** A webhook. */
export interface IWebhook {
    /** The Jira events that trigger the webhook. */
    events: Events[];
    /** The date after which the webhook is no longer sent. Use [Extend webhook life](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-webhooks/#api-rest-api-3-webhook-refresh-put) to extend the date. */
    expirationDate?: number;
    /** A list of field IDs. When the issue changelog contains any of the fields, the webhook `jira:issue_updated` is sent. If this parameter is not present, the app is notified about all field updates. */
    fieldIdsFilter?: string[];
    /** The ID of the webhook. */
    id: number;
    /** A list of issue property keys. A change of those issue properties triggers the `issue_property_set` or `issue_property_deleted` webhooks. If this parameter is not present, the app is notified about all issue property updates. */
    issuePropertyKeysFilter?: string[];
    /** The JQL filter that specifies which issues the webhook is sent for. */
    jqlFilter: string;
}

/** A list of webhooks. */
export class WebhookDetails implements IWebhookDetails {
    /** The Jira events that trigger the webhook. */
    events!: events[];
    /** A list of field IDs. When the issue changelog contains any of the fields, the webhook `jira:issue_updated` is sent. If this parameter is not present, the app is notified about all field updates. */
    fieldIdsFilter?: string[];
    /** A list of issue property keys. A change of those issue properties triggers the `issue_property_set` or `issue_property_deleted` webhooks. If this parameter is not present, the app is notified about all issue property updates. */
    issuePropertyKeysFilter?: string[];
    /** The JQL filter that specifies which issues the webhook is sent for. Only a subset of JQL can be used. The supported elements are:

 *  Fields: `issueKey`, `project`, `issuetype`, `status`, `assignee`, `reporter`, `issue.property`, and `cf[id]`. For custom fields (`cf[id]`), only the epic label custom field is supported.".
 *  Operators: `=`, `!=`, `IN`, and `NOT IN`. */
    jqlFilter!: string;

    constructor(data?: IWebhookDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.events = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["events"])) {
                this.events = [] as any;
                for (let item of _data["events"])
                    this.events!.push(item);
            }
            if (Array.isArray(_data["fieldIdsFilter"])) {
                this.fieldIdsFilter = [] as any;
                for (let item of _data["fieldIdsFilter"])
                    this.fieldIdsFilter!.push(item);
            }
            if (Array.isArray(_data["issuePropertyKeysFilter"])) {
                this.issuePropertyKeysFilter = [] as any;
                for (let item of _data["issuePropertyKeysFilter"])
                    this.issuePropertyKeysFilter!.push(item);
            }
            this.jqlFilter = _data["jqlFilter"];
        }
    }

    static fromJS(data: any): WebhookDetails {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.events)) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item);
        }
        if (Array.isArray(this.fieldIdsFilter)) {
            data["fieldIdsFilter"] = [];
            for (let item of this.fieldIdsFilter)
                data["fieldIdsFilter"].push(item);
        }
        if (Array.isArray(this.issuePropertyKeysFilter)) {
            data["issuePropertyKeysFilter"] = [];
            for (let item of this.issuePropertyKeysFilter)
                data["issuePropertyKeysFilter"].push(item);
        }
        data["jqlFilter"] = this.jqlFilter;
        return data;
    }
}

/** A list of webhooks. */
export interface IWebhookDetails {
    /** The Jira events that trigger the webhook. */
    events: events[];
    /** A list of field IDs. When the issue changelog contains any of the fields, the webhook `jira:issue_updated` is sent. If this parameter is not present, the app is notified about all field updates. */
    fieldIdsFilter?: string[];
    /** A list of issue property keys. A change of those issue properties triggers the `issue_property_set` or `issue_property_deleted` webhooks. If this parameter is not present, the app is notified about all issue property updates. */
    issuePropertyKeysFilter?: string[];
    /** The JQL filter that specifies which issues the webhook is sent for. Only a subset of JQL can be used. The supported elements are:

 *  Fields: `issueKey`, `project`, `issuetype`, `status`, `assignee`, `reporter`, `issue.property`, and `cf[id]`. For custom fields (`cf[id]`), only the epic label custom field is supported.".
 *  Operators: `=`, `!=`, `IN`, and `NOT IN`. */
    jqlFilter: string;
}

/** Details of webhooks to register. */
export class WebhookRegistrationDetails implements IWebhookRegistrationDetails {
    /** The URL that specifies where to send the webhooks. This URL must use the same base URL as the Connect app. Only a single URL per app is allowed to be registered. */
    url!: string;
    /** A list of webhooks. */
    webhooks!: WebhookDetails[];

    constructor(data?: IWebhookRegistrationDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.webhooks = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            if (Array.isArray(_data["webhooks"])) {
                this.webhooks = [] as any;
                for (let item of _data["webhooks"])
                    this.webhooks!.push(WebhookDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WebhookRegistrationDetails {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookRegistrationDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        if (Array.isArray(this.webhooks)) {
            data["webhooks"] = [];
            for (let item of this.webhooks)
                data["webhooks"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of webhooks to register. */
export interface IWebhookRegistrationDetails {
    /** The URL that specifies where to send the webhooks. This URL must use the same base URL as the Connect app. Only a single URL per app is allowed to be registered. */
    url: string;
    /** A list of webhooks. */
    webhooks: WebhookDetails[];
}

/** The date the refreshed webhooks expire. */
export class WebhooksExpirationDate implements IWebhooksExpirationDate {
    /** The expiration date of all the refreshed webhooks. */
    readonly expirationDate!: number;

    constructor(data?: IWebhooksExpirationDate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).expirationDate = _data["expirationDate"];
        }
    }

    static fromJS(data: any): WebhooksExpirationDate {
        data = typeof data === 'object' ? data : {};
        let result = new WebhooksExpirationDate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expirationDate"] = this.expirationDate;
        return data;
    }
}

/** The date the refreshed webhooks expire. */
export interface IWebhooksExpirationDate {
    /** The expiration date of all the refreshed webhooks. */
    expirationDate: number;
}

export class WorkManagementNavigationInfo implements IWorkManagementNavigationInfo {
    boardName?: string;

    [key: string]: any;

    constructor(data?: IWorkManagementNavigationInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.boardName = _data["boardName"];
        }
    }

    static fromJS(data: any): WorkManagementNavigationInfo {
        data = typeof data === 'object' ? data : {};
        let result = new WorkManagementNavigationInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["boardName"] = this.boardName;
        return data;
    }
}

export interface IWorkManagementNavigationInfo {
    boardName?: string;

    [key: string]: any;
}

/** Details about a workflow. */
export class Workflow implements IWorkflow {
    /** The creation date of the workflow. */
    created?: Date;
    /** The description of the workflow. */
    description!: string;
    /** Whether the workflow has a draft version. */
    hasDraftWorkflow?: boolean;
    id!: PublishedWorkflowId;
    /** Whether this is the default workflow. */
    isDefault?: boolean;
    operations?: WorkflowOperations;
    /** The projects the workflow is assigned to, through workflow schemes. */
    projects?: ProjectDetails[];
    /** The workflow schemes the workflow is assigned to. */
    schemes?: WorkflowSchemeIdName[];
    /** The statuses of the workflow. */
    statuses?: WorkflowStatus[];
    /** The transitions of the workflow. */
    transitions?: Transition[];
    /** The last edited date of the workflow. */
    updated?: Date;

    constructor(data?: IWorkflow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.id = new PublishedWorkflowId();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.hasDraftWorkflow = _data["hasDraftWorkflow"];
            this.id = _data["id"] ? PublishedWorkflowId.fromJS(_data["id"]) : new PublishedWorkflowId();
            this.isDefault = _data["isDefault"];
            this.operations = _data["operations"] ? WorkflowOperations.fromJS(_data["operations"]) : <any>undefined;
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects!.push(ProjectDetails.fromJS(item));
            }
            if (Array.isArray(_data["schemes"])) {
                this.schemes = [] as any;
                for (let item of _data["schemes"])
                    this.schemes!.push(WorkflowSchemeIdName.fromJS(item));
            }
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(WorkflowStatus.fromJS(item));
            }
            if (Array.isArray(_data["transitions"])) {
                this.transitions = [] as any;
                for (let item of _data["transitions"])
                    this.transitions!.push(Transition.fromJS(item));
            }
            this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Workflow {
        data = typeof data === 'object' ? data : {};
        let result = new Workflow();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["hasDraftWorkflow"] = this.hasDraftWorkflow;
        data["id"] = this.id ? this.id.toJSON() : <any>undefined;
        data["isDefault"] = this.isDefault;
        data["operations"] = this.operations ? this.operations.toJSON() : <any>undefined;
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item.toJSON());
        }
        if (Array.isArray(this.schemes)) {
            data["schemes"] = [];
            for (let item of this.schemes)
                data["schemes"].push(item.toJSON());
        }
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        if (Array.isArray(this.transitions)) {
            data["transitions"] = [];
            for (let item of this.transitions)
                data["transitions"].push(item.toJSON());
        }
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        return data;
    }
}

/** Details about a workflow. */
export interface IWorkflow {
    /** The creation date of the workflow. */
    created?: Date;
    /** The description of the workflow. */
    description: string;
    /** Whether the workflow has a draft version. */
    hasDraftWorkflow?: boolean;
    id: PublishedWorkflowId;
    /** Whether this is the default workflow. */
    isDefault?: boolean;
    operations?: WorkflowOperations;
    /** The projects the workflow is assigned to, through workflow schemes. */
    projects?: ProjectDetails[];
    /** The workflow schemes the workflow is assigned to. */
    schemes?: WorkflowSchemeIdName[];
    /** The statuses of the workflow. */
    statuses?: WorkflowStatus[];
    /** The transitions of the workflow. */
    transitions?: Transition[];
    /** The last edited date of the workflow. */
    updated?: Date;
}

/** The list of status mappings. */
export class WorkflowAssociationStatusMapping implements IWorkflowAssociationStatusMapping {
    /** The ID of the status in the new workflow. */
    newStatusId!: string;
    /** The ID of the status in the old workflow that isn't present in the new workflow. */
    oldStatusId!: string;

    constructor(data?: IWorkflowAssociationStatusMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newStatusId = _data["newStatusId"];
            this.oldStatusId = _data["oldStatusId"];
        }
    }

    static fromJS(data: any): WorkflowAssociationStatusMapping {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowAssociationStatusMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newStatusId"] = this.newStatusId;
        data["oldStatusId"] = this.oldStatusId;
        return data;
    }
}

/** The list of status mappings. */
export interface IWorkflowAssociationStatusMapping {
    /** The ID of the status in the new workflow. */
    newStatusId: string;
    /** The ID of the status in the old workflow that isn't present in the new workflow. */
    oldStatusId: string;
}

export class WorkflowCapabilities implements IWorkflowCapabilities {
    /** The Connect provided ecosystem rules available. */
    connectRules?: AvailableWorkflowConnectRule[];
    /** The scope of the workflow capabilities. `GLOBAL` for company-managed projects and `PROJECT` for team-managed projects. */
    editorScope?: WorkflowCapabilitiesEditorScope;
    /** The Forge provided ecosystem rules available. */
    forgeRules?: AvailableWorkflowForgeRule[];
    /** The types of projects that this capability set is available for. */
    projectTypes?: ProjectTypes[];
    /** The Atlassian provided system rules available. */
    systemRules?: AvailableWorkflowSystemRule[];
    /** The trigger rules available. */
    triggerRules?: AvailableWorkflowTriggers[];

    constructor(data?: IWorkflowCapabilities) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["connectRules"])) {
                this.connectRules = [] as any;
                for (let item of _data["connectRules"])
                    this.connectRules!.push(AvailableWorkflowConnectRule.fromJS(item));
            }
            this.editorScope = _data["editorScope"];
            if (Array.isArray(_data["forgeRules"])) {
                this.forgeRules = [] as any;
                for (let item of _data["forgeRules"])
                    this.forgeRules!.push(AvailableWorkflowForgeRule.fromJS(item));
            }
            if (Array.isArray(_data["projectTypes"])) {
                this.projectTypes = [] as any;
                for (let item of _data["projectTypes"])
                    this.projectTypes!.push(item);
            }
            if (Array.isArray(_data["systemRules"])) {
                this.systemRules = [] as any;
                for (let item of _data["systemRules"])
                    this.systemRules!.push(AvailableWorkflowSystemRule.fromJS(item));
            }
            if (Array.isArray(_data["triggerRules"])) {
                this.triggerRules = [] as any;
                for (let item of _data["triggerRules"])
                    this.triggerRules!.push(AvailableWorkflowTriggers.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowCapabilities {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowCapabilities();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.connectRules)) {
            data["connectRules"] = [];
            for (let item of this.connectRules)
                data["connectRules"].push(item.toJSON());
        }
        data["editorScope"] = this.editorScope;
        if (Array.isArray(this.forgeRules)) {
            data["forgeRules"] = [];
            for (let item of this.forgeRules)
                data["forgeRules"].push(item.toJSON());
        }
        if (Array.isArray(this.projectTypes)) {
            data["projectTypes"] = [];
            for (let item of this.projectTypes)
                data["projectTypes"].push(item);
        }
        if (Array.isArray(this.systemRules)) {
            data["systemRules"] = [];
            for (let item of this.systemRules)
                data["systemRules"].push(item.toJSON());
        }
        if (Array.isArray(this.triggerRules)) {
            data["triggerRules"] = [];
            for (let item of this.triggerRules)
                data["triggerRules"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowCapabilities {
    /** The Connect provided ecosystem rules available. */
    connectRules?: AvailableWorkflowConnectRule[];
    /** The scope of the workflow capabilities. `GLOBAL` for company-managed projects and `PROJECT` for team-managed projects. */
    editorScope?: WorkflowCapabilitiesEditorScope;
    /** The Forge provided ecosystem rules available. */
    forgeRules?: AvailableWorkflowForgeRule[];
    /** The types of projects that this capability set is available for. */
    projectTypes?: ProjectTypes[];
    /** The Atlassian provided system rules available. */
    systemRules?: AvailableWorkflowSystemRule[];
    /** The trigger rules available. */
    triggerRules?: AvailableWorkflowTriggers[];
}

/** The payload for creating a workflows. See https://www.atlassian.com/software/jira/guides/workflows/overview\#what-is-a-jira-workflow */
export class WorkflowCapabilityPayload implements IWorkflowCapabilityPayload {
    /** The statuses for the workflow */
    statuses?: StatusPayload[];
    workflowScheme?: WorkflowSchemePayload;
    /** The transitions for the workflow */
    workflows?: WorkflowPayload[];

    constructor(data?: IWorkflowCapabilityPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(StatusPayload.fromJS(item));
            }
            this.workflowScheme = _data["workflowScheme"] ? WorkflowSchemePayload.fromJS(_data["workflowScheme"]) : <any>undefined;
            if (Array.isArray(_data["workflows"])) {
                this.workflows = [] as any;
                for (let item of _data["workflows"])
                    this.workflows!.push(WorkflowPayload.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowCapabilityPayload {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowCapabilityPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        data["workflowScheme"] = this.workflowScheme ? this.workflowScheme.toJSON() : <any>undefined;
        if (Array.isArray(this.workflows)) {
            data["workflows"] = [];
            for (let item of this.workflows)
                data["workflows"].push(item.toJSON());
        }
        return data;
    }
}

/** The payload for creating a workflows. See https://www.atlassian.com/software/jira/guides/workflows/overview\#what-is-a-jira-workflow */
export interface IWorkflowCapabilityPayload {
    /** The statuses for the workflow */
    statuses?: StatusPayload[];
    workflowScheme?: WorkflowSchemePayload;
    /** The transitions for the workflow */
    workflows?: WorkflowPayload[];
}

/** A compound workflow transition rule condition. This object returns `nodeType` as `compound`. */
export class WorkflowCompoundCondition implements IWorkflowCompoundCondition {
    /** The list of workflow conditions. */
    conditions!: Conditions[];
    nodeType!: string;
    /** The compound condition operator. */
    operator!: WorkflowCompoundConditionOperator;

    [key: string]: any;

    constructor(data?: IWorkflowCompoundCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.conditions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(Conditions.fromJS(item));
            }
            this.nodeType = _data["nodeType"];
            this.operator = _data["operator"];
        }
    }

    static fromJS(data: any): WorkflowCompoundCondition {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowCompoundCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["nodeType"] = this.nodeType;
        data["operator"] = this.operator;
        return data;
    }
}

/** A compound workflow transition rule condition. This object returns `nodeType` as `compound`. */
export interface IWorkflowCompoundCondition {
    /** The list of workflow conditions. */
    conditions: Conditions[];
    nodeType: string;
    /** The compound condition operator. */
    operator: WorkflowCompoundConditionOperator;

    [key: string]: any;
}

/** The workflow transition rule conditions tree. */
export class WorkflowCondition implements IWorkflowCondition {

    [key: string]: any;

    constructor(data?: IWorkflowCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "simple";
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): WorkflowCondition {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

/** The workflow transition rule conditions tree. */
export interface IWorkflowCondition {

    [key: string]: any;
}

/** The details of the workflows to create. */
export class WorkflowCreate implements IWorkflowCreate {
    /** The description of the workflow to create. */
    description?: string;
    loopedTransitionContainerLayout?: WorkflowLayout | undefined;
    /** The name of the workflow to create. */
    name!: string;
    startPointLayout?: WorkflowLayout | undefined;
    /** The statuses associated with this workflow. */
    statuses!: StatusLayoutUpdate[];
    /** The transitions of this workflow. */
    transitions!: TransitionUpdateDTO[];

    constructor(data?: IWorkflowCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.statuses = [];
            this.transitions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.loopedTransitionContainerLayout = _data["loopedTransitionContainerLayout"] ? WorkflowLayout.fromJS(_data["loopedTransitionContainerLayout"]) : <any>undefined;
            this.name = _data["name"];
            this.startPointLayout = _data["startPointLayout"] ? WorkflowLayout.fromJS(_data["startPointLayout"]) : <any>undefined;
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(StatusLayoutUpdate.fromJS(item));
            }
            if (Array.isArray(_data["transitions"])) {
                this.transitions = [] as any;
                for (let item of _data["transitions"])
                    this.transitions!.push(TransitionUpdateDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowCreate {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["loopedTransitionContainerLayout"] = this.loopedTransitionContainerLayout ? this.loopedTransitionContainerLayout.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["startPointLayout"] = this.startPointLayout ? this.startPointLayout.toJSON() : <any>undefined;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        if (Array.isArray(this.transitions)) {
            data["transitions"] = [];
            for (let item of this.transitions)
                data["transitions"].push(item.toJSON());
        }
        return data;
    }
}

/** The details of the workflows to create. */
export interface IWorkflowCreate {
    /** The description of the workflow to create. */
    description?: string;
    loopedTransitionContainerLayout?: WorkflowLayout | undefined;
    /** The name of the workflow to create. */
    name: string;
    startPointLayout?: WorkflowLayout | undefined;
    /** The statuses associated with this workflow. */
    statuses: StatusLayoutUpdate[];
    /** The transitions of this workflow. */
    transitions: TransitionUpdateDTO[];
}

/** The create workflows payload. */
export class WorkflowCreateRequest implements IWorkflowCreateRequest {
    scope?: WorkflowScope;
    /** The statuses to associate with the workflows. */
    statuses?: WorkflowStatusUpdate[];
    /** The details of the workflows to create. */
    workflows?: WorkflowCreate[];

    constructor(data?: IWorkflowCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scope = _data["scope"] ? WorkflowScope.fromJS(_data["scope"]) : <any>undefined;
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(WorkflowStatusUpdate.fromJS(item));
            }
            if (Array.isArray(_data["workflows"])) {
                this.workflows = [] as any;
                for (let item of _data["workflows"])
                    this.workflows!.push(WorkflowCreate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        if (Array.isArray(this.workflows)) {
            data["workflows"] = [];
            for (let item of this.workflows)
                data["workflows"].push(item.toJSON());
        }
        return data;
    }
}

/** The create workflows payload. */
export interface IWorkflowCreateRequest {
    scope?: WorkflowScope;
    /** The statuses to associate with the workflows. */
    statuses?: WorkflowStatusUpdate[];
    /** The details of the workflows to create. */
    workflows?: WorkflowCreate[];
}

/** Details of the created workflows and statuses. */
export class WorkflowCreateResponse implements IWorkflowCreateResponse {
    /** List of created statuses. */
    statuses?: JiraWorkflowStatus[];
    /** List of created workflows. */
    workflows?: JiraWorkflow[];

    constructor(data?: IWorkflowCreateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(JiraWorkflowStatus.fromJS(item));
            }
            if (Array.isArray(_data["workflows"])) {
                this.workflows = [] as any;
                for (let item of _data["workflows"])
                    this.workflows!.push(JiraWorkflow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowCreateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowCreateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        if (Array.isArray(this.workflows)) {
            data["workflows"] = [];
            for (let item of this.workflows)
                data["workflows"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of the created workflows and statuses. */
export interface IWorkflowCreateResponse {
    /** List of created statuses. */
    statuses?: JiraWorkflowStatus[];
    /** List of created workflows. */
    workflows?: JiraWorkflow[];
}

export class WorkflowCreateValidateRequest implements IWorkflowCreateValidateRequest {
    payload!: WorkflowCreateRequest;
    validationOptions?: ValidationOptionsForCreate;

    constructor(data?: IWorkflowCreateValidateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.payload = new WorkflowCreateRequest();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.payload = _data["payload"] ? WorkflowCreateRequest.fromJS(_data["payload"]) : new WorkflowCreateRequest();
            this.validationOptions = _data["validationOptions"] ? ValidationOptionsForCreate.fromJS(_data["validationOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkflowCreateValidateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowCreateValidateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payload"] = this.payload ? this.payload.toJSON() : <any>undefined;
        data["validationOptions"] = this.validationOptions ? this.validationOptions.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWorkflowCreateValidateRequest {
    payload: WorkflowCreateRequest;
    validationOptions?: ValidationOptionsForCreate;
}

/** A reference to the location of the error. This will be null if the error does not refer to a specific element. */
export class WorkflowElementReference implements IWorkflowElementReference {
    /** A property key. */
    propertyKey?: string;
    /** A rule ID. */
    ruleId?: string;
    statusMappingReference?: ProjectAndIssueTypePair;
    /** A status reference. */
    statusReference?: string;
    /** A transition ID. */
    transitionId?: string;

    constructor(data?: IWorkflowElementReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyKey = _data["propertyKey"];
            this.ruleId = _data["ruleId"];
            this.statusMappingReference = _data["statusMappingReference"] ? ProjectAndIssueTypePair.fromJS(_data["statusMappingReference"]) : <any>undefined;
            this.statusReference = _data["statusReference"];
            this.transitionId = _data["transitionId"];
        }
    }

    static fromJS(data: any): WorkflowElementReference {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowElementReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyKey"] = this.propertyKey;
        data["ruleId"] = this.ruleId;
        data["statusMappingReference"] = this.statusMappingReference ? this.statusMappingReference.toJSON() : <any>undefined;
        data["statusReference"] = this.statusReference;
        data["transitionId"] = this.transitionId;
        return data;
    }
}

/** A reference to the location of the error. This will be null if the error does not refer to a specific element. */
export interface IWorkflowElementReference {
    /** A property key. */
    propertyKey?: string;
    /** A rule ID. */
    ruleId?: string;
    statusMappingReference?: ProjectAndIssueTypePair;
    /** A status reference. */
    statusReference?: string;
    /** A transition ID. */
    transitionId?: string;
}

/** The classic workflow identifiers. */
export class WorkflowIDs implements IWorkflowIDs {
    /** The entity ID of the workflow. */
    entityId?: string;
    /** The name of the workflow. */
    name!: string;

    constructor(data?: IWorkflowIDs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WorkflowIDs {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowIDs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["name"] = this.name;
        return data;
    }
}

/** The classic workflow identifiers. */
export interface IWorkflowIDs {
    /** The entity ID of the workflow. */
    entityId?: string;
    /** The name of the workflow. */
    name: string;
}

/** Properties that identify a workflow. */
export class WorkflowId implements IWorkflowId {
    /** Whether the workflow is in the draft state. */
    draft!: boolean;
    /** The name of the workflow. */
    name!: string;

    constructor(data?: IWorkflowId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.draft = _data["draft"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WorkflowId {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["draft"] = this.draft;
        data["name"] = this.name;
        return data;
    }
}

/** Properties that identify a workflow. */
export interface IWorkflowId {
    /** Whether the workflow is in the draft state. */
    draft: boolean;
    /** The name of the workflow. */
    name: string;
}

/** The starting point for the statuses in the workflow. */
export class WorkflowLayout implements IWorkflowLayout {
    /** The x axis location. */
    x?: number;
    /** The y axis location. */
    y?: number;

    constructor(data?: IWorkflowLayout) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.x = _data["x"];
            this.y = _data["y"];
        }
    }

    static fromJS(data: any): WorkflowLayout {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowLayout();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        return data;
    }
}

/** The starting point for the statuses in the workflow. */
export interface IWorkflowLayout {
    /** The x axis location. */
    x?: number;
    /** The y axis location. */
    y?: number;
}

/** The workflow metadata and issue type IDs which use this workflow. */
export class WorkflowMetadataAndIssueTypeRestModel implements IWorkflowMetadataAndIssueTypeRestModel {
    /** The list of issue type IDs for the mapping. */
    issueTypeIds!: string[];
    workflow!: WorkflowMetadataRestModel;

    constructor(data?: IWorkflowMetadataAndIssueTypeRestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueTypeIds = [];
            this.workflow = new WorkflowMetadataRestModel();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueTypeIds"])) {
                this.issueTypeIds = [] as any;
                for (let item of _data["issueTypeIds"])
                    this.issueTypeIds!.push(item);
            }
            this.workflow = _data["workflow"] ? WorkflowMetadataRestModel.fromJS(_data["workflow"]) : new WorkflowMetadataRestModel();
        }
    }

    static fromJS(data: any): WorkflowMetadataAndIssueTypeRestModel {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowMetadataAndIssueTypeRestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueTypeIds)) {
            data["issueTypeIds"] = [];
            for (let item of this.issueTypeIds)
                data["issueTypeIds"].push(item);
        }
        data["workflow"] = this.workflow ? this.workflow.toJSON() : <any>undefined;
        return data;
    }
}

/** The workflow metadata and issue type IDs which use this workflow. */
export interface IWorkflowMetadataAndIssueTypeRestModel {
    /** The list of issue type IDs for the mapping. */
    issueTypeIds: string[];
    workflow: WorkflowMetadataRestModel;
}

/** Workflow metadata and usage detail. */
export class WorkflowMetadataRestModel implements IWorkflowMetadataRestModel {
    /** The description of the workflow. */
    description!: string;
    /** The ID of the workflow. */
    id!: string;
    /** The name of the workflow. */
    name!: string;
    /** Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details.

Use the optional `workflows.usages` expand to get additional information about the projects and issue types associated with the workflows in the workflow scheme. */
    usage!: (SimpleUsage | undefined)[] | undefined;
    version!: DocumentVersion;

    constructor(data?: IWorkflowMetadataRestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.version = new DocumentVersion();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["usage"])) {
                this.usage = [] as any;
                for (let item of _data["usage"])
                    this.usage!.push(SimpleUsage.fromJS(item));
            }
            this.version = _data["version"] ? DocumentVersion.fromJS(_data["version"]) : new DocumentVersion();
        }
    }

    static fromJS(data: any): WorkflowMetadataRestModel {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowMetadataRestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.usage)) {
            data["usage"] = [];
            for (let item of this.usage)
                data["usage"].push(item.toJSON());
        }
        data["version"] = this.version ? this.version.toJSON() : <any>undefined;
        return data;
    }
}

/** Workflow metadata and usage detail. */
export interface IWorkflowMetadataRestModel {
    /** The description of the workflow. */
    description: string;
    /** The ID of the workflow. */
    id: string;
    /** The name of the workflow. */
    name: string;
    /** Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details.

Use the optional `workflows.usages` expand to get additional information about the projects and issue types associated with the workflows in the workflow scheme. */
    usage: (SimpleUsage | undefined)[] | undefined;
    version: DocumentVersion;
}

/** Operations allowed on a workflow */
export class WorkflowOperations implements IWorkflowOperations {
    /** Whether the workflow can be deleted. */
    canDelete!: boolean;
    /** Whether the workflow can be updated. */
    canEdit!: boolean;

    constructor(data?: IWorkflowOperations) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canDelete = _data["canDelete"];
            this.canEdit = _data["canEdit"];
        }
    }

    static fromJS(data: any): WorkflowOperations {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowOperations();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canDelete"] = this.canDelete;
        data["canEdit"] = this.canEdit;
        return data;
    }
}

/** Operations allowed on a workflow */
export interface IWorkflowOperations {
    /** Whether the workflow can be deleted. */
    canDelete: boolean;
    /** Whether the workflow can be updated. */
    canEdit: boolean;
}

/** The payload for creating workflow, see https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-workflows/\#api-rest-api-3-workflows-create-post */
export class WorkflowPayload implements IWorkflowPayload {
    /** The description of the workflow */
    description?: string;
    loopedTransitionContainerLayout?: WorkflowStatusLayoutPayload;
    /** The name of the workflow */
    name?: string;
    /** The strategy to use if there is a conflict with another workflow */
    onConflict?: WorkflowPayloadOnConflict;
    pcri?: ProjectCreateResourceIdentifier;
    startPointLayout?: WorkflowStatusLayoutPayload;
    /** The statuses to be used in the workflow */
    statuses?: WorkflowStatusPayload[];
    /** The transitions for the workflow */
    transitions?: TransitionPayload[];

    constructor(data?: IWorkflowPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.onConflict = WorkflowPayloadOnConflict.NEW;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.loopedTransitionContainerLayout = _data["loopedTransitionContainerLayout"] ? WorkflowStatusLayoutPayload.fromJS(_data["loopedTransitionContainerLayout"]) : <any>undefined;
            this.name = _data["name"];
            this.onConflict = _data["onConflict"] !== undefined ? _data["onConflict"] : WorkflowPayloadOnConflict.NEW;
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
            this.startPointLayout = _data["startPointLayout"] ? WorkflowStatusLayoutPayload.fromJS(_data["startPointLayout"]) : <any>undefined;
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(WorkflowStatusPayload.fromJS(item));
            }
            if (Array.isArray(_data["transitions"])) {
                this.transitions = [] as any;
                for (let item of _data["transitions"])
                    this.transitions!.push(TransitionPayload.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowPayload {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["loopedTransitionContainerLayout"] = this.loopedTransitionContainerLayout ? this.loopedTransitionContainerLayout.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["onConflict"] = this.onConflict;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        data["startPointLayout"] = this.startPointLayout ? this.startPointLayout.toJSON() : <any>undefined;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        if (Array.isArray(this.transitions)) {
            data["transitions"] = [];
            for (let item of this.transitions)
                data["transitions"].push(item.toJSON());
        }
        return data;
    }
}

/** The payload for creating workflow, see https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-workflows/\#api-rest-api-3-workflows-create-post */
export interface IWorkflowPayload {
    /** The description of the workflow */
    description?: string;
    loopedTransitionContainerLayout?: WorkflowStatusLayoutPayload;
    /** The name of the workflow */
    name?: string;
    /** The strategy to use if there is a conflict with another workflow */
    onConflict?: WorkflowPayloadOnConflict;
    pcri?: ProjectCreateResourceIdentifier;
    startPointLayout?: WorkflowStatusLayoutPayload;
    /** The statuses to be used in the workflow */
    statuses?: WorkflowStatusPayload[];
    /** The transitions for the workflow */
    transitions?: TransitionPayload[];
}

/** The issue type. */
export class WorkflowProjectIssueTypeUsage implements IWorkflowProjectIssueTypeUsage {
    /** The ID of the issue type. */
    id?: string;

    constructor(data?: IWorkflowProjectIssueTypeUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WorkflowProjectIssueTypeUsage {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowProjectIssueTypeUsage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** The issue type. */
export interface IWorkflowProjectIssueTypeUsage {
    /** The ID of the issue type. */
    id?: string;
}

/** Issue types associated with the workflow for a project. */
export class WorkflowProjectIssueTypeUsageDTO implements IWorkflowProjectIssueTypeUsageDTO {
    issueTypes?: WorkflowProjectIssueTypeUsagePage;
    /** The ID of the project. */
    projectId?: string;
    /** The ID of the workflow. */
    workflowId?: string;

    constructor(data?: IWorkflowProjectIssueTypeUsageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issueTypes = _data["issueTypes"] ? WorkflowProjectIssueTypeUsagePage.fromJS(_data["issueTypes"]) : <any>undefined;
            this.projectId = _data["projectId"];
            this.workflowId = _data["workflowId"];
        }
    }

    static fromJS(data: any): WorkflowProjectIssueTypeUsageDTO {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowProjectIssueTypeUsageDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issueTypes"] = this.issueTypes ? this.issueTypes.toJSON() : <any>undefined;
        data["projectId"] = this.projectId;
        data["workflowId"] = this.workflowId;
        return data;
    }
}

/** Issue types associated with the workflow for a project. */
export interface IWorkflowProjectIssueTypeUsageDTO {
    issueTypes?: WorkflowProjectIssueTypeUsagePage;
    /** The ID of the project. */
    projectId?: string;
    /** The ID of the workflow. */
    workflowId?: string;
}

/** A page of issue types. */
export class WorkflowProjectIssueTypeUsagePage implements IWorkflowProjectIssueTypeUsagePage {
    /** Token for the next page of issue type usages. */
    nextPageToken?: string;
    /** The list of issue types. */
    values?: WorkflowProjectIssueTypeUsage[];

    constructor(data?: IWorkflowProjectIssueTypeUsagePage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nextPageToken = _data["nextPageToken"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(WorkflowProjectIssueTypeUsage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowProjectIssueTypeUsagePage {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowProjectIssueTypeUsagePage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nextPageToken"] = this.nextPageToken;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of issue types. */
export interface IWorkflowProjectIssueTypeUsagePage {
    /** Token for the next page of issue type usages. */
    nextPageToken?: string;
    /** The list of issue types. */
    values?: WorkflowProjectIssueTypeUsage[];
}

/** Projects using the workflow. */
export class WorkflowProjectUsageDTO implements IWorkflowProjectUsageDTO {
    projects?: ProjectUsagePage;
    /** The workflow ID. */
    workflowId?: string;

    constructor(data?: IWorkflowProjectUsageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projects = _data["projects"] ? ProjectUsagePage.fromJS(_data["projects"]) : <any>undefined;
            this.workflowId = _data["workflowId"];
        }
    }

    static fromJS(data: any): WorkflowProjectUsageDTO {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowProjectUsageDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projects"] = this.projects ? this.projects.toJSON() : <any>undefined;
        data["workflowId"] = this.workflowId;
        return data;
    }
}

/** Projects using the workflow. */
export interface IWorkflowProjectUsageDTO {
    projects?: ProjectUsagePage;
    /** The workflow ID. */
    workflowId?: string;
}

export class WorkflowReadRequest implements IWorkflowReadRequest {
    /** The list of projects and issue types to query. */
    projectAndIssueTypes?: ProjectAndIssueTypePair[];
    /** The list of workflow IDs to query. */
    workflowIds?: string[];
    /** The list of workflow names to query. */
    workflowNames?: string[];

    constructor(data?: IWorkflowReadRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["projectAndIssueTypes"])) {
                this.projectAndIssueTypes = [] as any;
                for (let item of _data["projectAndIssueTypes"])
                    this.projectAndIssueTypes!.push(ProjectAndIssueTypePair.fromJS(item));
            }
            if (Array.isArray(_data["workflowIds"])) {
                this.workflowIds = [] as any;
                for (let item of _data["workflowIds"])
                    this.workflowIds!.push(item);
            }
            if (Array.isArray(_data["workflowNames"])) {
                this.workflowNames = [] as any;
                for (let item of _data["workflowNames"])
                    this.workflowNames!.push(item);
            }
        }
    }

    static fromJS(data: any): WorkflowReadRequest {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowReadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.projectAndIssueTypes)) {
            data["projectAndIssueTypes"] = [];
            for (let item of this.projectAndIssueTypes)
                data["projectAndIssueTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.workflowIds)) {
            data["workflowIds"] = [];
            for (let item of this.workflowIds)
                data["workflowIds"].push(item);
        }
        if (Array.isArray(this.workflowNames)) {
            data["workflowNames"] = [];
            for (let item of this.workflowNames)
                data["workflowNames"].push(item);
        }
        return data;
    }
}

export interface IWorkflowReadRequest {
    /** The list of projects and issue types to query. */
    projectAndIssueTypes?: ProjectAndIssueTypePair[];
    /** The list of workflow IDs to query. */
    workflowIds?: string[];
    /** The list of workflow names to query. */
    workflowNames?: string[];
}

/** Details of workflows and related statuses. */
export class WorkflowReadResponse implements IWorkflowReadResponse {
    /** List of statuses. */
    statuses?: JiraWorkflowStatus[];
    /** List of workflows. */
    workflows?: JiraWorkflow[];

    constructor(data?: IWorkflowReadResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(JiraWorkflowStatus.fromJS(item));
            }
            if (Array.isArray(_data["workflows"])) {
                this.workflows = [] as any;
                for (let item of _data["workflows"])
                    this.workflows!.push(JiraWorkflow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowReadResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowReadResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        if (Array.isArray(this.workflows)) {
            data["workflows"] = [];
            for (let item of this.workflows)
                data["workflows"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of workflows and related statuses. */
export interface IWorkflowReadResponse {
    /** List of statuses. */
    statuses?: JiraWorkflowStatus[];
    /** List of workflows. */
    workflows?: JiraWorkflow[];
}

/** The statuses referenced in the workflow. */
export class WorkflowReferenceStatus implements IWorkflowReferenceStatus {
    approvalConfiguration?: ApprovalConfiguration | undefined;
    /** Indicates if the status is deprecated. */
    deprecated?: boolean;
    layout?: WorkflowStatusLayout | undefined;
    /** The properties associated with the status. */
    properties?: { [key: string]: string; };
    /** The reference of the status. */
    statusReference?: string;

    constructor(data?: IWorkflowReferenceStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.approvalConfiguration = _data["approvalConfiguration"] ? ApprovalConfiguration.fromJS(_data["approvalConfiguration"]) : <any>undefined;
            this.deprecated = _data["deprecated"];
            this.layout = _data["layout"] ? WorkflowStatusLayout.fromJS(_data["layout"]) : <any>undefined;
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.statusReference = _data["statusReference"];
        }
    }

    static fromJS(data: any): WorkflowReferenceStatus {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowReferenceStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["approvalConfiguration"] = this.approvalConfiguration ? this.approvalConfiguration.toJSON() : <any>undefined;
        data["deprecated"] = this.deprecated;
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["statusReference"] = this.statusReference;
        return data;
    }
}

/** The statuses referenced in the workflow. */
export interface IWorkflowReferenceStatus {
    approvalConfiguration?: ApprovalConfiguration | undefined;
    /** Indicates if the status is deprecated. */
    deprecated?: boolean;
    layout?: WorkflowStatusLayout | undefined;
    /** The properties associated with the status. */
    properties?: { [key: string]: string; };
    /** The reference of the status. */
    statusReference?: string;
}

/** The configuration of the rule. */
export class WorkflowRuleConfiguration implements IWorkflowRuleConfiguration {
    /** The ID of the rule. */
    id?: string | undefined;
    /** The parameters related to the rule. */
    parameters?: { [key: string]: string; };
    /** The rule key of the rule. */
    ruleKey!: string;

    constructor(data?: IWorkflowRuleConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (_data["parameters"]) {
                this.parameters = {} as any;
                for (let key in _data["parameters"]) {
                    if (_data["parameters"].hasOwnProperty(key))
                        (<any>this.parameters)![key] = _data["parameters"][key];
                }
            }
            this.ruleKey = _data["ruleKey"];
        }
    }

    static fromJS(data: any): WorkflowRuleConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowRuleConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.parameters) {
            data["parameters"] = {};
            for (let key in this.parameters) {
                if (this.parameters.hasOwnProperty(key))
                    (<any>data["parameters"])[key] = (<any>this.parameters)[key];
            }
        }
        data["ruleKey"] = this.ruleKey;
        return data;
    }
}

/** The configuration of the rule. */
export interface IWorkflowRuleConfiguration {
    /** The ID of the rule. */
    id?: string | undefined;
    /** The parameters related to the rule. */
    parameters?: { [key: string]: string; };
    /** The rule key of the rule. */
    ruleKey: string;
}

/** A collection of transition rules. */
export class WorkflowRules implements IWorkflowRules {
    conditionsTree?: Conditions;
    /** The workflow post functions. */
    postFunctions?: WorkflowTransitionRule[];
    /** The workflow validators. */
    validators?: WorkflowTransitionRule[];

    constructor(data?: IWorkflowRules) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conditionsTree = _data["conditionsTree"] ? Conditions.fromJS(_data["conditionsTree"]) : <any>undefined;
            if (Array.isArray(_data["postFunctions"])) {
                this.postFunctions = [] as any;
                for (let item of _data["postFunctions"])
                    this.postFunctions!.push(WorkflowTransitionRule.fromJS(item));
            }
            if (Array.isArray(_data["validators"])) {
                this.validators = [] as any;
                for (let item of _data["validators"])
                    this.validators!.push(WorkflowTransitionRule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowRules {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowRules();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["conditionsTree"] = this.conditionsTree ? this.conditionsTree.toJSON() : <any>undefined;
        if (Array.isArray(this.postFunctions)) {
            data["postFunctions"] = [];
            for (let item of this.postFunctions)
                data["postFunctions"].push(item.toJSON());
        }
        if (Array.isArray(this.validators)) {
            data["validators"] = [];
            for (let item of this.validators)
                data["validators"].push(item.toJSON());
        }
        return data;
    }
}

/** A collection of transition rules. */
export interface IWorkflowRules {
    conditionsTree?: Conditions;
    /** The workflow post functions. */
    postFunctions?: WorkflowTransitionRule[];
    /** The workflow validators. */
    validators?: WorkflowTransitionRule[];
}

/** Details of the workflow and its transition rules. */
export class WorkflowRulesSearch implements IWorkflowRulesSearch {
    /** Use expand to include additional information in the response. This parameter accepts `transition` which, for each rule, returns information about the transition the rule is assigned to. */
    expand?: string;
    /** The list of workflow rule IDs. */
    ruleIds!: string[];
    /** The workflow ID. */
    workflowEntityId!: string;

    [key: string]: any;

    constructor(data?: IWorkflowRulesSearch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ruleIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.expand = _data["expand"];
            if (Array.isArray(_data["ruleIds"])) {
                this.ruleIds = [] as any;
                for (let item of _data["ruleIds"])
                    this.ruleIds!.push(item);
            }
            this.workflowEntityId = _data["workflowEntityId"];
        }
    }

    static fromJS(data: any): WorkflowRulesSearch {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowRulesSearch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["expand"] = this.expand;
        if (Array.isArray(this.ruleIds)) {
            data["ruleIds"] = [];
            for (let item of this.ruleIds)
                data["ruleIds"].push(item);
        }
        data["workflowEntityId"] = this.workflowEntityId;
        return data;
    }
}

/** Details of the workflow and its transition rules. */
export interface IWorkflowRulesSearch {
    /** Use expand to include additional information in the response. This parameter accepts `transition` which, for each rule, returns information about the transition the rule is assigned to. */
    expand?: string;
    /** The list of workflow rule IDs. */
    ruleIds: string[];
    /** The workflow ID. */
    workflowEntityId: string;

    [key: string]: any;
}

/** Details of workflow transition rules. */
export class WorkflowRulesSearchDetails implements IWorkflowRulesSearchDetails {
    /** List of workflow rule IDs that do not belong to the workflow or can not be found. */
    invalidRules?: string[];
    /** List of valid workflow transition rules. */
    validRules?: WorkflowTransitionRules[];
    /** The workflow ID. */
    workflowEntityId?: string;

    [key: string]: any;

    constructor(data?: IWorkflowRulesSearchDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["invalidRules"])) {
                this.invalidRules = [] as any;
                for (let item of _data["invalidRules"])
                    this.invalidRules!.push(item);
            }
            if (Array.isArray(_data["validRules"])) {
                this.validRules = [] as any;
                for (let item of _data["validRules"])
                    this.validRules!.push(WorkflowTransitionRules.fromJS(item));
            }
            this.workflowEntityId = _data["workflowEntityId"];
        }
    }

    static fromJS(data: any): WorkflowRulesSearchDetails {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowRulesSearchDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.invalidRules)) {
            data["invalidRules"] = [];
            for (let item of this.invalidRules)
                data["invalidRules"].push(item);
        }
        if (Array.isArray(this.validRules)) {
            data["validRules"] = [];
            for (let item of this.validRules)
                data["validRules"].push(item.toJSON());
        }
        data["workflowEntityId"] = this.workflowEntityId;
        return data;
    }
}

/** Details of workflow transition rules. */
export interface IWorkflowRulesSearchDetails {
    /** List of workflow rule IDs that do not belong to the workflow or can not be found. */
    invalidRules?: string[];
    /** List of valid workflow transition rules. */
    validRules?: WorkflowTransitionRules[];
    /** The workflow ID. */
    workflowEntityId?: string;

    [key: string]: any;
}

/** Details about a workflow scheme. */
export class WorkflowScheme implements IWorkflowScheme {
    /** The name of the default workflow for the workflow scheme. The default workflow has *All Unassigned Issue Types* assigned to it in Jira. If `defaultWorkflow` is not specified when creating a workflow scheme, it is set to *Jira Workflow (jira)*. */
    defaultWorkflow?: string;
    /** The description of the workflow scheme. */
    description?: string;
    /** Whether the workflow scheme is a draft or not. */
    readonly draft?: boolean;
    /** The ID of the workflow scheme. */
    readonly id?: number;
    /** The issue type to workflow mappings, where each mapping is an issue type ID and workflow name pair. Note that an issue type can only be mapped to one workflow in a workflow scheme. */
    issueTypeMappings?: { [key: string]: string; };
    /** The issue types available in Jira. */
    readonly issueTypes?: { [key: string]: IssueTypeDetails; };
    /** The date-time that the draft workflow scheme was last modified. A modification is a change to the issue type-project mappings only. This property does not apply to non-draft workflows. */
    readonly lastModified?: string;
    /** The user that last modified the draft workflow scheme. A modification is a change to the issue type-project mappings only. This property does not apply to non-draft workflows. */
    readonly lastModifiedUser?: User;
    /** The name of the workflow scheme. The name must be unique. The maximum length is 255 characters. Required when creating a workflow scheme. */
    name?: string;
    /** For draft workflow schemes, this property is the name of the default workflow for the original workflow scheme. The default workflow has *All Unassigned Issue Types* assigned to it in Jira. */
    readonly originalDefaultWorkflow?: string;
    /** For draft workflow schemes, this property is the issue type to workflow mappings for the original workflow scheme, where each mapping is an issue type ID and workflow name pair. Note that an issue type can only be mapped to one workflow in a workflow scheme. */
    readonly originalIssueTypeMappings?: { [key: string]: string; };
    readonly self?: string;
    /** Whether to create or update a draft workflow scheme when updating an active workflow scheme. An active workflow scheme is a workflow scheme that is used by at least one project. The following examples show how this property works:

 *  Update an active workflow scheme with `updateDraftIfNeeded` set to `true`: If a draft workflow scheme exists, it is updated. Otherwise, a draft workflow scheme is created.
 *  Update an active workflow scheme with `updateDraftIfNeeded` set to `false`: An error is returned, as active workflow schemes cannot be updated.
 *  Update an inactive workflow scheme with `updateDraftIfNeeded` set to `true`: The workflow scheme is updated, as inactive workflow schemes do not require drafts to update.

Defaults to `false`. */
    updateDraftIfNeeded?: boolean;

    constructor(data?: IWorkflowScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultWorkflow = _data["defaultWorkflow"];
            this.description = _data["description"];
            (<any>this).draft = _data["draft"];
            (<any>this).id = _data["id"];
            if (_data["issueTypeMappings"]) {
                this.issueTypeMappings = {} as any;
                for (let key in _data["issueTypeMappings"]) {
                    if (_data["issueTypeMappings"].hasOwnProperty(key))
                        (<any>this.issueTypeMappings)![key] = _data["issueTypeMappings"][key];
                }
            }
            if (_data["issueTypes"]) {
                (<any>this).issueTypes = {} as any;
                for (let key in _data["issueTypes"]) {
                    if (_data["issueTypes"].hasOwnProperty(key))
                        (<any>(<any>this).issueTypes)![key] = _data["issueTypes"][key] ? IssueTypeDetails.fromJS(_data["issueTypes"][key]) : new IssueTypeDetails();
                }
            }
            (<any>this).lastModified = _data["lastModified"];
            (<any>this).lastModifiedUser = _data["lastModifiedUser"] ? User.fromJS(_data["lastModifiedUser"]) : <any>undefined;
            this.name = _data["name"];
            (<any>this).originalDefaultWorkflow = _data["originalDefaultWorkflow"];
            if (_data["originalIssueTypeMappings"]) {
                (<any>this).originalIssueTypeMappings = {} as any;
                for (let key in _data["originalIssueTypeMappings"]) {
                    if (_data["originalIssueTypeMappings"].hasOwnProperty(key))
                        (<any>(<any>this).originalIssueTypeMappings)![key] = _data["originalIssueTypeMappings"][key];
                }
            }
            (<any>this).self = _data["self"];
            this.updateDraftIfNeeded = _data["updateDraftIfNeeded"];
        }
    }

    static fromJS(data: any): WorkflowScheme {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultWorkflow"] = this.defaultWorkflow;
        data["description"] = this.description;
        data["draft"] = this.draft;
        data["id"] = this.id;
        if (this.issueTypeMappings) {
            data["issueTypeMappings"] = {};
            for (let key in this.issueTypeMappings) {
                if (this.issueTypeMappings.hasOwnProperty(key))
                    (<any>data["issueTypeMappings"])[key] = (<any>this.issueTypeMappings)[key];
            }
        }
        if (this.issueTypes) {
            data["issueTypes"] = {};
            for (let key in this.issueTypes) {
                if (this.issueTypes.hasOwnProperty(key))
                    (<any>data["issueTypes"])[key] = this.issueTypes[key] ? this.issueTypes[key].toJSON() : <any>undefined;
            }
        }
        data["lastModified"] = this.lastModified;
        data["lastModifiedUser"] = this.lastModifiedUser ? this.lastModifiedUser.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["originalDefaultWorkflow"] = this.originalDefaultWorkflow;
        if (this.originalIssueTypeMappings) {
            data["originalIssueTypeMappings"] = {};
            for (let key in this.originalIssueTypeMappings) {
                if (this.originalIssueTypeMappings.hasOwnProperty(key))
                    (<any>data["originalIssueTypeMappings"])[key] = (<any>this.originalIssueTypeMappings)[key];
            }
        }
        data["self"] = this.self;
        data["updateDraftIfNeeded"] = this.updateDraftIfNeeded;
        return data;
    }
}

/** Details about a workflow scheme. */
export interface IWorkflowScheme {
    /** The name of the default workflow for the workflow scheme. The default workflow has *All Unassigned Issue Types* assigned to it in Jira. If `defaultWorkflow` is not specified when creating a workflow scheme, it is set to *Jira Workflow (jira)*. */
    defaultWorkflow?: string;
    /** The description of the workflow scheme. */
    description?: string;
    /** Whether the workflow scheme is a draft or not. */
    draft?: boolean;
    /** The ID of the workflow scheme. */
    id?: number;
    /** The issue type to workflow mappings, where each mapping is an issue type ID and workflow name pair. Note that an issue type can only be mapped to one workflow in a workflow scheme. */
    issueTypeMappings?: { [key: string]: string; };
    /** The issue types available in Jira. */
    issueTypes?: { [key: string]: IssueTypeDetails; };
    /** The date-time that the draft workflow scheme was last modified. A modification is a change to the issue type-project mappings only. This property does not apply to non-draft workflows. */
    lastModified?: string;
    /** The user that last modified the draft workflow scheme. A modification is a change to the issue type-project mappings only. This property does not apply to non-draft workflows. */
    lastModifiedUser?: User;
    /** The name of the workflow scheme. The name must be unique. The maximum length is 255 characters. Required when creating a workflow scheme. */
    name?: string;
    /** For draft workflow schemes, this property is the name of the default workflow for the original workflow scheme. The default workflow has *All Unassigned Issue Types* assigned to it in Jira. */
    originalDefaultWorkflow?: string;
    /** For draft workflow schemes, this property is the issue type to workflow mappings for the original workflow scheme, where each mapping is an issue type ID and workflow name pair. Note that an issue type can only be mapped to one workflow in a workflow scheme. */
    originalIssueTypeMappings?: { [key: string]: string; };
    self?: string;
    /** Whether to create or update a draft workflow scheme when updating an active workflow scheme. An active workflow scheme is a workflow scheme that is used by at least one project. The following examples show how this property works:

 *  Update an active workflow scheme with `updateDraftIfNeeded` set to `true`: If a draft workflow scheme exists, it is updated. Otherwise, a draft workflow scheme is created.
 *  Update an active workflow scheme with `updateDraftIfNeeded` set to `false`: An error is returned, as active workflow schemes cannot be updated.
 *  Update an inactive workflow scheme with `updateDraftIfNeeded` set to `true`: The workflow scheme is updated, as inactive workflow schemes do not require drafts to update.

Defaults to `false`. */
    updateDraftIfNeeded?: boolean;
}

/** The explicit association between issue types and a workflow in a workflow scheme. */
export class WorkflowSchemeAssociation implements IWorkflowSchemeAssociation {
    /** The issue types assigned to the workflow. */
    issueTypeIds!: string[];
    /** The ID of the workflow. */
    workflowId!: string;

    constructor(data?: IWorkflowSchemeAssociation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.issueTypeIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["issueTypeIds"])) {
                this.issueTypeIds = [] as any;
                for (let item of _data["issueTypeIds"])
                    this.issueTypeIds!.push(item);
            }
            this.workflowId = _data["workflowId"];
        }
    }

    static fromJS(data: any): WorkflowSchemeAssociation {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSchemeAssociation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.issueTypeIds)) {
            data["issueTypeIds"] = [];
            for (let item of this.issueTypeIds)
                data["issueTypeIds"].push(item);
        }
        data["workflowId"] = this.workflowId;
        return data;
    }
}

/** The explicit association between issue types and a workflow in a workflow scheme. */
export interface IWorkflowSchemeAssociation {
    /** The issue types assigned to the workflow. */
    issueTypeIds: string[];
    /** The ID of the workflow. */
    workflowId: string;
}

/** A workflow scheme along with a list of projects that use it. */
export class WorkflowSchemeAssociations implements IWorkflowSchemeAssociations {
    /** The list of projects that use the workflow scheme. */
    projectIds!: string[];
    /** The workflow scheme. */
    workflowScheme!: WorkflowScheme;

    constructor(data?: IWorkflowSchemeAssociations) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.projectIds = [];
            this.workflowScheme = new WorkflowScheme();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["projectIds"])) {
                this.projectIds = [] as any;
                for (let item of _data["projectIds"])
                    this.projectIds!.push(item);
            }
            this.workflowScheme = _data["workflowScheme"] ? WorkflowScheme.fromJS(_data["workflowScheme"]) : new WorkflowScheme();
        }
    }

    static fromJS(data: any): WorkflowSchemeAssociations {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSchemeAssociations();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.projectIds)) {
            data["projectIds"] = [];
            for (let item of this.projectIds)
                data["projectIds"].push(item);
        }
        data["workflowScheme"] = this.workflowScheme ? this.workflowScheme.toJSON() : <any>undefined;
        return data;
    }
}

/** A workflow scheme along with a list of projects that use it. */
export interface IWorkflowSchemeAssociations {
    /** The list of projects that use the workflow scheme. */
    projectIds: string[];
    /** The workflow scheme. */
    workflowScheme: WorkflowScheme;
}

/** The ID and the name of the workflow scheme. */
export class WorkflowSchemeIdName implements IWorkflowSchemeIdName {
    /** The ID of the workflow scheme. */
    id!: string;
    /** The name of the workflow scheme. */
    name!: string;

    constructor(data?: IWorkflowSchemeIdName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WorkflowSchemeIdName {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSchemeIdName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** The ID and the name of the workflow scheme. */
export interface IWorkflowSchemeIdName {
    /** The ID of the workflow scheme. */
    id: string;
    /** The name of the workflow scheme. */
    name: string;
}

/** The payload for creating a workflow scheme. See https://www.atlassian.com/software/jira/guides/workflows/overview\#what-is-a-jira-workflow-scheme */
export class WorkflowSchemePayload implements IWorkflowSchemePayload {
    defaultWorkflow?: ProjectCreateResourceIdentifier;
    /** The description of the workflow scheme */
    description?: string;
    /** Association between issuetypes and workflows */
    explicitMappings?: { [key: string]: ProjectCreateResourceIdentifier; };
    /** The name of the workflow scheme */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;

    constructor(data?: IWorkflowSchemePayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultWorkflow = _data["defaultWorkflow"] ? ProjectCreateResourceIdentifier.fromJS(_data["defaultWorkflow"]) : <any>undefined;
            this.description = _data["description"];
            if (_data["explicitMappings"]) {
                this.explicitMappings = {} as any;
                for (let key in _data["explicitMappings"]) {
                    if (_data["explicitMappings"].hasOwnProperty(key))
                        (<any>this.explicitMappings)![key] = _data["explicitMappings"][key] ? ProjectCreateResourceIdentifier.fromJS(_data["explicitMappings"][key]) : new ProjectCreateResourceIdentifier();
                }
            }
            this.name = _data["name"];
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkflowSchemePayload {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSchemePayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultWorkflow"] = this.defaultWorkflow ? this.defaultWorkflow.toJSON() : <any>undefined;
        data["description"] = this.description;
        if (this.explicitMappings) {
            data["explicitMappings"] = {};
            for (let key in this.explicitMappings) {
                if (this.explicitMappings.hasOwnProperty(key))
                    (<any>data["explicitMappings"])[key] = this.explicitMappings[key] ? this.explicitMappings[key].toJSON() : <any>undefined;
            }
        }
        data["name"] = this.name;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        return data;
    }
}

/** The payload for creating a workflow scheme. See https://www.atlassian.com/software/jira/guides/workflows/overview\#what-is-a-jira-workflow-scheme */
export interface IWorkflowSchemePayload {
    defaultWorkflow?: ProjectCreateResourceIdentifier;
    /** The description of the workflow scheme */
    description?: string;
    /** Association between issuetypes and workflows */
    explicitMappings?: { [key: string]: ProjectCreateResourceIdentifier; };
    /** The name of the workflow scheme */
    name?: string;
    pcri?: ProjectCreateResourceIdentifier;
}

/** An associated workflow scheme and project. */
export class WorkflowSchemeProjectAssociation implements IWorkflowSchemeProjectAssociation {
    /** The ID of the project. */
    projectId!: string;
    /** The ID of the workflow scheme. If the workflow scheme ID is `null`, the operation assigns the default workflow scheme. */
    workflowSchemeId?: string;

    constructor(data?: IWorkflowSchemeProjectAssociation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.workflowSchemeId = _data["workflowSchemeId"];
        }
    }

    static fromJS(data: any): WorkflowSchemeProjectAssociation {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSchemeProjectAssociation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["workflowSchemeId"] = this.workflowSchemeId;
        return data;
    }
}

/** An associated workflow scheme and project. */
export interface IWorkflowSchemeProjectAssociation {
    /** The ID of the project. */
    projectId: string;
    /** The ID of the workflow scheme. If the workflow scheme ID is `null`, the operation assigns the default workflow scheme. */
    workflowSchemeId?: string;
}

/** Projects using the workflow scheme. */
export class WorkflowSchemeProjectUsageDTO implements IWorkflowSchemeProjectUsageDTO {
    projects?: ProjectUsagePage;
    /** The workflow scheme ID. */
    workflowSchemeId?: string;

    constructor(data?: IWorkflowSchemeProjectUsageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projects = _data["projects"] ? ProjectUsagePage.fromJS(_data["projects"]) : <any>undefined;
            this.workflowSchemeId = _data["workflowSchemeId"];
        }
    }

    static fromJS(data: any): WorkflowSchemeProjectUsageDTO {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSchemeProjectUsageDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projects"] = this.projects ? this.projects.toJSON() : <any>undefined;
        data["workflowSchemeId"] = this.workflowSchemeId;
        return data;
    }
}

/** Projects using the workflow scheme. */
export interface IWorkflowSchemeProjectUsageDTO {
    projects?: ProjectUsagePage;
    /** The workflow scheme ID. */
    workflowSchemeId?: string;
}

/** The workflow scheme read request body. */
export class WorkflowSchemeReadRequest implements IWorkflowSchemeReadRequest {
    /** The list of project IDs to query. */
    projectIds?: (string | undefined)[] | undefined;
    /** The list of workflow scheme IDs to query. */
    workflowSchemeIds?: (string | undefined)[] | undefined;

    constructor(data?: IWorkflowSchemeReadRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["projectIds"])) {
                this.projectIds = [] as any;
                for (let item of _data["projectIds"])
                    this.projectIds!.push(item);
            }
            if (Array.isArray(_data["workflowSchemeIds"])) {
                this.workflowSchemeIds = [] as any;
                for (let item of _data["workflowSchemeIds"])
                    this.workflowSchemeIds!.push(item);
            }
        }
    }

    static fromJS(data: any): WorkflowSchemeReadRequest {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSchemeReadRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.projectIds)) {
            data["projectIds"] = [];
            for (let item of this.projectIds)
                data["projectIds"].push(item);
        }
        if (Array.isArray(this.workflowSchemeIds)) {
            data["workflowSchemeIds"] = [];
            for (let item of this.workflowSchemeIds)
                data["workflowSchemeIds"].push(item);
        }
        return data;
    }
}

/** The workflow scheme read request body. */
export interface IWorkflowSchemeReadRequest {
    /** The list of project IDs to query. */
    projectIds?: (string | undefined)[] | undefined;
    /** The list of workflow scheme IDs to query. */
    workflowSchemeIds?: (string | undefined)[] | undefined;
}

export class WorkflowSchemeReadResponse implements IWorkflowSchemeReadResponse {
    defaultWorkflow?: WorkflowMetadataRestModel;
    /** The description of the workflow scheme. */
    description?: string | undefined;
    /** The ID of the workflow scheme. */
    id!: string;
    /** The name of the workflow scheme. */
    name!: string;
    /** Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details.

The IDs of projects using the workflow scheme. */
    projectIdsUsingScheme?: (string | undefined)[] | undefined;
    scope!: WorkflowScope;
    /** Indicates if there's an [asynchronous task](#async-operations) for this workflow scheme. */
    taskId?: string | undefined;
    version!: DocumentVersion;
    /** Mappings from workflows to issue types. */
    workflowsForIssueTypes!: WorkflowMetadataAndIssueTypeRestModel[];

    constructor(data?: IWorkflowSchemeReadResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.scope = new WorkflowScope();
            this.version = new DocumentVersion();
            this.workflowsForIssueTypes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultWorkflow = _data["defaultWorkflow"] ? WorkflowMetadataRestModel.fromJS(_data["defaultWorkflow"]) : <any>undefined;
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["projectIdsUsingScheme"])) {
                this.projectIdsUsingScheme = [] as any;
                for (let item of _data["projectIdsUsingScheme"])
                    this.projectIdsUsingScheme!.push(item);
            }
            this.scope = _data["scope"] ? WorkflowScope.fromJS(_data["scope"]) : new WorkflowScope();
            this.taskId = _data["taskId"];
            this.version = _data["version"] ? DocumentVersion.fromJS(_data["version"]) : new DocumentVersion();
            if (Array.isArray(_data["workflowsForIssueTypes"])) {
                this.workflowsForIssueTypes = [] as any;
                for (let item of _data["workflowsForIssueTypes"])
                    this.workflowsForIssueTypes!.push(WorkflowMetadataAndIssueTypeRestModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowSchemeReadResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSchemeReadResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultWorkflow"] = this.defaultWorkflow ? this.defaultWorkflow.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.projectIdsUsingScheme)) {
            data["projectIdsUsingScheme"] = [];
            for (let item of this.projectIdsUsingScheme)
                data["projectIdsUsingScheme"].push(item);
        }
        data["scope"] = this.scope ? this.scope.toJSON() : <any>undefined;
        data["taskId"] = this.taskId;
        data["version"] = this.version ? this.version.toJSON() : <any>undefined;
        if (Array.isArray(this.workflowsForIssueTypes)) {
            data["workflowsForIssueTypes"] = [];
            for (let item of this.workflowsForIssueTypes)
                data["workflowsForIssueTypes"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowSchemeReadResponse {
    defaultWorkflow?: WorkflowMetadataRestModel;
    /** The description of the workflow scheme. */
    description?: string | undefined;
    /** The ID of the workflow scheme. */
    id: string;
    /** The name of the workflow scheme. */
    name: string;
    /** Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details.

The IDs of projects using the workflow scheme. */
    projectIdsUsingScheme?: (string | undefined)[] | undefined;
    scope: WorkflowScope;
    /** Indicates if there's an [asynchronous task](#async-operations) for this workflow scheme. */
    taskId?: string | undefined;
    version: DocumentVersion;
    /** Mappings from workflows to issue types. */
    workflowsForIssueTypes: WorkflowMetadataAndIssueTypeRestModel[];
}

/** The update workflow scheme payload. */
export class WorkflowSchemeUpdateRequest implements IWorkflowSchemeUpdateRequest {
    /** The ID of the workflow for issue types without having a mapping defined in this workflow scheme. Only used in global-scoped workflow schemes. If the `defaultWorkflowId` isn't specified, this is set to *Jira Workflow (jira)*. */
    defaultWorkflowId?: string;
    /** The new description for this workflow scheme. */
    description!: string;
    /** The ID of this workflow scheme. */
    id!: string;
    /** The new name for this workflow scheme. */
    name!: string;
    /** Overrides, for the selected issue types, any status mappings provided in `statusMappingsByWorkflows`. Status mappings are required when the new workflow for an issue type doesn't contain all statuses that the old workflow has. Status mappings can be provided by a combination of `statusMappingsByWorkflows` and `statusMappingsByIssueTypeOverride`. */
    statusMappingsByIssueTypeOverride?: MappingsByIssueTypeOverride[];
    /** The status mappings by workflows. Status mappings are required when the new workflow for an issue type doesn't contain all statuses that the old workflow has. Status mappings can be provided by a combination of `statusMappingsByWorkflows` and `statusMappingsByIssueTypeOverride`. */
    statusMappingsByWorkflows?: MappingsByWorkflow[];
    version!: DocumentVersion;
    /** Mappings from workflows to issue types. */
    workflowsForIssueTypes?: WorkflowSchemeAssociation[];

    [key: string]: any;

    constructor(data?: IWorkflowSchemeUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.version = new DocumentVersion();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.defaultWorkflowId = _data["defaultWorkflowId"];
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["statusMappingsByIssueTypeOverride"])) {
                this.statusMappingsByIssueTypeOverride = [] as any;
                for (let item of _data["statusMappingsByIssueTypeOverride"])
                    this.statusMappingsByIssueTypeOverride!.push(MappingsByIssueTypeOverride.fromJS(item));
            }
            if (Array.isArray(_data["statusMappingsByWorkflows"])) {
                this.statusMappingsByWorkflows = [] as any;
                for (let item of _data["statusMappingsByWorkflows"])
                    this.statusMappingsByWorkflows!.push(MappingsByWorkflow.fromJS(item));
            }
            this.version = _data["version"] ? DocumentVersion.fromJS(_data["version"]) : new DocumentVersion();
            if (Array.isArray(_data["workflowsForIssueTypes"])) {
                this.workflowsForIssueTypes = [] as any;
                for (let item of _data["workflowsForIssueTypes"])
                    this.workflowsForIssueTypes!.push(WorkflowSchemeAssociation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowSchemeUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSchemeUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["defaultWorkflowId"] = this.defaultWorkflowId;
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.statusMappingsByIssueTypeOverride)) {
            data["statusMappingsByIssueTypeOverride"] = [];
            for (let item of this.statusMappingsByIssueTypeOverride)
                data["statusMappingsByIssueTypeOverride"].push(item.toJSON());
        }
        if (Array.isArray(this.statusMappingsByWorkflows)) {
            data["statusMappingsByWorkflows"] = [];
            for (let item of this.statusMappingsByWorkflows)
                data["statusMappingsByWorkflows"].push(item.toJSON());
        }
        data["version"] = this.version ? this.version.toJSON() : <any>undefined;
        if (Array.isArray(this.workflowsForIssueTypes)) {
            data["workflowsForIssueTypes"] = [];
            for (let item of this.workflowsForIssueTypes)
                data["workflowsForIssueTypes"].push(item.toJSON());
        }
        return data;
    }
}

/** The update workflow scheme payload. */
export interface IWorkflowSchemeUpdateRequest {
    /** The ID of the workflow for issue types without having a mapping defined in this workflow scheme. Only used in global-scoped workflow schemes. If the `defaultWorkflowId` isn't specified, this is set to *Jira Workflow (jira)*. */
    defaultWorkflowId?: string;
    /** The new description for this workflow scheme. */
    description: string;
    /** The ID of this workflow scheme. */
    id: string;
    /** The new name for this workflow scheme. */
    name: string;
    /** Overrides, for the selected issue types, any status mappings provided in `statusMappingsByWorkflows`. Status mappings are required when the new workflow for an issue type doesn't contain all statuses that the old workflow has. Status mappings can be provided by a combination of `statusMappingsByWorkflows` and `statusMappingsByIssueTypeOverride`. */
    statusMappingsByIssueTypeOverride?: MappingsByIssueTypeOverride[];
    /** The status mappings by workflows. Status mappings are required when the new workflow for an issue type doesn't contain all statuses that the old workflow has. Status mappings can be provided by a combination of `statusMappingsByWorkflows` and `statusMappingsByIssueTypeOverride`. */
    statusMappingsByWorkflows?: MappingsByWorkflow[];
    version: DocumentVersion;
    /** Mappings from workflows to issue types. */
    workflowsForIssueTypes?: WorkflowSchemeAssociation[];

    [key: string]: any;
}

/** The request payload to get the required mappings for updating a workflow scheme. */
export class WorkflowSchemeUpdateRequiredMappingsRequest implements IWorkflowSchemeUpdateRequiredMappingsRequest {
    /** The ID of the new default workflow for this workflow scheme. Only used in global-scoped workflow schemes. If it isn't specified, is set to *Jira Workflow (jira)*. */
    defaultWorkflowId?: string | undefined;
    /** The ID of the workflow scheme. */
    id!: string;
    /** The new workflow to issue type mappings for this workflow scheme. */
    workflowsForIssueTypes!: WorkflowSchemeAssociation[];

    constructor(data?: IWorkflowSchemeUpdateRequiredMappingsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.workflowsForIssueTypes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultWorkflowId = _data["defaultWorkflowId"];
            this.id = _data["id"];
            if (Array.isArray(_data["workflowsForIssueTypes"])) {
                this.workflowsForIssueTypes = [] as any;
                for (let item of _data["workflowsForIssueTypes"])
                    this.workflowsForIssueTypes!.push(WorkflowSchemeAssociation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowSchemeUpdateRequiredMappingsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSchemeUpdateRequiredMappingsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultWorkflowId"] = this.defaultWorkflowId;
        data["id"] = this.id;
        if (Array.isArray(this.workflowsForIssueTypes)) {
            data["workflowsForIssueTypes"] = [];
            for (let item of this.workflowsForIssueTypes)
                data["workflowsForIssueTypes"].push(item.toJSON());
        }
        return data;
    }
}

/** The request payload to get the required mappings for updating a workflow scheme. */
export interface IWorkflowSchemeUpdateRequiredMappingsRequest {
    /** The ID of the new default workflow for this workflow scheme. Only used in global-scoped workflow schemes. If it isn't specified, is set to *Jira Workflow (jira)*. */
    defaultWorkflowId?: string | undefined;
    /** The ID of the workflow scheme. */
    id: string;
    /** The new workflow to issue type mappings for this workflow scheme. */
    workflowsForIssueTypes: WorkflowSchemeAssociation[];
}

export class WorkflowSchemeUpdateRequiredMappingsResponse implements IWorkflowSchemeUpdateRequiredMappingsResponse {
    /** The list of required status mappings by issue type. */
    statusMappingsByIssueTypes?: RequiredMappingByIssueType[];
    /** The list of required status mappings by workflow. */
    statusMappingsByWorkflows?: RequiredMappingByWorkflows[];
    /** The details of the statuses in the associated workflows. */
    statuses?: StatusMetadata[];
    /** The statuses associated with each workflow. */
    statusesPerWorkflow?: StatusesPerWorkflow[];

    constructor(data?: IWorkflowSchemeUpdateRequiredMappingsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["statusMappingsByIssueTypes"])) {
                this.statusMappingsByIssueTypes = [] as any;
                for (let item of _data["statusMappingsByIssueTypes"])
                    this.statusMappingsByIssueTypes!.push(RequiredMappingByIssueType.fromJS(item));
            }
            if (Array.isArray(_data["statusMappingsByWorkflows"])) {
                this.statusMappingsByWorkflows = [] as any;
                for (let item of _data["statusMappingsByWorkflows"])
                    this.statusMappingsByWorkflows!.push(RequiredMappingByWorkflows.fromJS(item));
            }
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(StatusMetadata.fromJS(item));
            }
            if (Array.isArray(_data["statusesPerWorkflow"])) {
                this.statusesPerWorkflow = [] as any;
                for (let item of _data["statusesPerWorkflow"])
                    this.statusesPerWorkflow!.push(StatusesPerWorkflow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowSchemeUpdateRequiredMappingsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSchemeUpdateRequiredMappingsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.statusMappingsByIssueTypes)) {
            data["statusMappingsByIssueTypes"] = [];
            for (let item of this.statusMappingsByIssueTypes)
                data["statusMappingsByIssueTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.statusMappingsByWorkflows)) {
            data["statusMappingsByWorkflows"] = [];
            for (let item of this.statusMappingsByWorkflows)
                data["statusMappingsByWorkflows"].push(item.toJSON());
        }
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        if (Array.isArray(this.statusesPerWorkflow)) {
            data["statusesPerWorkflow"] = [];
            for (let item of this.statusesPerWorkflow)
                data["statusesPerWorkflow"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowSchemeUpdateRequiredMappingsResponse {
    /** The list of required status mappings by issue type. */
    statusMappingsByIssueTypes?: RequiredMappingByIssueType[];
    /** The list of required status mappings by workflow. */
    statusMappingsByWorkflows?: RequiredMappingByWorkflows[];
    /** The details of the statuses in the associated workflows. */
    statuses?: StatusMetadata[];
    /** The statuses associated with each workflow. */
    statusesPerWorkflow?: StatusesPerWorkflow[];
}

/** The worflow scheme. */
export class WorkflowSchemeUsage implements IWorkflowSchemeUsage {
    /** The workflow scheme ID. */
    id?: string;

    constructor(data?: IWorkflowSchemeUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WorkflowSchemeUsage {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSchemeUsage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

/** The worflow scheme. */
export interface IWorkflowSchemeUsage {
    /** The workflow scheme ID. */
    id?: string;
}

/** Workflow schemes using the workflow. */
export class WorkflowSchemeUsageDTO implements IWorkflowSchemeUsageDTO {
    /** The workflow ID. */
    workflowId?: string;
    workflowSchemes?: WorkflowSchemeUsagePage;

    constructor(data?: IWorkflowSchemeUsageDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.workflowSchemes = _data["workflowSchemes"] ? WorkflowSchemeUsagePage.fromJS(_data["workflowSchemes"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkflowSchemeUsageDTO {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSchemeUsageDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["workflowSchemes"] = this.workflowSchemes ? this.workflowSchemes.toJSON() : <any>undefined;
        return data;
    }
}

/** Workflow schemes using the workflow. */
export interface IWorkflowSchemeUsageDTO {
    /** The workflow ID. */
    workflowId?: string;
    workflowSchemes?: WorkflowSchemeUsagePage;
}

/** A page of workflow schemes. */
export class WorkflowSchemeUsagePage implements IWorkflowSchemeUsagePage {
    /** Token for the next page of issue type usages. */
    nextPageToken?: string;
    /** The list of workflow schemes. */
    values?: WorkflowSchemeUsage[];

    constructor(data?: IWorkflowSchemeUsagePage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nextPageToken = _data["nextPageToken"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(WorkflowSchemeUsage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowSchemeUsagePage {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSchemeUsagePage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nextPageToken"] = this.nextPageToken;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** A page of workflow schemes. */
export interface IWorkflowSchemeUsagePage {
    /** Token for the next page of issue type usages. */
    nextPageToken?: string;
    /** The list of workflow schemes. */
    values?: WorkflowSchemeUsage[];
}

/** The scope of the workflow. */
export class WorkflowScope implements IWorkflowScope {
    project?: ProjectId | undefined;
    /** The scope of the workflow. `GLOBAL` for company-managed projects and `PROJECT` for team-managed projects. */
    type?: WorkflowScopeType;

    constructor(data?: IWorkflowScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.project = _data["project"] ? ProjectId.fromJS(_data["project"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): WorkflowScope {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

/** The scope of the workflow. */
export interface IWorkflowScope {
    project?: ProjectId | undefined;
    /** The scope of the workflow. `GLOBAL` for company-managed projects and `PROJECT` for team-managed projects. */
    type?: WorkflowScopeType;
}

/** Page of items, including workflows and related statuses. */
export class WorkflowSearchResponse implements IWorkflowSearchResponse {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** List of statuses. */
    statuses?: JiraWorkflowStatus[];
    /** The number of items returned. */
    total?: number;
    /** List of workflows. */
    values?: JiraWorkflow[];

    constructor(data?: IWorkflowSearchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isLast = _data["isLast"];
            this.maxResults = _data["maxResults"];
            this.nextPage = _data["nextPage"];
            this.self = _data["self"];
            this.startAt = _data["startAt"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(JiraWorkflowStatus.fromJS(item));
            }
            this.total = _data["total"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(JiraWorkflow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowSearchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowSearchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLast"] = this.isLast;
        data["maxResults"] = this.maxResults;
        data["nextPage"] = this.nextPage;
        data["self"] = this.self;
        data["startAt"] = this.startAt;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        data["total"] = this.total;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** Page of items, including workflows and related statuses. */
export interface IWorkflowSearchResponse {
    /** Whether this is the last page. */
    isLast?: boolean;
    /** The maximum number of items that could be returned. */
    maxResults?: number;
    /** If there is another page of results, the URL of the next page. */
    nextPage?: string;
    /** The URL of the page. */
    self?: string;
    /** The index of the first item returned. */
    startAt?: number;
    /** List of statuses. */
    statuses?: JiraWorkflowStatus[];
    /** The number of items returned. */
    total?: number;
    /** List of workflows. */
    values?: JiraWorkflow[];
}

/** Details of a workflow status. */
export class WorkflowStatus implements IWorkflowStatus {
    /** The ID of the issue status. */
    id!: string;
    /** The name of the status in the workflow. */
    name!: string;
    /** Additional properties that modify the behavior of issues in this status. Supports the properties `jira.issue.editable` and `issueEditable` (deprecated) that indicate whether issues are editable. */
    properties?: { [key: string]: any; };

    constructor(data?: IWorkflowStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): WorkflowStatus {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

/** Details of a workflow status. */
export interface IWorkflowStatus {
    /** The ID of the issue status. */
    id: string;
    /** The name of the status in the workflow. */
    name: string;
    /** Additional properties that modify the behavior of issues in this status. Supports the properties `jira.issue.editable` and `issueEditable` (deprecated) that indicate whether issues are editable. */
    properties?: { [key: string]: any; };
}

/** The x and y location of the status in the workflow. */
export class WorkflowStatusLayout implements IWorkflowStatusLayout {
    /** The x axis location. */
    x?: number | undefined;
    /** The y axis location. */
    y?: number | undefined;

    constructor(data?: IWorkflowStatusLayout) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.x = _data["x"];
            this.y = _data["y"];
        }
    }

    static fromJS(data: any): WorkflowStatusLayout {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowStatusLayout();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        return data;
    }
}

/** The x and y location of the status in the workflow. */
export interface IWorkflowStatusLayout {
    /** The x axis location. */
    x?: number | undefined;
    /** The y axis location. */
    y?: number | undefined;
}

/** The layout of the workflow status. */
export class WorkflowStatusLayoutPayload implements IWorkflowStatusLayoutPayload {
    /** The x coordinate of the status. */
    x?: number;
    /** The y coordinate of the status. */
    y?: number;

    constructor(data?: IWorkflowStatusLayoutPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.x = _data["x"];
            this.y = _data["y"];
        }
    }

    static fromJS(data: any): WorkflowStatusLayoutPayload {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowStatusLayoutPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["x"] = this.x;
        data["y"] = this.y;
        return data;
    }
}

/** The layout of the workflow status. */
export interface IWorkflowStatusLayoutPayload {
    /** The x coordinate of the status. */
    x?: number;
    /** The y coordinate of the status. */
    y?: number;
}

/** The statuses to be used in the workflow */
export class WorkflowStatusPayload implements IWorkflowStatusPayload {
    layout?: WorkflowStatusLayoutPayload;
    pcri?: ProjectCreateResourceIdentifier;
    /** The properties of the workflow status. */
    properties?: { [key: string]: string; };

    constructor(data?: IWorkflowStatusPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.layout = _data["layout"] ? WorkflowStatusLayoutPayload.fromJS(_data["layout"]) : <any>undefined;
            this.pcri = _data["pcri"] ? ProjectCreateResourceIdentifier.fromJS(_data["pcri"]) : <any>undefined;
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): WorkflowStatusPayload {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowStatusPayload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["pcri"] = this.pcri ? this.pcri.toJSON() : <any>undefined;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

/** The statuses to be used in the workflow */
export interface IWorkflowStatusPayload {
    layout?: WorkflowStatusLayoutPayload;
    pcri?: ProjectCreateResourceIdentifier;
    /** The properties of the workflow status. */
    properties?: { [key: string]: string; };
}

/** Details of the status being updated. */
export class WorkflowStatusUpdate implements IWorkflowStatusUpdate {
    /** The description of the status. */
    description?: string;
    /** The ID of the status. */
    id?: string;
    /** The name of the status. */
    name!: string;
    /** The category of the status. */
    statusCategory!: WorkflowStatusUpdateStatusCategory;
    /** The reference of the status. */
    statusReference!: string;

    [key: string]: any;

    constructor(data?: IWorkflowStatusUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.description = _data["description"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.statusCategory = _data["statusCategory"];
            this.statusReference = _data["statusReference"];
        }
    }

    static fromJS(data: any): WorkflowStatusUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowStatusUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["description"] = this.description;
        data["id"] = this.id;
        data["name"] = this.name;
        data["statusCategory"] = this.statusCategory;
        data["statusReference"] = this.statusReference;
        return data;
    }
}

/** Details of the status being updated. */
export interface IWorkflowStatusUpdate {
    /** The description of the status. */
    description?: string;
    /** The ID of the status. */
    id?: string;
    /** The name of the status. */
    name: string;
    /** The category of the status. */
    statusCategory: WorkflowStatusUpdateStatusCategory;
    /** The reference of the status. */
    statusReference: string;

    [key: string]: any;
}

/** A workflow transition. */
export class WorkflowTransition implements IWorkflowTransition {
    /** The transition ID. */
    id!: number;
    /** The transition name. */
    name!: string;

    constructor(data?: IWorkflowTransition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WorkflowTransition {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTransition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

/** A workflow transition. */
export interface IWorkflowTransition {
    /** The transition ID. */
    id: number;
    /** The transition name. */
    name: string;
}

/** The statuses the transition can start from, and the mapping of ports between the statuses. */
export class WorkflowTransitionLinks implements IWorkflowTransitionLinks {
    /** The port that the transition starts from. */
    fromPort?: number | undefined;
    /** The status that the transition starts from. */
    fromStatusReference?: string | undefined;
    /** The port that the transition goes to. */
    toPort?: number | undefined;

    constructor(data?: IWorkflowTransitionLinks) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fromPort = _data["fromPort"];
            this.fromStatusReference = _data["fromStatusReference"];
            this.toPort = _data["toPort"];
        }
    }

    static fromJS(data: any): WorkflowTransitionLinks {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTransitionLinks();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromPort"] = this.fromPort;
        data["fromStatusReference"] = this.fromStatusReference;
        data["toPort"] = this.toPort;
        return data;
    }
}

/** The statuses the transition can start from, and the mapping of ports between the statuses. */
export interface IWorkflowTransitionLinks {
    /** The port that the transition starts from. */
    fromPort?: number | undefined;
    /** The status that the transition starts from. */
    fromStatusReference?: string | undefined;
    /** The port that the transition goes to. */
    toPort?: number | undefined;
}

/** Details about the server Jira is running on. */
export class WorkflowTransitionProperty implements IWorkflowTransitionProperty {
    /** The ID of the transition property. */
    readonly id?: string;
    /** The key of the transition property. Also known as the name of the transition property. */
    readonly key?: string;
    /** The value of the transition property. */
    value!: string;

    [key: string]: any;

    constructor(data?: IWorkflowTransitionProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).id = _data["id"];
            (<any>this).key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): WorkflowTransitionProperty {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTransitionProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

/** Details about the server Jira is running on. */
export interface IWorkflowTransitionProperty {
    /** The ID of the transition property. */
    id?: string;
    /** The key of the transition property. Also known as the name of the transition property. */
    key?: string;
    /** The value of the transition property. */
    value: string;

    [key: string]: any;
}

/** A workflow transition rule. */
export class WorkflowTransitionRule implements IWorkflowTransitionRule {
    /** EXPERIMENTAL. The configuration of the transition rule. */
    configuration?: any;
    /** The type of the transition rule. */
    type!: string;

    constructor(data?: IWorkflowTransitionRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.configuration = _data["configuration"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): WorkflowTransitionRule {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTransitionRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["configuration"] = this.configuration;
        data["type"] = this.type;
        return data;
    }
}

/** A workflow transition rule. */
export interface IWorkflowTransitionRule {
    /** EXPERIMENTAL. The configuration of the transition rule. */
    configuration?: any;
    /** The type of the transition rule. */
    type: string;
}

/** A workflow with transition rules. */
export class WorkflowTransitionRules implements IWorkflowTransitionRules {
    /** The list of conditions within the workflow. */
    conditions?: AppWorkflowTransitionRule[];
    /** The list of post functions within the workflow. */
    postFunctions?: AppWorkflowTransitionRule[];
    /** The list of validators within the workflow. */
    validators?: AppWorkflowTransitionRule[];
    workflowId!: WorkflowId;

    constructor(data?: IWorkflowTransitionRules) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.workflowId = new WorkflowId();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(AppWorkflowTransitionRule.fromJS(item));
            }
            if (Array.isArray(_data["postFunctions"])) {
                this.postFunctions = [] as any;
                for (let item of _data["postFunctions"])
                    this.postFunctions!.push(AppWorkflowTransitionRule.fromJS(item));
            }
            if (Array.isArray(_data["validators"])) {
                this.validators = [] as any;
                for (let item of _data["validators"])
                    this.validators!.push(AppWorkflowTransitionRule.fromJS(item));
            }
            this.workflowId = _data["workflowId"] ? WorkflowId.fromJS(_data["workflowId"]) : new WorkflowId();
        }
    }

    static fromJS(data: any): WorkflowTransitionRules {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTransitionRules();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        if (Array.isArray(this.postFunctions)) {
            data["postFunctions"] = [];
            for (let item of this.postFunctions)
                data["postFunctions"].push(item.toJSON());
        }
        if (Array.isArray(this.validators)) {
            data["validators"] = [];
            for (let item of this.validators)
                data["validators"].push(item.toJSON());
        }
        data["workflowId"] = this.workflowId ? this.workflowId.toJSON() : <any>undefined;
        return data;
    }
}

/** A workflow with transition rules. */
export interface IWorkflowTransitionRules {
    /** The list of conditions within the workflow. */
    conditions?: AppWorkflowTransitionRule[];
    /** The list of post functions within the workflow. */
    postFunctions?: AppWorkflowTransitionRule[];
    /** The list of validators within the workflow. */
    validators?: AppWorkflowTransitionRule[];
    workflowId: WorkflowId;
}

/** Details about a workflow configuration update request. */
export class WorkflowTransitionRulesDetails implements IWorkflowTransitionRulesDetails {
    workflowId!: WorkflowId;
    /** The list of connect workflow rule IDs. */
    workflowRuleIds!: string[];

    constructor(data?: IWorkflowTransitionRulesDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.workflowId = new WorkflowId();
            this.workflowRuleIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"] ? WorkflowId.fromJS(_data["workflowId"]) : new WorkflowId();
            if (Array.isArray(_data["workflowRuleIds"])) {
                this.workflowRuleIds = [] as any;
                for (let item of _data["workflowRuleIds"])
                    this.workflowRuleIds!.push(item);
            }
        }
    }

    static fromJS(data: any): WorkflowTransitionRulesDetails {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTransitionRulesDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId ? this.workflowId.toJSON() : <any>undefined;
        if (Array.isArray(this.workflowRuleIds)) {
            data["workflowRuleIds"] = [];
            for (let item of this.workflowRuleIds)
                data["workflowRuleIds"].push(item);
        }
        return data;
    }
}

/** Details about a workflow configuration update request. */
export interface IWorkflowTransitionRulesDetails {
    workflowId: WorkflowId;
    /** The list of connect workflow rule IDs. */
    workflowRuleIds: string[];
}

/** Details about a workflow configuration update request. */
export class WorkflowTransitionRulesUpdate implements IWorkflowTransitionRulesUpdate {
    /** The list of workflows with transition rules to update. */
    workflows!: WorkflowTransitionRules[];

    constructor(data?: IWorkflowTransitionRulesUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.workflows = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["workflows"])) {
                this.workflows = [] as any;
                for (let item of _data["workflows"])
                    this.workflows!.push(WorkflowTransitionRules.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTransitionRulesUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTransitionRulesUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.workflows)) {
            data["workflows"] = [];
            for (let item of this.workflows)
                data["workflows"].push(item.toJSON());
        }
        return data;
    }
}

/** Details about a workflow configuration update request. */
export interface IWorkflowTransitionRulesUpdate {
    /** The list of workflows with transition rules to update. */
    workflows: WorkflowTransitionRules[];
}

/** Details of any errors encountered while updating workflow transition rules for a workflow. */
export class WorkflowTransitionRulesUpdateErrorDetails implements IWorkflowTransitionRulesUpdateErrorDetails {
    /** A list of transition rule update errors, indexed by the transition rule ID. Any transition rule that appears here wasn't updated. */
    ruleUpdateErrors!: { [key: string]: string[]; };
    /** The list of errors that specify why the workflow update failed. The workflow was not updated if the list contains any entries. */
    updateErrors!: string[];
    workflowId!: WorkflowId;

    constructor(data?: IWorkflowTransitionRulesUpdateErrorDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ruleUpdateErrors = {};
            this.updateErrors = [];
            this.workflowId = new WorkflowId();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["ruleUpdateErrors"]) {
                this.ruleUpdateErrors = {} as any;
                for (let key in _data["ruleUpdateErrors"]) {
                    if (_data["ruleUpdateErrors"].hasOwnProperty(key))
                        (<any>this.ruleUpdateErrors)![key] = _data["ruleUpdateErrors"][key] !== undefined ? _data["ruleUpdateErrors"][key] : [];
                }
            }
            if (Array.isArray(_data["updateErrors"])) {
                this.updateErrors = [] as any;
                for (let item of _data["updateErrors"])
                    this.updateErrors!.push(item);
            }
            this.workflowId = _data["workflowId"] ? WorkflowId.fromJS(_data["workflowId"]) : new WorkflowId();
        }
    }

    static fromJS(data: any): WorkflowTransitionRulesUpdateErrorDetails {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTransitionRulesUpdateErrorDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.ruleUpdateErrors) {
            data["ruleUpdateErrors"] = {};
            for (let key in this.ruleUpdateErrors) {
                if (this.ruleUpdateErrors.hasOwnProperty(key))
                    (<any>data["ruleUpdateErrors"])[key] = (<any>this.ruleUpdateErrors)[key];
            }
        }
        if (Array.isArray(this.updateErrors)) {
            data["updateErrors"] = [];
            for (let item of this.updateErrors)
                data["updateErrors"].push(item);
        }
        data["workflowId"] = this.workflowId ? this.workflowId.toJSON() : <any>undefined;
        return data;
    }
}

/** Details of any errors encountered while updating workflow transition rules for a workflow. */
export interface IWorkflowTransitionRulesUpdateErrorDetails {
    /** A list of transition rule update errors, indexed by the transition rule ID. Any transition rule that appears here wasn't updated. */
    ruleUpdateErrors: { [key: string]: string[]; };
    /** The list of errors that specify why the workflow update failed. The workflow was not updated if the list contains any entries. */
    updateErrors: string[];
    workflowId: WorkflowId;
}

/** Details of any errors encountered while updating workflow transition rules. */
export class WorkflowTransitionRulesUpdateErrors implements IWorkflowTransitionRulesUpdateErrors {
    /** A list of workflows. */
    updateResults!: WorkflowTransitionRulesUpdateErrorDetails[];

    constructor(data?: IWorkflowTransitionRulesUpdateErrors) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.updateResults = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["updateResults"])) {
                this.updateResults = [] as any;
                for (let item of _data["updateResults"])
                    this.updateResults!.push(WorkflowTransitionRulesUpdateErrorDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTransitionRulesUpdateErrors {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTransitionRulesUpdateErrors();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.updateResults)) {
            data["updateResults"] = [];
            for (let item of this.updateResults)
                data["updateResults"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of any errors encountered while updating workflow transition rules. */
export interface IWorkflowTransitionRulesUpdateErrors {
    /** A list of workflows. */
    updateResults: WorkflowTransitionRulesUpdateErrorDetails[];
}

/** The transitions of the workflow. */
export class WorkflowTransitions implements IWorkflowTransitions {
    /** The post-functions of the transition. */
    actions?: (WorkflowRuleConfiguration | undefined)[];
    conditions?: ConditionGroupConfiguration | undefined;
    /** The custom event ID of the transition. */
    customIssueEventId?: string | undefined;
    /** The description of the transition. */
    description?: string;
    /** The ID of the transition. */
    id?: string;
    /** The statuses the transition can start from, and the mapping of ports between the statuses. */
    links?: (WorkflowTransitionLinks | undefined)[];
    /** The name of the transition. */
    name?: string;
    /** The properties of the transition. */
    properties?: { [key: string]: string; };
    /** The status the transition goes to. */
    toStatusReference?: string;
    transitionScreen?: WorkflowRuleConfiguration | undefined;
    /** The triggers of the transition. */
    triggers?: WorkflowTrigger[];
    /** The transition type. */
    type?: WorkflowTransitionsType;
    /** The validators of the transition. */
    validators?: (WorkflowRuleConfiguration | undefined)[];

    constructor(data?: IWorkflowTransitions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(WorkflowRuleConfiguration.fromJS(item));
            }
            this.conditions = _data["conditions"] ? ConditionGroupConfiguration.fromJS(_data["conditions"]) : <any>undefined;
            this.customIssueEventId = _data["customIssueEventId"];
            this.description = _data["description"];
            this.id = _data["id"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(WorkflowTransitionLinks.fromJS(item));
            }
            this.name = _data["name"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.toStatusReference = _data["toStatusReference"];
            this.transitionScreen = _data["transitionScreen"] ? WorkflowRuleConfiguration.fromJS(_data["transitionScreen"]) : <any>undefined;
            if (Array.isArray(_data["triggers"])) {
                this.triggers = [] as any;
                for (let item of _data["triggers"])
                    this.triggers!.push(WorkflowTrigger.fromJS(item));
            }
            this.type = _data["type"];
            if (Array.isArray(_data["validators"])) {
                this.validators = [] as any;
                for (let item of _data["validators"])
                    this.validators!.push(WorkflowRuleConfiguration.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowTransitions {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTransitions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        data["conditions"] = this.conditions ? this.conditions.toJSON() : <any>undefined;
        data["customIssueEventId"] = this.customIssueEventId;
        data["description"] = this.description;
        data["id"] = this.id;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["name"] = this.name;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["toStatusReference"] = this.toStatusReference;
        data["transitionScreen"] = this.transitionScreen ? this.transitionScreen.toJSON() : <any>undefined;
        if (Array.isArray(this.triggers)) {
            data["triggers"] = [];
            for (let item of this.triggers)
                data["triggers"].push(item.toJSON());
        }
        data["type"] = this.type;
        if (Array.isArray(this.validators)) {
            data["validators"] = [];
            for (let item of this.validators)
                data["validators"].push(item.toJSON());
        }
        return data;
    }
}

/** The transitions of the workflow. */
export interface IWorkflowTransitions {
    /** The post-functions of the transition. */
    actions?: (WorkflowRuleConfiguration | undefined)[];
    conditions?: ConditionGroupConfiguration | undefined;
    /** The custom event ID of the transition. */
    customIssueEventId?: string | undefined;
    /** The description of the transition. */
    description?: string;
    /** The ID of the transition. */
    id?: string;
    /** The statuses the transition can start from, and the mapping of ports between the statuses. */
    links?: (WorkflowTransitionLinks | undefined)[];
    /** The name of the transition. */
    name?: string;
    /** The properties of the transition. */
    properties?: { [key: string]: string; };
    /** The status the transition goes to. */
    toStatusReference?: string;
    transitionScreen?: WorkflowRuleConfiguration | undefined;
    /** The triggers of the transition. */
    triggers?: WorkflowTrigger[];
    /** The transition type. */
    type?: WorkflowTransitionsType;
    /** The validators of the transition. */
    validators?: (WorkflowRuleConfiguration | undefined)[];
}

/** The trigger configuration associated with a workflow. */
export class WorkflowTrigger implements IWorkflowTrigger {
    /** The ID of the trigger. */
    id?: string;
    /** The parameters of the trigger. */
    parameters!: { [key: string]: string; };
    /** The rule key of the trigger. */
    ruleKey!: string;

    constructor(data?: IWorkflowTrigger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.parameters = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (_data["parameters"]) {
                this.parameters = {} as any;
                for (let key in _data["parameters"]) {
                    if (_data["parameters"].hasOwnProperty(key))
                        (<any>this.parameters)![key] = _data["parameters"][key];
                }
            }
            this.ruleKey = _data["ruleKey"];
        }
    }

    static fromJS(data: any): WorkflowTrigger {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowTrigger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.parameters) {
            data["parameters"] = {};
            for (let key in this.parameters) {
                if (this.parameters.hasOwnProperty(key))
                    (<any>data["parameters"])[key] = (<any>this.parameters)[key];
            }
        }
        data["ruleKey"] = this.ruleKey;
        return data;
    }
}

/** The trigger configuration associated with a workflow. */
export interface IWorkflowTrigger {
    /** The ID of the trigger. */
    id?: string;
    /** The parameters of the trigger. */
    parameters: { [key: string]: string; };
    /** The rule key of the trigger. */
    ruleKey: string;
}

/** The details of the workflows to update. */
export class WorkflowUpdate implements IWorkflowUpdate {
    /** The mapping of old to new status ID. */
    defaultStatusMappings?: StatusMigration[];
    /** The new description for this workflow. */
    description?: string;
    /** The ID of this workflow. */
    id!: string;
    loopedTransitionContainerLayout?: WorkflowLayout | undefined;
    startPointLayout?: WorkflowLayout | undefined;
    /** The mapping of old to new status ID for a specific project and issue type. */
    statusMappings?: StatusMappingDTO[];
    /** The statuses associated with this workflow. */
    statuses!: StatusLayoutUpdate[];
    /** The transitions of this workflow. */
    transitions!: TransitionUpdateDTO[];
    version!: DocumentVersion;

    [key: string]: any;

    constructor(data?: IWorkflowUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.statuses = [];
            this.transitions = [];
            this.version = new DocumentVersion();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["defaultStatusMappings"])) {
                this.defaultStatusMappings = [] as any;
                for (let item of _data["defaultStatusMappings"])
                    this.defaultStatusMappings!.push(StatusMigration.fromJS(item));
            }
            this.description = _data["description"];
            this.id = _data["id"];
            this.loopedTransitionContainerLayout = _data["loopedTransitionContainerLayout"] ? WorkflowLayout.fromJS(_data["loopedTransitionContainerLayout"]) : <any>undefined;
            this.startPointLayout = _data["startPointLayout"] ? WorkflowLayout.fromJS(_data["startPointLayout"]) : <any>undefined;
            if (Array.isArray(_data["statusMappings"])) {
                this.statusMappings = [] as any;
                for (let item of _data["statusMappings"])
                    this.statusMappings!.push(StatusMappingDTO.fromJS(item));
            }
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(StatusLayoutUpdate.fromJS(item));
            }
            if (Array.isArray(_data["transitions"])) {
                this.transitions = [] as any;
                for (let item of _data["transitions"])
                    this.transitions!.push(TransitionUpdateDTO.fromJS(item));
            }
            this.version = _data["version"] ? DocumentVersion.fromJS(_data["version"]) : new DocumentVersion();
        }
    }

    static fromJS(data: any): WorkflowUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.defaultStatusMappings)) {
            data["defaultStatusMappings"] = [];
            for (let item of this.defaultStatusMappings)
                data["defaultStatusMappings"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["id"] = this.id;
        data["loopedTransitionContainerLayout"] = this.loopedTransitionContainerLayout ? this.loopedTransitionContainerLayout.toJSON() : <any>undefined;
        data["startPointLayout"] = this.startPointLayout ? this.startPointLayout.toJSON() : <any>undefined;
        if (Array.isArray(this.statusMappings)) {
            data["statusMappings"] = [];
            for (let item of this.statusMappings)
                data["statusMappings"].push(item.toJSON());
        }
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        if (Array.isArray(this.transitions)) {
            data["transitions"] = [];
            for (let item of this.transitions)
                data["transitions"].push(item.toJSON());
        }
        data["version"] = this.version ? this.version.toJSON() : <any>undefined;
        return data;
    }
}

/** The details of the workflows to update. */
export interface IWorkflowUpdate {
    /** The mapping of old to new status ID. */
    defaultStatusMappings?: StatusMigration[];
    /** The new description for this workflow. */
    description?: string;
    /** The ID of this workflow. */
    id: string;
    loopedTransitionContainerLayout?: WorkflowLayout | undefined;
    startPointLayout?: WorkflowLayout | undefined;
    /** The mapping of old to new status ID for a specific project and issue type. */
    statusMappings?: StatusMappingDTO[];
    /** The statuses associated with this workflow. */
    statuses: StatusLayoutUpdate[];
    /** The transitions of this workflow. */
    transitions: TransitionUpdateDTO[];
    version: DocumentVersion;

    [key: string]: any;
}

/** The update workflows payload. */
export class WorkflowUpdateRequest implements IWorkflowUpdateRequest {
    /** The statuses to associate with the workflows. */
    statuses?: WorkflowStatusUpdate[];
    /** The details of the workflows to update. */
    workflows?: WorkflowUpdate[];

    constructor(data?: IWorkflowUpdateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(WorkflowStatusUpdate.fromJS(item));
            }
            if (Array.isArray(_data["workflows"])) {
                this.workflows = [] as any;
                for (let item of _data["workflows"])
                    this.workflows!.push(WorkflowUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowUpdateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowUpdateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        if (Array.isArray(this.workflows)) {
            data["workflows"] = [];
            for (let item of this.workflows)
                data["workflows"].push(item.toJSON());
        }
        return data;
    }
}

/** The update workflows payload. */
export interface IWorkflowUpdateRequest {
    /** The statuses to associate with the workflows. */
    statuses?: WorkflowStatusUpdate[];
    /** The details of the workflows to update. */
    workflows?: WorkflowUpdate[];
}

export class WorkflowUpdateResponse implements IWorkflowUpdateResponse {
    /** List of updated statuses. */
    statuses?: JiraWorkflowStatus[];
    /** If there is a [asynchronous task](#async-operations) operation, as a result of this update. */
    taskId?: string | undefined;
    /** List of updated workflows. */
    workflows?: JiraWorkflow[];

    constructor(data?: IWorkflowUpdateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(JiraWorkflowStatus.fromJS(item));
            }
            this.taskId = _data["taskId"];
            if (Array.isArray(_data["workflows"])) {
                this.workflows = [] as any;
                for (let item of _data["workflows"])
                    this.workflows!.push(JiraWorkflow.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowUpdateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowUpdateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        data["taskId"] = this.taskId;
        if (Array.isArray(this.workflows)) {
            data["workflows"] = [];
            for (let item of this.workflows)
                data["workflows"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowUpdateResponse {
    /** List of updated statuses. */
    statuses?: JiraWorkflowStatus[];
    /** If there is a [asynchronous task](#async-operations) operation, as a result of this update. */
    taskId?: string | undefined;
    /** List of updated workflows. */
    workflows?: JiraWorkflow[];
}

export class WorkflowUpdateValidateRequestBean implements IWorkflowUpdateValidateRequestBean {
    payload!: WorkflowUpdateRequest;
    validationOptions?: ValidationOptionsForUpdate;

    constructor(data?: IWorkflowUpdateValidateRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.payload = new WorkflowUpdateRequest();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.payload = _data["payload"] ? WorkflowUpdateRequest.fromJS(_data["payload"]) : new WorkflowUpdateRequest();
            this.validationOptions = _data["validationOptions"] ? ValidationOptionsForUpdate.fromJS(_data["validationOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkflowUpdateValidateRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowUpdateValidateRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payload"] = this.payload ? this.payload.toJSON() : <any>undefined;
        data["validationOptions"] = this.validationOptions ? this.validationOptions.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWorkflowUpdateValidateRequestBean {
    payload: WorkflowUpdateRequest;
    validationOptions?: ValidationOptionsForUpdate;
}

/** Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details. The workflows that use this status. Only available if the `workflowUsages` expand is requested. */
export class WorkflowUsages implements IWorkflowUsages {
    /** Workflow ID. */
    workflowId?: string;
    /** Workflow name. */
    workflowName?: string;

    constructor(data?: IWorkflowUsages) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.workflowId = _data["workflowId"];
            this.workflowName = _data["workflowName"];
        }
    }

    static fromJS(data: any): WorkflowUsages {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowUsages();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workflowId"] = this.workflowId;
        data["workflowName"] = this.workflowName;
        return data;
    }
}

/** Deprecated. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-2298) for details. The workflows that use this status. Only available if the `workflowUsages` expand is requested. */
export interface IWorkflowUsages {
    /** Workflow ID. */
    workflowId?: string;
    /** Workflow name. */
    workflowName?: string;
}

/** The details about a workflow validation error. */
export class WorkflowValidationError implements IWorkflowValidationError {
    /** An error code. */
    code?: string;
    elementReference?: WorkflowElementReference;
    /** The validation error level. */
    level?: WorkflowValidationErrorLevel;
    /** An error message. */
    message?: string;
    /** The type of element the error or warning references. */
    type?: WorkflowValidationErrorType;

    constructor(data?: IWorkflowValidationError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.elementReference = _data["elementReference"] ? WorkflowElementReference.fromJS(_data["elementReference"]) : <any>undefined;
            this.level = _data["level"];
            this.message = _data["message"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): WorkflowValidationError {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowValidationError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["elementReference"] = this.elementReference ? this.elementReference.toJSON() : <any>undefined;
        data["level"] = this.level;
        data["message"] = this.message;
        data["type"] = this.type;
        return data;
    }
}

/** The details about a workflow validation error. */
export interface IWorkflowValidationError {
    /** An error code. */
    code?: string;
    elementReference?: WorkflowElementReference;
    /** The validation error level. */
    level?: WorkflowValidationErrorLevel;
    /** An error message. */
    message?: string;
    /** The type of element the error or warning references. */
    type?: WorkflowValidationErrorType;
}

export class WorkflowValidationErrorList implements IWorkflowValidationErrorList {
    /** The list of validation errors. */
    errors?: WorkflowValidationError[];

    constructor(data?: IWorkflowValidationErrorList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(WorkflowValidationError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowValidationErrorList {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowValidationErrorList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWorkflowValidationErrorList {
    /** The list of validation errors. */
    errors?: WorkflowValidationError[];
}

/** Details of workflows and their transition rules to delete. */
export class WorkflowsWithTransitionRulesDetails implements IWorkflowsWithTransitionRulesDetails {
    /** The list of workflows with transition rules to delete. */
    workflows!: WorkflowTransitionRulesDetails[];

    constructor(data?: IWorkflowsWithTransitionRulesDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.workflows = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["workflows"])) {
                this.workflows = [] as any;
                for (let item of _data["workflows"])
                    this.workflows!.push(WorkflowTransitionRulesDetails.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkflowsWithTransitionRulesDetails {
        data = typeof data === 'object' ? data : {};
        let result = new WorkflowsWithTransitionRulesDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.workflows)) {
            data["workflows"] = [];
            for (let item of this.workflows)
                data["workflows"].push(item.toJSON());
        }
        return data;
    }
}

/** Details of workflows and their transition rules to delete. */
export interface IWorkflowsWithTransitionRulesDetails {
    /** The list of workflows with transition rules to delete. */
    workflows: WorkflowTransitionRulesDetails[];
}

/** Working days configuration */
export class WorkingDaysConfig implements IWorkingDaysConfig {
    friday?: boolean;
    id?: number;
    monday?: boolean;
    nonWorkingDays?: NonWorkingDay[];
    saturday?: boolean;
    sunday?: boolean;
    thursday?: boolean;
    timezoneId?: string;
    tuesday?: boolean;
    wednesday?: boolean;

    constructor(data?: IWorkingDaysConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.friday = _data["friday"];
            this.id = _data["id"];
            this.monday = _data["monday"];
            if (Array.isArray(_data["nonWorkingDays"])) {
                this.nonWorkingDays = [] as any;
                for (let item of _data["nonWorkingDays"])
                    this.nonWorkingDays!.push(NonWorkingDay.fromJS(item));
            }
            this.saturday = _data["saturday"];
            this.sunday = _data["sunday"];
            this.thursday = _data["thursday"];
            this.timezoneId = _data["timezoneId"];
            this.tuesday = _data["tuesday"];
            this.wednesday = _data["wednesday"];
        }
    }

    static fromJS(data: any): WorkingDaysConfig {
        data = typeof data === 'object' ? data : {};
        let result = new WorkingDaysConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friday"] = this.friday;
        data["id"] = this.id;
        data["monday"] = this.monday;
        if (Array.isArray(this.nonWorkingDays)) {
            data["nonWorkingDays"] = [];
            for (let item of this.nonWorkingDays)
                data["nonWorkingDays"].push(item.toJSON());
        }
        data["saturday"] = this.saturday;
        data["sunday"] = this.sunday;
        data["thursday"] = this.thursday;
        data["timezoneId"] = this.timezoneId;
        data["tuesday"] = this.tuesday;
        data["wednesday"] = this.wednesday;
        return data;
    }
}

/** Working days configuration */
export interface IWorkingDaysConfig {
    friday?: boolean;
    id?: number;
    monday?: boolean;
    nonWorkingDays?: NonWorkingDay[];
    saturday?: boolean;
    sunday?: boolean;
    thursday?: boolean;
    timezoneId?: string;
    tuesday?: boolean;
    wednesday?: boolean;
}

/** Details of a worklog. */
export class Worklog implements IWorklog {
    /** Details of the user who created the worklog. */
    readonly author?: UserDetails;
    /** A comment about the worklog in [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure/). Optional when creating or updating a worklog. */
    comment?: any;
    /** The datetime on which the worklog was created. */
    readonly created?: Date;
    /** The ID of the worklog record. */
    readonly id?: string;
    /** The ID of the issue this worklog is for. */
    readonly issueId?: string;
    /** Details of properties for the worklog. Optional when creating or updating a worklog. */
    properties?: EntityProperty[];
    /** The URL of the worklog item. */
    readonly self?: string;
    /** The datetime on which the worklog effort was started. Required when creating a worklog. Optional when updating a worklog. */
    started?: Date;
    /** The time spent working on the issue as days (\#d), hours (\#h), or minutes (\#m or \#). Required when creating a worklog if `timeSpentSeconds` isn't provided. Optional when updating a worklog. Cannot be provided if `timeSpentSecond` is provided. */
    timeSpent?: string;
    /** The time in seconds spent working on the issue. Required when creating a worklog if `timeSpent` isn't provided. Optional when updating a worklog. Cannot be provided if `timeSpent` is provided. */
    timeSpentSeconds?: number;
    /** Details of the user who last updated the worklog. */
    readonly updateAuthor?: UserDetails;
    /** The datetime on which the worklog was last updated. */
    readonly updated?: Date;
    /** Details about any restrictions in the visibility of the worklog. Optional when creating or updating a worklog. */
    visibility?: Visibility;

    [key: string]: any;

    constructor(data?: IWorklog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            (<any>this).author = _data["author"] ? UserDetails.fromJS(_data["author"]) : <any>undefined;
            this.comment = _data["comment"];
            (<any>this).created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            (<any>this).id = _data["id"];
            (<any>this).issueId = _data["issueId"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(EntityProperty.fromJS(item));
            }
            (<any>this).self = _data["self"];
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.timeSpent = _data["timeSpent"];
            this.timeSpentSeconds = _data["timeSpentSeconds"];
            (<any>this).updateAuthor = _data["updateAuthor"] ? UserDetails.fromJS(_data["updateAuthor"]) : <any>undefined;
            (<any>this).updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
            this.visibility = _data["visibility"] ? Visibility.fromJS(_data["visibility"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Worklog {
        data = typeof data === 'object' ? data : {};
        let result = new Worklog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["comment"] = this.comment;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["issueId"] = this.issueId;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        data["self"] = this.self;
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["timeSpent"] = this.timeSpent;
        data["timeSpentSeconds"] = this.timeSpentSeconds;
        data["updateAuthor"] = this.updateAuthor ? this.updateAuthor.toJSON() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["visibility"] = this.visibility ? this.visibility.toJSON() : <any>undefined;
        return data;
    }
}

/** Details of a worklog. */
export interface IWorklog {
    /** Details of the user who created the worklog. */
    author?: UserDetails;
    /** A comment about the worklog in [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure/). Optional when creating or updating a worklog. */
    comment?: any;
    /** The datetime on which the worklog was created. */
    created?: Date;
    /** The ID of the worklog record. */
    id?: string;
    /** The ID of the issue this worklog is for. */
    issueId?: string;
    /** Details of properties for the worklog. Optional when creating or updating a worklog. */
    properties?: EntityProperty[];
    /** The URL of the worklog item. */
    self?: string;
    /** The datetime on which the worklog effort was started. Required when creating a worklog. Optional when updating a worklog. */
    started?: Date;
    /** The time spent working on the issue as days (\#d), hours (\#h), or minutes (\#m or \#). Required when creating a worklog if `timeSpentSeconds` isn't provided. Optional when updating a worklog. Cannot be provided if `timeSpentSecond` is provided. */
    timeSpent?: string;
    /** The time in seconds spent working on the issue. Required when creating a worklog if `timeSpent` isn't provided. Optional when updating a worklog. Cannot be provided if `timeSpent` is provided. */
    timeSpentSeconds?: number;
    /** Details of the user who last updated the worklog. */
    updateAuthor?: UserDetails;
    /** The datetime on which the worklog was last updated. */
    updated?: Date;
    /** Details about any restrictions in the visibility of the worklog. Optional when creating or updating a worklog. */
    visibility?: Visibility;

    [key: string]: any;
}

export class WorklogIdsRequestBean implements IWorklogIdsRequestBean {
    /** A list of worklog IDs. */
    ids!: number[];

    constructor(data?: IWorklogIdsRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ids = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): WorklogIdsRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new WorklogIdsRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data;
    }
}

export interface IWorklogIdsRequestBean {
    /** A list of worklog IDs. */
    ids: number[];
}

export class WorklogsMoveRequestBean implements IWorklogsMoveRequestBean {
    /** A list of worklog IDs. */
    ids?: number[];
    /** The issue id or key of the destination issue */
    issueIdOrKey?: string;

    constructor(data?: IWorklogsMoveRequestBean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.issueIdOrKey = _data["issueIdOrKey"];
        }
    }

    static fromJS(data: any): WorklogsMoveRequestBean {
        data = typeof data === 'object' ? data : {};
        let result = new WorklogsMoveRequestBean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["issueIdOrKey"] = this.issueIdOrKey;
        return data;
    }
}

export interface IWorklogsMoveRequestBean {
    /** A list of worklog IDs. */
    ids?: number[];
    /** The issue id or key of the destination issue */
    issueIdOrKey?: string;
}

/** Details about data policy. */
export class WorkspaceDataPolicy implements IWorkspaceDataPolicy {
    /** Whether the workspace contains any content inaccessible to the requesting application. */
    readonly anyContentBlocked?: boolean;

    constructor(data?: IWorkspaceDataPolicy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).anyContentBlocked = _data["anyContentBlocked"];
        }
    }

    static fromJS(data: any): WorkspaceDataPolicy {
        data = typeof data === 'object' ? data : {};
        let result = new WorkspaceDataPolicy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["anyContentBlocked"] = this.anyContentBlocked;
        return data;
    }
}

/** Details about data policy. */
export interface IWorkspaceDataPolicy {
    /** Whether the workspace contains any content inaccessible to the requesting application. */
    anyContentBlocked?: boolean;
}

/** Can contain multiple field values of following types depending on `type` key */
export class fields implements Ifields {
    /** If `true`, will try to retain original non-null issue field values on move. */
    retain?: boolean | undefined;
    value?: any;

    protected _discriminator: string;

    constructor(data?: Ifields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.retain = true;
        }
        this._discriminator = "fields";
    }

    init(_data?: any) {
        if (_data) {
            this.retain = _data["retain"] !== undefined ? _data["retain"] : true;
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): fields {
        data = typeof data === 'object' ? data : {};
        let result = new fields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this._discriminator;
        data["retain"] = this.retain;
        data["value"] = this.value;
        return data;
    }
}

/** Can contain multiple field values of following types depending on `type` key */
export interface Ifields {
    /** If `true`, will try to retain original non-null issue field values on move. */
    retain?: boolean | undefined;
    value?: any;
}

/** Classification mapping for classifications in source issues to respective target classification. */
export class TargetClassification implements ITargetClassification {
    /** An object with the key as the ID of the target classification and value with the list of the IDs of the current source classifications. */
    classifications!: { [key: string]: string[]; };
    /** ID of the source issueType to which issues present in `issueIdOrKeys` belongs. */
    issueType?: string;
    /** ID or key of the source project to which issues present in `issueIdOrKeys` belongs. */
    projectKeyOrId?: string;

    constructor(data?: ITargetClassification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.classifications = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["classifications"]) {
                this.classifications = {} as any;
                for (let key in _data["classifications"]) {
                    if (_data["classifications"].hasOwnProperty(key))
                        (<any>this.classifications)![key] = _data["classifications"][key] !== undefined ? _data["classifications"][key] : [];
                }
            }
            this.issueType = _data["issueType"];
            this.projectKeyOrId = _data["projectKeyOrId"];
        }
    }

    static fromJS(data: any): TargetClassification {
        data = typeof data === 'object' ? data : {};
        let result = new TargetClassification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.classifications) {
            data["classifications"] = {};
            for (let key in this.classifications) {
                if (this.classifications.hasOwnProperty(key))
                    (<any>data["classifications"])[key] = (<any>this.classifications)[key];
            }
        }
        data["issueType"] = this.issueType;
        data["projectKeyOrId"] = this.projectKeyOrId;
        return data;
    }
}

/** Classification mapping for classifications in source issues to respective target classification. */
export interface ITargetClassification {
    /** An object with the key as the ID of the target classification and value with the list of the IDs of the current source classifications. */
    classifications: { [key: string]: string[]; };
    /** ID of the source issueType to which issues present in `issueIdOrKeys` belongs. */
    issueType?: string;
    /** ID or key of the source project to which issues present in `issueIdOrKeys` belongs. */
    projectKeyOrId?: string;
}

/** Field mapping for mandatory fields in target */
export class TargetMandatoryFields implements ITargetMandatoryFields {
    /** Contains the value of mandatory fields */
    fields!: { [key: string]: fields; };

    constructor(data?: ITargetMandatoryFields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fields = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["fields"]) {
                this.fields = {} as any;
                for (let key in _data["fields"]) {
                    if (_data["fields"].hasOwnProperty(key))
                        (<any>this.fields)![key] = _data["fields"][key] ? fields.fromJS(_data["fields"][key]) : new fields();
                }
            }
        }
    }

    static fromJS(data: any): TargetMandatoryFields {
        data = typeof data === 'object' ? data : {};
        let result = new TargetMandatoryFields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.fields) {
            data["fields"] = {};
            for (let key in this.fields) {
                if (this.fields.hasOwnProperty(key))
                    (<any>data["fields"])[key] = this.fields[key] ? this.fields[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

/** Field mapping for mandatory fields in target */
export interface ITargetMandatoryFields {
    /** Contains the value of mandatory fields */
    fields: { [key: string]: fields; };
}

/** Status mapping for statuses in source workflow to respective target status in target workflow. */
export class TargetStatus implements ITargetStatus {
    /** An object with the key as the ID of the target status and value with the list of the IDs of the current source statuses. */
    statuses!: { [key: string]: string[]; };

    constructor(data?: ITargetStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.statuses = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["statuses"]) {
                this.statuses = {} as any;
                for (let key in _data["statuses"]) {
                    if (_data["statuses"].hasOwnProperty(key))
                        (<any>this.statuses)![key] = _data["statuses"][key] !== undefined ? _data["statuses"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): TargetStatus {
        data = typeof data === 'object' ? data : {};
        let result = new TargetStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.statuses) {
            data["statuses"] = {};
            for (let key in this.statuses) {
                if (this.statuses.hasOwnProperty(key))
                    (<any>data["statuses"])[key] = (<any>this.statuses)[key];
            }
        }
        return data;
    }
}

/** Status mapping for statuses in source workflow to respective target status in target workflow. */
export interface ITargetStatus {
    /** An object with the key as the ID of the target status and value with the list of the IDs of the current source statuses. */
    statuses: { [key: string]: string[]; };
}

/** An object representing the mapping of issues and data related to destination entities, like fields and statuses, that are required during a bulk move. */
export class TargetToSourcesMapping implements ITargetToSourcesMapping {
    /** If `true`, when issues are moved into this target group, they will adopt the target project's default classification, if they don't have a classification already. If they do have a classification, it will be kept the same even after the move. Leave `targetClassification` empty when using this.

If `false`, you must provide a `targetClassification` mapping for each classification associated with the selected issues.

[Benefit from data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/) */
    inferClassificationDefaults!: boolean;
    /** If `true`, values from the source issues will be retained for the mandatory fields in the field configuration of the destination project. The `targetMandatoryFields` property shouldn't be defined.

If `false`, the user is required to set values for mandatory fields present in the field configuration of the destination project. Provide input by defining the `targetMandatoryFields` property */
    inferFieldDefaults!: boolean;
    /** If `true`, the statuses of issues being moved in this target group that are not present in the target workflow will be changed to the default status of the target workflow (see below). Leave `targetStatus` empty when using this.

If `false`, you must provide a `targetStatus` for each status not present in the target workflow.

The default status in a workflow is referred to as the "initial status". Each workflow has its own unique initial status. When an issue is created, it is automatically assigned to this initial status. Read more about configuring initial statuses: [Configure the initial status | Atlassian Support.](https://support.atlassian.com/jira-cloud-administration/docs/configure-the-initial-status/) */
    inferStatusDefaults!: boolean;
    /** When an issue is moved, its subtasks (if there are any) need to be moved with it. `inferSubtaskTypeDefault` helps with moving the subtasks by picking a random subtask type in the target project.

If `true`, subtasks will automatically move to the same project as their parent.

When they move:

 *  Their `issueType` will be set to the default for subtasks in the target project.
 *  Values for mandatory fields will be retained from the source issues
 *  Specifying separate mapping for implicit subtasks won’t be allowed.

If `false`, you must manually move the subtasks. They will retain the parent which they had in the current project after being moved. */
    inferSubtaskTypeDefault!: boolean;
    /** List of issue IDs or keys to be moved. These issues must be from the same project, have the same issue type, and be from the same parent (if they’re subtasks). */
    issueIdsOrKeys?: string[];
    /** List of the objects containing classifications in the source issues and their new values which need to be set during the bulk move operation.

 *  **You should only define this property when `inferClassificationDefaults` is `false`.**
 *  **In order to provide mapping for issues which don't have a classification, use `"-1"`.** */
    targetClassification?: (TargetClassification | undefined)[] | undefined;
    /** List of objects containing mandatory fields in the target field configuration and new values that need to be set during the bulk move operation.

The new values will only be applied if the field is mandatory in the target project and at least one issue from the source has that field empty, or if the field context is different in the target project (e.g. project-scoped version fields).

**You should only define this property when `inferFieldDefaults` is `false`.** */
    targetMandatoryFields?: (TargetMandatoryFields | undefined)[] | undefined;
    /** List of the objects containing statuses in the source workflow and their new values which need to be set during the bulk move operation.

The new values will only be applied if the source status is invalid for the target project and issue type.

**You should only define this property when `inferStatusDefaults` is `false`.** */
    targetStatus?: (TargetStatus | undefined)[] | undefined;

    constructor(data?: ITargetToSourcesMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inferClassificationDefaults = _data["inferClassificationDefaults"];
            this.inferFieldDefaults = _data["inferFieldDefaults"];
            this.inferStatusDefaults = _data["inferStatusDefaults"];
            this.inferSubtaskTypeDefault = _data["inferSubtaskTypeDefault"];
            if (Array.isArray(_data["issueIdsOrKeys"])) {
                this.issueIdsOrKeys = [] as any;
                for (let item of _data["issueIdsOrKeys"])
                    this.issueIdsOrKeys!.push(item);
            }
            if (Array.isArray(_data["targetClassification"])) {
                this.targetClassification = [] as any;
                for (let item of _data["targetClassification"])
                    this.targetClassification!.push(TargetClassification.fromJS(item));
            }
            if (Array.isArray(_data["targetMandatoryFields"])) {
                this.targetMandatoryFields = [] as any;
                for (let item of _data["targetMandatoryFields"])
                    this.targetMandatoryFields!.push(TargetMandatoryFields.fromJS(item));
            }
            if (Array.isArray(_data["targetStatus"])) {
                this.targetStatus = [] as any;
                for (let item of _data["targetStatus"])
                    this.targetStatus!.push(TargetStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TargetToSourcesMapping {
        data = typeof data === 'object' ? data : {};
        let result = new TargetToSourcesMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inferClassificationDefaults"] = this.inferClassificationDefaults;
        data["inferFieldDefaults"] = this.inferFieldDefaults;
        data["inferStatusDefaults"] = this.inferStatusDefaults;
        data["inferSubtaskTypeDefault"] = this.inferSubtaskTypeDefault;
        if (Array.isArray(this.issueIdsOrKeys)) {
            data["issueIdsOrKeys"] = [];
            for (let item of this.issueIdsOrKeys)
                data["issueIdsOrKeys"].push(item);
        }
        if (Array.isArray(this.targetClassification)) {
            data["targetClassification"] = [];
            for (let item of this.targetClassification)
                data["targetClassification"].push(item.toJSON());
        }
        if (Array.isArray(this.targetMandatoryFields)) {
            data["targetMandatoryFields"] = [];
            for (let item of this.targetMandatoryFields)
                data["targetMandatoryFields"].push(item.toJSON());
        }
        if (Array.isArray(this.targetStatus)) {
            data["targetStatus"] = [];
            for (let item of this.targetStatus)
                data["targetStatus"].push(item.toJSON());
        }
        return data;
    }
}

/** An object representing the mapping of issues and data related to destination entities, like fields and statuses, that are required during a bulk move. */
export interface ITargetToSourcesMapping {
    /** If `true`, when issues are moved into this target group, they will adopt the target project's default classification, if they don't have a classification already. If they do have a classification, it will be kept the same even after the move. Leave `targetClassification` empty when using this.

If `false`, you must provide a `targetClassification` mapping for each classification associated with the selected issues.

[Benefit from data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/) */
    inferClassificationDefaults: boolean;
    /** If `true`, values from the source issues will be retained for the mandatory fields in the field configuration of the destination project. The `targetMandatoryFields` property shouldn't be defined.

If `false`, the user is required to set values for mandatory fields present in the field configuration of the destination project. Provide input by defining the `targetMandatoryFields` property */
    inferFieldDefaults: boolean;
    /** If `true`, the statuses of issues being moved in this target group that are not present in the target workflow will be changed to the default status of the target workflow (see below). Leave `targetStatus` empty when using this.

If `false`, you must provide a `targetStatus` for each status not present in the target workflow.

The default status in a workflow is referred to as the "initial status". Each workflow has its own unique initial status. When an issue is created, it is automatically assigned to this initial status. Read more about configuring initial statuses: [Configure the initial status | Atlassian Support.](https://support.atlassian.com/jira-cloud-administration/docs/configure-the-initial-status/) */
    inferStatusDefaults: boolean;
    /** When an issue is moved, its subtasks (if there are any) need to be moved with it. `inferSubtaskTypeDefault` helps with moving the subtasks by picking a random subtask type in the target project.

If `true`, subtasks will automatically move to the same project as their parent.

When they move:

 *  Their `issueType` will be set to the default for subtasks in the target project.
 *  Values for mandatory fields will be retained from the source issues
 *  Specifying separate mapping for implicit subtasks won’t be allowed.

If `false`, you must manually move the subtasks. They will retain the parent which they had in the current project after being moved. */
    inferSubtaskTypeDefault: boolean;
    /** List of issue IDs or keys to be moved. These issues must be from the same project, have the same issue type, and be from the same parent (if they’re subtasks). */
    issueIdsOrKeys?: string[];
    /** List of the objects containing classifications in the source issues and their new values which need to be set during the bulk move operation.

 *  **You should only define this property when `inferClassificationDefaults` is `false`.**
 *  **In order to provide mapping for issues which don't have a classification, use `"-1"`.** */
    targetClassification?: (TargetClassification | undefined)[] | undefined;
    /** List of objects containing mandatory fields in the target field configuration and new values that need to be set during the bulk move operation.

The new values will only be applied if the field is mandatory in the target project and at least one issue from the source has that field empty, or if the field context is different in the target project (e.g. project-scoped version fields).

**You should only define this property when `inferFieldDefaults` is `false`.** */
    targetMandatoryFields?: (TargetMandatoryFields | undefined)[] | undefined;
    /** List of the objects containing statuses in the source workflow and their new values which need to be set during the bulk move operation.

The new values will only be applied if the source status is invalid for the target project and issue type.

**You should only define this property when `inferStatusDefaults` is `false`.** */
    targetStatus?: (TargetStatus | undefined)[] | undefined;
}

export enum Type {
    Issuetype = "issuetype",
    Project = "project",
    User = "user",
    Priority = "priority",
}

/** The status of the project classification. */
export enum Status2 {
    PUBLISHED = "PUBLISHED",
    ARCHIVED = "ARCHIVED",
    DRAFT = "DRAFT",
}

export enum OrderBy {
    Rank = "rank",
    Minusrank = "-rank",
    Plusrank = "+rank",
}

export enum OrderBy2 {
    Description = "description",
    Minusdescription = "-description",
    Plusdescription = "+description",
    Name = "name",
    Minusname = "-name",
    Plusname = "+name",
}

export enum Filter2 {
    My = "my",
    Favourite = "favourite",
}

export enum OrderBy3 {
    Description = "description",
    Minusdescription = "-description",
    Plusdescription = "+description",
    Favorite_count = "favorite_count",
    Minusfavorite_count = "-favorite_count",
    Plusfavorite_count = "+favorite_count",
    Id = "id",
    Minusid = "-id",
    Plusid = "+id",
    Is_favorite = "is_favorite",
    Minusis_favorite = "-is_favorite",
    Plusis_favorite = "+is_favorite",
    Name = "name",
    Minusname = "-name",
    Plusname = "+name",
    Owner = "owner",
    Minusowner = "-owner",
    Plusowner = "+owner",
}

export enum Status3 {
    Active = "active",
    Archived = "archived",
    Deleted = "deleted",
}

export enum Check {
    Syntax = "syntax",
    Type = "type",
    Complexity = "complexity",
}

export enum Type2 {
    Custom = "custom",
    System = "system",
}

export enum OrderBy4 {
    ContextsCount = "contextsCount",
    MinuscontextsCount = "-contextsCount",
    PluscontextsCount = "+contextsCount",
    LastUsed = "lastUsed",
    MinuslastUsed = "-lastUsed",
    PluslastUsed = "+lastUsed",
    Name = "name",
    Minusname = "-name",
    Plusname = "+name",
    ScreensCount = "screensCount",
    MinusscreensCount = "-screensCount",
    PlusscreensCount = "+screensCount",
    ProjectsCount = "projectsCount",
    MinusprojectsCount = "-projectsCount",
    PlusprojectsCount = "+projectsCount",
}

export enum Expand {
    Name = "name",
    Minusname = "-name",
    Plusname = "+name",
    TrashDate = "trashDate",
    MinustrashDate = "-trashDate",
    PlustrashDate = "+trashDate",
    PlannedDeletionDate = "plannedDeletionDate",
    MinusplannedDeletionDate = "-plannedDeletionDate",
    PlusplannedDeletionDate = "+plannedDeletionDate",
    ProjectsCount = "projectsCount",
    MinusprojectsCount = "-projectsCount",
    PlusprojectsCount = "+projectsCount",
}

export enum OrderBy5 {
    Description = "description",
    Minusdescription = "-description",
    Plusdescription = "+description",
    Favourite_count = "favourite_count",
    Minusfavourite_count = "-favourite_count",
    Plusfavourite_count = "+favourite_count",
    Id = "id",
    Minusid = "-id",
    Plusid = "+id",
    Is_favourite = "is_favourite",
    Minusis_favourite = "-is_favourite",
    Plusis_favourite = "+is_favourite",
    Name = "name",
    Minusname = "-name",
    Plusname = "+name",
    Owner = "owner",
    Minusowner = "-owner",
    Plusowner = "+owner",
    Is_shared = "is_shared",
    Minusis_shared = "-is_shared",
    Plusis_shared = "+is_shared",
}

export enum AvatarSize {
    Xsmall = "xsmall",
    Xsmall_2x = "xsmall@2x",
    Xsmall_3x = "xsmall@3x",
    Small = "small",
    Small_2x = "small@2x",
    Small_3x = "small@3x",
    Medium = "medium",
    Medium_2x = "medium@2x",
    Medium_3x = "medium@3x",
    Large = "large",
    Large_2x = "large@2x",
    Large_3x = "large@3x",
    Xlarge = "xlarge",
    Xlarge_2x = "xlarge@2x",
    Xlarge_3x = "xlarge@3x",
    Xxlarge = "xxlarge",
    Xxlarge_2x = "xxlarge@2x",
    Xxlarge_3x = "xxlarge@3x",
    Xxxlarge = "xxxlarge",
    Xxxlarge_2x = "xxxlarge@2x",
    Xxxlarge_3x = "xxxlarge@3x",
}

export enum DeleteSubtasks {
    True = "true",
    False = "false",
}

export enum OrderBy6 {
    Created = "created",
    Minuscreated = "-created",
    Pluscreated = "+created",
}

export enum AdjustEstimate {
    Leave = "leave",
    Auto = "auto",
}

export enum AdjustEstimate2 {
    New = "new",
    Leave = "leave",
    Manual = "manual",
    Auto = "auto",
}

export enum AdjustEstimate3 {
    Leave = "leave",
    Auto = "auto",
}

export enum AdjustEstimate4 {
    New = "new",
    Leave = "leave",
    Manual = "manual",
    Auto = "auto",
}

export enum AdjustEstimate5 {
    New = "new",
    Leave = "leave",
    Manual = "manual",
    Auto = "auto",
}

export enum OrderBy7 {
    Name = "name",
    Minusname = "-name",
    Plusname = "+name",
    Id = "id",
    Minusid = "-id",
    Plusid = "+id",
}

export enum OrderBy8 {
    Name = "name",
    Minusname = "-name",
    Plusname = "+name",
    Id = "id",
    Minusid = "-id",
    Plusid = "+id",
}

export enum Validation {
    Strict = "strict",
    Warn = "warn",
    None = "none",
}

export enum ApplicationKey {
    JiraCore = "jira-core",
    JiraProductDiscovery = "jira-product-discovery",
    JiraSoftware = "jira-software",
    JiraServicedesk = "jira-servicedesk",
}

export enum OrderBy9 {
    Name = "name",
    Plusname = "+name",
    Minusname = "-name",
}

export enum OrderBy10 {
    Category = "category",
    Minuscategory = "-category",
    Pluscategory = "+category",
    Key = "key",
    Minuskey = "-key",
    Pluskey = "+key",
    Name = "name",
    Minusname = "-name",
    Plusname = "+name",
    Owner = "owner",
    Minusowner = "-owner",
    Plusowner = "+owner",
    IssueCount = "issueCount",
    MinusissueCount = "-issueCount",
    PlusissueCount = "+issueCount",
    LastIssueUpdatedDate = "lastIssueUpdatedDate",
    MinuslastIssueUpdatedDate = "-lastIssueUpdatedDate",
    PluslastIssueUpdatedDate = "+lastIssueUpdatedDate",
    ArchivedDate = "archivedDate",
    PlusarchivedDate = "+archivedDate",
    MinusarchivedDate = "-archivedDate",
    DeletedDate = "deletedDate",
    PlusdeletedDate = "+deletedDate",
    MinusdeletedDate = "-deletedDate",
}

export enum Action {
    View = "view",
    Browse = "browse",
    Edit = "edit",
    Create = "create",
}

export enum Status4 {
    Live = "live",
    Archived = "archived",
    Deleted = "deleted",
}

export enum ProjectTypeKey {
    Software = "software",
    Service_desk = "service_desk",
    Business = "business",
    Product_discovery = "product_discovery",
}

export enum ProjectTypeKey2 {
    Software = "software",
    Service_desk = "service_desk",
    Business = "business",
    Product_discovery = "product_discovery",
}

export enum OrderBy11 {
    Description = "description",
    Minusdescription = "-description",
    Plusdescription = "+description",
    IssueCount = "issueCount",
    MinusissueCount = "-issueCount",
    PlusissueCount = "+issueCount",
    Lead = "lead",
    Minuslead = "-lead",
    Pluslead = "+lead",
    Name = "name",
    Minusname = "-name",
    Plusname = "+name",
}

export enum ComponentSource {
    Jira = "jira",
    Compass = "compass",
    Auto = "auto",
}

export enum ComponentSource2 {
    Jira = "jira",
    Compass = "compass",
    Auto = "auto",
}

export enum OrderBy12 {
    Description = "description",
    Minusdescription = "-description",
    Plusdescription = "+description",
    Name = "name",
    Minusname = "-name",
    Plusname = "+name",
    ReleaseDate = "releaseDate",
    MinusreleaseDate = "-releaseDate",
    PlusreleaseDate = "+releaseDate",
    Sequence = "sequence",
    Minussequence = "-sequence",
    Plussequence = "+sequence",
    StartDate = "startDate",
    MinusstartDate = "-startDate",
    PlusstartDate = "+startDate",
}

export enum Scope2 {
    GLOBAL = "GLOBAL",
    TEMPLATE = "TEMPLATE",
    PROJECT = "PROJECT",
}

export enum OrderBy13 {
    Name = "name",
    Minusname = "-name",
    Plusname = "+name",
    Id = "id",
    Minusid = "-id",
    Plusid = "+id",
}

export enum OrderBy14 {
    Name = "name",
    Minusname = "-name",
    Plusname = "+name",
    Id = "id",
    Minusid = "-id",
    Plusid = "+id",
}

export enum ValidateQuery {
    Strict = "strict",
    Warn = "warn",
    None = "none",
    True = "true",
    False = "false",
}

export enum Type3 {
    Project = "project",
    Issuetype = "issuetype",
    Priority = "priority",
}

export enum Type4 {
    Project = "project",
    Issuetype = "issuetype",
    Priority = "priority",
}

export enum Type5 {
    Project = "project",
    Issuetype = "issuetype",
    Priority = "priority",
}

export enum Type6 {
    Issuetype = "issuetype",
    Project = "project",
    Priority = "priority",
}

export enum Size {
    Xsmall = "xsmall",
    Small = "small",
    Medium = "medium",
    Large = "large",
    Xlarge = "xlarge",
}

export enum Format {
    Png = "png",
    Svg = "svg",
}

export enum Type7 {
    Issuetype = "issuetype",
    Project = "project",
    Priority = "priority",
}

export enum Size2 {
    Xsmall = "xsmall",
    Small = "small",
    Medium = "medium",
    Large = "large",
    Xlarge = "xlarge",
}

export enum Format2 {
    Png = "png",
    Svg = "svg",
}

export enum Type8 {
    Issuetype = "issuetype",
    Project = "project",
    Priority = "priority",
}

export enum Size3 {
    Xsmall = "xsmall",
    Small = "small",
    Medium = "medium",
    Large = "large",
    Xlarge = "xlarge",
}

export enum Format3 {
    Png = "png",
    Svg = "svg",
}

export enum Types {
    Postfunction = "postfunction",
    Condition = "condition",
    Validator = "validator",
}

export enum OrderBy15 {
    Name = "name",
    Minusname = "-name",
    Plusname = "+name",
    Created = "created",
    Minuscreated = "-created",
    Pluscreated = "+created",
    Updated = "updated",
    Plusupdated = "+updated",
    Minusupdated = "-updated",
}

export enum WorkflowMode {
    Live = "live",
    Draft = "draft",
}

export enum WorkflowMode2 {
    Live = "live",
    Draft = "draft",
}

export enum WorkflowMode3 {
    Live = "live",
    Draft = "draft",
}

export enum WorkflowMode4 {
    Live = "live",
    Draft = "draft",
}

export enum EntityType {
    IssueProperty = "IssueProperty",
    CommentProperty = "CommentProperty",
    DashboardItemProperty = "DashboardItemProperty",
    IssueTypeProperty = "IssueTypeProperty",
    ProjectProperty = "ProjectProperty",
    UserProperty = "UserProperty",
    WorklogProperty = "WorklogProperty",
    BoardProperty = "BoardProperty",
    SprintProperty = "SprintProperty",
}

export enum AddAtlassianTeamRequestPlanningStyle {
    Scrum = "Scrum",
    Kanban = "Kanban",
}

export enum AnnouncementBannerConfigurationVisibility {
    PUBLIC = "PUBLIC",
    PRIVATE = "PRIVATE",
}

export enum ApprovalConfigurationActive {
    True = "true",
    False = "false",
}

export enum ApprovalConfigurationConditionType {
    Number = "number",
    Percent = "percent",
    NumberPerPrincipal = "numberPerPrincipal",
}

export enum ApprovalConfigurationExclude {
    Assignee = "assignee",
    Reporter = "reporter",
}

/** A list of roles that should be excluded as possible approvers. */
export enum Exclude {
    Assignee = "assignee",
    Reporter = "reporter",
}

export enum AvailableWorkflowConnectRuleRuleType {
    Condition = "Condition",
    Validator = "Validator",
    Function = "Function",
    Screen = "Screen",
}

export enum AvailableWorkflowForgeRuleRuleType {
    Condition = "Condition",
    Validator = "Validator",
    Function = "Function",
    Screen = "Screen",
}

export enum AvailableWorkflowSystemRuleRuleType {
    Condition = "Condition",
    Validator = "Validator",
    Function = "Function",
    Screen = "Screen",
}

export enum BoardFeaturePayloadFeatureKey {
    ESTIMATION = "ESTIMATION",
    SPRINT = "SPRINT",
}

export enum BoardPayloadCardColorStrategy {
    ISSUE_TYPE = "ISSUE_TYPE",
    REQUEST_TYPE = "REQUEST_TYPE",
    ASSIGNEE = "ASSIGNEE",
    PRIORITY = "PRIORITY",
    NONE = "NONE",
    CUSTOM = "CUSTOM",
}

export enum BulkEditShareableEntityRequestAction {
    ChangeOwner = "changeOwner",
    ChangePermission = "changePermission",
    AddPermission = "addPermission",
    RemovePermission = "removePermission",
}

export enum BulkEditShareableEntityResponseAction {
    ChangeOwner = "changeOwner",
    ChangePermission = "changePermission",
    AddPermission = "addPermission",
    RemovePermission = "removePermission",
}

export enum BulkOperationProgressStatus {
    ENQUEUED = "ENQUEUED",
    RUNNING = "RUNNING",
    COMPLETE = "COMPLETE",
    FAILED = "FAILED",
    CANCEL_REQUESTED = "CANCEL_REQUESTED",
    CANCELLED = "CANCELLED",
    DEAD = "DEAD",
}

export enum CardLayoutFieldMode {
    PLAN = "PLAN",
    WORK = "WORK",
}

export enum ComponentWithIssueCountAssigneeType {
    PROJECT_DEFAULT = "PROJECT_DEFAULT",
    COMPONENT_LEAD = "COMPONENT_LEAD",
    PROJECT_LEAD = "PROJECT_LEAD",
    UNASSIGNED = "UNASSIGNED",
}

export enum ComponentWithIssueCountRealAssigneeType {
    PROJECT_DEFAULT = "PROJECT_DEFAULT",
    COMPONENT_LEAD = "COMPONENT_LEAD",
    PROJECT_LEAD = "PROJECT_LEAD",
    UNASSIGNED = "UNASSIGNED",
}

export enum CompoundClauseOperator {
    And = "and",
    Or = "or",
    Not = "not",
}

export enum ConditionGroupConfigurationOperation {
    ANY = "ANY",
    ALL = "ALL",
}

export enum ConditionGroupPayloadOperation {
    ANY = "ANY",
    ALL = "ALL",
}

export enum ConditionGroupUpdateOperation {
    ANY = "ANY",
    ALL = "ALL",
}

export enum ConnectCustomFieldValue_type {
    StringIssueField = "StringIssueField",
    NumberIssueField = "NumberIssueField",
    RichTextIssueField = "RichTextIssueField",
    SingleSelectIssueField = "SingleSelectIssueField",
    MultiSelectIssueField = "MultiSelectIssueField",
    TextIssueField = "TextIssueField",
}

export enum CreateDateFieldRequestType {
    DueDate = "DueDate",
    TargetStartDate = "TargetStartDate",
    TargetEndDate = "TargetEndDate",
    DateCustomField = "DateCustomField",
}

export enum CreateIssueSourceRequestType {
    Board = "Board",
    Project = "Project",
    Filter = "Filter",
}

export enum CreatePermissionHolderRequestType {
    Group = "Group",
    AccountId = "AccountId",
}

export enum CreatePermissionRequestType {
    View = "View",
    Edit = "Edit",
}

export enum CreatePlanOnlyTeamRequestPlanningStyle {
    Scrum = "Scrum",
    Kanban = "Kanban",
}

export enum CreatePriorityDetailsIconUrl {
    _images_icons_priorities_blocker_png = "/images/icons/priorities/blocker.png",
    _images_icons_priorities_critical_png = "/images/icons/priorities/critical.png",
    _images_icons_priorities_high_png = "/images/icons/priorities/high.png",
    _images_icons_priorities_highest_png = "/images/icons/priorities/highest.png",
    _images_icons_priorities_low_png = "/images/icons/priorities/low.png",
    _images_icons_priorities_lowest_png = "/images/icons/priorities/lowest.png",
    _images_icons_priorities_major_png = "/images/icons/priorities/major.png",
    _images_icons_priorities_medium_png = "/images/icons/priorities/medium.png",
    _images_icons_priorities_minor_png = "/images/icons/priorities/minor.png",
    _images_icons_priorities_trivial_png = "/images/icons/priorities/trivial.png",
    _images_icons_priorities_blocker_new_png = "/images/icons/priorities/blocker_new.png",
    _images_icons_priorities_critical_new_png = "/images/icons/priorities/critical_new.png",
    _images_icons_priorities_high_new_png = "/images/icons/priorities/high_new.png",
    _images_icons_priorities_highest_new_png = "/images/icons/priorities/highest_new.png",
    _images_icons_priorities_low_new_png = "/images/icons/priorities/low_new.png",
    _images_icons_priorities_lowest_new_png = "/images/icons/priorities/lowest_new.png",
    _images_icons_priorities_major_new_png = "/images/icons/priorities/major_new.png",
    _images_icons_priorities_medium_new_png = "/images/icons/priorities/medium_new.png",
    _images_icons_priorities_minor_new_png = "/images/icons/priorities/minor_new.png",
    _images_icons_priorities_trivial_new_png = "/images/icons/priorities/trivial_new.png",
}

export enum CreateProjectDetailsAssigneeType {
    PROJECT_LEAD = "PROJECT_LEAD",
    UNASSIGNED = "UNASSIGNED",
}

export enum CreateProjectDetailsProjectTemplateKey {
    Com_pyxis_greenhopper_jiraGhSimplifiedAgilityKanban = "com.pyxis.greenhopper.jira:gh-simplified-agility-kanban",
    Com_pyxis_greenhopper_jiraGhSimplifiedAgilityScrum = "com.pyxis.greenhopper.jira:gh-simplified-agility-scrum",
    Com_pyxis_greenhopper_jiraGhSimplifiedBasic = "com.pyxis.greenhopper.jira:gh-simplified-basic",
    Com_pyxis_greenhopper_jiraGhSimplifiedKanbanClassic = "com.pyxis.greenhopper.jira:gh-simplified-kanban-classic",
    Com_pyxis_greenhopper_jiraGhSimplifiedScrumClassic = "com.pyxis.greenhopper.jira:gh-simplified-scrum-classic",
    Com_pyxis_greenhopper_jiraGhCrossTeamTemplate = "com.pyxis.greenhopper.jira:gh-cross-team-template",
    Com_pyxis_greenhopper_jiraGhCrossTeamPlanningTemplate = "com.pyxis.greenhopper.jira:gh-cross-team-planning-template",
    Com_atlassian_servicedeskSimplifiedItServiceManagement = "com.atlassian.servicedesk:simplified-it-service-management",
    Com_atlassian_servicedeskSimplifiedItServiceManagementBasic = "com.atlassian.servicedesk:simplified-it-service-management-basic",
    Com_atlassian_servicedeskSimplifiedItServiceManagementOperations = "com.atlassian.servicedesk:simplified-it-service-management-operations",
    Com_atlassian_servicedeskSimplifiedGeneralServiceDesk = "com.atlassian.servicedesk:simplified-general-service-desk",
    Com_atlassian_servicedeskSimplifiedGeneralServiceDeskIt = "com.atlassian.servicedesk:simplified-general-service-desk-it",
    Com_atlassian_servicedeskSimplifiedGeneralServiceDeskBusiness = "com.atlassian.servicedesk:simplified-general-service-desk-business",
    Com_atlassian_servicedeskSimplifiedInternalServiceDesk = "com.atlassian.servicedesk:simplified-internal-service-desk",
    Com_atlassian_servicedeskSimplifiedExternalServiceDesk = "com.atlassian.servicedesk:simplified-external-service-desk",
    Com_atlassian_servicedeskSimplifiedHrServiceDesk = "com.atlassian.servicedesk:simplified-hr-service-desk",
    Com_atlassian_servicedeskSimplifiedFacilitiesServiceDesk = "com.atlassian.servicedesk:simplified-facilities-service-desk",
    Com_atlassian_servicedeskSimplifiedLegalServiceDesk = "com.atlassian.servicedesk:simplified-legal-service-desk",
    Com_atlassian_servicedeskSimplifiedMarketingServiceDesk = "com.atlassian.servicedesk:simplified-marketing-service-desk",
    Com_atlassian_servicedeskSimplifiedFinanceServiceDesk = "com.atlassian.servicedesk:simplified-finance-service-desk",
    Com_atlassian_servicedeskSimplifiedAnalyticsServiceDesk = "com.atlassian.servicedesk:simplified-analytics-service-desk",
    Com_atlassian_servicedeskSimplifiedDesignServiceDesk = "com.atlassian.servicedesk:simplified-design-service-desk",
    Com_atlassian_servicedeskSimplifiedSalesServiceDesk = "com.atlassian.servicedesk:simplified-sales-service-desk",
    Com_atlassian_servicedeskSimplifiedHalpServiceDesk = "com.atlassian.servicedesk:simplified-halp-service-desk",
    Com_atlassian_servicedeskSimplifiedBlankProjectIt = "com.atlassian.servicedesk:simplified-blank-project-it",
    Com_atlassian_servicedeskSimplifiedBlankProjectBusiness = "com.atlassian.servicedesk:simplified-blank-project-business",
    Com_atlassian_servicedeskNextGenItServiceDesk = "com.atlassian.servicedesk:next-gen-it-service-desk",
    Com_atlassian_servicedeskNextGenHrServiceDesk = "com.atlassian.servicedesk:next-gen-hr-service-desk",
    Com_atlassian_servicedeskNextGenLegalServiceDesk = "com.atlassian.servicedesk:next-gen-legal-service-desk",
    Com_atlassian_servicedeskNextGenMarketingServiceDesk = "com.atlassian.servicedesk:next-gen-marketing-service-desk",
    Com_atlassian_servicedeskNextGenFacilitiesServiceDesk = "com.atlassian.servicedesk:next-gen-facilities-service-desk",
    Com_atlassian_servicedeskNextGenGeneralServiceDesk = "com.atlassian.servicedesk:next-gen-general-service-desk",
    Com_atlassian_servicedeskNextGenGeneralItServiceDesk = "com.atlassian.servicedesk:next-gen-general-it-service-desk",
    Com_atlassian_servicedeskNextGenGeneralBusinessServiceDesk = "com.atlassian.servicedesk:next-gen-general-business-service-desk",
    Com_atlassian_servicedeskNextGenAnalyticsServiceDesk = "com.atlassian.servicedesk:next-gen-analytics-service-desk",
    Com_atlassian_servicedeskNextGenFinanceServiceDesk = "com.atlassian.servicedesk:next-gen-finance-service-desk",
    Com_atlassian_servicedeskNextGenDesignServiceDesk = "com.atlassian.servicedesk:next-gen-design-service-desk",
    Com_atlassian_servicedeskNextGenSalesServiceDesk = "com.atlassian.servicedesk:next-gen-sales-service-desk",
    Com_atlassian_jiraCoreProjectTemplatesJiraCoreSimplifiedContentManagement = "com.atlassian.jira-core-project-templates:jira-core-simplified-content-management",
    Com_atlassian_jiraCoreProjectTemplatesJiraCoreSimplifiedDocumentApproval = "com.atlassian.jira-core-project-templates:jira-core-simplified-document-approval",
    Com_atlassian_jiraCoreProjectTemplatesJiraCoreSimplifiedLeadTracking = "com.atlassian.jira-core-project-templates:jira-core-simplified-lead-tracking",
    Com_atlassian_jiraCoreProjectTemplatesJiraCoreSimplifiedProcessControl = "com.atlassian.jira-core-project-templates:jira-core-simplified-process-control",
    Com_atlassian_jiraCoreProjectTemplatesJiraCoreSimplifiedProcurement = "com.atlassian.jira-core-project-templates:jira-core-simplified-procurement",
    Com_atlassian_jiraCoreProjectTemplatesJiraCoreSimplifiedProjectManagement = "com.atlassian.jira-core-project-templates:jira-core-simplified-project-management",
    Com_atlassian_jiraCoreProjectTemplatesJiraCoreSimplifiedRecruitment = "com.atlassian.jira-core-project-templates:jira-core-simplified-recruitment",
    Com_atlassian_jiraCoreProjectTemplatesJiraCoreSimplifiedTask = "com.atlassian.jira-core-project-templates:jira-core-simplified-task-",
}

export enum CreateProjectDetailsProjectTypeKey {
    Software = "software",
    Service_desk = "service_desk",
    Business = "business",
}

export enum CreateSchedulingRequestDependencies {
    Sequential = "Sequential",
    Concurrent = "Concurrent",
}

export enum CreateSchedulingRequestEstimation {
    StoryPoints = "StoryPoints",
    Days = "Days",
    Hours = "Hours",
}

export enum CreateSchedulingRequestInferredDates {
    None = "None",
    SprintDates = "SprintDates",
    ReleaseDates = "ReleaseDates",
}

export enum CreateWorkflowConditionOperator {
    AND = "AND",
    OR = "OR",
}

export enum CreateWorkflowTransitionDetailsType {
    Global = "global",
    Initial = "initial",
    Directed = "directed",
}

export enum CustomFieldDefinitionJsonBeanSearcherKey {
    Com_atlassian_jira_plugin_system_customfieldtypesCascadingselectsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:cascadingselectsearcher",
    Com_atlassian_jira_plugin_system_customfieldtypesDaterange = "com.atlassian.jira.plugin.system.customfieldtypes:daterange",
    Com_atlassian_jira_plugin_system_customfieldtypesDatetimerange = "com.atlassian.jira.plugin.system.customfieldtypes:datetimerange",
    Com_atlassian_jira_plugin_system_customfieldtypesExactnumber = "com.atlassian.jira.plugin.system.customfieldtypes:exactnumber",
    Com_atlassian_jira_plugin_system_customfieldtypesExacttextsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:exacttextsearcher",
    Com_atlassian_jira_plugin_system_customfieldtypesGrouppickersearcher = "com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher",
    Com_atlassian_jira_plugin_system_customfieldtypesLabelsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:labelsearcher",
    Com_atlassian_jira_plugin_system_customfieldtypesMultiselectsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:multiselectsearcher",
    Com_atlassian_jira_plugin_system_customfieldtypesNumberrange = "com.atlassian.jira.plugin.system.customfieldtypes:numberrange",
    Com_atlassian_jira_plugin_system_customfieldtypesProjectsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:projectsearcher",
    Com_atlassian_jira_plugin_system_customfieldtypesTextsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:textsearcher",
    Com_atlassian_jira_plugin_system_customfieldtypesUserpickergroupsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:userpickergroupsearcher",
    Com_atlassian_jira_plugin_system_customfieldtypesVersionsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:versionsearcher",
}

export enum CustomFieldPayloadOnConflict {
    FAIL = "FAIL",
    USE = "USE",
    NEW = "NEW",
}

export enum CustomTemplatesProjectDetailsAccessLevel {
    Open = "open",
    Limited = "limited",
    Private = "private",
    Free = "free",
}

export enum CustomTemplatesProjectDetailsAssigneeType {
    PROJECT_DEFAULT = "PROJECT_DEFAULT",
    COMPONENT_LEAD = "COMPONENT_LEAD",
    PROJECT_LEAD = "PROJECT_LEAD",
    UNASSIGNED = "UNASSIGNED",
}

export enum DashboardGadgetColor {
    Blue = "blue",
    Red = "red",
    Yellow = "yellow",
    Green = "green",
    Cyan = "cyan",
    Purple = "purple",
    Gray = "gray",
    White = "white",
}

export enum DefaultShareScopeScope {
    GLOBAL = "GLOBAL",
    AUTHENTICATED = "AUTHENTICATED",
    PRIVATE = "PRIVATE",
}

export enum EventNotificationNotificationType {
    CurrentAssignee = "CurrentAssignee",
    Reporter = "Reporter",
    CurrentUser = "CurrentUser",
    ProjectLead = "ProjectLead",
    ComponentLead = "ComponentLead",
    User = "User",
    Group = "Group",
    ProjectRole = "ProjectRole",
    EmailAddress = "EmailAddress",
    AllWatchers = "AllWatchers",
    UserCustomField = "UserCustomField",
    GroupCustomField = "GroupCustomField",
}

export enum FieldChangedClauseOperator {
    Changed = "changed",
}

export enum FieldLastUsedType {
    TRACKED = "TRACKED",
    NOT_TRACKED = "NOT_TRACKED",
    NO_INFORMATION = "NO_INFORMATION",
}

export enum FieldReferenceDataAuto {
    True = "true",
    False = "false",
}

export enum FieldReferenceDataDeprecated {
    True = "true",
    False = "false",
}

export enum FieldReferenceDataOrderable {
    True = "true",
    False = "false",
}

export enum FieldReferenceDataSearchable {
    True = "true",
    False = "false",
}

export enum FieldValueClauseOperator {
    Eq = "=",
    Ne = "!=",
    Gt = ">",
    Lt = "<",
    Ge = ">=",
    Le = "<=",
    In = "in",
    Not_in = "not in",
    _ = "~",
    Approx = "~=",
    Is = "is",
    Is_not = "is not",
}

export enum FieldWasClauseOperator {
    Was = "was",
    Was_in = "was in",
    Was_not_in = "was not in",
    Was_not = "was not",
}

export enum FunctionReferenceDataIsList {
    True = "true",
    False = "false",
}

export enum FunctionReferenceDataSupportsListAndSingleValueOperators {
    True = "true",
    False = "false",
}

export enum GetAtlassianTeamResponsePlanningStyle {
    Scrum = "Scrum",
    Kanban = "Kanban",
}

export enum GetDateFieldResponseType {
    DueDate = "DueDate",
    TargetStartDate = "TargetStartDate",
    TargetEndDate = "TargetEndDate",
    DateCustomField = "DateCustomField",
}

export enum GetIssueSourceResponseType {
    Board = "Board",
    Project = "Project",
    Filter = "Filter",
    Custom = "Custom",
}

export enum GetPermissionHolderResponseType {
    Group = "Group",
    AccountId = "AccountId",
}

export enum GetPermissionResponseType {
    View = "View",
    Edit = "Edit",
}

export enum GetPlanOnlyTeamResponsePlanningStyle {
    Scrum = "Scrum",
    Kanban = "Kanban",
}

export enum GetPlanResponseStatus {
    Active = "Active",
    Trashed = "Trashed",
    Archived = "Archived",
}

export enum GetPlanResponseForPageStatus {
    Active = "Active",
    Trashed = "Trashed",
    Archived = "Archived",
}

export enum GetSchedulingResponseDependencies {
    Sequential = "Sequential",
    Concurrent = "Concurrent",
}

export enum GetSchedulingResponseEstimation {
    StoryPoints = "StoryPoints",
    Days = "Days",
    Hours = "Hours",
}

export enum GetSchedulingResponseInferredDates {
    None = "None",
    SprintDates = "SprintDates",
    ReleaseDates = "ReleaseDates",
}

export enum GetTeamResponseForPageType {
    PlanOnly = "PlanOnly",
    Atlassian = "Atlassian",
}

export enum Attributes {
    NotSelectable = "notSelectable",
    DefaultValue = "defaultValue",
}

export enum GroupLabelType {
    ADMIN = "ADMIN",
    SINGLE = "SINGLE",
    MULTIPLE = "MULTIPLE",
}

export enum MultiSelectFieldOptions {
    ADD = "ADD",
    REMOVE = "REMOVE",
    REPLACE = "REPLACE",
    REMOVE_ALL = "REMOVE_ALL",
}

export enum attributes {
    NotSelectable = "notSelectable",
    DefaultValue = "defaultValue",
}

export enum IssueLayouItemtPayloadSectionType {
    Content = "content",
    PrimaryContext = "primaryContext",
    SecondaryContext = "secondaryContext",
}

export enum IssueLayouItemtPayloadType {
    FIELD = "FIELD",
}

export enum IssueLayoutPayloadIssueLayoutType {
    ISSUE_VIEW = "ISSUE_VIEW",
    ISSUE_CREATE = "ISSUE_CREATE",
    REQUEST_FORM = "REQUEST_FORM",
}

export enum IssueTypeCreateBeanType {
    Subtask = "subtask",
    Standard = "standard",
}

export enum IssueTypeHierarchyPayloadOnConflict {
    FAIL = "FAIL",
    USE = "USE",
    NEW = "NEW",
}

export enum IssueTypePayloadOnConflict {
    FAIL = "FAIL",
    USE = "USE",
    NEW = "NEW",
}

export enum JexpJqlIssuesValidation {
    Strict = "strict",
    Warn = "warn",
    None = "none",
}

export enum JiraExpressionValidationErrorType {
    Syntax = "syntax",
    Type = "type",
    Other = "other",
}

export enum JiraLabelsFieldBulkEditMultiSelectFieldOption {
    ADD = "ADD",
    REMOVE = "REMOVE",
    REPLACE = "REPLACE",
    REMOVE_ALL = "REMOVE_ALL",
}

export enum JiraMultiSelectComponentFieldBulkEditMultiSelectFieldOption {
    ADD = "ADD",
    REMOVE = "REMOVE",
    REPLACE = "REPLACE",
    REMOVE_ALL = "REMOVE_ALL",
}

export enum JiraMultipleVersionPickerFieldBulkEditMultiSelectFieldOption {
    ADD = "ADD",
    REMOVE = "REMOVE",
    REPLACE = "REPLACE",
    REMOVE_ALL = "REMOVE_ALL",
}

export enum JiraStatusStatusCategory {
    TODO = "TODO",
    IN_PROGRESS = "IN_PROGRESS",
    DONE = "DONE",
}

export enum JiraWorkflowStatusStatusCategory {
    TODO = "TODO",
    IN_PROGRESS = "IN_PROGRESS",
    DONE = "DONE",
}

export enum JqlQueryClauseTimePredicateOperator {
    Before = "before",
    After = "after",
    From = "from",
    To = "to",
    On = "on",
    During = "during",
    By = "by",
}

export enum JqlQueryFieldEntityPropertyType {
    Number = "number",
    String = "string",
    Text = "text",
    Date = "date",
    User = "user",
}

export enum JqlQueryOrderByClauseElementDirection {
    Asc = "asc",
    Desc = "desc",
}

export enum JsonNodeNumberType {
    INT = "INT",
    LONG = "LONG",
    BIG_INTEGER = "BIG_INTEGER",
    FLOAT = "FLOAT",
    DOUBLE = "DOUBLE",
    BIG_DECIMAL = "BIG_DECIMAL",
}

export enum KeywordOperandKeyword {
    Empty = "empty",
}

export enum LicensedApplicationPlan {
    UNLICENSED = "UNLICENSED",
    FREE = "FREE",
    PAID = "PAID",
}

export enum MandatoryFieldValueType {
    Adf = "adf",
    Raw = "raw",
}

export enum MandatoryFieldValueForADFType {
    Adf = "adf",
    Raw = "raw",
}

export enum MoveFieldBeanPosition {
    Earlier = "Earlier",
    Later = "Later",
    First = "First",
    Last = "Last",
}

export enum NotificationSchemePayloadOnConflict {
    FAIL = "FAIL",
    USE = "USE",
    NEW = "NEW",
}

export enum OrderOfCustomFieldOptionsPosition {
    First = "First",
    Last = "Last",
}

export enum OrderOfIssueTypesPosition {
    First = "First",
    Last = "Last",
}

export enum PermissionPayloadDTOOnConflict {
    FAIL = "FAIL",
    USE = "USE",
    NEW = "NEW",
}

export enum ProjectAssigneeType {
    PROJECT_LEAD = "PROJECT_LEAD",
    UNASSIGNED = "UNASSIGNED",
}

export enum projectTypeKey {
    Software = "software",
    Service_desk = "service_desk",
    Business = "business",
}

export enum ProjectStyle {
    Classic = "classic",
    NextGen = "next-gen",
}

export enum ProjectComponentAssigneeType {
    PROJECT_DEFAULT = "PROJECT_DEFAULT",
    COMPONENT_LEAD = "COMPONENT_LEAD",
    PROJECT_LEAD = "PROJECT_LEAD",
    UNASSIGNED = "UNASSIGNED",
}

export enum ProjectComponentRealAssigneeType {
    PROJECT_DEFAULT = "PROJECT_DEFAULT",
    COMPONENT_LEAD = "COMPONENT_LEAD",
    PROJECT_LEAD = "PROJECT_LEAD",
    UNASSIGNED = "UNASSIGNED",
}

export enum ProjectCreateResourceIdentifierType {
    Id = "id",
    Ref = "ref",
}

export enum ProjectDetailsProjectTypeKey {
    Software = "software",
    Service_desk = "service_desk",
    Business = "business",
}

export enum ProjectFeatureState2 {
    ENABLED = "ENABLED",
    DISABLED = "DISABLED",
    COMING_SOON = "COMING_SOON",
}

export enum ProjectFeatureStateState {
    ENABLED = "ENABLED",
    DISABLED = "DISABLED",
    COMING_SOON = "COMING_SOON",
}

export enum ProjectPayloadProjectTypeKey {
    Software = "software",
    Business = "business",
    Service_desk = "service_desk",
    Product_discovery = "product_discovery",
}

export enum Attributes2 {
    NotSelectable = "notSelectable",
    DefaultValue = "defaultValue",
}

export enum RoleActorType {
    AtlassianGroupRoleActor = "atlassian-group-role-actor",
    AtlassianUserRoleActor = "atlassian-user-role-actor",
}

export enum RolePayloadOnConflict {
    FAIL = "FAIL",
    USE = "USE",
    NEW = "NEW",
}

export enum RolePayloadType {
    HIDDEN = "HIDDEN",
    VIEWABLE = "VIEWABLE",
    EDITABLE = "EDITABLE",
}

export enum ScopeType {
    PROJECT = "PROJECT",
    TEMPLATE = "TEMPLATE",
}

export enum ScopePayloadType {
    GLOBAL = "GLOBAL",
    PROJECT = "PROJECT",
}

export enum SearchRequestBeanValidateQuery {
    Strict = "strict",
    Warn = "warn",
    None = "none",
    True = "true",
    False = "false",
}

export enum SecurityLevelMemberPayloadType {
    Group = "group",
    Reporter = "reporter",
    Users = "users",
}

export enum SharePermissionType {
    User = "user",
    Group = "group",
    Project = "project",
    ProjectRole = "projectRole",
    Global = "global",
    Loggedin = "loggedin",
    Authenticated = "authenticated",
    ProjectUnknown = "project-unknown",
}

export enum SharePermissionInputBeanType {
    User = "user",
    Project = "project",
    Group = "group",
    ProjectRole = "projectRole",
    Global = "global",
    Authenticated = "authenticated",
}

export enum StatusCreateStatusCategory {
    TODO = "TODO",
    IN_PROGRESS = "IN_PROGRESS",
    DONE = "DONE",
}

export enum StatusMetadataCategory {
    TODO = "TODO",
    IN_PROGRESS = "IN_PROGRESS",
    DONE = "DONE",
}

export enum StatusPayloadOnConflict {
    FAIL = "FAIL",
    USE = "USE",
    NEW = "NEW",
}

export enum StatusPayloadStatusCategory {
    TODO = "TODO",
    IN_PROGRESS = "IN_PROGRESS",
    DONE = "DONE",
}

export enum StatusScopeType {
    PROJECT = "PROJECT",
    GLOBAL = "GLOBAL",
}

export enum StatusUpdateStatusCategory {
    TODO = "TODO",
    IN_PROGRESS = "IN_PROGRESS",
    DONE = "DONE",
}

export enum SwimlanesPayloadCustomSwimlanes {
    None__custom__parentChild__assignee__assigneeUnassignedFirst__epic__project__issueparent__issuechildren__request_type = "none, custom, parentChild, assignee, assigneeUnassignedFirst, epic, project, issueparent, issuechildren, request_type",
}

export enum SwimlanesPayloadSwimlaneStrategy {
    None = "none",
    Custom = "custom",
    ParentChild = "parentChild",
    Assignee = "assignee",
    AssigneeUnassignedFirst = "assigneeUnassignedFirst",
    Epic = "epic",
    Project = "project",
    Issueparent = "issueparent",
    Issuechildren = "issuechildren",
    Request_type = "request_type",
}

export enum TaskProgressBeanJsonNodeStatus {
    ENQUEUED = "ENQUEUED",
    RUNNING = "RUNNING",
    COMPLETE = "COMPLETE",
    FAILED = "FAILED",
    CANCEL_REQUESTED = "CANCEL_REQUESTED",
    CANCELLED = "CANCELLED",
    DEAD = "DEAD",
}

export enum TaskProgressBeanObjectStatus {
    ENQUEUED = "ENQUEUED",
    RUNNING = "RUNNING",
    COMPLETE = "COMPLETE",
    FAILED = "FAILED",
    CANCEL_REQUESTED = "CANCEL_REQUESTED",
    CANCELLED = "CANCELLED",
    DEAD = "DEAD",
}

export enum TaskProgressBeanRemoveOptionFromIssuesResultStatus {
    ENQUEUED = "ENQUEUED",
    RUNNING = "RUNNING",
    COMPLETE = "COMPLETE",
    FAILED = "FAILED",
    CANCEL_REQUESTED = "CANCEL_REQUESTED",
    CANCELLED = "CANCELLED",
    DEAD = "DEAD",
}

export enum TimeTrackingConfigurationDefaultUnit {
    Minute = "minute",
    Hour = "hour",
    Day = "day",
    Week = "week",
}

export enum TimeTrackingConfigurationTimeFormat {
    Pretty = "pretty",
    Days = "days",
    Hours = "hours",
}

export enum TransitionType {
    Global = "global",
    Initial = "initial",
    Directed = "directed",
}

export enum TransitionPayloadType {
    Global = "global",
    Initial = "initial",
    Directed = "directed",
}

export enum TransitionUpdateDTOType {
    INITIAL = "INITIAL",
    GLOBAL = "GLOBAL",
    DIRECTED = "DIRECTED",
}

export enum UiModificationContextDetailsViewType {
    GIC = "GIC",
    IssueView = "IssueView",
    IssueTransition = "IssueTransition",
}

export enum UpdateCustomFieldDetailsSearcherKey {
    Com_atlassian_jira_plugin_system_customfieldtypesCascadingselectsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:cascadingselectsearcher",
    Com_atlassian_jira_plugin_system_customfieldtypesDaterange = "com.atlassian.jira.plugin.system.customfieldtypes:daterange",
    Com_atlassian_jira_plugin_system_customfieldtypesDatetimerange = "com.atlassian.jira.plugin.system.customfieldtypes:datetimerange",
    Com_atlassian_jira_plugin_system_customfieldtypesExactnumber = "com.atlassian.jira.plugin.system.customfieldtypes:exactnumber",
    Com_atlassian_jira_plugin_system_customfieldtypesExacttextsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:exacttextsearcher",
    Com_atlassian_jira_plugin_system_customfieldtypesGrouppickersearcher = "com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher",
    Com_atlassian_jira_plugin_system_customfieldtypesLabelsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:labelsearcher",
    Com_atlassian_jira_plugin_system_customfieldtypesMultiselectsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:multiselectsearcher",
    Com_atlassian_jira_plugin_system_customfieldtypesNumberrange = "com.atlassian.jira.plugin.system.customfieldtypes:numberrange",
    Com_atlassian_jira_plugin_system_customfieldtypesProjectsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:projectsearcher",
    Com_atlassian_jira_plugin_system_customfieldtypesTextsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:textsearcher",
    Com_atlassian_jira_plugin_system_customfieldtypesUserpickergroupsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:userpickergroupsearcher",
    Com_atlassian_jira_plugin_system_customfieldtypesVersionsearcher = "com.atlassian.jira.plugin.system.customfieldtypes:versionsearcher",
}

export enum UpdatePriorityDetailsIconUrl {
    _images_icons_priorities_blocker_png = "/images/icons/priorities/blocker.png",
    _images_icons_priorities_critical_png = "/images/icons/priorities/critical.png",
    _images_icons_priorities_high_png = "/images/icons/priorities/high.png",
    _images_icons_priorities_highest_png = "/images/icons/priorities/highest.png",
    _images_icons_priorities_low_png = "/images/icons/priorities/low.png",
    _images_icons_priorities_lowest_png = "/images/icons/priorities/lowest.png",
    _images_icons_priorities_major_png = "/images/icons/priorities/major.png",
    _images_icons_priorities_medium_png = "/images/icons/priorities/medium.png",
    _images_icons_priorities_minor_png = "/images/icons/priorities/minor.png",
    _images_icons_priorities_trivial_png = "/images/icons/priorities/trivial.png",
    _images_icons_priorities_blocker_new_png = "/images/icons/priorities/blocker_new.png",
    _images_icons_priorities_critical_new_png = "/images/icons/priorities/critical_new.png",
    _images_icons_priorities_high_new_png = "/images/icons/priorities/high_new.png",
    _images_icons_priorities_highest_new_png = "/images/icons/priorities/highest_new.png",
    _images_icons_priorities_low_new_png = "/images/icons/priorities/low_new.png",
    _images_icons_priorities_lowest_new_png = "/images/icons/priorities/lowest_new.png",
    _images_icons_priorities_major_new_png = "/images/icons/priorities/major_new.png",
    _images_icons_priorities_medium_new_png = "/images/icons/priorities/medium_new.png",
    _images_icons_priorities_minor_new_png = "/images/icons/priorities/minor_new.png",
    _images_icons_priorities_trivial_new_png = "/images/icons/priorities/trivial_new.png",
}

export enum UpdateProjectDetailsAssigneeType {
    PROJECT_LEAD = "PROJECT_LEAD",
    UNASSIGNED = "UNASSIGNED",
}

export enum UserAccountType {
    Atlassian = "atlassian",
    App = "app",
    Customer = "customer",
    Unknown = "unknown",
}

export enum UserPermissionType {
    GLOBAL = "GLOBAL",
    PROJECT = "PROJECT",
}

export enum Levels {
    WARNING = "WARNING",
    ERROR = "ERROR",
}

export enum levels {
    WARNING = "WARNING",
    ERROR = "ERROR",
}

export enum VersionMoveBeanPosition {
    Earlier = "Earlier",
    Later = "Later",
    First = "First",
    Last = "Last",
}

export enum VisibilityType {
    Group = "group",
    Role = "role",
}

export enum Events {
    JiraIssue_created = "jira:issue_created",
    JiraIssue_updated = "jira:issue_updated",
    JiraIssue_deleted = "jira:issue_deleted",
    Comment_created = "comment_created",
    Comment_updated = "comment_updated",
    Comment_deleted = "comment_deleted",
    Issue_property_set = "issue_property_set",
    Issue_property_deleted = "issue_property_deleted",
}

export enum events {
    JiraIssue_created = "jira:issue_created",
    JiraIssue_updated = "jira:issue_updated",
    JiraIssue_deleted = "jira:issue_deleted",
    Comment_created = "comment_created",
    Comment_updated = "comment_updated",
    Comment_deleted = "comment_deleted",
    Issue_property_set = "issue_property_set",
    Issue_property_deleted = "issue_property_deleted",
}

export enum WorkflowCapabilitiesEditorScope {
    PROJECT = "PROJECT",
    GLOBAL = "GLOBAL",
}

export enum ProjectTypes {
    Software = "software",
    Service_desk = "service_desk",
    Product_discovery = "product_discovery",
    Business = "business",
    Unknown = "unknown",
}

export enum WorkflowCompoundConditionOperator {
    AND = "AND",
    OR = "OR",
}

export enum WorkflowPayloadOnConflict {
    FAIL = "FAIL",
    USE = "USE",
    NEW = "NEW",
}

export enum WorkflowScopeType {
    PROJECT = "PROJECT",
    GLOBAL = "GLOBAL",
}

export enum WorkflowStatusUpdateStatusCategory {
    TODO = "TODO",
    IN_PROGRESS = "IN_PROGRESS",
    DONE = "DONE",
}

export enum WorkflowTransitionsType {
    INITIAL = "INITIAL",
    GLOBAL = "GLOBAL",
    DIRECTED = "DIRECTED",
}

export enum WorkflowValidationErrorLevel {
    WARNING = "WARNING",
    ERROR = "ERROR",
}

export enum WorkflowValidationErrorType {
    RULE = "RULE",
    STATUS = "STATUS",
    STATUS_LAYOUT = "STATUS_LAYOUT",
    STATUS_PROPERTY = "STATUS_PROPERTY",
    WORKFLOW = "WORKFLOW",
    TRANSITION = "TRANSITION",
    TRANSITION_PROPERTY = "TRANSITION_PROPERTY",
    SCOPE = "SCOPE",
    STATUS_MAPPING = "STATUS_MAPPING",
    TRIGGER = "TRIGGER",
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(q: ng.IQService, message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): ng.IPromise<any> {
    if (result !== null && result !== undefined)
        return q.reject(result);
    else
        return q.reject(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: Blob, q: ng.IQService): ng.IPromise<string> {
    return new q((resolve) => {
        let reader = new FileReader();
        reader.onload = event => resolve((event.target as any).result);
        reader.readAsText(blob);
    });
}