/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.4.3.0 (NJsonSchema v9.4.10.0) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, OpaqueToken } from '@angular/core';
import { Http, Headers, ResponseContentType, Response } from '@angular/http';

export const API_BASE_URL = new OpaqueToken('API_BASE_URL');

@Injectable()
export class GitHubClient {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.github.com";
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    emojis(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Emojis> {
        let url_ = this.baseUrl + "/emojis";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processEmojis(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processEmojis(response_);
                } catch (e) {
                    return <Observable<Emojis>><any>Observable.throw(e);
                }
            } else
                return <Observable<Emojis>><any>Observable.throw(response_);
        });
    }

    protected processEmojis(response: Response): Observable<Emojis> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Emojis | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Emojis.fromJS(resultData200) : new Emojis();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Emojis>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    events(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Events> {
        let url_ = this.baseUrl + "/events";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processEvents(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processEvents(response_);
                } catch (e) {
                    return <Observable<Events>><any>Observable.throw(e);
                }
            } else
                return <Observable<Events>><any>Observable.throw(response_);
        });
    }

    protected processEvents(response: Response): Observable<Events> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Events | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Events>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    feeds(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Feeds> {
        let url_ = this.baseUrl + "/feeds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processFeeds(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processFeeds(response_);
                } catch (e) {
                    return <Observable<Feeds>><any>Observable.throw(e);
                }
            } else
                return <Observable<Feeds>><any>Observable.throw(response_);
        });
    }

    protected processFeeds(response: Response): Observable<Feeds> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Feeds | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Feeds.fromJS(resultData200) : new Feeds();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Feeds>(<any>null);
    }

    /**
     * @since Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
Only gists updated at or after this time are returned.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    gistsAll(since: string | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous[]> {
        let url_ = this.baseUrl + "/gists?";
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGistsAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGistsAll(response_);
                } catch (e) {
                    return <Observable<Anonymous[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous[]>><any>Observable.throw(response_);
        });
    }

    protected processGistsAll(response: Response): Observable<Anonymous[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous[]>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    gists(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: PostGist): Observable<Gist> {
        let url_ = this.baseUrl + "/gists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGists(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGists(response_);
                } catch (e) {
                    return <Observable<Gist>><any>Observable.throw(e);
                }
            } else
                return <Observable<Gist>><any>Observable.throw(response_);
        });
    }

    protected processGists(response: Response): Observable<Gist> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Gist | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Gist.fromJS(resultData201) : new Gist();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Gist>(<any>null);
    }

    /**
     * @since Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
Only gists updated at or after this time are returned.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    publicAll(since: string | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous[]> {
        let url_ = this.baseUrl + "/gists/public?";
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPublicAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPublicAll(response_);
                } catch (e) {
                    return <Observable<Anonymous[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous[]>><any>Observable.throw(response_);
        });
    }

    protected processPublicAll(response: Response): Observable<Anonymous[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous[]>(<any>null);
    }

    /**
     * @since Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
Only gists updated at or after this time are returned.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    starredAll(since: string | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous[]> {
        let url_ = this.baseUrl + "/gists/starred?";
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processStarredAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processStarredAll(response_);
                } catch (e) {
                    return <Observable<Anonymous[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous[]>><any>Observable.throw(response_);
        });
    }

    protected processStarredAll(response: Response): Observable<Anonymous[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous[]>(<any>null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    gists2(id: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/gists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGists2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGists2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processGists2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    gists3(id: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Gist> {
        let url_ = this.baseUrl + "/gists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGists3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGists3(response_);
                } catch (e) {
                    return <Observable<Gist>><any>Observable.throw(e);
                }
            } else
                return <Observable<Gist>><any>Observable.throw(response_);
        });
    }

    protected processGists3(response: Response): Observable<Gist> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Gist | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Gist.fromJS(resultData200) : new Gist();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Gist>(<any>null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    gists4(id: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: PatchGist): Observable<Gist> {
        let url_ = this.baseUrl + "/gists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGists4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGists4(response_);
                } catch (e) {
                    return <Observable<Gist>><any>Observable.throw(e);
                }
            } else
                return <Observable<Gist>><any>Observable.throw(response_);
        });
    }

    protected processGists4(response: Response): Observable<Gist> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Gist | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Gist.fromJS(resultData200) : new Gist();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Gist>(<any>null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    commentsAll(id: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous2[]> {
        let url_ = this.baseUrl + "/gists/{id}/comments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processCommentsAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCommentsAll(response_);
                } catch (e) {
                    return <Observable<Anonymous2[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous2[]>><any>Observable.throw(response_);
        });
    }

    protected processCommentsAll(response: Response): Observable<Anonymous2[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous2[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous2.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous2[]>(<any>null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    comments(id: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: CommentBody): Observable<Comment> {
        let url_ = this.baseUrl + "/gists/{id}/comments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments(response_);
                } catch (e) {
                    return <Observable<Comment>><any>Observable.throw(e);
                }
            } else
                return <Observable<Comment>><any>Observable.throw(response_);
        });
    }

    protected processComments(response: Response): Observable<Comment> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Comment | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Comment.fromJS(resultData201) : new Comment();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Comment>(<any>null);
    }

    /**
     * @id Id of gist.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    comments2(id: number, commentId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/gists/{id}/comments/{commentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processComments2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id Id of gist.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments3(id: number, commentId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Comment> {
        let url_ = this.baseUrl + "/gists/{id}/comments/{commentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments3(response_);
                } catch (e) {
                    return <Observable<Comment>><any>Observable.throw(e);
                }
            } else
                return <Observable<Comment>><any>Observable.throw(response_);
        });
    }

    protected processComments3(response: Response): Observable<Comment> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Comment | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Comment.fromJS(resultData200) : new Comment();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Comment>(<any>null);
    }

    /**
     * @id Id of gist.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments4(id: number, commentId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: Comment): Observable<Comment> {
        let url_ = this.baseUrl + "/gists/{id}/comments/{commentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments4(response_);
                } catch (e) {
                    return <Observable<Comment>><any>Observable.throw(e);
                }
            } else
                return <Observable<Comment>><any>Observable.throw(response_);
        });
    }

    protected processComments4(response: Response): Observable<Comment> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Comment | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Comment.fromJS(resultData200) : new Comment();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Comment>(<any>null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Exists.
     */
    forks(id: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/gists/{id}/forks";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processForks(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processForks(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processForks(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Item removed.
     */
    star(id: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/gists/{id}/star";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processStar(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processStar(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processStar(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Exists.
     */
    star2(id: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/gists/{id}/star";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processStar2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processStar2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processStar2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id Id of gist.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Starred.
     */
    star3(id: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/gists/{id}/star";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "put",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processStar3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processStar3(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processStar3(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    templatesAll(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<any[]> {
        let url_ = this.baseUrl + "/gitignore/templates";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTemplatesAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTemplatesAll(response_);
                } catch (e) {
                    return <Observable<any[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<any[]>><any>Observable.throw(response_);
        });
    }

    protected processTemplatesAll(response: Response): Observable<any[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<any[]>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    templates(language: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<GitignoreLang> {
        let url_ = this.baseUrl + "/gitignore/templates/{language}";
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTemplates(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTemplates(response_);
                } catch (e) {
                    return <Observable<GitignoreLang>><any>Observable.throw(e);
                }
            } else
                return <Observable<GitignoreLang>><any>Observable.throw(response_);
        });
    }

    protected processTemplates(response: Response): Observable<GitignoreLang> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: GitignoreLang | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GitignoreLang.fromJS(resultData200) : new GitignoreLang();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GitignoreLang>(<any>null);
    }

    /**
     * @filter Issues assigned to you / created by you / mentioning you / you're
subscribed to updates for / All issues the authenticated user can see
     * @labels String list of comma separated Label names. Example - bug,ui,@high.
     * @since Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Only issues updated at or after this time are returned.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    issuesAll(filter: Filter, state: State, labels: string, sort: Sort, direction: Direction, since: string | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous3[]> {
        let url_ = this.baseUrl + "/issues?";
        if (filter === undefined || filter === null)
            throw new Error("The parameter 'filter' must be defined and cannot be null.");
        else
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined and cannot be null.");
        else
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (labels === undefined || labels === null)
            throw new Error("The parameter 'labels' must be defined and cannot be null.");
        else
            url_ += "labels=" + encodeURIComponent("" + labels) + "&"; 
        if (sort === undefined || sort === null)
            throw new Error("The parameter 'sort' must be defined and cannot be null.");
        else
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        if (direction === undefined || direction === null)
            throw new Error("The parameter 'direction' must be defined and cannot be null.");
        else
            url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processIssuesAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processIssuesAll(response_);
                } catch (e) {
                    return <Observable<Anonymous3[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous3[]>><any>Observable.throw(response_);
        });
    }

    protected processIssuesAll(response: Response): Observable<Anonymous3[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous3[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous3.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous3[]>(<any>null);
    }

    /**
     * @keyword The search term.
     * @state Indicates the state of the issues to return. Can be either open or closed.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    search(keyword: string, state: State2, owner: string, repository: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<SearchIssuesByKeyword> {
        let url_ = this.baseUrl + "/legacy/issues/search/{owner}/{repository}/{state}/{keyword}";
        if (keyword === undefined || keyword === null)
            throw new Error("The parameter 'keyword' must be defined.");
        url_ = url_.replace("{keyword}", encodeURIComponent("" + keyword)); 
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined.");
        url_ = url_.replace("{state}", encodeURIComponent("" + state)); 
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repository === undefined || repository === null)
            throw new Error("The parameter 'repository' must be defined.");
        url_ = url_.replace("{repository}", encodeURIComponent("" + repository)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSearch(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearch(response_);
                } catch (e) {
                    return <Observable<SearchIssuesByKeyword>><any>Observable.throw(e);
                }
            } else
                return <Observable<SearchIssuesByKeyword>><any>Observable.throw(response_);
        });
    }

    protected processSearch(response: Response): Observable<SearchIssuesByKeyword> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: SearchIssuesByKeyword | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SearchIssuesByKeyword.fromJS(resultData200) : new SearchIssuesByKeyword();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SearchIssuesByKeyword>(<any>null);
    }

    /**
     * @keyword The search term
     * @order The sort field. if sort param is provided. Can be either asc or desc.
     * @language Filter results by language
     * @start_page The page number to fetch
     * @sort The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    search2(keyword: string, order: Order | null, language: string | null, start_page: string | null, sort: Sort2 | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<SearchRepositoriesByKeyword> {
        let url_ = this.baseUrl + "/legacy/repos/search/{keyword}?";
        if (keyword === undefined || keyword === null)
            throw new Error("The parameter 'keyword' must be defined.");
        url_ = url_.replace("{keyword}", encodeURIComponent("" + keyword)); 
        if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&"; 
        if (language !== undefined)
            url_ += "language=" + encodeURIComponent("" + language) + "&"; 
        if (start_page !== undefined)
            url_ += "start_page=" + encodeURIComponent("" + start_page) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSearch2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearch2(response_);
                } catch (e) {
                    return <Observable<SearchRepositoriesByKeyword>><any>Observable.throw(e);
                }
            } else
                return <Observable<SearchRepositoriesByKeyword>><any>Observable.throw(response_);
        });
    }

    protected processSearch2(response: Response): Observable<SearchRepositoriesByKeyword> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: SearchRepositoriesByKeyword | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SearchRepositoriesByKeyword.fromJS(resultData200) : new SearchRepositoriesByKeyword();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SearchRepositoriesByKeyword>(<any>null);
    }

    /**
     * @email The email address
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    email(email: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<SearchUserByEmail> {
        let url_ = this.baseUrl + "/legacy/user/email/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processEmail(response_);
                } catch (e) {
                    return <Observable<SearchUserByEmail>><any>Observable.throw(e);
                }
            } else
                return <Observable<SearchUserByEmail>><any>Observable.throw(response_);
        });
    }

    protected processEmail(response: Response): Observable<SearchUserByEmail> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: SearchUserByEmail | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SearchUserByEmail.fromJS(resultData200) : new SearchUserByEmail();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SearchUserByEmail>(<any>null);
    }

    /**
     * @keyword The search term
     * @order The sort field. if sort param is provided. Can be either asc or desc.
     * @start_page The page number to fetch
     * @sort The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    search3(keyword: string, order: Order2 | null, start_page: string | null, sort: Sort3 | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<SearchUsersByKeyword> {
        let url_ = this.baseUrl + "/legacy/user/search/{keyword}?";
        if (keyword === undefined || keyword === null)
            throw new Error("The parameter 'keyword' must be defined.");
        url_ = url_.replace("{keyword}", encodeURIComponent("" + keyword)); 
        if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&"; 
        if (start_page !== undefined)
            url_ += "start_page=" + encodeURIComponent("" + start_page) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSearch3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSearch3(response_);
                } catch (e) {
                    return <Observable<SearchUsersByKeyword>><any>Observable.throw(e);
                }
            } else
                return <Observable<SearchUsersByKeyword>><any>Observable.throw(response_);
        });
    }

    protected processSearch3(response: Response): Observable<SearchUsersByKeyword> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: SearchUsersByKeyword | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SearchUsersByKeyword.fromJS(resultData200) : new SearchUsersByKeyword();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SearchUsersByKeyword>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    markdown(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: Markdown): Observable<void> {
        let url_ = this.baseUrl + "/markdown";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMarkdown(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMarkdown(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMarkdown(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    raw(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/markdown/raw";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "text/plain", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRaw(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRaw(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processRaw(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    meta(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Meta> {
        let url_ = this.baseUrl + "/meta";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMeta(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMeta(response_);
                } catch (e) {
                    return <Observable<Meta>><any>Observable.throw(e);
                }
            } else
                return <Observable<Meta>><any>Observable.throw(response_);
        });
    }

    protected processMeta(response: Response): Observable<Meta> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Meta | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Meta.fromJS(resultData200) : new Meta();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Meta>(<any>null);
    }

    /**
     * @owner Name of the owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    events2(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Events> {
        let url_ = this.baseUrl + "/networks/{owner}/{repo}/events";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processEvents2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processEvents2(response_);
                } catch (e) {
                    return <Observable<Events>><any>Observable.throw(e);
                }
            } else
                return <Observable<Events>><any>Observable.throw(response_);
        });
    }

    protected processEvents2(response: Response): Observable<Events> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Events | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Events>(<any>null);
    }

    /**
     * @all True to show notifications marked as read.
     * @participating True to show only notifications in which the user is directly participating
or mentioned.
     * @since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Example: "2012-10-09T23:39:01Z".
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    notifications(all: boolean | null, participating: boolean | null, since: string | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Notifications> {
        let url_ = this.baseUrl + "/notifications?";
        if (all !== undefined)
            url_ += "all=" + encodeURIComponent("" + all) + "&"; 
        if (participating !== undefined)
            url_ += "participating=" + encodeURIComponent("" + participating) + "&"; 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processNotifications(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processNotifications(response_);
                } catch (e) {
                    return <Observable<Notifications>><any>Observable.throw(e);
                }
            } else
                return <Observable<Notifications>><any>Observable.throw(response_);
        });
    }

    protected processNotifications(response: Response): Observable<Notifications> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Notifications | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Notifications.fromJS(resultData200) : new Notifications();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Notifications>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Marked as read.
     */
    notifications2(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: NotificationMarkRead): Observable<void> {
        let url_ = this.baseUrl + "/notifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processNotifications2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processNotifications2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processNotifications2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 205) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id Id of thread.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    threads(id: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Notifications> {
        let url_ = this.baseUrl + "/notifications/threads/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processThreads(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processThreads(response_);
                } catch (e) {
                    return <Observable<Notifications>><any>Observable.throw(e);
                }
            } else
                return <Observable<Notifications>><any>Observable.throw(response_);
        });
    }

    protected processThreads(response: Response): Observable<Notifications> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Notifications | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Notifications.fromJS(resultData200) : new Notifications();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Notifications>(<any>null);
    }

    /**
     * @id Id of thread.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Thread marked as read.
     */
    threads2(id: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/notifications/threads/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processThreads2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processThreads2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processThreads2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 205) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id Id of thread.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No Content
     */
    subscription(id: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/notifications/threads/{id}/subscription";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSubscription(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSubscription(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSubscription(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id Id of thread.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    subscription2(id: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Subscription> {
        let url_ = this.baseUrl + "/notifications/threads/{id}/subscription";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSubscription2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSubscription2(response_);
                } catch (e) {
                    return <Observable<Subscription>><any>Observable.throw(e);
                }
            } else
                return <Observable<Subscription>><any>Observable.throw(response_);
        });
    }

    protected processSubscription2(response: Response): Observable<Subscription> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Subscription | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Subscription.fromJS(resultData200) : new Subscription();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Subscription>(<any>null);
    }

    /**
     * @id Id of thread.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    subscription3(id: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: PutSubscription): Observable<Subscription> {
        let url_ = this.baseUrl + "/notifications/threads/{id}/subscription";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSubscription3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSubscription3(response_);
                } catch (e) {
                    return <Observable<Subscription>><any>Observable.throw(e);
                }
            } else
                return <Observable<Subscription>><any>Observable.throw(response_);
        });
    }

    protected processSubscription3(response: Response): Observable<Subscription> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Subscription | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Subscription.fromJS(resultData200) : new Subscription();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Subscription>(<any>null);
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    orgs(org: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Organization> {
        let url_ = this.baseUrl + "/orgs/{org}";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processOrgs(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processOrgs(response_);
                } catch (e) {
                    return <Observable<Organization>><any>Observable.throw(e);
                }
            } else
                return <Observable<Organization>><any>Observable.throw(response_);
        });
    }

    protected processOrgs(response: Response): Observable<Organization> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Organization | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Organization.fromJS(resultData200) : new Organization();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Organization>(<any>null);
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    orgs2(org: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: PatchOrg): Observable<Organization> {
        let url_ = this.baseUrl + "/orgs/{org}";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processOrgs2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processOrgs2(response_);
                } catch (e) {
                    return <Observable<Organization>><any>Observable.throw(e);
                }
            } else
                return <Observable<Organization>><any>Observable.throw(response_);
        });
    }

    protected processOrgs2(response: Response): Observable<Organization> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Organization | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Organization.fromJS(resultData200) : new Organization();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Organization>(<any>null);
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    events3(org: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Events> {
        let url_ = this.baseUrl + "/orgs/{org}/events";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processEvents3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processEvents3(response_);
                } catch (e) {
                    return <Observable<Events>><any>Observable.throw(e);
                }
            } else
                return <Observable<Events>><any>Observable.throw(response_);
        });
    }

    protected processEvents3(response: Response): Observable<Events> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Events | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Events>(<any>null);
    }

    /**
     * @org Name of organisation.
     * @filter Issues assigned to you / created by you / mentioning you / you're
subscribed to updates for / All issues the authenticated user can see
     * @labels String list of comma separated Label names. Example - bug,ui,@high.
     * @since Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Only issues updated at or after this time are returned.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    issues(org: string, filter: Filter2, state: State3, labels: string, sort: Sort4, direction: Direction2, since: string | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous3[]> {
        let url_ = this.baseUrl + "/orgs/{org}/issues?";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        if (filter === undefined || filter === null)
            throw new Error("The parameter 'filter' must be defined and cannot be null.");
        else
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined and cannot be null.");
        else
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (labels === undefined || labels === null)
            throw new Error("The parameter 'labels' must be defined and cannot be null.");
        else
            url_ += "labels=" + encodeURIComponent("" + labels) + "&"; 
        if (sort === undefined || sort === null)
            throw new Error("The parameter 'sort' must be defined and cannot be null.");
        else
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        if (direction === undefined || direction === null)
            throw new Error("The parameter 'direction' must be defined and cannot be null.");
        else
            url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processIssues(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processIssues(response_);
                } catch (e) {
                    return <Observable<Anonymous3[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous3[]>><any>Observable.throw(response_);
        });
    }

    protected processIssues(response: Response): Observable<Anonymous3[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous3[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous3.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous3[]>(<any>null);
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    membersAll(org: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous4[]> {
        let url_ = this.baseUrl + "/orgs/{org}/members";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMembersAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMembersAll(response_);
                } catch (e) {
                    return <Observable<Anonymous4[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous4[]>><any>Observable.throw(response_);
        });
    }

    protected processMembersAll(response: Response): Observable<Anonymous4[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous4[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 302) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous4[]>(<any>null);
    }

    /**
     * @org Name of organisation.
     * @username Name of the user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    members(org: string, username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/orgs/{org}/members/{username}";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMembers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMembers(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMembers(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @org Name of organisation.
     * @username Name of the user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content. Response if requester is an organization member and user is a member
     */
    members2(org: string, username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/orgs/{org}/members/{username}";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMembers2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMembers2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMembers2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 302) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    reposAll(org: string, type: Type | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous5[]> {
        let url_ = this.baseUrl + "/orgs/{org}/repos?";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processReposAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processReposAll(response_);
                } catch (e) {
                    return <Observable<Anonymous5[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous5[]>><any>Observable.throw(response_);
        });
    }

    protected processReposAll(response: Response): Observable<Anonymous5[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous5[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous5.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous5[]>(<any>null);
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    repos(org: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: PostRepo): Observable<Anonymous5[]> {
        let url_ = this.baseUrl + "/orgs/{org}/repos";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRepos(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRepos(response_);
                } catch (e) {
                    return <Observable<Anonymous5[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous5[]>><any>Observable.throw(response_);
        });
    }

    protected processRepos(response: Response): Observable<Anonymous5[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Anonymous5[] | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData201 && resultData201.constructor === Array) {
                result201 = [];
                for (let item of resultData201)
                    result201.push(Anonymous5.fromJS(item));
            }
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous5[]>(<any>null);
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    teamsAll(org: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous6[]> {
        let url_ = this.baseUrl + "/orgs/{org}/teams";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTeamsAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTeamsAll(response_);
                } catch (e) {
                    return <Observable<Anonymous6[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous6[]>><any>Observable.throw(response_);
        });
    }

    protected processTeamsAll(response: Response): Observable<Anonymous6[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous6[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous6.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous6[]>(<any>null);
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    teams(org: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: OrgTeamsPost): Observable<Team> {
        let url_ = this.baseUrl + "/orgs/{org}/teams";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTeams(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTeams(response_);
                } catch (e) {
                    return <Observable<Team>><any>Observable.throw(e);
                }
            } else
                return <Observable<Team>><any>Observable.throw(response_);
        });
    }

    protected processTeams(response: Response): Observable<Team> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Team | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Team.fromJS(resultData201) : new Team();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Team>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Item removed.
     */
    repos2(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRepos2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRepos2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processRepos2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    repos3(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Repo> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRepos3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRepos3(response_);
                } catch (e) {
                    return <Observable<Repo>><any>Observable.throw(e);
                }
            } else
                return <Observable<Repo>><any>Observable.throw(response_);
        });
    }

    protected processRepos3(response: Response): Observable<Repo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Repo | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Repo.fromJS(resultData200) : new Repo();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Repo>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    repos4(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: RepoEdit): Observable<Repo> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRepos4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRepos4(response_);
                } catch (e) {
                    return <Observable<Repo>><any>Observable.throw(e);
                }
            } else
                return <Observable<Repo>><any>Observable.throw(response_);
        });
    }

    protected processRepos4(response: Response): Observable<Repo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Repo | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Repo.fromJS(resultData200) : new Repo();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Repo>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    assigneesAll(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous7[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/assignees";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processAssigneesAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAssigneesAll(response_);
                } catch (e) {
                    return <Observable<Anonymous7[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous7[]>><any>Observable.throw(response_);
        });
    }

    protected processAssigneesAll(response: Response): Observable<Anonymous7[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous7[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous7.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous7[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @assignee Login of the assignee.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return User is an assignee.
     */
    assignees(owner: string, repo: string, assignee: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/assignees/{assignee}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (assignee === undefined || assignee === null)
            throw new Error("The parameter 'assignee' must be defined.");
        url_ = url_.replace("{assignee}", encodeURIComponent("" + assignee)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processAssignees(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAssignees(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processAssignees(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    branchesAll(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous8[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/branches";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processBranchesAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processBranchesAll(response_);
                } catch (e) {
                    return <Observable<Anonymous8[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous8[]>><any>Observable.throw(response_);
        });
    }

    protected processBranchesAll(response: Response): Observable<Anonymous8[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous8[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous8.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous8[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @branch Name of the branch.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    branches(owner: string, repo: string, branch: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Branch> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/branches/{branch}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (branch === undefined || branch === null)
            throw new Error("The parameter 'branch' must be defined.");
        url_ = url_.replace("{branch}", encodeURIComponent("" + branch)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processBranches(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processBranches(response_);
                } catch (e) {
                    return <Observable<Branch>><any>Observable.throw(e);
                }
            } else
                return <Observable<Branch>><any>Observable.throw(response_);
        });
    }

    protected processBranches(response: Response): Observable<Branch> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Branch | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Branch.fromJS(resultData200) : new Branch();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Branch>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    collaboratorsAll(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous4[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/collaborators";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processCollaboratorsAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCollaboratorsAll(response_);
                } catch (e) {
                    return <Observable<Anonymous4[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous4[]>><any>Observable.throw(response_);
        });
    }

    protected processCollaboratorsAll(response: Response): Observable<Anonymous4[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous4[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous4[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @user Login of the user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Collaborator removed.
     */
    collaborators(owner: string, repo: string, user: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/collaborators/{user}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (user === undefined || user === null)
            throw new Error("The parameter 'user' must be defined.");
        url_ = url_.replace("{user}", encodeURIComponent("" + user)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processCollaborators(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCollaborators(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCollaborators(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @user Login of the user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return User is a collaborator.
     */
    collaborators2(owner: string, repo: string, user: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/collaborators/{user}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (user === undefined || user === null)
            throw new Error("The parameter 'user' must be defined.");
        url_ = url_.replace("{user}", encodeURIComponent("" + user)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processCollaborators2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCollaborators2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCollaborators2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @user Login of the user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Collaborator added.
     */
    collaborators3(owner: string, repo: string, user: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/collaborators/{user}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (user === undefined || user === null)
            throw new Error("The parameter 'user' must be defined.");
        url_ = url_.replace("{user}", encodeURIComponent("" + user)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "put",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processCollaborators3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCollaborators3(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCollaborators3(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments5(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous9[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/comments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments5(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments5(response_);
                } catch (e) {
                    return <Observable<Anonymous9[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous9[]>><any>Observable.throw(response_);
        });
    }

    protected processComments5(response: Response): Observable<Anonymous9[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous9[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous9.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous9[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    comments6(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments6(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments6(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processComments6(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments7(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<CommitComments> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments7(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments7(response_);
                } catch (e) {
                    return <Observable<CommitComments>><any>Observable.throw(e);
                }
            } else
                return <Observable<CommitComments>><any>Observable.throw(response_);
        });
    }

    protected processComments7(response: Response): Observable<CommitComments> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: CommitComments | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommitComments.fromJS(resultData200) : new CommitComments();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CommitComments>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments8(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: CommentBody): Observable<CommitComments> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments8(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments8(response_);
                } catch (e) {
                    return <Observable<CommitComments>><any>Observable.throw(e);
                }
            } else
                return <Observable<CommitComments>><any>Observable.throw(response_);
        });
    }

    protected processComments8(response: Response): Observable<CommitComments> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: CommitComments | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CommitComments.fromJS(resultData200) : new CommitComments();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CommitComments>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Example: "2012-10-09T23:39:01Z".
     * @sha Sha or branch to start listing commits from.
     * @path Only commits containing this file path will be returned.
     * @author GitHub login, name, or email by which to filter by commit author.
     * @until ISO 8601 Date - Only commits before this date will be returned.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    commitsAll(owner: string, repo: string, since: string | null, sha: string | null, path: string | null, author: string | null, until: string | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous10[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/commits?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        if (sha !== undefined)
            url_ += "sha=" + encodeURIComponent("" + sha) + "&"; 
        if (path !== undefined)
            url_ += "path=" + encodeURIComponent("" + path) + "&"; 
        if (author !== undefined)
            url_ += "author=" + encodeURIComponent("" + author) + "&"; 
        if (until !== undefined)
            url_ += "until=" + encodeURIComponent("" + until) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processCommitsAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCommitsAll(response_);
                } catch (e) {
                    return <Observable<Anonymous10[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous10[]>><any>Observable.throw(response_);
        });
    }

    protected processCommitsAll(response: Response): Observable<Anonymous10[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous10[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous10.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous10[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    status(owner: string, repo: string, ref: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous11[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/commits/{ref}/status";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (ref === undefined || ref === null)
            throw new Error("The parameter 'ref' must be defined.");
        url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processStatus(response_);
                } catch (e) {
                    return <Observable<Anonymous11[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous11[]>><any>Observable.throw(response_);
        });
    }

    protected processStatus(response: Response): Observable<Anonymous11[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous11[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous11.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous11[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @shaCode SHA-1 code of the commit.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    commits(owner: string, repo: string, shaCode: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Commit> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/commits/{shaCode}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (shaCode === undefined || shaCode === null)
            throw new Error("The parameter 'shaCode' must be defined.");
        url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processCommits(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCommits(response_);
                } catch (e) {
                    return <Observable<Commit>><any>Observable.throw(e);
                }
            } else
                return <Observable<Commit>><any>Observable.throw(response_);
        });
    }

    protected processCommits(response: Response): Observable<Commit> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Commit | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Commit.fromJS(resultData200) : new Commit();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Commit>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @shaCode SHA-1 code of the commit.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments9(owner: string, repo: string, shaCode: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous9[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/commits/{shaCode}/comments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (shaCode === undefined || shaCode === null)
            throw new Error("The parameter 'shaCode' must be defined.");
        url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments9(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments9(response_);
                } catch (e) {
                    return <Observable<Anonymous9[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous9[]>><any>Observable.throw(response_);
        });
    }

    protected processComments9(response: Response): Observable<Anonymous9[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous9[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous9.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous9[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @shaCode SHA-1 code of the commit.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    comments10(owner: string, repo: string, shaCode: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: CommitBody): Observable<CommitComments> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/commits/{shaCode}/comments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (shaCode === undefined || shaCode === null)
            throw new Error("The parameter 'shaCode' must be defined.");
        url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments10(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments10(response_);
                } catch (e) {
                    return <Observable<CommitComments>><any>Observable.throw(e);
                }
            } else
                return <Observable<CommitComments>><any>Observable.throw(response_);
        });
    }

    protected processComments10(response: Response): Observable<CommitComments> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: CommitComments | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? CommitComments.fromJS(resultData201) : new CommitComments();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CommitComments>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    compare(owner: string, repo: string, baseId: string, headId: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<CompareCommits> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/compare/{baseId}...{headId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (baseId === undefined || baseId === null)
            throw new Error("The parameter 'baseId' must be defined.");
        url_ = url_.replace("{baseId}", encodeURIComponent("" + baseId)); 
        if (headId === undefined || headId === null)
            throw new Error("The parameter 'headId' must be defined.");
        url_ = url_.replace("{headId}", encodeURIComponent("" + headId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processCompare(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCompare(response_);
                } catch (e) {
                    return <Observable<CompareCommits>><any>Observable.throw(e);
                }
            } else
                return <Observable<CompareCommits>><any>Observable.throw(response_);
        });
    }

    protected processCompare(response: Response): Observable<CompareCommits> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: CompareCommits | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CompareCommits.fromJS(resultData200) : new CompareCommits();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CompareCommits>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    contents(owner: string, repo: string, path: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: DeleteFileBody): Observable<DeleteFile> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/contents/{path}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processContents(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processContents(response_);
                } catch (e) {
                    return <Observable<DeleteFile>><any>Observable.throw(e);
                }
            } else
                return <Observable<DeleteFile>><any>Observable.throw(response_);
        });
    }

    protected processContents(response: Response): Observable<DeleteFile> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: DeleteFile | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DeleteFile.fromJS(resultData200) : new DeleteFile();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DeleteFile>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @pathQuery The content path.
     * @ref The String name of the Commit/Branch/Tag. Defaults to 'master'.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    contents2(owner: string, repo: string, pathPath: string, pathQuery: string | null, ref: string | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<ContentsPath> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/contents/{path}?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (pathPath === undefined || pathPath === null)
            throw new Error("The parameter 'pathPath' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + pathPath)); 
        if (pathQuery !== undefined)
            url_ += "path=" + encodeURIComponent("" + pathQuery) + "&"; 
        if (ref !== undefined)
            url_ += "ref=" + encodeURIComponent("" + ref) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processContents2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processContents2(response_);
                } catch (e) {
                    return <Observable<ContentsPath>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentsPath>><any>Observable.throw(response_);
        });
    }

    protected processContents2(response: Response): Observable<ContentsPath> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentsPath | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentsPath.fromJS(resultData200) : new ContentsPath();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ContentsPath>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    contents3(owner: string, repo: string, path: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: CreateFileBody): Observable<CreateFile> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/contents/{path}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processContents3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processContents3(response_);
                } catch (e) {
                    return <Observable<CreateFile>><any>Observable.throw(e);
                }
            } else
                return <Observable<CreateFile>><any>Observable.throw(response_);
        });
    }

    protected processContents3(response: Response): Observable<CreateFile> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: CreateFile | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CreateFile.fromJS(resultData200) : new CreateFile();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CreateFile>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @anon Set to 1 or true to include anonymous contributors in results.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    contributorsAll(owner: string, repo: string, anon: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous12[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/contributors?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (anon === undefined || anon === null)
            throw new Error("The parameter 'anon' must be defined and cannot be null.");
        else
            url_ += "anon=" + encodeURIComponent("" + anon) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processContributorsAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processContributorsAll(response_);
                } catch (e) {
                    return <Observable<Anonymous12[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous12[]>><any>Observable.throw(response_);
        });
    }

    protected processContributorsAll(response: Response): Observable<Anonymous12[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous12[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous12.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous12[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    deploymentsAll(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous13[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/deployments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processDeploymentsAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeploymentsAll(response_);
                } catch (e) {
                    return <Observable<Anonymous13[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous13[]>><any>Observable.throw(response_);
        });
    }

    protected processDeploymentsAll(response: Response): Observable<Anonymous13[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous13[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous13.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous13[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    deployments(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: Deployment): Observable<DeploymentResp> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/deployments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processDeployments(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeployments(response_);
                } catch (e) {
                    return <Observable<DeploymentResp>><any>Observable.throw(e);
                }
            } else
                return <Observable<DeploymentResp>><any>Observable.throw(response_);
        });
    }

    protected processDeployments(response: Response): Observable<DeploymentResp> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: DeploymentResp | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? DeploymentResp.fromJS(resultData201) : new DeploymentResp();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<DeploymentResp>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @id The Deployment ID to list the statuses from.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    statusesAll(owner: string, repo: string, id: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous14[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/deployments/{id}/statuses";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processStatusesAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processStatusesAll(response_);
                } catch (e) {
                    return <Observable<Anonymous14[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous14[]>><any>Observable.throw(response_);
        });
    }

    protected processStatusesAll(response: Response): Observable<Anonymous14[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous14[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous14.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous14[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @id The Deployment ID to list the statuses from.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return ok
     */
    statuses(owner: string, repo: string, id: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: DeploymentStatusesCreate): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/deployments/{id}/statuses";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processStatuses(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processStatuses(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processStatuses(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    downloads(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Downloads> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/downloads";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processDownloads(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDownloads(response_);
                } catch (e) {
                    return <Observable<Downloads>><any>Observable.throw(e);
                }
            } else
                return <Observable<Downloads>><any>Observable.throw(response_);
        });
    }

    protected processDownloads(response: Response): Observable<Downloads> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Downloads | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Downloads.fromJS(resultData200) : new Downloads();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Downloads>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @downloadId Id of download.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    downloads2(owner: string, repo: string, downloadId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/downloads/{downloadId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (downloadId === undefined || downloadId === null)
            throw new Error("The parameter 'downloadId' must be defined.");
        url_ = url_.replace("{downloadId}", encodeURIComponent("" + downloadId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processDownloads2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDownloads2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDownloads2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @downloadId Id of download.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    downloads3(owner: string, repo: string, downloadId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Downloads> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/downloads/{downloadId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (downloadId === undefined || downloadId === null)
            throw new Error("The parameter 'downloadId' must be defined.");
        url_ = url_.replace("{downloadId}", encodeURIComponent("" + downloadId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processDownloads3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDownloads3(response_);
                } catch (e) {
                    return <Observable<Downloads>><any>Observable.throw(e);
                }
            } else
                return <Observable<Downloads>><any>Observable.throw(response_);
        });
    }

    protected processDownloads3(response: Response): Observable<Downloads> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Downloads | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Downloads.fromJS(resultData200) : new Downloads();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Downloads>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    events4(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Events> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/events";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processEvents4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processEvents4(response_);
                } catch (e) {
                    return <Observable<Events>><any>Observable.throw(e);
                }
            } else
                return <Observable<Events>><any>Observable.throw(response_);
        });
    }

    protected processEvents4(response: Response): Observable<Events> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Events | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Events>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    forksAll(owner: string, repo: string, sort: Sort5 | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous15[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/forks?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processForksAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processForksAll(response_);
                } catch (e) {
                    return <Observable<Anonymous15[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous15[]>><any>Observable.throw(response_);
        });
    }

    protected processForksAll(response: Response): Observable<Anonymous15[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous15[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous15.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous15[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    forks2(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: ForkBody): Observable<Fork> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/forks";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processForks2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processForks2(response_);
                } catch (e) {
                    return <Observable<Fork>><any>Observable.throw(e);
                }
            } else
                return <Observable<Fork>><any>Observable.throw(response_);
        });
    }

    protected processForks2(response: Response): Observable<Fork> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Fork | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Fork.fromJS(resultData201) : new Fork();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Fork>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    blobs(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: Blob): Observable<Blobs> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/blobs";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processBlobs(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processBlobs(response_);
                } catch (e) {
                    return <Observable<Blobs>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blobs>><any>Observable.throw(response_);
        });
    }

    protected processBlobs(response: Response): Observable<Blobs> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Blobs | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Blobs.fromJS(resultData201) : new Blobs();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Blobs>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @shaCode SHA-1 code.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    blobs2(owner: string, repo: string, shaCode: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Blob> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/blobs/{shaCode}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (shaCode === undefined || shaCode === null)
            throw new Error("The parameter 'shaCode' must be defined.");
        url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processBlobs2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processBlobs2(response_);
                } catch (e) {
                    return <Observable<Blob>><any>Observable.throw(e);
                }
            } else
                return <Observable<Blob>><any>Observable.throw(response_);
        });
    }

    protected processBlobs2(response: Response): Observable<Blob> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Blob | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Blob.fromJS(resultData200) : new Blob();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Blob>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    commits2(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: RepoCommitBody): Observable<GitCommit> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/commits";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processCommits2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCommits2(response_);
                } catch (e) {
                    return <Observable<GitCommit>><any>Observable.throw(e);
                }
            } else
                return <Observable<GitCommit>><any>Observable.throw(response_);
        });
    }

    protected processCommits2(response: Response): Observable<GitCommit> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: GitCommit | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? GitCommit.fromJS(resultData201) : new GitCommit();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GitCommit>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @shaCode SHA-1 code.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    commits3(owner: string, repo: string, shaCode: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<RepoCommit> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/commits/{shaCode}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (shaCode === undefined || shaCode === null)
            throw new Error("The parameter 'shaCode' must be defined.");
        url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processCommits3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCommits3(response_);
                } catch (e) {
                    return <Observable<RepoCommit>><any>Observable.throw(e);
                }
            } else
                return <Observable<RepoCommit>><any>Observable.throw(response_);
        });
    }

    protected processCommits3(response: Response): Observable<RepoCommit> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: RepoCommit | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RepoCommit.fromJS(resultData200) : new RepoCommit();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RepoCommit>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    refsAll(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous16[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/refs";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRefsAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRefsAll(response_);
                } catch (e) {
                    return <Observable<Anonymous16[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous16[]>><any>Observable.throw(response_);
        });
    }

    protected processRefsAll(response: Response): Observable<Anonymous16[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous16[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous16.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous16[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    refs(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: RefsBody): Observable<HeadBranch> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/refs";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRefs(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRefs(response_);
                } catch (e) {
                    return <Observable<HeadBranch>><any>Observable.throw(e);
                }
            } else
                return <Observable<HeadBranch>><any>Observable.throw(response_);
        });
    }

    protected processRefs(response: Response): Observable<HeadBranch> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: HeadBranch | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? HeadBranch.fromJS(resultData201) : new HeadBranch();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<HeadBranch>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No Content
     */
    refs2(owner: string, repo: string, ref: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/refs/{ref}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (ref === undefined || ref === null)
            throw new Error("The parameter 'ref' must be defined.");
        url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRefs2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRefs2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processRefs2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    refs3(owner: string, repo: string, ref: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<HeadBranch> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/refs/{ref}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (ref === undefined || ref === null)
            throw new Error("The parameter 'ref' must be defined.");
        url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRefs3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRefs3(response_);
                } catch (e) {
                    return <Observable<HeadBranch>><any>Observable.throw(e);
                }
            } else
                return <Observable<HeadBranch>><any>Observable.throw(response_);
        });
    }

    protected processRefs3(response: Response): Observable<HeadBranch> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: HeadBranch | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HeadBranch.fromJS(resultData200) : new HeadBranch();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<HeadBranch>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    refs4(owner: string, repo: string, ref: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: GitRefPatch): Observable<HeadBranch> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/refs/{ref}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (ref === undefined || ref === null)
            throw new Error("The parameter 'ref' must be defined.");
        url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRefs4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRefs4(response_);
                } catch (e) {
                    return <Observable<HeadBranch>><any>Observable.throw(e);
                }
            } else
                return <Observable<HeadBranch>><any>Observable.throw(response_);
        });
    }

    protected processRefs4(response: Response): Observable<HeadBranch> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: HeadBranch | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HeadBranch.fromJS(resultData200) : new HeadBranch();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<HeadBranch>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    tags(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: Tag): Observable<Tags> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/tags";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTags(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTags(response_);
                } catch (e) {
                    return <Observable<Tags>><any>Observable.throw(e);
                }
            } else
                return <Observable<Tags>><any>Observable.throw(response_);
        });
    }

    protected processTags(response: Response): Observable<Tags> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Tags | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Tags.fromJS(resultData201) : new Tags();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Tags>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    tags2(owner: string, repo: string, shaCode: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Tag> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/tags/{shaCode}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (shaCode === undefined || shaCode === null)
            throw new Error("The parameter 'shaCode' must be defined.");
        url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTags2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTags2(response_);
                } catch (e) {
                    return <Observable<Tag>><any>Observable.throw(e);
                }
            } else
                return <Observable<Tag>><any>Observable.throw(response_);
        });
    }

    protected processTags2(response: Response): Observable<Tag> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Tag | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Tag.fromJS(resultData200) : new Tag();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Tag>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    trees(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: Tree): Observable<Trees> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/trees";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTrees(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTrees(response_);
                } catch (e) {
                    return <Observable<Trees>><any>Observable.throw(e);
                }
            } else
                return <Observable<Trees>><any>Observable.throw(response_);
        });
    }

    protected processTrees(response: Response): Observable<Trees> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Trees | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Trees.fromJS(resultData201) : new Trees();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Trees>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @shaCode Tree SHA.
     * @recursive Get a Tree Recursively. (0 or 1)
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    trees2(owner: string, repo: string, shaCode: string, recursive: number | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Tree> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/trees/{shaCode}?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (shaCode === undefined || shaCode === null)
            throw new Error("The parameter 'shaCode' must be defined.");
        url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
        if (recursive !== undefined)
            url_ += "recursive=" + encodeURIComponent("" + recursive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTrees2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTrees2(response_);
                } catch (e) {
                    return <Observable<Tree>><any>Observable.throw(e);
                }
            } else
                return <Observable<Tree>><any>Observable.throw(response_);
        });
    }

    protected processTrees2(response: Response): Observable<Tree> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Tree | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Tree.fromJS(resultData200) : new Tree();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Tree>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    hooksAll(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous17[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processHooksAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processHooksAll(response_);
                } catch (e) {
                    return <Observable<Anonymous17[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous17[]>><any>Observable.throw(response_);
        });
    }

    protected processHooksAll(response: Response): Observable<Anonymous17[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous17[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous17.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous17[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    hooks(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: HookBody): Observable<Anonymous17[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processHooks(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processHooks(response_);
                } catch (e) {
                    return <Observable<Anonymous17[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous17[]>><any>Observable.throw(response_);
        });
    }

    protected processHooks(response: Response): Observable<Anonymous17[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Anonymous17[] | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData201 && resultData201.constructor === Array) {
                result201 = [];
                for (let item of resultData201)
                    result201.push(Anonymous17.fromJS(item));
            }
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous17[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @hookId Id of hook.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    hooks2(owner: string, repo: string, hookId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks/{hookId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (hookId === undefined || hookId === null)
            throw new Error("The parameter 'hookId' must be defined.");
        url_ = url_.replace("{hookId}", encodeURIComponent("" + hookId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processHooks2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processHooks2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processHooks2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @hookId Id of hook.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    hooks3(owner: string, repo: string, hookId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous17[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks/{hookId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (hookId === undefined || hookId === null)
            throw new Error("The parameter 'hookId' must be defined.");
        url_ = url_.replace("{hookId}", encodeURIComponent("" + hookId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processHooks3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processHooks3(response_);
                } catch (e) {
                    return <Observable<Anonymous17[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous17[]>><any>Observable.throw(response_);
        });
    }

    protected processHooks3(response: Response): Observable<Anonymous17[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous17[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous17.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous17[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @hookId Id of hook.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    hooks4(owner: string, repo: string, hookId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: HookBody): Observable<Anonymous17[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks/{hookId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (hookId === undefined || hookId === null)
            throw new Error("The parameter 'hookId' must be defined.");
        url_ = url_.replace("{hookId}", encodeURIComponent("" + hookId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processHooks4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processHooks4(response_);
                } catch (e) {
                    return <Observable<Anonymous17[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous17[]>><any>Observable.throw(response_);
        });
    }

    protected processHooks4(response: Response): Observable<Anonymous17[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous17[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous17.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous17[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @hookId Id of hook.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Hook is triggered.
     */
    tests(owner: string, repo: string, hookId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks/{hookId}/tests";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (hookId === undefined || hookId === null)
            throw new Error("The parameter 'hookId' must be defined.");
        url_ = url_.replace("{hookId}", encodeURIComponent("" + hookId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTests(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTests(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processTests(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @filter Issues assigned to you / created by you / mentioning you / you're
subscribed to updates for / All issues the authenticated user can see
     * @labels String list of comma separated Label names. Example - bug,ui,@high.
     * @since Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Only issues updated at or after this time are returned.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    issues2(owner: string, repo: string, filter: Filter3, state: State4, labels: string, sort: Sort6, direction: Direction3, since: string | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous3[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (filter === undefined || filter === null)
            throw new Error("The parameter 'filter' must be defined and cannot be null.");
        else
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined and cannot be null.");
        else
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (labels === undefined || labels === null)
            throw new Error("The parameter 'labels' must be defined and cannot be null.");
        else
            url_ += "labels=" + encodeURIComponent("" + labels) + "&"; 
        if (sort === undefined || sort === null)
            throw new Error("The parameter 'sort' must be defined and cannot be null.");
        else
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        if (direction === undefined || direction === null)
            throw new Error("The parameter 'direction' must be defined and cannot be null.");
        else
            url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processIssues2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processIssues2(response_);
                } catch (e) {
                    return <Observable<Anonymous3[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous3[]>><any>Observable.throw(response_);
        });
    }

    protected processIssues2(response: Response): Observable<Anonymous3[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous3[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous3.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous3[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    issues3(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: Issue): Observable<Issue> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processIssues3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processIssues3(response_);
                } catch (e) {
                    return <Observable<Issue>><any>Observable.throw(e);
                }
            } else
                return <Observable<Issue>><any>Observable.throw(response_);
        });
    }

    protected processIssues3(response: Response): Observable<Issue> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Issue | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Issue.fromJS(resultData201) : new Issue();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Issue>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @direction Ignored without 'sort' parameter.
     * @since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Example: "2012-10-09T23:39:01Z".
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments11(owner: string, repo: string, direction: string | null, sort: Sort7 | null, since: string | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous18[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/comments?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (direction !== undefined)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments11(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments11(response_);
                } catch (e) {
                    return <Observable<Anonymous18[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous18[]>><any>Observable.throw(response_);
        });
    }

    protected processComments11(response: Response): Observable<Anonymous18[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous18[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous18.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous18[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId ID of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    comments12(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments12(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments12(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processComments12(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId ID of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments13(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<IssuesComment> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments13(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments13(response_);
                } catch (e) {
                    return <Observable<IssuesComment>><any>Observable.throw(e);
                }
            } else
                return <Observable<IssuesComment>><any>Observable.throw(response_);
        });
    }

    protected processComments13(response: Response): Observable<IssuesComment> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: IssuesComment | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IssuesComment.fromJS(resultData200) : new IssuesComment();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<IssuesComment>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId ID of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments14(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: CommentBody): Observable<IssuesComment> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments14(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments14(response_);
                } catch (e) {
                    return <Observable<IssuesComment>><any>Observable.throw(e);
                }
            } else
                return <Observable<IssuesComment>><any>Observable.throw(response_);
        });
    }

    protected processComments14(response: Response): Observable<IssuesComment> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: IssuesComment | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IssuesComment.fromJS(resultData200) : new IssuesComment();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<IssuesComment>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    events5(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Events> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/events";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processEvents5(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processEvents5(response_);
                } catch (e) {
                    return <Observable<Events>><any>Observable.throw(e);
                }
            } else
                return <Observable<Events>><any>Observable.throw(response_);
        });
    }

    protected processEvents5(response: Response): Observable<Events> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Events | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Events>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @eventId Id of the event.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    events6(owner: string, repo: string, eventId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Event> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/events/{eventId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processEvents6(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processEvents6(response_);
                } catch (e) {
                    return <Observable<Event>><any>Observable.throw(e);
                }
            } else
                return <Observable<Event>><any>Observable.throw(response_);
        });
    }

    protected processEvents6(response: Response): Observable<Event> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Event | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Event.fromJS(resultData200) : new Event();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Event>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    issues4(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Issue> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processIssues4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processIssues4(response_);
                } catch (e) {
                    return <Observable<Issue>><any>Observable.throw(e);
                }
            } else
                return <Observable<Issue>><any>Observable.throw(response_);
        });
    }

    protected processIssues4(response: Response): Observable<Issue> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Issue | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Issue.fromJS(resultData200) : new Issue();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Issue>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    issues5(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: Issue): Observable<Issue> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processIssues5(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processIssues5(response_);
                } catch (e) {
                    return <Observable<Issue>><any>Observable.throw(e);
                }
            } else
                return <Observable<Issue>><any>Observable.throw(response_);
        });
    }

    protected processIssues5(response: Response): Observable<Issue> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Issue | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Issue.fromJS(resultData200) : new Issue();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Issue>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments15(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous18[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/comments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments15(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments15(response_);
                } catch (e) {
                    return <Observable<Anonymous18[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous18[]>><any>Observable.throw(response_);
        });
    }

    protected processComments15(response: Response): Observable<Anonymous18[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous18[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous18.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous18[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    comments16(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: CommentBody): Observable<IssuesComment> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/comments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments16(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments16(response_);
                } catch (e) {
                    return <Observable<IssuesComment>><any>Observable.throw(e);
                }
            } else
                return <Observable<IssuesComment>><any>Observable.throw(response_);
        });
    }

    protected processComments16(response: Response): Observable<IssuesComment> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: IssuesComment | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? IssuesComment.fromJS(resultData201) : new IssuesComment();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<IssuesComment>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    events7(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Events> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/events";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processEvents7(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processEvents7(response_);
                } catch (e) {
                    return <Observable<Events>><any>Observable.throw(e);
                }
            } else
                return <Observable<Events>><any>Observable.throw(response_);
        });
    }

    protected processEvents7(response: Response): Observable<Events> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Events | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Events>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    labels(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/labels";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processLabels(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processLabels(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processLabels(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    labelsAll(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous19[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/labels";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processLabelsAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processLabelsAll(response_);
                } catch (e) {
                    return <Observable<Anonymous19[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous19[]>><any>Observable.throw(response_);
        });
    }

    protected processLabelsAll(response: Response): Observable<Anonymous19[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous19[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous19.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous19[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    labels2(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: string[]): Observable<Label> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/labels";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processLabels2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processLabels2(response_);
                } catch (e) {
                    return <Observable<Label>><any>Observable.throw(e);
                }
            } else
                return <Observable<Label>><any>Observable.throw(response_);
        });
    }

    protected processLabels2(response: Response): Observable<Label> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Label | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Label.fromJS(resultData201) : new Label();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Label>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    labels3(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: string[]): Observable<Label> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/labels";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processLabels3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processLabels3(response_);
                } catch (e) {
                    return <Observable<Label>><any>Observable.throw(e);
                }
            } else
                return <Observable<Label>><any>Observable.throw(response_);
        });
    }

    protected processLabels3(response: Response): Observable<Label> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Label | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Label.fromJS(resultData201) : new Label();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Label>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of issue.
     * @name Name of the label.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Item removed.
     */
    labels4(owner: string, repo: string, number: number, name: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/labels/{name}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processLabels4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processLabels4(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processLabels4(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    keysAll(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous20[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/keys";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processKeysAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processKeysAll(response_);
                } catch (e) {
                    return <Observable<Anonymous20[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous20[]>><any>Observable.throw(response_);
        });
    }

    protected processKeysAll(response: Response): Observable<Anonymous20[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous20[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous20.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous20[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    keys(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: UserKeysPost): Observable<UserKeysKeyId> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/keys";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processKeys(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processKeys(response_);
                } catch (e) {
                    return <Observable<UserKeysKeyId>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserKeysKeyId>><any>Observable.throw(response_);
        });
    }

    protected processKeys(response: Response): Observable<UserKeysKeyId> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: UserKeysKeyId | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? UserKeysKeyId.fromJS(resultData201) : new UserKeysKeyId();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserKeysKeyId>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @keyId Id of key.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    keys2(owner: string, repo: string, keyId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/keys/{keyId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (keyId === undefined || keyId === null)
            throw new Error("The parameter 'keyId' must be defined.");
        url_ = url_.replace("{keyId}", encodeURIComponent("" + keyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processKeys2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processKeys2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processKeys2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @keyId Id of key.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    keys3(owner: string, repo: string, keyId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<UserKeysKeyId> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/keys/{keyId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (keyId === undefined || keyId === null)
            throw new Error("The parameter 'keyId' must be defined.");
        url_ = url_.replace("{keyId}", encodeURIComponent("" + keyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processKeys3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processKeys3(response_);
                } catch (e) {
                    return <Observable<UserKeysKeyId>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserKeysKeyId>><any>Observable.throw(response_);
        });
    }

    protected processKeys3(response: Response): Observable<UserKeysKeyId> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: UserKeysKeyId | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserKeysKeyId.fromJS(resultData200) : new UserKeysKeyId();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserKeysKeyId>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    labels5(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous19[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/labels";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processLabels5(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processLabels5(response_);
                } catch (e) {
                    return <Observable<Anonymous19[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous19[]>><any>Observable.throw(response_);
        });
    }

    protected processLabels5(response: Response): Observable<Anonymous19[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous19[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous19.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous19[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    labels6(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: string[]): Observable<Label> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/labels";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processLabels6(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processLabels6(response_);
                } catch (e) {
                    return <Observable<Label>><any>Observable.throw(e);
                }
            } else
                return <Observable<Label>><any>Observable.throw(response_);
        });
    }

    protected processLabels6(response: Response): Observable<Label> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Label | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Label.fromJS(resultData201) : new Label();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Label>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @name Name of the label.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    labels7(owner: string, repo: string, name: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/labels/{name}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processLabels7(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processLabels7(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processLabels7(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @name Name of the label.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    labels8(owner: string, repo: string, name: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Label> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/labels/{name}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processLabels8(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processLabels8(response_);
                } catch (e) {
                    return <Observable<Label>><any>Observable.throw(e);
                }
            } else
                return <Observable<Label>><any>Observable.throw(response_);
        });
    }

    protected processLabels8(response: Response): Observable<Label> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Label | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Label.fromJS(resultData200) : new Label();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Label>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @name Name of the label.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    labels9(owner: string, repo: string, name: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: string[]): Observable<Label> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/labels/{name}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processLabels9(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processLabels9(response_);
                } catch (e) {
                    return <Observable<Label>><any>Observable.throw(e);
                }
            } else
                return <Observable<Label>><any>Observable.throw(response_);
        });
    }

    protected processLabels9(response: Response): Observable<Label> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Label | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Label.fromJS(resultData200) : new Label();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Label>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    languages(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<{ [key: string] : number; }> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/languages";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processLanguages(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processLanguages(response_);
                } catch (e) {
                    return <Observable<{ [key: string] : number; }>><any>Observable.throw(e);
                }
            } else
                return <Observable<{ [key: string] : number; }>><any>Observable.throw(response_);
        });
    }

    protected processLanguages(response: Response): Observable<{ [key: string] : number; }> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: { [key: string] : number; } | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<{ [key: string] : number; }>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Successful Response (The resulting merge commit)
     */
    merges(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: MergesBody): Observable<MergesSuccessful> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/merges";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMerges(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMerges(response_);
                } catch (e) {
                    return <Observable<MergesSuccessful>><any>Observable.throw(e);
                }
            } else
                return <Observable<MergesSuccessful>><any>Observable.throw(response_);
        });
    }

    protected processMerges(response: Response): Observable<MergesSuccessful> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: MergesSuccessful | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? MergesSuccessful.fromJS(resultData201) : new MergesSuccessful();
            return Observable.of(result201);
        } else if (status === 204) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.text();
            let result404: MergesConflict | null = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? MergesConflict.fromJS(resultData404) : new MergesConflict();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
        } else if (status === 409) {
            const _responseText = response.text();
            let result409: MergesConflict | null = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = resultData409 ? MergesConflict.fromJS(resultData409) : new MergesConflict();
            return throwException("A server error occurred.", status, _responseText, _headers, result409);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MergesSuccessful>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @state String to filter by state.
     * @direction Ignored without 'sort' parameter.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    milestones(owner: string, repo: string, state: State5 | null, direction: string | null, sort: Sort8 | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Milestone> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (direction !== undefined)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMilestones(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMilestones(response_);
                } catch (e) {
                    return <Observable<Milestone>><any>Observable.throw(e);
                }
            } else
                return <Observable<Milestone>><any>Observable.throw(response_);
        });
    }

    protected processMilestones(response: Response): Observable<Milestone> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Milestone | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Milestone.fromJS(resultData200) : new Milestone();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Milestone>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    milestones2(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: MilestoneUpdate): Observable<Milestone> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMilestones2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMilestones2(response_);
                } catch (e) {
                    return <Observable<Milestone>><any>Observable.throw(e);
                }
            } else
                return <Observable<Milestone>><any>Observable.throw(response_);
        });
    }

    protected processMilestones2(response: Response): Observable<Milestone> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Milestone | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Milestone.fromJS(resultData201) : new Milestone();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Milestone>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of milestone.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    milestones3(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones/{number}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMilestones3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMilestones3(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMilestones3(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of milestone.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    milestones4(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Milestone> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones/{number}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMilestones4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMilestones4(response_);
                } catch (e) {
                    return <Observable<Milestone>><any>Observable.throw(e);
                }
            } else
                return <Observable<Milestone>><any>Observable.throw(response_);
        });
    }

    protected processMilestones4(response: Response): Observable<Milestone> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Milestone | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Milestone.fromJS(resultData200) : new Milestone();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Milestone>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of milestone.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    milestones5(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: MilestoneUpdate): Observable<Milestone> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones/{number}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMilestones5(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMilestones5(response_);
                } catch (e) {
                    return <Observable<Milestone>><any>Observable.throw(e);
                }
            } else
                return <Observable<Milestone>><any>Observable.throw(response_);
        });
    }

    protected processMilestones5(response: Response): Observable<Milestone> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Milestone | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Milestone.fromJS(resultData200) : new Milestone();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Milestone>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Number of milestone.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    labels10(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous19[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones/{number}/labels";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processLabels10(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processLabels10(response_);
                } catch (e) {
                    return <Observable<Anonymous19[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous19[]>><any>Observable.throw(response_);
        });
    }

    protected processLabels10(response: Response): Observable<Anonymous19[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous19[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous19.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous19[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @all True to show notifications marked as read.
     * @participating True to show only notifications in which the user is directly participating
or mentioned.
     * @since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Example: "2012-10-09T23:39:01Z".
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    notifications3(owner: string, repo: string, all: boolean | null, participating: boolean | null, since: string | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Notifications> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/notifications?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (all !== undefined)
            url_ += "all=" + encodeURIComponent("" + all) + "&"; 
        if (participating !== undefined)
            url_ += "participating=" + encodeURIComponent("" + participating) + "&"; 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processNotifications3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processNotifications3(response_);
                } catch (e) {
                    return <Observable<Notifications>><any>Observable.throw(e);
                }
            } else
                return <Observable<Notifications>><any>Observable.throw(response_);
        });
    }

    protected processNotifications3(response: Response): Observable<Notifications> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Notifications | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Notifications.fromJS(resultData200) : new Notifications();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Notifications>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Marked as read.
     */
    notifications4(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: NotificationMarkRead): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/notifications";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processNotifications4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processNotifications4(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processNotifications4(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 205) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @state String to filter by state.
     * @head Filter pulls by head user and branch name in the format of 'user:ref-name'.
Example: github:new-script-format.
     * @base Filter pulls by base branch name. Example - gh-pages.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    pullsAll(owner: string, repo: string, state: State6 | null, head: string | null, base: string | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous21[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (head !== undefined)
            url_ += "head=" + encodeURIComponent("" + head) + "&"; 
        if (base !== undefined)
            url_ += "base=" + encodeURIComponent("" + base) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPullsAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPullsAll(response_);
                } catch (e) {
                    return <Observable<Anonymous21[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous21[]>><any>Observable.throw(response_);
        });
    }

    protected processPullsAll(response: Response): Observable<Anonymous21[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous21[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous21.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous21[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    pulls(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: PullsPost): Observable<Anonymous21[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPulls(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPulls(response_);
                } catch (e) {
                    return <Observable<Anonymous21[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous21[]>><any>Observable.throw(response_);
        });
    }

    protected processPulls(response: Response): Observable<Anonymous21[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Anonymous21[] | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData201 && resultData201.constructor === Array) {
                result201 = [];
                for (let item of resultData201)
                    result201.push(Anonymous21.fromJS(item));
            }
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous21[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @direction Ignored without 'sort' parameter.
     * @since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Example: "2012-10-09T23:39:01Z".
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments17(owner: string, repo: string, direction: string | null, sort: Sort9 | null, since: string | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous18[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/comments?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (direction !== undefined)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments17(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments17(response_);
                } catch (e) {
                    return <Observable<Anonymous18[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous18[]>><any>Observable.throw(response_);
        });
    }

    protected processComments17(response: Response): Observable<Anonymous18[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous18[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous18.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous18[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    comments18(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments18(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments18(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processComments18(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments19(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<PullsComment> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments19(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments19(response_);
                } catch (e) {
                    return <Observable<PullsComment>><any>Observable.throw(e);
                }
            } else
                return <Observable<PullsComment>><any>Observable.throw(response_);
        });
    }

    protected processComments19(response: Response): Observable<PullsComment> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: PullsComment | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PullsComment.fromJS(resultData200) : new PullsComment();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PullsComment>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @commentId Id of comment.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments20(owner: string, repo: string, commentId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: CommentBody): Observable<PullsComment> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/comments/{commentId}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (commentId === undefined || commentId === null)
            throw new Error("The parameter 'commentId' must be defined.");
        url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments20(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments20(response_);
                } catch (e) {
                    return <Observable<PullsComment>><any>Observable.throw(e);
                }
            } else
                return <Observable<PullsComment>><any>Observable.throw(response_);
        });
    }

    protected processComments20(response: Response): Observable<PullsComment> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: PullsComment | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PullsComment.fromJS(resultData200) : new PullsComment();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PullsComment>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Id of pull.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    pulls2(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<PullRequest> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPulls2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPulls2(response_);
                } catch (e) {
                    return <Observable<PullRequest>><any>Observable.throw(e);
                }
            } else
                return <Observable<PullRequest>><any>Observable.throw(response_);
        });
    }

    protected processPulls2(response: Response): Observable<PullRequest> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: PullRequest | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PullRequest.fromJS(resultData200) : new PullRequest();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PullRequest>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Id of pull.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    pulls3(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: PullUpdate): Observable<Repo> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPulls3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPulls3(response_);
                } catch (e) {
                    return <Observable<Repo>><any>Observable.throw(e);
                }
            } else
                return <Observable<Repo>><any>Observable.throw(response_);
        });
    }

    protected processPulls3(response: Response): Observable<Repo> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Repo | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Repo.fromJS(resultData200) : new Repo();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Repo>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Id of pull.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    comments21(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<PullsComment> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/comments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments21(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments21(response_);
                } catch (e) {
                    return <Observable<PullsComment>><any>Observable.throw(e);
                }
            } else
                return <Observable<PullsComment>><any>Observable.throw(response_);
        });
    }

    protected processComments21(response: Response): Observable<PullsComment> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: PullsComment | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PullsComment.fromJS(resultData200) : new PullsComment();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PullsComment>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Id of pull.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    comments22(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: PullsCommentPost): Observable<PullsComment> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/comments";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processComments22(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processComments22(response_);
                } catch (e) {
                    return <Observable<PullsComment>><any>Observable.throw(e);
                }
            } else
                return <Observable<PullsComment>><any>Observable.throw(response_);
        });
    }

    protected processComments22(response: Response): Observable<PullsComment> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: PullsComment | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? PullsComment.fromJS(resultData201) : new PullsComment();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PullsComment>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Id of pull.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    commits4(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous10[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/commits";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processCommits4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCommits4(response_);
                } catch (e) {
                    return <Observable<Anonymous10[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous10[]>><any>Observable.throw(response_);
        });
    }

    protected processCommits4(response: Response): Observable<Anonymous10[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous10[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous10.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous10[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Id of pull.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    files(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous21[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/files";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processFiles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processFiles(response_);
                } catch (e) {
                    return <Observable<Anonymous21[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous21[]>><any>Observable.throw(response_);
        });
    }

    protected processFiles(response: Response): Observable<Anonymous21[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous21[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous21.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous21[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Id of pull.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Pull request has been merged.
     */
    merge(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/merge";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMerge(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMerge(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMerge(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @number Id of pull.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Response if merge was successful.
     */
    merge2(owner: string, repo: string, number: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: MergePullBody): Observable<Merge> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/merge";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMerge2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMerge2(response_);
                } catch (e) {
                    return <Observable<Merge>><any>Observable.throw(e);
                }
            } else
                return <Observable<Merge>><any>Observable.throw(response_);
        });
    }

    protected processMerge2(response: Response): Observable<Merge> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Merge | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Merge.fromJS(resultData200) : new Merge();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 405) {
            const _responseText = response.text();
            let result405: Merge | null = null;
            let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result405 = resultData405 ? Merge.fromJS(resultData405) : new Merge();
            return throwException("A server error occurred.", status, _responseText, _headers, result405);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Merge>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @ref The String name of the Commit/Branch/Tag. Defaults to master.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    readme(owner: string, repo: string, ref: string | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<ContentsPath> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/readme?";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (ref !== undefined)
            url_ += "ref=" + encodeURIComponent("" + ref) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processReadme(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processReadme(response_);
                } catch (e) {
                    return <Observable<ContentsPath>><any>Observable.throw(e);
                }
            } else
                return <Observable<ContentsPath>><any>Observable.throw(response_);
        });
    }

    protected processReadme(response: Response): Observable<ContentsPath> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: ContentsPath | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContentsPath.fromJS(resultData200) : new ContentsPath();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ContentsPath>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    releasesAll(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous22[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processReleasesAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processReleasesAll(response_);
                } catch (e) {
                    return <Observable<Anonymous22[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous22[]>><any>Observable.throw(response_);
        });
    }

    protected processReleasesAll(response: Response): Observable<Anonymous22[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous22[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous22.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous22[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    releases(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: ReleaseCreate): Observable<Release> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processReleases(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processReleases(response_);
                } catch (e) {
                    return <Observable<Release>><any>Observable.throw(e);
                }
            } else
                return <Observable<Release>><any>Observable.throw(response_);
        });
    }

    protected processReleases(response: Response): Observable<Release> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Release | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? Release.fromJS(resultData201) : new Release();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Release>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No Content
     */
    assets(owner: string, repo: string, id: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/assets/{id}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processAssets(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAssets(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processAssets(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    assets2(owner: string, repo: string, id: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Asset> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/assets/{id}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processAssets2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAssets2(response_);
                } catch (e) {
                    return <Observable<Asset>><any>Observable.throw(e);
                }
            } else
                return <Observable<Asset>><any>Observable.throw(response_);
        });
    }

    protected processAssets2(response: Response): Observable<Asset> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Asset | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Asset.fromJS(resultData200) : new Asset();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Asset>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    assets3(owner: string, repo: string, id: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: AssetPatch): Observable<Asset> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/assets/{id}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processAssets3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAssets3(response_);
                } catch (e) {
                    return <Observable<Asset>><any>Observable.throw(e);
                }
            } else
                return <Observable<Asset>><any>Observable.throw(response_);
        });
    }

    protected processAssets3(response: Response): Observable<Asset> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Asset | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Asset.fromJS(resultData200) : new Asset();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Asset>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No Content
     */
    releases2(owner: string, repo: string, id: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/{id}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processReleases2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processReleases2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processReleases2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    releases3(owner: string, repo: string, id: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Release> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/{id}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processReleases3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processReleases3(response_);
                } catch (e) {
                    return <Observable<Release>><any>Observable.throw(e);
                }
            } else
                return <Observable<Release>><any>Observable.throw(response_);
        });
    }

    protected processReleases3(response: Response): Observable<Release> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Release | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Release.fromJS(resultData200) : new Release();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Release>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    releases4(owner: string, repo: string, id: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: ReleaseCreate): Observable<Release> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/{id}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processReleases4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processReleases4(response_);
                } catch (e) {
                    return <Observable<Release>><any>Observable.throw(e);
                }
            } else
                return <Observable<Release>><any>Observable.throw(response_);
        });
    }

    protected processReleases4(response: Response): Observable<Release> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Release | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Release.fromJS(resultData200) : new Release();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Release>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    assetsAll(owner: string, repo: string, id: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous23[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/{id}/assets";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processAssetsAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAssetsAll(response_);
                } catch (e) {
                    return <Observable<Anonymous23[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous23[]>><any>Observable.throw(response_);
        });
    }

    protected processAssetsAll(response: Response): Observable<Anonymous23[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous23[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous23.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous23[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    stargazers(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous4[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/stargazers";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processStargazers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processStargazers(response_);
                } catch (e) {
                    return <Observable<Anonymous4[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous4[]>><any>Observable.throw(response_);
        });
    }

    protected processStargazers(response: Response): Observable<Anonymous4[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous4[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous4[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    contributors(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous24[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/stats/contributors";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processContributors(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processContributors(response_);
                } catch (e) {
                    return <Observable<Anonymous24[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous24[]>><any>Observable.throw(response_);
        });
    }

    protected processContributors(response: Response): Observable<Anonymous24[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous24[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous24.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous24[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    participation(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<ParticipationStats> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/stats/participation";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processParticipation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processParticipation(response_);
                } catch (e) {
                    return <Observable<ParticipationStats>><any>Observable.throw(e);
                }
            } else
                return <Observable<ParticipationStats>><any>Observable.throw(response_);
        });
    }

    protected processParticipation(response: Response): Observable<ParticipationStats> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: ParticipationStats | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ParticipationStats.fromJS(resultData200) : new ParticipationStats();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ParticipationStats>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @ref Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    statuses2(owner: string, repo: string, ref: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous25[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/statuses/{ref}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (ref === undefined || ref === null)
            throw new Error("The parameter 'ref' must be defined.");
        url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processStatuses2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processStatuses2(response_);
                } catch (e) {
                    return <Observable<Anonymous25[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous25[]>><any>Observable.throw(response_);
        });
    }

    protected processStatuses2(response: Response): Observable<Anonymous25[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous25[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous25.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous25[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @ref Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    statuses3(owner: string, repo: string, ref: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: HeadBranch): Observable<Anonymous25[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/statuses/{ref}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (ref === undefined || ref === null)
            throw new Error("The parameter 'ref' must be defined.");
        url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processStatuses3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processStatuses3(response_);
                } catch (e) {
                    return <Observable<Anonymous25[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous25[]>><any>Observable.throw(response_);
        });
    }

    protected processStatuses3(response: Response): Observable<Anonymous25[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Anonymous25[] | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData201 && resultData201.constructor === Array) {
                result201 = [];
                for (let item of resultData201)
                    result201.push(Anonymous25.fromJS(item));
            }
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous25[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    subscribers(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous4[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/subscribers";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSubscribers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSubscribers(response_);
                } catch (e) {
                    return <Observable<Anonymous4[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous4[]>><any>Observable.throw(response_);
        });
    }

    protected processSubscribers(response: Response): Observable<Anonymous4[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous4[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous4[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    subscription4(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/subscription";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSubscription4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSubscription4(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSubscription4(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    subscription5(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Subscribition> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/subscription";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSubscription5(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSubscription5(response_);
                } catch (e) {
                    return <Observable<Subscribition>><any>Observable.throw(e);
                }
            } else
                return <Observable<Subscribition>><any>Observable.throw(response_);
        });
    }

    protected processSubscription5(response: Response): Observable<Subscribition> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Subscribition | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Subscribition.fromJS(resultData200) : new Subscribition();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Subscribition>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    subscription6(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: SubscribitionBody): Observable<Subscribition> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/subscription";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "put",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSubscription6(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSubscription6(response_);
                } catch (e) {
                    return <Observable<Subscribition>><any>Observable.throw(e);
                }
            } else
                return <Observable<Subscribition>><any>Observable.throw(response_);
        });
    }

    protected processSubscription6(response: Response): Observable<Subscribition> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Subscribition | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Subscribition.fromJS(resultData200) : new Subscribition();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Subscribition>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    tags3(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Tags> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/tags";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTags3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTags3(response_);
                } catch (e) {
                    return <Observable<Tags>><any>Observable.throw(e);
                }
            } else
                return <Observable<Tags>><any>Observable.throw(response_);
        });
    }

    protected processTags3(response: Response): Observable<Tags> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Tags | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Tags.fromJS(resultData200) : new Tags();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Tags>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    teams2(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous6[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/teams";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTeams2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTeams2(response_);
                } catch (e) {
                    return <Observable<Anonymous6[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous6[]>><any>Observable.throw(response_);
        });
    }

    protected processTeams2(response: Response): Observable<Anonymous6[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous6[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous6.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous6[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    watchers(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous4[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/watchers";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processWatchers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processWatchers(response_);
                } catch (e) {
                    return <Observable<Anonymous4[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous4[]>><any>Observable.throw(response_);
        });
    }

    protected processWatchers(response: Response): Observable<Anonymous4[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous4[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous4[]>(<any>null);
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @path Valid Git reference, defaults to 'master'.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    repos5(owner: string, repo: string, archive_format: Archive_format, path: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/{archive_format}/{path}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        if (archive_format === undefined || archive_format === null)
            throw new Error("The parameter 'archive_format' must be defined.");
        url_ = url_.replace("{archive_format}", encodeURIComponent("" + archive_format)); 
        if (path === undefined || path === null)
            throw new Error("The parameter 'path' must be defined.");
        url_ = url_.replace("{path}", encodeURIComponent("" + path)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRepos5(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRepos5(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processRepos5(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 302) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Example: "2012-10-09T23:39:01Z".
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    repositoriesAll(since: string | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous26[]> {
        let url_ = this.baseUrl + "/repositories?";
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRepositoriesAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRepositoriesAll(response_);
                } catch (e) {
                    return <Observable<Anonymous26[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous26[]>><any>Observable.throw(response_);
        });
    }

    protected processRepositoriesAll(response: Response): Observable<Anonymous26[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous26[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous26.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous26[]>(<any>null);
    }

    /**
     * @order The sort field. if sort param is provided. Can be either asc or desc.
     * @q The search terms. This can be any combination of the supported code
search parameters:
'Search In' Qualifies which fields are searched. With this qualifier
you can restrict the search to just the file contents, the file path,
or both.
'Languages' Searches code based on the language it's written in.
'Forks' Filters repositories based on the number of forks, and/or
whether code from forked repositories should be included in the results
at all.
'Size' Finds files that match a certain size (in bytes).
'Path' Specifies the path that the resulting file must be at.
'Extension' Matches files with a certain extension.
'Users' or 'Repositories' Limits searches to a specific user or repository.
     * @sort Can only be 'indexed', which indicates how recently a file has been indexed
by the GitHub search infrastructure. If not provided, results are sorted
by best match.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    code(order: Order3 | null, q: string, sort: Sort10 | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<SearchCode> {
        let url_ = this.baseUrl + "/search/code?";
        if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&"; 
        if (q === undefined || q === null)
            throw new Error("The parameter 'q' must be defined and cannot be null.");
        else
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processCode(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCode(response_);
                } catch (e) {
                    return <Observable<SearchCode>><any>Observable.throw(e);
                }
            } else
                return <Observable<SearchCode>><any>Observable.throw(response_);
        });
    }

    protected processCode(response: Response): Observable<SearchCode> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: SearchCode | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SearchCode.fromJS(resultData200) : new SearchCode();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SearchCode>(<any>null);
    }

    /**
     * @order The sort field. if sort param is provided. Can be either asc or desc.
     * @q The q search term can also contain any combination of the supported issue search qualifiers:
     * @sort The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    issues6(order: Order4 | null, q: string, sort: Sort11 | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<SearchIssues> {
        let url_ = this.baseUrl + "/search/issues?";
        if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&"; 
        if (q === undefined || q === null)
            throw new Error("The parameter 'q' must be defined and cannot be null.");
        else
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processIssues6(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processIssues6(response_);
                } catch (e) {
                    return <Observable<SearchIssues>><any>Observable.throw(e);
                }
            } else
                return <Observable<SearchIssues>><any>Observable.throw(response_);
        });
    }

    protected processIssues6(response: Response): Observable<SearchIssues> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: SearchIssues | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SearchIssues.fromJS(resultData200) : new SearchIssues();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SearchIssues>(<any>null);
    }

    /**
     * @order The sort field. if sort param is provided. Can be either asc or desc.
     * @q The search terms. This can be any combination of the supported repository
search parameters:
'Search In' Qualifies which fields are searched. With this qualifier you
can restrict the search to just the repository name, description, readme,
or any combination of these.
'Size' Finds repositories that match a certain size (in kilobytes).
'Forks' Filters repositories based on the number of forks, and/or whether
forked repositories should be included in the results at all.
'Created' and 'Last Updated' Filters repositories based on times of
creation, or when they were last updated.
'Users or Repositories' Limits searches to a specific user or repository.
'Languages' Searches repositories based on the language they are written in.
'Stars' Searches repositories based on the number of stars.
     * @sort If not provided, results are sorted by best match.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    repositories(order: Order5 | null, q: string, sort: Sort12 | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<SearchRepositories> {
        let url_ = this.baseUrl + "/search/repositories?";
        if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&"; 
        if (q === undefined || q === null)
            throw new Error("The parameter 'q' must be defined and cannot be null.");
        else
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRepositories(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRepositories(response_);
                } catch (e) {
                    return <Observable<SearchRepositories>><any>Observable.throw(e);
                }
            } else
                return <Observable<SearchRepositories>><any>Observable.throw(response_);
        });
    }

    protected processRepositories(response: Response): Observable<SearchRepositories> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: SearchRepositories | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SearchRepositories.fromJS(resultData200) : new SearchRepositories();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SearchRepositories>(<any>null);
    }

    /**
     * @order The sort field. if sort param is provided. Can be either asc or desc.
     * @q The search terms. This can be any combination of the supported user
search parameters:
'Search In' Qualifies which fields are searched. With this qualifier you
can restrict the search to just the username, public email, full name,
location, or any combination of these.
'Repository count' Filters users based on the number of repositories they
have.
'Location' Filter users by the location indicated in their profile.
'Language' Search for users that have repositories that match a certain
language.
'Created' Filter users based on when they joined.
'Followers' Filter users based on the number of followers they have.
     * @sort If not provided, results are sorted by best match.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    users(order: Order6 | null, q: string, sort: Sort13 | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<SearchUsers> {
        let url_ = this.baseUrl + "/search/users?";
        if (order !== undefined)
            url_ += "order=" + encodeURIComponent("" + order) + "&"; 
        if (q === undefined || q === null)
            throw new Error("The parameter 'q' must be defined and cannot be null.");
        else
            url_ += "q=" + encodeURIComponent("" + q) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUsers(response_);
                } catch (e) {
                    return <Observable<SearchUsers>><any>Observable.throw(e);
                }
            } else
                return <Observable<SearchUsers>><any>Observable.throw(response_);
        });
    }

    protected processUsers(response: Response): Observable<SearchUsers> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: SearchUsers | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SearchUsers.fromJS(resultData200) : new SearchUsers();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<SearchUsers>(<any>null);
    }

    /**
     * @teamId Id of team.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    teams3(teamId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/teams/{teamId}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTeams3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTeams3(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processTeams3(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @teamId Id of team.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    teams4(teamId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Team> {
        let url_ = this.baseUrl + "/teams/{teamId}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTeams4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTeams4(response_);
                } catch (e) {
                    return <Observable<Team>><any>Observable.throw(e);
                }
            } else
                return <Observable<Team>><any>Observable.throw(response_);
        });
    }

    protected processTeams4(response: Response): Observable<Team> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Team | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Team.fromJS(resultData200) : new Team();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Team>(<any>null);
    }

    /**
     * @teamId Id of team.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    teams5(teamId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: EditTeam): Observable<Team> {
        let url_ = this.baseUrl + "/teams/{teamId}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTeams5(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTeams5(response_);
                } catch (e) {
                    return <Observable<Team>><any>Observable.throw(e);
                }
            } else
                return <Observable<Team>><any>Observable.throw(response_);
        });
    }

    protected processTeams5(response: Response): Observable<Team> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Team | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Team.fromJS(resultData200) : new Team();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Team>(<any>null);
    }

    /**
     * @teamId Id of team.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    members3(teamId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous4[]> {
        let url_ = this.baseUrl + "/teams/{teamId}/members";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMembers3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMembers3(response_);
                } catch (e) {
                    return <Observable<Anonymous4[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous4[]>><any>Observable.throw(response_);
        });
    }

    protected processMembers3(response: Response): Observable<Anonymous4[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous4[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous4[]>(<any>null);
    }

    /**
     * @teamId Id of team.
     * @username Name of a member.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Team member removed.
     */
    members4(teamId: number, username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/teams/{teamId}/members/{username}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMembers4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMembers4(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMembers4(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @teamId Id of team.
     * @username Name of a member.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return User is a member.
     */
    members5(teamId: number, username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/teams/{teamId}/members/{username}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMembers5(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMembers5(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMembers5(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @teamId Id of team.
     * @username Name of a member.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Team member added.
     */
    members6(teamId: number, username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/teams/{teamId}/members/{username}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "put",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMembers6(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMembers6(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMembers6(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 422) {
            const _responseText = response.text();
            let result422: OrganizationAsTeamMember | null = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = resultData422 ? OrganizationAsTeamMember.fromJS(resultData422) : new OrganizationAsTeamMember();
            return throwException("A server error occurred.", status, _responseText, _headers, result422);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @teamId Id of team.
     * @username Name of a member.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Team member removed.
     */
    memberships(teamId: number, username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/teams/{teamId}/memberships/{username}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMemberships(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMemberships(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMemberships(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @teamId Id of team.
     * @username Name of a member.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return User is a member.
     */
    memberships2(teamId: number, username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<TeamMembership> {
        let url_ = this.baseUrl + "/teams/{teamId}/memberships/{username}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMemberships2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMemberships2(response_);
                } catch (e) {
                    return <Observable<TeamMembership>><any>Observable.throw(e);
                }
            } else
                return <Observable<TeamMembership>><any>Observable.throw(response_);
        });
    }

    protected processMemberships2(response: Response): Observable<TeamMembership> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: TeamMembership | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TeamMembership.fromJS(resultData200) : new TeamMembership();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TeamMembership>(<any>null);
    }

    /**
     * @teamId Id of team.
     * @username Name of a member.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Team member added.
     */
    memberships3(teamId: number, username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<TeamMembership> {
        let url_ = this.baseUrl + "/teams/{teamId}/memberships/{username}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "put",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMemberships3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMemberships3(response_);
                } catch (e) {
                    return <Observable<TeamMembership>><any>Observable.throw(e);
                }
            } else
                return <Observable<TeamMembership>><any>Observable.throw(response_);
        });
    }

    protected processMemberships3(response: Response): Observable<TeamMembership> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: TeamMembership | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TeamMembership.fromJS(resultData200) : new TeamMembership();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 422) {
            const _responseText = response.text();
            let result422: OrganizationAsTeamMember | null = null;
            let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result422 = resultData422 ? OrganizationAsTeamMember.fromJS(resultData422) : new OrganizationAsTeamMember();
            return throwException("A server error occurred.", status, _responseText, _headers, result422);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TeamMembership>(<any>null);
    }

    /**
     * @teamId Id of team.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    repos6(teamId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous27[]> {
        let url_ = this.baseUrl + "/teams/{teamId}/repos";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRepos6(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRepos6(response_);
                } catch (e) {
                    return <Observable<Anonymous27[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous27[]>><any>Observable.throw(response_);
        });
    }

    protected processRepos6(response: Response): Observable<Anonymous27[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous27[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous27.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous27[]>(<any>null);
    }

    /**
     * @teamId Id of team.
     * @org Name of a organization.
     * @repo Name of a repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    repos7(teamId: number, org: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/teams/{teamId}/repos/{org}/{repo}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "put",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRepos7(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRepos7(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processRepos7(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @teamId Id of team.
     * @owner Name of a repository owner.
     * @repo Name of a repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    repos8(teamId: number, owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/teams/{teamId}/repos/{owner}/{repo}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRepos8(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRepos8(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processRepos8(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @teamId Id of team.
     * @owner Name of a repository owner.
     * @repo Name of a repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    repos9(teamId: number, owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/teams/{teamId}/repos/{owner}/{repo}";
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRepos9(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRepos9(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processRepos9(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    user(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<User> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUser(response_);
                } catch (e) {
                    return <Observable<User>><any>Observable.throw(e);
                }
            } else
                return <Observable<User>><any>Observable.throw(response_);
        });
    }

    protected processUser(response: Response): Observable<User> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: User | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? User.fromJS(resultData200) : new User();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<User>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    user2(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: UserUpdate): Observable<User> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "patch",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processUser2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUser2(response_);
                } catch (e) {
                    return <Observable<User>><any>Observable.throw(e);
                }
            } else
                return <Observable<User>><any>Observable.throw(response_);
        });
    }

    protected processUser2(response: Response): Observable<User> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: User | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? User.fromJS(resultData200) : new User();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<User>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    emails(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: string[]): Observable<void> {
        let url_ = this.baseUrl + "/user/emails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processEmails(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processEmails(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processEmails(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    emailsAll(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<string[]> {
        let url_ = this.baseUrl + "/user/emails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processEmailsAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processEmailsAll(response_);
                } catch (e) {
                    return <Observable<string[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<string[]>><any>Observable.throw(response_);
        });
    }

    protected processEmailsAll(response: Response): Observable<string[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: string[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<string[]>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    emails2(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: string[]): Observable<void> {
        let url_ = this.baseUrl + "/user/emails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processEmails2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processEmails2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processEmails2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    followersAll(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous4[]> {
        let url_ = this.baseUrl + "/user/followers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processFollowersAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processFollowersAll(response_);
                } catch (e) {
                    return <Observable<Anonymous4[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous4[]>><any>Observable.throw(response_);
        });
    }

    protected processFollowersAll(response: Response): Observable<Anonymous4[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous4[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous4[]>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    followingAll(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous4[]> {
        let url_ = this.baseUrl + "/user/following";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processFollowingAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processFollowingAll(response_);
                } catch (e) {
                    return <Observable<Anonymous4[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous4[]>><any>Observable.throw(response_);
        });
    }

    protected processFollowingAll(response: Response): Observable<Anonymous4[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous4[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous4[]>(<any>null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return User unfollowed.
     */
    following(username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/user/following/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processFollowing(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processFollowing(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processFollowing(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Response if you are following this user.
     */
    following2(username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/user/following/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processFollowing2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processFollowing2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processFollowing2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return You are now following the user.
     */
    following3(username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/user/following/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "put",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processFollowing3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processFollowing3(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processFollowing3(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @filter Issues assigned to you / created by you / mentioning you / you're
subscribed to updates for / All issues the authenticated user can see
     * @labels String list of comma separated Label names. Example - bug,ui,@high.
     * @since Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Only issues updated at or after this time are returned.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    issues7(filter: Filter4, state: State7, labels: string, sort: Sort14, direction: Direction4, since: string | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous3[]> {
        let url_ = this.baseUrl + "/user/issues?";
        if (filter === undefined || filter === null)
            throw new Error("The parameter 'filter' must be defined and cannot be null.");
        else
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined and cannot be null.");
        else
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (labels === undefined || labels === null)
            throw new Error("The parameter 'labels' must be defined and cannot be null.");
        else
            url_ += "labels=" + encodeURIComponent("" + labels) + "&"; 
        if (sort === undefined || sort === null)
            throw new Error("The parameter 'sort' must be defined and cannot be null.");
        else
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        if (direction === undefined || direction === null)
            throw new Error("The parameter 'direction' must be defined and cannot be null.");
        else
            url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processIssues7(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processIssues7(response_);
                } catch (e) {
                    return <Observable<Anonymous3[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous3[]>><any>Observable.throw(response_);
        });
    }

    protected processIssues7(response: Response): Observable<Anonymous3[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous3[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous3.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous3[]>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    keys4(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<any[]> {
        let url_ = this.baseUrl + "/user/keys";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processKeys4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processKeys4(response_);
                } catch (e) {
                    return <Observable<any[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<any[]>><any>Observable.throw(response_);
        });
    }

    protected processKeys4(response: Response): Observable<any[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<any[]>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    keys5(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: UserKeysPost): Observable<UserKeysKeyId> {
        let url_ = this.baseUrl + "/user/keys";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processKeys5(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processKeys5(response_);
                } catch (e) {
                    return <Observable<UserKeysKeyId>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserKeysKeyId>><any>Observable.throw(response_);
        });
    }

    protected processKeys5(response: Response): Observable<UserKeysKeyId> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: UserKeysKeyId | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 ? UserKeysKeyId.fromJS(resultData201) : new UserKeysKeyId();
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserKeysKeyId>(<any>null);
    }

    /**
     * @keyId ID of key.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return No content.
     */
    keys6(keyId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/user/keys/{keyId}";
        if (keyId === undefined || keyId === null)
            throw new Error("The parameter 'keyId' must be defined.");
        url_ = url_.replace("{keyId}", encodeURIComponent("" + keyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processKeys6(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processKeys6(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processKeys6(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @keyId ID of key.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    keys7(keyId: number, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<UserKeysKeyId> {
        let url_ = this.baseUrl + "/user/keys/{keyId}";
        if (keyId === undefined || keyId === null)
            throw new Error("The parameter 'keyId' must be defined.");
        url_ = url_.replace("{keyId}", encodeURIComponent("" + keyId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processKeys7(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processKeys7(response_);
                } catch (e) {
                    return <Observable<UserKeysKeyId>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserKeysKeyId>><any>Observable.throw(response_);
        });
    }

    protected processKeys7(response: Response): Observable<UserKeysKeyId> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: UserKeysKeyId | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserKeysKeyId.fromJS(resultData200) : new UserKeysKeyId();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserKeysKeyId>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    orgsAll(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<any[]> {
        let url_ = this.baseUrl + "/user/orgs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processOrgsAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processOrgsAll(response_);
                } catch (e) {
                    return <Observable<any[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<any[]>><any>Observable.throw(response_);
        });
    }

    protected processOrgsAll(response: Response): Observable<any[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<any[]>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    repos10(type: Type2 | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous5[]> {
        let url_ = this.baseUrl + "/user/repos?";
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRepos10(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRepos10(response_);
                } catch (e) {
                    return <Observable<Anonymous5[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous5[]>><any>Observable.throw(response_);
        });
    }

    protected processRepos10(response: Response): Observable<Anonymous5[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous5[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous5.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous5[]>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Created
     */
    repos11(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null, body: PostRepo): Observable<Anonymous5[]> {
        let url_ = this.baseUrl + "/user/repos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);
        
        let options_ = {
            body: content_,
            method: "post",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRepos11(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRepos11(response_);
                } catch (e) {
                    return <Observable<Anonymous5[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous5[]>><any>Observable.throw(response_);
        });
    }

    protected processRepos11(response: Response): Observable<Anonymous5[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 201) {
            const _responseText = response.text();
            let result201: Anonymous5[] | null = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData201 && resultData201.constructor === Array) {
                result201 = [];
                for (let item of resultData201)
                    result201.push(Anonymous5.fromJS(item));
            }
            return Observable.of(result201);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous5[]>(<any>null);
    }

    /**
     * @direction Ignored without 'sort' parameter.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    starred(direction: string | null, sort: Sort15 | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<any[]> {
        let url_ = this.baseUrl + "/user/starred?";
        if (direction !== undefined)
            url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
        if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processStarred(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processStarred(response_);
                } catch (e) {
                    return <Observable<any[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<any[]>><any>Observable.throw(response_);
        });
    }

    protected processStarred(response: Response): Observable<any[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<any[]>(<any>null);
    }

    /**
     * @owner Name of a repository owner.
     * @repo Name of a repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Unstarred.
     */
    starred2(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/user/starred/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processStarred2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processStarred2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processStarred2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of a repository owner.
     * @repo Name of a repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return This repository is starred by you.
     */
    starred3(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/user/starred/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processStarred3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processStarred3(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processStarred3(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of a repository owner.
     * @repo Name of a repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Repository starred.
     */
    starred4(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/user/starred/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "put",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processStarred4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processStarred4(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processStarred4(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    subscriptionsAll(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous28[]> {
        let url_ = this.baseUrl + "/user/subscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSubscriptionsAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSubscriptionsAll(response_);
                } catch (e) {
                    return <Observable<Anonymous28[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous28[]>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptionsAll(response: Response): Observable<Anonymous28[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous28[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous28.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous28[]>(<any>null);
    }

    /**
     * @owner Name of the owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Unwatched.
     */
    subscriptions(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/user/subscriptions/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSubscriptions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSubscriptions(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptions(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of the owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Repository is watched by you.
     */
    subscriptions2(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/user/subscriptions/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSubscriptions2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSubscriptions2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptions2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @owner Name of the owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Repository is watched.
     */
    subscriptions3(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/user/subscriptions/{owner}/{repo}";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "put",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSubscriptions3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSubscriptions3(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptions3(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    teams6(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous29[]> {
        let url_ = this.baseUrl + "/user/teams";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processTeams6(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processTeams6(response_);
                } catch (e) {
                    return <Observable<Anonymous29[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous29[]>><any>Observable.throw(response_);
        });
    }

    protected processTeams6(response: Response): Observable<Anonymous29[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous29[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous29.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous29[]>(<any>null);
    }

    /**
     * @since The integer ID of the last User that you've seen.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    usersAll(since: number | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous4[]> {
        let url_ = this.baseUrl + "/users?";
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processUsersAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUsersAll(response_);
                } catch (e) {
                    return <Observable<Anonymous4[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous4[]>><any>Observable.throw(response_);
        });
    }

    protected processUsersAll(response: Response): Observable<Anonymous4[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous4[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous4[]>(<any>null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    users2(username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous4[]> {
        let url_ = this.baseUrl + "/users/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processUsers2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUsers2(response_);
                } catch (e) {
                    return <Observable<Anonymous4[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous4[]>><any>Observable.throw(response_);
        });
    }

    protected processUsers2(response: Response): Observable<Anonymous4[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous4[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous4[]>(<any>null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    events8(username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/users/{username}/events";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processEvents8(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processEvents8(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processEvents8(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    orgs3(username: string, org: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/users/{username}/events/orgs/{org}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processOrgs3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processOrgs3(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processOrgs3(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    followers(username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous4[]> {
        let url_ = this.baseUrl + "/users/{username}/followers";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processFollowers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processFollowers(response_);
                } catch (e) {
                    return <Observable<Anonymous4[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous4[]>><any>Observable.throw(response_);
        });
    }

    protected processFollowers(response: Response): Observable<Anonymous4[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous4[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous4[]>(<any>null);
    }

    /**
     * @username Name of user.
     * @targetUser Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Response if user follows target user.
     */
    following4(username: string, targetUser: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/users/{username}/following/{targetUser}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        if (targetUser === undefined || targetUser === null)
            throw new Error("The parameter 'targetUser' must be defined.");
        url_ = url_.replace("{targetUser}", encodeURIComponent("" + targetUser)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processFollowing4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processFollowing4(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processFollowing4(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @username Name of user.
     * @since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
Example: "2012-10-09T23:39:01Z".
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    gists5(username: string, since: string | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous[]> {
        let url_ = this.baseUrl + "/users/{username}/gists?";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        if (since !== undefined)
            url_ += "since=" + encodeURIComponent("" + since) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processGists5(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGists5(response_);
                } catch (e) {
                    return <Observable<Anonymous[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous[]>><any>Observable.throw(response_);
        });
    }

    protected processGists5(response: Response): Observable<Anonymous[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous[]>(<any>null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    keys8(username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<any[]> {
        let url_ = this.baseUrl + "/users/{username}/keys";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processKeys8(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processKeys8(response_);
                } catch (e) {
                    return <Observable<any[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<any[]>><any>Observable.throw(response_);
        });
    }

    protected processKeys8(response: Response): Observable<any[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<any[]>(<any>null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    orgs4(username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<any[]> {
        let url_ = this.baseUrl + "/users/{username}/orgs";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processOrgs4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processOrgs4(response_);
                } catch (e) {
                    return <Observable<any[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<any[]>><any>Observable.throw(response_);
        });
    }

    protected processOrgs4(response: Response): Observable<any[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<any[]>(<any>null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    public(username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/users/{username}/received_events/public";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processPublic(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processPublic(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processPublic(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    repos12(username: string, type: Type3 | null, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous5[]> {
        let url_ = this.baseUrl + "/users/{username}/repos?";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processRepos12(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRepos12(response_);
                } catch (e) {
                    return <Observable<Anonymous5[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous5[]>><any>Observable.throw(response_);
        });
    }

    protected processRepos12(response: Response): Observable<Anonymous5[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous5[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous5.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous5[]>(<any>null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    starred5(username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/users/{username}/starred";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processStarred5(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processStarred5(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processStarred5(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    subscriptions4(username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/users/{username}/subscriptions";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processSubscriptions4(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSubscriptions4(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSubscriptions4(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class PublicGitHubClient {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.github.com";
    }

    /**
     * @org Name of organisation.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    membersAll(org: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous4[]> {
        let url_ = this.baseUrl + "/orgs/{org}/public_members";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMembersAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMembersAll(response_);
                } catch (e) {
                    return <Observable<Anonymous4[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous4[]>><any>Observable.throw(response_);
        });
    }

    protected processMembersAll(response: Response): Observable<Anonymous4[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous4[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous4.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous4[]>(<any>null);
    }

    /**
     * @org Name of organisation.
     * @username Name of the user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Concealed.
     */
    members(org: string, username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/orgs/{org}/public_members/{username}";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "delete",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMembers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMembers(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMembers(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @org Name of organisation.
     * @username Name of the user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return User is a public member.
     */
    members2(org: string, username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/orgs/{org}/public_members/{username}";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMembers2(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMembers2(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMembers2(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 404) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @org Name of organisation.
     * @username Name of the user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return Publicized.
     */
    members3(org: string, username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/orgs/{org}/public_members/{username}";
        if (org === undefined || org === null)
            throw new Error("The parameter 'org' must be defined.");
        url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "put",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processMembers3(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processMembers3(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMembers3(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 204) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class RateGitHubClient {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.github.com";
    }

    /**
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    limit(x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Rate_limit> {
        let url_ = this.baseUrl + "/rate_limit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processLimit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processLimit(response_);
                } catch (e) {
                    return <Observable<Rate_limit>><any>Observable.throw(e);
                }
            } else
                return <Observable<Rate_limit>><any>Observable.throw(response_);
        });
    }

    protected processLimit(response: Response): Observable<Rate_limit> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Rate_limit | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Rate_limit.fromJS(resultData200) : new Rate_limit();
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Rate_limit>(<any>null);
    }
}

@Injectable()
export class CodeGitHubClient {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.github.com";
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    frequency(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<number[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/stats/code_frequency";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processFrequency(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processFrequency(response_);
                } catch (e) {
                    return <Observable<number[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<number[]>><any>Observable.throw(response_);
        });
    }

    protected processFrequency(response: Response): Observable<number[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: number[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<number[]>(<any>null);
    }
}

@Injectable()
export class CommitGitHubClient {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.github.com";
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    activity(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<Anonymous30[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/stats/commit_activity";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processActivity(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processActivity(response_);
                } catch (e) {
                    return <Observable<Anonymous30[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Anonymous30[]>><any>Observable.throw(response_);
        });
    }

    protected processActivity(response: Response): Observable<Anonymous30[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: Anonymous30[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Anonymous30.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<Anonymous30[]>(<any>null);
    }
}

@Injectable()
export class PunchGitHubClient {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.github.com";
    }

    /**
     * @owner Name of repository owner.
     * @repo Name of repository.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     * @return OK
     */
    card(owner: string, repo: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<number[]> {
        let url_ = this.baseUrl + "/repos/{owner}/{repo}/stats/punch_card";
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
        if (repo === undefined || repo === null)
            throw new Error("The parameter 'repo' must be defined.");
        url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processCard(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCard(response_);
                } catch (e) {
                    return <Observable<number[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<number[]>><any>Observable.throw(response_);
        });
    }

    protected processCard(response: Response): Observable<number[]> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: number[] | null = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return Observable.of(result200);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<number[]>(<any>null);
    }
}

@Injectable()
export class ReceivedGitHubClient {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.github.com";
    }

    /**
     * @username Name of user.
     * @x_GitHub_Media_Type You can check the current version of media type in responses.
     * @accept Is used to set specified media type.
     */
    events(username: string, x_GitHub_Media_Type: string | null, accept: string | null, x_RateLimit_Limit: number | null, x_RateLimit_Remaining: number | null, x_RateLimit_Reset: number | null, x_GitHub_Request_Id: number | null): Observable<void> {
        let url_ = this.baseUrl + "/users/{username}/received_events";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = {
            method: "get",
            headers: new Headers({
                "X-GitHub-Media-Type": x_GitHub_Media_Type, 
                "Accept": accept, 
                "X-RateLimit-Limit": x_RateLimit_Limit, 
                "X-RateLimit-Remaining": x_RateLimit_Remaining, 
                "X-RateLimit-Reset": x_RateLimit_Reset, 
                "X-GitHub-Request-Id": x_GitHub_Request_Id, 
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_) => {
            return this.processEvents(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processEvents(response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processEvents(response: Response): Observable<void> {
        const status = response.status; 

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

export class Asset implements IAsset {
    content_type?: string | undefined;
    created_at?: string | undefined;
    download_count?: number | undefined;
    id?: number | undefined;
    label?: string | undefined;
    name?: string | undefined;
    size?: number | undefined;
    state?: string | undefined;
    updated_at?: string | undefined;
    uploader?: Uploader | undefined;
    url?: string | undefined;

    constructor(data?: IAsset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content_type = data["content_type"];
            this.created_at = data["created_at"];
            this.download_count = data["download_count"];
            this.id = data["id"];
            this.label = data["label"];
            this.name = data["name"];
            this.size = data["size"];
            this.state = data["state"];
            this.updated_at = data["updated_at"];
            this.uploader = data["uploader"] ? Uploader.fromJS(data["uploader"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Asset {
        let result = new Asset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content_type"] = this.content_type;
        data["created_at"] = this.created_at;
        data["download_count"] = this.download_count;
        data["id"] = this.id;
        data["label"] = this.label;
        data["name"] = this.name;
        data["size"] = this.size;
        data["state"] = this.state;
        data["updated_at"] = this.updated_at;
        data["uploader"] = this.uploader ? this.uploader.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAsset {
    content_type?: string | undefined;
    created_at?: string | undefined;
    download_count?: number | undefined;
    id?: number | undefined;
    label?: string | undefined;
    name?: string | undefined;
    size?: number | undefined;
    state?: string | undefined;
    updated_at?: string | undefined;
    uploader?: Uploader | undefined;
    url?: string | undefined;
}

export class AssetPatch implements IAssetPatch {
    label?: string | undefined;
    name: string;

    constructor(data?: IAssetPatch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): AssetPatch {
        let result = new AssetPatch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAssetPatch {
    label?: string | undefined;
    name: string;
}

export class Blob implements IBlob {
    content?: string | undefined;
    encoding?: BlobEncoding | undefined;
    sha?: string | undefined;
    size?: number | undefined;

    constructor(data?: IBlob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
            this.encoding = data["encoding"];
            this.sha = data["sha"];
            this.size = data["size"];
        }
    }

    static fromJS(data: any): Blob {
        let result = new Blob();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["encoding"] = this.encoding;
        data["sha"] = this.sha;
        data["size"] = this.size;
        return data; 
    }
}

export interface IBlob {
    content?: string | undefined;
    encoding?: BlobEncoding | undefined;
    sha?: string | undefined;
    size?: number | undefined;
}

export class Blobs implements IBlobs {
    sha?: string | undefined;

    constructor(data?: IBlobs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
        }
    }

    static fromJS(data: any): Blobs {
        let result = new Blobs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        return data; 
    }
}

export interface IBlobs {
    sha?: string | undefined;
}

export class Branch implements IBranch {
    _links?: _links | undefined;
    commit?: Commit2 | undefined;
    name?: string | undefined;

    constructor(data?: IBranch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links.fromJS(data["_links"]) : <any>undefined;
            this.commit = data["commit"] ? Commit2.fromJS(data["commit"]) : <any>undefined;
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Branch {
        let result = new Branch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["name"] = this.name;
        return data; 
    }
}

export interface IBranch {
    _links?: _links | undefined;
    commit?: Commit2 | undefined;
    name?: string | undefined;
}

export class Comment implements IComment {
    body?: string | undefined;

    constructor(data?: IComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
        }
    }

    static fromJS(data: any): Comment {
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        return data; 
    }
}

export interface IComment {
    body?: string | undefined;
}

export class CommentBody implements ICommentBody {
    body: string;

    constructor(data?: ICommentBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
        }
    }

    static fromJS(data: any): CommentBody {
        let result = new CommentBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        return data; 
    }
}

export interface ICommentBody {
    body: string;
}

export class Commit implements ICommit {
    author?: Author | undefined;
    commit?: Commit3 | undefined;
    committer?: Committer | undefined;
    files?: Files[] | undefined;
    parents?: Parents[] | undefined;
    sha?: string | undefined;
    stats?: Stats | undefined;
    url?: string | undefined;

    constructor(data?: ICommit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author.fromJS(data["author"]) : <any>undefined;
            this.commit = data["commit"] ? Commit3.fromJS(data["commit"]) : <any>undefined;
            this.committer = data["committer"] ? Committer.fromJS(data["committer"]) : <any>undefined;
            if (data["files"] && data["files"].constructor === Array) {
                this.files = [];
                for (let item of data["files"])
                    this.files.push(Files.fromJS(item));
            }
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(Parents.fromJS(item));
            }
            this.sha = data["sha"];
            this.stats = data["stats"] ? Stats.fromJS(data["stats"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Commit {
        let result = new Commit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        if (this.files && this.files.constructor === Array) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        data["sha"] = this.sha;
        data["stats"] = this.stats ? this.stats.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommit {
    author?: Author | undefined;
    commit?: Commit3 | undefined;
    committer?: Committer | undefined;
    files?: Files[] | undefined;
    parents?: Parents[] | undefined;
    sha?: string | undefined;
    stats?: Stats | undefined;
    url?: string | undefined;
}

export class CommitBody implements ICommitBody {
    body: string;
    /** Deprecated - Use position parameter instead. */
    line?: string | undefined;
    /** Line number in the file to comment on. Defaults to null. */
    number?: string | undefined;
    /** Relative path of the file to comment on. */
    path?: string | undefined;
    /** Line index in the diff to comment on. */
    position?: number | undefined;
    /** SHA of the commit to comment on. */
    sha: string;

    constructor(data?: ICommitBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.line = data["line"];
            this.number = data["number"];
            this.path = data["path"];
            this.position = data["position"];
            this.sha = data["sha"];
        }
    }

    static fromJS(data: any): CommitBody {
        let result = new CommitBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        data["line"] = this.line;
        data["number"] = this.number;
        data["path"] = this.path;
        data["position"] = this.position;
        data["sha"] = this.sha;
        return data; 
    }
}

export interface ICommitBody {
    body: string;
    /** Deprecated - Use position parameter instead. */
    line?: string | undefined;
    /** Line number in the file to comment on. Defaults to null. */
    number?: string | undefined;
    /** Relative path of the file to comment on. */
    path?: string | undefined;
    /** Line index in the diff to comment on. */
    position?: number | undefined;
    /** SHA of the commit to comment on. */
    sha: string;
}

export class CommitComments implements ICommitComments {
    body?: string | undefined;
    commit_id?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    line?: number | undefined;
    path?: string | undefined;
    position?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User2 | undefined;

    constructor(data?: ICommitComments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.commit_id = data["commit_id"];
            this.created_at = data["created_at"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.line = data["line"];
            this.path = data["path"];
            this.position = data["position"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? User2.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CommitComments {
        let result = new CommitComments();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        data["commit_id"] = this.commit_id;
        data["created_at"] = this.created_at;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["line"] = this.line;
        data["path"] = this.path;
        data["position"] = this.position;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICommitComments {
    body?: string | undefined;
    commit_id?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    line?: number | undefined;
    path?: string | undefined;
    position?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User2 | undefined;
}

export class CompareCommits implements ICompareCommits {
    ahead_by?: number | undefined;
    base_commit?: Base_commit | undefined;
    behind_by?: number | undefined;
    commits?: Commits[] | undefined;
    diff_url?: string | undefined;
    files?: Files2[] | undefined;
    html_url?: string | undefined;
    patch_url?: string | undefined;
    permalink_url?: string | undefined;
    status?: string | undefined;
    total_commits?: number | undefined;
    url?: string | undefined;

    constructor(data?: ICompareCommits) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ahead_by = data["ahead_by"];
            this.base_commit = data["base_commit"] ? Base_commit.fromJS(data["base_commit"]) : <any>undefined;
            this.behind_by = data["behind_by"];
            if (data["commits"] && data["commits"].constructor === Array) {
                this.commits = [];
                for (let item of data["commits"])
                    this.commits.push(Commits.fromJS(item));
            }
            this.diff_url = data["diff_url"];
            if (data["files"] && data["files"].constructor === Array) {
                this.files = [];
                for (let item of data["files"])
                    this.files.push(Files2.fromJS(item));
            }
            this.html_url = data["html_url"];
            this.patch_url = data["patch_url"];
            this.permalink_url = data["permalink_url"];
            this.status = data["status"];
            this.total_commits = data["total_commits"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): CompareCommits {
        let result = new CompareCommits();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ahead_by"] = this.ahead_by;
        data["base_commit"] = this.base_commit ? this.base_commit.toJSON() : <any>undefined;
        data["behind_by"] = this.behind_by;
        if (this.commits && this.commits.constructor === Array) {
            data["commits"] = [];
            for (let item of this.commits)
                data["commits"].push(item.toJSON());
        }
        data["diff_url"] = this.diff_url;
        if (this.files && this.files.constructor === Array) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        data["html_url"] = this.html_url;
        data["patch_url"] = this.patch_url;
        data["permalink_url"] = this.permalink_url;
        data["status"] = this.status;
        data["total_commits"] = this.total_commits;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICompareCommits {
    ahead_by?: number | undefined;
    base_commit?: Base_commit | undefined;
    behind_by?: number | undefined;
    commits?: Commits[] | undefined;
    diff_url?: string | undefined;
    files?: Files2[] | undefined;
    html_url?: string | undefined;
    patch_url?: string | undefined;
    permalink_url?: string | undefined;
    status?: string | undefined;
    total_commits?: number | undefined;
    url?: string | undefined;
}

export class ContentsPath implements IContentsPath {
    _links?: _links2 | undefined;
    content?: string | undefined;
    encoding?: string | undefined;
    git_url?: string | undefined;
    html_url?: string | undefined;
    name?: string | undefined;
    path?: string | undefined;
    sha?: string | undefined;
    size?: number | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IContentsPath) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links2.fromJS(data["_links"]) : <any>undefined;
            this.content = data["content"];
            this.encoding = data["encoding"];
            this.git_url = data["git_url"];
            this.html_url = data["html_url"];
            this.name = data["name"];
            this.path = data["path"];
            this.sha = data["sha"];
            this.size = data["size"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): ContentsPath {
        let result = new ContentsPath();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["content"] = this.content;
        data["encoding"] = this.encoding;
        data["git_url"] = this.git_url;
        data["html_url"] = this.html_url;
        data["name"] = this.name;
        data["path"] = this.path;
        data["sha"] = this.sha;
        data["size"] = this.size;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IContentsPath {
    _links?: _links2 | undefined;
    content?: string | undefined;
    encoding?: string | undefined;
    git_url?: string | undefined;
    html_url?: string | undefined;
    name?: string | undefined;
    path?: string | undefined;
    sha?: string | undefined;
    size?: number | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class CreateDownload implements ICreateDownload {
    accesskeyid?: string | undefined;
    acl?: string | undefined;
    bucket?: string | undefined;
    content_type?: string | undefined;
    description?: string | undefined;
    download_count?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    expirationdate?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    mime_type?: string | undefined;
    name?: string | undefined;
    path?: string | undefined;
    policy?: string | undefined;
    prefix?: string | undefined;
    redirect?: boolean | undefined;
    s3_url?: string | undefined;
    signature?: string | undefined;
    size?: number | undefined;
    url?: string | undefined;

    constructor(data?: ICreateDownload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accesskeyid = data["accesskeyid"];
            this.acl = data["acl"];
            this.bucket = data["bucket"];
            this.content_type = data["content_type"];
            this.description = data["description"];
            this.download_count = data["download_count"];
            this.expirationdate = data["expirationdate"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.mime_type = data["mime_type"];
            this.name = data["name"];
            this.path = data["path"];
            this.policy = data["policy"];
            this.prefix = data["prefix"];
            this.redirect = data["redirect"];
            this.s3_url = data["s3_url"];
            this.signature = data["signature"];
            this.size = data["size"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): CreateDownload {
        let result = new CreateDownload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accesskeyid"] = this.accesskeyid;
        data["acl"] = this.acl;
        data["bucket"] = this.bucket;
        data["content_type"] = this.content_type;
        data["description"] = this.description;
        data["download_count"] = this.download_count;
        data["expirationdate"] = this.expirationdate;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["mime_type"] = this.mime_type;
        data["name"] = this.name;
        data["path"] = this.path;
        data["policy"] = this.policy;
        data["prefix"] = this.prefix;
        data["redirect"] = this.redirect;
        data["s3_url"] = this.s3_url;
        data["signature"] = this.signature;
        data["size"] = this.size;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICreateDownload {
    accesskeyid?: string | undefined;
    acl?: string | undefined;
    bucket?: string | undefined;
    content_type?: string | undefined;
    description?: string | undefined;
    download_count?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    expirationdate?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    mime_type?: string | undefined;
    name?: string | undefined;
    path?: string | undefined;
    policy?: string | undefined;
    prefix?: string | undefined;
    redirect?: boolean | undefined;
    s3_url?: string | undefined;
    signature?: string | undefined;
    size?: number | undefined;
    url?: string | undefined;
}

export class CreateFile implements ICreateFile {
    commit?: Commit4 | undefined;
    content?: Content | undefined;

    constructor(data?: ICreateFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.commit = data["commit"] ? Commit4.fromJS(data["commit"]) : <any>undefined;
            this.content = data["content"] ? Content.fromJS(data["content"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateFile {
        let result = new CreateFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateFile {
    commit?: Commit4 | undefined;
    content?: Content | undefined;
}

export class CreateFileBody implements ICreateFileBody {
    committer?: Committer2 | undefined;
    content?: string | undefined;
    message?: string | undefined;

    constructor(data?: ICreateFileBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.committer = data["committer"] ? Committer2.fromJS(data["committer"]) : <any>undefined;
            this.content = data["content"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): CreateFileBody {
        let result = new CreateFileBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["content"] = this.content;
        data["message"] = this.message;
        return data; 
    }
}

export interface ICreateFileBody {
    committer?: Committer2 | undefined;
    content?: string | undefined;
    message?: string | undefined;
}

export class DeleteFile implements IDeleteFile {
    commit?: Commit5 | undefined;
    content?: string | undefined;

    constructor(data?: IDeleteFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.commit = data["commit"] ? Commit5.fromJS(data["commit"]) : <any>undefined;
            this.content = data["content"];
        }
    }

    static fromJS(data: any): DeleteFile {
        let result = new DeleteFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["content"] = this.content;
        return data; 
    }
}

export interface IDeleteFile {
    commit?: Commit5 | undefined;
    content?: string | undefined;
}

export class DeleteFileBody implements IDeleteFileBody {
    committer?: Committer3 | undefined;
    message?: string | undefined;
    sha?: string | undefined;

    constructor(data?: IDeleteFileBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.committer = data["committer"] ? Committer3.fromJS(data["committer"]) : <any>undefined;
            this.message = data["message"];
            this.sha = data["sha"];
        }
    }

    static fromJS(data: any): DeleteFileBody {
        let result = new DeleteFileBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["sha"] = this.sha;
        return data; 
    }
}

export interface IDeleteFileBody {
    committer?: Committer3 | undefined;
    message?: string | undefined;
    sha?: string | undefined;
}

export class Deployment implements IDeployment {
    description?: string | undefined;
    payload?: Payload | undefined;
    ref?: string | undefined;

    constructor(data?: IDeployment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.payload = data["payload"] ? Payload.fromJS(data["payload"]) : <any>undefined;
            this.ref = data["ref"];
        }
    }

    static fromJS(data: any): Deployment {
        let result = new Deployment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["payload"] = this.payload ? this.payload.toJSON() : <any>undefined;
        data["ref"] = this.ref;
        return data; 
    }
}

export interface IDeployment {
    description?: string | undefined;
    payload?: Payload | undefined;
    ref?: string | undefined;
}

export class DeploymentResp implements IDeploymentResp {
    created_at?: string | undefined;
    creator?: Creator | undefined;
    description?: string | undefined;
    id?: number | undefined;
    payload?: string | undefined;
    sha?: string | undefined;
    statuses_url?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;

    constructor(data?: IDeploymentResp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.creator = data["creator"] ? Creator.fromJS(data["creator"]) : <any>undefined;
            this.description = data["description"];
            this.id = data["id"];
            this.payload = data["payload"];
            this.sha = data["sha"];
            this.statuses_url = data["statuses_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): DeploymentResp {
        let result = new DeploymentResp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created_at"] = this.created_at;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["id"] = this.id;
        data["payload"] = this.payload;
        data["sha"] = this.sha;
        data["statuses_url"] = this.statuses_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        return data; 
    }
}

export interface IDeploymentResp {
    created_at?: string | undefined;
    creator?: Creator | undefined;
    description?: string | undefined;
    id?: number | undefined;
    payload?: string | undefined;
    sha?: string | undefined;
    statuses_url?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;
}

export class DeploymentStatusesCreate implements IDeploymentStatusesCreate {
    description?: string | undefined;
    state?: string | undefined;
    target_url?: string | undefined;

    constructor(data?: IDeploymentStatusesCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.state = data["state"];
            this.target_url = data["target_url"];
        }
    }

    static fromJS(data: any): DeploymentStatusesCreate {
        let result = new DeploymentStatusesCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["state"] = this.state;
        data["target_url"] = this.target_url;
        return data; 
    }
}

export interface IDeploymentStatusesCreate {
    description?: string | undefined;
    state?: string | undefined;
    target_url?: string | undefined;
}

export class DownloadBody implements IDownloadBody {
    content_type?: string | undefined;
    description?: string | undefined;
    name: string;
    /** Size of file in bytes. */
    size: number;

    constructor(data?: IDownloadBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content_type = data["content_type"];
            this.description = data["description"];
            this.name = data["name"];
            this.size = data["size"];
        }
    }

    static fromJS(data: any): DownloadBody {
        let result = new DownloadBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content_type"] = this.content_type;
        data["description"] = this.description;
        data["name"] = this.name;
        data["size"] = this.size;
        return data; 
    }
}

export interface IDownloadBody {
    content_type?: string | undefined;
    description?: string | undefined;
    name: string;
    /** Size of file in bytes. */
    size: number;
}

export class Downloads implements IDownloads {
    content_type?: string | undefined;
    description?: string | undefined;
    download_count?: number | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    name?: string | undefined;
    size?: number | undefined;
    url?: string | undefined;

    constructor(data?: IDownloads) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content_type = data["content_type"];
            this.description = data["description"];
            this.download_count = data["download_count"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.name = data["name"];
            this.size = data["size"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Downloads {
        let result = new Downloads();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content_type"] = this.content_type;
        data["description"] = this.description;
        data["download_count"] = this.download_count;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["name"] = this.name;
        data["size"] = this.size;
        data["url"] = this.url;
        return data; 
    }
}

export interface IDownloads {
    content_type?: string | undefined;
    description?: string | undefined;
    download_count?: number | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    name?: string | undefined;
    size?: number | undefined;
    url?: string | undefined;
}

export class EditTeam implements IEditTeam {
    name: string;
    permission?: EditTeamPermission | undefined;

    constructor(data?: IEditTeam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.permission = data["permission"];
        }
    }

    static fromJS(data: any): EditTeam {
        let result = new EditTeam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["permission"] = this.permission;
        return data; 
    }
}

export interface IEditTeam {
    name: string;
    permission?: EditTeamPermission | undefined;
}

export class Emojis implements IEmojis {
    _100?: string | undefined;
    _1234?: string | undefined;
    plus1?: string | undefined;
    _1?: string | undefined;
    _8ball?: string | undefined;
    a?: string | undefined;
    ab?: string | undefined;

    constructor(data?: IEmojis) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._100 = data["100"];
            this._1234 = data["1234"];
            this.plus1 = data["+1"];
            this._1 = data["-1"];
            this._8ball = data["8ball"];
            this.a = data["a"];
            this.ab = data["ab"];
        }
    }

    static fromJS(data: any): Emojis {
        let result = new Emojis();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["100"] = this._100;
        data["1234"] = this._1234;
        data["+1"] = this.plus1;
        data["-1"] = this._1;
        data["8ball"] = this._8ball;
        data["a"] = this.a;
        data["ab"] = this.ab;
        return data; 
    }
}

export interface IEmojis {
    _100?: string | undefined;
    _1234?: string | undefined;
    plus1?: string | undefined;
    _1?: string | undefined;
    _8ball?: string | undefined;
    a?: string | undefined;
    ab?: string | undefined;
}

export class Event implements IEvent {
    actor?: Actor | undefined;
    commit_id?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    event?: string | undefined;
    issue?: Issue2 | undefined;
    url?: string | undefined;

    constructor(data?: IEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.actor = data["actor"] ? Actor.fromJS(data["actor"]) : <any>undefined;
            this.commit_id = data["commit_id"];
            this.created_at = data["created_at"];
            this.event = data["event"];
            this.issue = data["issue"] ? Issue2.fromJS(data["issue"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Event {
        let result = new Event();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        data["commit_id"] = this.commit_id;
        data["created_at"] = this.created_at;
        data["event"] = this.event;
        data["issue"] = this.issue ? this.issue.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

export interface IEvent {
    actor?: Actor | undefined;
    commit_id?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    event?: string | undefined;
    issue?: Issue2 | undefined;
    url?: string | undefined;
}

export class Events implements IEvents {
    actor?: Actor2 | undefined;
    created_at?: any | undefined;
    id?: number | undefined;
    org?: Org | undefined;
    payload?: any | undefined;
    public?: boolean | undefined;
    repo?: Repo2 | undefined;
    type?: string | undefined;

    constructor(data?: IEvents) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.actor = data["actor"] ? Actor2.fromJS(data["actor"]) : <any>undefined;
            if (data["created_at"]) {
                this.created_at = {};
                for (let key in data["created_at"]) {
                    if (data["created_at"].hasOwnProperty(key))
                        this.created_at[key] = data["created_at"][key];
                }
            }
            this.id = data["id"];
            this.org = data["org"] ? Org.fromJS(data["org"]) : <any>undefined;
            if (data["payload"]) {
                this.payload = {};
                for (let key in data["payload"]) {
                    if (data["payload"].hasOwnProperty(key))
                        this.payload[key] = data["payload"][key];
                }
            }
            this.public = data["public"];
            this.repo = data["repo"] ? Repo2.fromJS(data["repo"]) : <any>undefined;
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Events {
        let result = new Events();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        if (this.created_at) {
            data["created_at"] = {};
            for (let key in this.created_at) {
                if (this.created_at.hasOwnProperty(key))
                    data["created_at"][key] = this.created_at[key];
            }
        }
        data["id"] = this.id;
        data["org"] = this.org ? this.org.toJSON() : <any>undefined;
        if (this.payload) {
            data["payload"] = {};
            for (let key in this.payload) {
                if (this.payload.hasOwnProperty(key))
                    data["payload"][key] = this.payload[key];
            }
        }
        data["public"] = this.public;
        data["repo"] = this.repo ? this.repo.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data; 
    }
}

export interface IEvents {
    actor?: Actor2 | undefined;
    created_at?: any | undefined;
    id?: number | undefined;
    org?: Org | undefined;
    payload?: any | undefined;
    public?: boolean | undefined;
    repo?: Repo2 | undefined;
    type?: string | undefined;
}

export class Feeds implements IFeeds {
    _links?: _links3 | undefined;
    current_user_actor_url?: string | undefined;
    current_user_organization_url?: string | undefined;
    current_user_public?: string | undefined;
    current_user_url?: string | undefined;
    timeline_url?: string | undefined;
    user_url?: string | undefined;

    constructor(data?: IFeeds) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links3.fromJS(data["_links"]) : <any>undefined;
            this.current_user_actor_url = data["current_user_actor_url"];
            this.current_user_organization_url = data["current_user_organization_url"];
            this.current_user_public = data["current_user_public"];
            this.current_user_url = data["current_user_url"];
            this.timeline_url = data["timeline_url"];
            this.user_url = data["user_url"];
        }
    }

    static fromJS(data: any): Feeds {
        let result = new Feeds();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["current_user_actor_url"] = this.current_user_actor_url;
        data["current_user_organization_url"] = this.current_user_organization_url;
        data["current_user_public"] = this.current_user_public;
        data["current_user_url"] = this.current_user_url;
        data["timeline_url"] = this.timeline_url;
        data["user_url"] = this.user_url;
        return data; 
    }
}

export interface IFeeds {
    _links?: _links3 | undefined;
    current_user_actor_url?: string | undefined;
    current_user_organization_url?: string | undefined;
    current_user_public?: string | undefined;
    current_user_url?: string | undefined;
    timeline_url?: string | undefined;
    user_url?: string | undefined;
}

export class Fork implements IFork {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;

    constructor(data?: IFork) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? Owner.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Fork {
        let result = new Fork();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

export interface IFork {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;
}

export class ForkBody implements IForkBody {
    organization?: string | undefined;

    constructor(data?: IForkBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organization = data["organization"];
        }
    }

    static fromJS(data: any): ForkBody {
        let result = new ForkBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organization"] = this.organization;
        return data; 
    }
}

export interface IForkBody {
    organization?: string | undefined;
}

export class Gist implements IGist {
    comments?: number | undefined;
    comments_url?: string | undefined;
    /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
    created_at?: string | undefined;
    description?: string | undefined;
    files?: Files3 | undefined;
    forks?: Forks[] | undefined;
    git_pull_url?: string | undefined;
    git_push_url?: string | undefined;
    history?: History[] | undefined;
    html_url?: string | undefined;
    id?: string | undefined;
    public?: boolean | undefined;
    url?: string | undefined;
    user?: User3 | undefined;

    constructor(data?: IGist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comments = data["comments"];
            this.comments_url = data["comments_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.files = data["files"] ? Files3.fromJS(data["files"]) : <any>undefined;
            if (data["forks"] && data["forks"].constructor === Array) {
                this.forks = [];
                for (let item of data["forks"])
                    this.forks.push(Forks.fromJS(item));
            }
            this.git_pull_url = data["git_pull_url"];
            this.git_push_url = data["git_push_url"];
            if (data["history"] && data["history"].constructor === Array) {
                this.history = [];
                for (let item of data["history"])
                    this.history.push(History.fromJS(item));
            }
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.public = data["public"];
            this.url = data["url"];
            this.user = data["user"] ? User3.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Gist {
        let result = new Gist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comments"] = this.comments;
        data["comments_url"] = this.comments_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["files"] = this.files ? this.files.toJSON() : <any>undefined;
        if (this.forks && this.forks.constructor === Array) {
            data["forks"] = [];
            for (let item of this.forks)
                data["forks"].push(item.toJSON());
        }
        data["git_pull_url"] = this.git_pull_url;
        data["git_push_url"] = this.git_push_url;
        if (this.history && this.history.constructor === Array) {
            data["history"] = [];
            for (let item of this.history)
                data["history"].push(item.toJSON());
        }
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["public"] = this.public;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGist {
    comments?: number | undefined;
    comments_url?: string | undefined;
    /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
    created_at?: string | undefined;
    description?: string | undefined;
    files?: Files3 | undefined;
    forks?: Forks[] | undefined;
    git_pull_url?: string | undefined;
    git_push_url?: string | undefined;
    history?: History[] | undefined;
    html_url?: string | undefined;
    id?: string | undefined;
    public?: boolean | undefined;
    url?: string | undefined;
    user?: User3 | undefined;
}

export class GitCommit implements IGitCommit {
    author?: Author2 | undefined;
    message?: string | undefined;
    parents?: string | undefined;
    tree?: string | undefined;

    constructor(data?: IGitCommit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author2.fromJS(data["author"]) : <any>undefined;
            this.message = data["message"];
            this.parents = data["parents"];
            this.tree = data["tree"];
        }
    }

    static fromJS(data: any): GitCommit {
        let result = new GitCommit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["parents"] = this.parents;
        data["tree"] = this.tree;
        return data; 
    }
}

export interface IGitCommit {
    author?: Author2 | undefined;
    message?: string | undefined;
    parents?: string | undefined;
    tree?: string | undefined;
}

export class GitRefPatch implements IGitRefPatch {
    force?: boolean | undefined;
    sha?: string | undefined;

    constructor(data?: IGitRefPatch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.force = data["force"];
            this.sha = data["sha"];
        }
    }

    static fromJS(data: any): GitRefPatch {
        let result = new GitRefPatch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["force"] = this.force;
        data["sha"] = this.sha;
        return data; 
    }
}

export interface IGitRefPatch {
    force?: boolean | undefined;
    sha?: string | undefined;
}

export class GitignoreLang implements IGitignoreLang {
    name?: string | undefined;
    source?: string | undefined;

    constructor(data?: IGitignoreLang) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.source = data["source"];
        }
    }

    static fromJS(data: any): GitignoreLang {
        let result = new GitignoreLang();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["source"] = this.source;
        return data; 
    }
}

export interface IGitignoreLang {
    name?: string | undefined;
    source?: string | undefined;
}

export class HeadBranch implements IHeadBranch {
    object?: Object | undefined;
    ref?: string | undefined;
    url?: string | undefined;

    constructor(data?: IHeadBranch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.object = data["object"] ? Object.fromJS(data["object"]) : <any>undefined;
            this.ref = data["ref"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): HeadBranch {
        let result = new HeadBranch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["object"] = this.object ? this.object.toJSON() : <any>undefined;
        data["ref"] = this.ref;
        data["url"] = this.url;
        return data; 
    }
}

export interface IHeadBranch {
    object?: Object | undefined;
    ref?: string | undefined;
    url?: string | undefined;
}

export class HeadBranchBody implements IHeadBranchBody {
    /** Boolean indicating whether to force the update or to make sure the update is a fast-forward update. The default is false, so leaving this out or setting it to false will make sure you’re not overwriting work. */
    force: boolean;
    /** String of the SHA1 value to set this reference to. */
    sha: string;

    constructor(data?: IHeadBranchBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.force = data["force"];
            this.sha = data["sha"];
        }
    }

    static fromJS(data: any): HeadBranchBody {
        let result = new HeadBranchBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["force"] = this.force;
        data["sha"] = this.sha;
        return data; 
    }
}

export interface IHeadBranchBody {
    /** Boolean indicating whether to force the update or to make sure the update is a fast-forward update. The default is false, so leaving this out or setting it to false will make sure you’re not overwriting work. */
    force: boolean;
    /** String of the SHA1 value to set this reference to. */
    sha: string;
}

export class HookBody implements IHookBody {
    active?: boolean | undefined;
    add_events?: string[] | undefined;

    constructor(data?: IHookBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.active = data["active"];
            if (data["add_events"] && data["add_events"].constructor === Array) {
                this.add_events = [];
                for (let item of data["add_events"])
                    this.add_events.push(item);
            }
        }
    }

    static fromJS(data: any): HookBody {
        let result = new HookBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        if (this.add_events && this.add_events.constructor === Array) {
            data["add_events"] = [];
            for (let item of this.add_events)
                data["add_events"].push(item);
        }
        return data; 
    }
}

export interface IHookBody {
    active?: boolean | undefined;
    add_events?: string[] | undefined;
}

export class Issue implements IIssue {
    assignee?: string | undefined;
    body?: string | undefined;
    labels?: string[] | undefined;
    milestone?: number | undefined;
    title?: string | undefined;

    constructor(data?: IIssue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assignee = data["assignee"];
            this.body = data["body"];
            if (data["labels"] && data["labels"].constructor === Array) {
                this.labels = [];
                for (let item of data["labels"])
                    this.labels.push(item);
            }
            this.milestone = data["milestone"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): Issue {
        let result = new Issue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assignee"] = this.assignee;
        data["body"] = this.body;
        if (this.labels && this.labels.constructor === Array) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        data["milestone"] = this.milestone;
        data["title"] = this.title;
        return data; 
    }
}

export interface IIssue {
    assignee?: string | undefined;
    body?: string | undefined;
    labels?: string[] | undefined;
    milestone?: number | undefined;
    title?: string | undefined;
}

export class IssueBody implements IIssueBody {
    assignee?: string | undefined;
    body?: string | undefined;
    labels?: string[] | undefined;
    milestone?: number | undefined;
    title?: string | undefined;

    constructor(data?: IIssueBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assignee = data["assignee"];
            this.body = data["body"];
            if (data["labels"] && data["labels"].constructor === Array) {
                this.labels = [];
                for (let item of data["labels"])
                    this.labels.push(item);
            }
            this.milestone = data["milestone"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): IssueBody {
        let result = new IssueBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assignee"] = this.assignee;
        data["body"] = this.body;
        if (this.labels && this.labels.constructor === Array) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        data["milestone"] = this.milestone;
        data["title"] = this.title;
        return data; 
    }
}

export interface IIssueBody {
    assignee?: string | undefined;
    body?: string | undefined;
    labels?: string[] | undefined;
    milestone?: number | undefined;
    title?: string | undefined;
}

export class IssuesComment implements IIssuesComment {
    body?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User4 | undefined;

    constructor(data?: IIssuesComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.created_at = data["created_at"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? User4.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IssuesComment {
        let result = new IssuesComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        data["created_at"] = this.created_at;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIssuesComment {
    body?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User4 | undefined;
}

export class Key implements IKey {
    id?: number | undefined;
    key?: string | undefined;
    title?: string | undefined;
    url?: string | undefined;

    constructor(data?: IKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.key = data["key"];
            this.title = data["title"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Key {
        let result = new Key();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["title"] = this.title;
        data["url"] = this.url;
        return data; 
    }
}

export interface IKey {
    id?: number | undefined;
    key?: string | undefined;
    title?: string | undefined;
    url?: string | undefined;
}

export class KeyBody implements IKeyBody {
    key?: string | undefined;
    title?: string | undefined;

    constructor(data?: IKeyBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): KeyBody {
        let result = new KeyBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["title"] = this.title;
        return data; 
    }
}

export interface IKeyBody {
    key?: string | undefined;
    title?: string | undefined;
}

export class Label implements ILabel {
    color?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;

    constructor(data?: ILabel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.color = data["color"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Label {
        let result = new Label();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["color"] = this.color;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

export interface ILabel {
    color?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
}

export class Markdown implements IMarkdown {
    context?: string | undefined;
    mode?: string | undefined;
    text?: string | undefined;

    constructor(data?: IMarkdown) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.context = data["context"];
            this.mode = data["mode"];
            this.text = data["text"];
        }
    }

    static fromJS(data: any): Markdown {
        let result = new Markdown();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["context"] = this.context;
        data["mode"] = this.mode;
        data["text"] = this.text;
        return data; 
    }
}

export interface IMarkdown {
    context?: string | undefined;
    mode?: string | undefined;
    text?: string | undefined;
}

export class Merge implements IMerge {
    merged?: boolean | undefined;
    message?: string | undefined;
    sha?: string | undefined;

    constructor(data?: IMerge) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.merged = data["merged"];
            this.message = data["message"];
            this.sha = data["sha"];
        }
    }

    static fromJS(data: any): Merge {
        let result = new Merge();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["merged"] = this.merged;
        data["message"] = this.message;
        data["sha"] = this.sha;
        return data; 
    }
}

export interface IMerge {
    merged?: boolean | undefined;
    message?: string | undefined;
    sha?: string | undefined;
}

export class MergePullBody implements IMergePullBody {
    commit_message?: string | undefined;

    constructor(data?: IMergePullBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.commit_message = data["commit_message"];
        }
    }

    static fromJS(data: any): MergePullBody {
        let result = new MergePullBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commit_message"] = this.commit_message;
        return data; 
    }
}

export interface IMergePullBody {
    commit_message?: string | undefined;
}

export class MergesBody implements IMergesBody {
    base?: string | undefined;
    commit_message?: string | undefined;
    head?: string | undefined;

    constructor(data?: IMergesBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.base = data["base"];
            this.commit_message = data["commit_message"];
            this.head = data["head"];
        }
    }

    static fromJS(data: any): MergesBody {
        let result = new MergesBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base"] = this.base;
        data["commit_message"] = this.commit_message;
        data["head"] = this.head;
        return data; 
    }
}

export interface IMergesBody {
    base?: string | undefined;
    commit_message?: string | undefined;
    head?: string | undefined;
}

export class MergesConflict implements IMergesConflict {
    /** Error message */
    message?: string | undefined;

    constructor(data?: IMergesConflict) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["message"];
        }
    }

    static fromJS(data: any): MergesConflict {
        let result = new MergesConflict();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        return data; 
    }
}

export interface IMergesConflict {
    /** Error message */
    message?: string | undefined;
}

export class MergesSuccessful implements IMergesSuccessful {
    author?: Author3 | undefined;
    comments_url?: string | undefined;
    commit?: Commit6 | undefined;
    committer?: Committer4 | undefined;
    merged?: boolean | undefined;
    message?: string | undefined;
    parents?: Parents2[] | undefined;
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: IMergesSuccessful) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author3.fromJS(data["author"]) : <any>undefined;
            this.comments_url = data["comments_url"];
            this.commit = data["commit"] ? Commit6.fromJS(data["commit"]) : <any>undefined;
            this.committer = data["committer"] ? Committer4.fromJS(data["committer"]) : <any>undefined;
            this.merged = data["merged"];
            this.message = data["message"];
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(Parents2.fromJS(item));
            }
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): MergesSuccessful {
        let result = new MergesSuccessful();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["comments_url"] = this.comments_url;
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["merged"] = this.merged;
        data["message"] = this.message;
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface IMergesSuccessful {
    author?: Author3 | undefined;
    comments_url?: string | undefined;
    commit?: Commit6 | undefined;
    committer?: Committer4 | undefined;
    merged?: boolean | undefined;
    message?: string | undefined;
    parents?: Parents2[] | undefined;
    sha?: string | undefined;
    url?: string | undefined;
}

export class Meta implements IMeta {
    git?: string[] | undefined;
    hooks?: string[] | undefined;

    constructor(data?: IMeta) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["git"] && data["git"].constructor === Array) {
                this.git = [];
                for (let item of data["git"])
                    this.git.push(item);
            }
            if (data["hooks"] && data["hooks"].constructor === Array) {
                this.hooks = [];
                for (let item of data["hooks"])
                    this.hooks.push(item);
            }
        }
    }

    static fromJS(data: any): Meta {
        let result = new Meta();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.git && this.git.constructor === Array) {
            data["git"] = [];
            for (let item of this.git)
                data["git"].push(item);
        }
        if (this.hooks && this.hooks.constructor === Array) {
            data["hooks"] = [];
            for (let item of this.hooks)
                data["hooks"].push(item);
        }
        return data; 
    }
}

export interface IMeta {
    git?: string[] | undefined;
    hooks?: string[] | undefined;
}

export class Milestone implements IMilestone {
    closed_issues?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    creator?: Creator2 | undefined;
    description?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    due_on?: string | undefined;
    number?: number | undefined;
    open_issues?: number | undefined;
    state?: MilestoneState | undefined;
    title?: string | undefined;
    url?: string | undefined;

    constructor(data?: IMilestone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.closed_issues = data["closed_issues"];
            this.created_at = data["created_at"];
            this.creator = data["creator"] ? Creator2.fromJS(data["creator"]) : <any>undefined;
            this.description = data["description"];
            this.due_on = data["due_on"];
            this.number = data["number"];
            this.open_issues = data["open_issues"];
            this.state = data["state"];
            this.title = data["title"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Milestone {
        let result = new Milestone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["closed_issues"] = this.closed_issues;
        data["created_at"] = this.created_at;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["due_on"] = this.due_on;
        data["number"] = this.number;
        data["open_issues"] = this.open_issues;
        data["state"] = this.state;
        data["title"] = this.title;
        data["url"] = this.url;
        return data; 
    }
}

export interface IMilestone {
    closed_issues?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    creator?: Creator2 | undefined;
    description?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    due_on?: string | undefined;
    number?: number | undefined;
    open_issues?: number | undefined;
    state?: MilestoneState | undefined;
    title?: string | undefined;
    url?: string | undefined;
}

export class MilestoneBody implements IMilestoneBody {
    description?: string | undefined;
    due_on?: string | undefined;
    state?: string | undefined;
    title?: string | undefined;

    constructor(data?: IMilestoneBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.due_on = data["due_on"];
            this.state = data["state"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): MilestoneBody {
        let result = new MilestoneBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["due_on"] = this.due_on;
        data["state"] = this.state;
        data["title"] = this.title;
        return data; 
    }
}

export interface IMilestoneBody {
    description?: string | undefined;
    due_on?: string | undefined;
    state?: string | undefined;
    title?: string | undefined;
}

export class MilestoneUpdate implements IMilestoneUpdate {
    description?: string | undefined;
    due_on?: string | undefined;
    state?: string | undefined;
    title?: string | undefined;

    constructor(data?: IMilestoneUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.due_on = data["due_on"];
            this.state = data["state"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): MilestoneUpdate {
        let result = new MilestoneUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["due_on"] = this.due_on;
        data["state"] = this.state;
        data["title"] = this.title;
        return data; 
    }
}

export interface IMilestoneUpdate {
    description?: string | undefined;
    due_on?: string | undefined;
    state?: string | undefined;
    title?: string | undefined;
}

export class NotificationMarkRead implements INotificationMarkRead {
    last_read_at?: string | undefined;

    constructor(data?: INotificationMarkRead) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.last_read_at = data["last_read_at"];
        }
    }

    static fromJS(data: any): NotificationMarkRead {
        let result = new NotificationMarkRead();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["last_read_at"] = this.last_read_at;
        return data; 
    }
}

export interface INotificationMarkRead {
    last_read_at?: string | undefined;
}

export class Notifications implements INotifications {
    id?: number | undefined;
    last_read_at?: string | undefined;
    reason?: string | undefined;
    repository?: Repository | undefined;
    subject?: Subject | undefined;
    unread?: boolean | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;

    constructor(data?: INotifications) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.last_read_at = data["last_read_at"];
            this.reason = data["reason"];
            this.repository = data["repository"] ? Repository.fromJS(data["repository"]) : <any>undefined;
            this.subject = data["subject"] ? Subject.fromJS(data["subject"]) : <any>undefined;
            this.unread = data["unread"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Notifications {
        let result = new Notifications();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["last_read_at"] = this.last_read_at;
        data["reason"] = this.reason;
        data["repository"] = this.repository ? this.repository.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["unread"] = this.unread;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        return data; 
    }
}

export interface INotifications {
    id?: number | undefined;
    last_read_at?: string | undefined;
    reason?: string | undefined;
    repository?: Repository | undefined;
    subject?: Subject | undefined;
    unread?: boolean | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;
}

export class OrgTeamsPost implements IOrgTeamsPost {
    name: string;
    permission?: OrgTeamsPostPermission | undefined;
    repo_names?: string[] | undefined;

    constructor(data?: IOrgTeamsPost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.permission = data["permission"];
            if (data["repo_names"] && data["repo_names"].constructor === Array) {
                this.repo_names = [];
                for (let item of data["repo_names"])
                    this.repo_names.push(item);
            }
        }
    }

    static fromJS(data: any): OrgTeamsPost {
        let result = new OrgTeamsPost();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["permission"] = this.permission;
        if (this.repo_names && this.repo_names.constructor === Array) {
            data["repo_names"] = [];
            for (let item of this.repo_names)
                data["repo_names"].push(item);
        }
        return data; 
    }
}

export interface IOrgTeamsPost {
    name: string;
    permission?: OrgTeamsPostPermission | undefined;
    repo_names?: string[] | undefined;
}

export class Organization implements IOrganization {
    avatar_url?: string | undefined;
    blog?: string | undefined;
    company?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    email?: string | undefined;
    followers?: number | undefined;
    following?: number | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    location?: string | undefined;
    login?: string | undefined;
    name?: string | undefined;
    public_gists?: number | undefined;
    public_repos?: number | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOrganization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.blog = data["blog"];
            this.company = data["company"];
            this.created_at = data["created_at"];
            this.email = data["email"];
            this.followers = data["followers"];
            this.following = data["following"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.location = data["location"];
            this.login = data["login"];
            this.name = data["name"];
            this.public_gists = data["public_gists"];
            this.public_repos = data["public_repos"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Organization {
        let result = new Organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["blog"] = this.blog;
        data["company"] = this.company;
        data["created_at"] = this.created_at;
        data["email"] = this.email;
        data["followers"] = this.followers;
        data["following"] = this.following;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["location"] = this.location;
        data["login"] = this.login;
        data["name"] = this.name;
        data["public_gists"] = this.public_gists;
        data["public_repos"] = this.public_repos;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOrganization {
    avatar_url?: string | undefined;
    blog?: string | undefined;
    company?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    email?: string | undefined;
    followers?: number | undefined;
    following?: number | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    location?: string | undefined;
    login?: string | undefined;
    name?: string | undefined;
    public_gists?: number | undefined;
    public_repos?: number | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class OrganizationAsTeamMember implements IOrganizationAsTeamMember {
    errors?: Errors[] | undefined;
    message?: string | undefined;

    constructor(data?: IOrganizationAsTeamMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [];
                for (let item of data["errors"])
                    this.errors.push(Errors.fromJS(item));
            }
            this.message = data["message"];
        }
    }

    static fromJS(data: any): OrganizationAsTeamMember {
        let result = new OrganizationAsTeamMember();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["message"] = this.message;
        return data; 
    }
}

export interface IOrganizationAsTeamMember {
    errors?: Errors[] | undefined;
    message?: string | undefined;
}

export class ParticipationStats implements IParticipationStats {
    all?: number[] | undefined;
    owner?: number[] | undefined;

    constructor(data?: IParticipationStats) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["all"] && data["all"].constructor === Array) {
                this.all = [];
                for (let item of data["all"])
                    this.all.push(item);
            }
            if (data["owner"] && data["owner"].constructor === Array) {
                this.owner = [];
                for (let item of data["owner"])
                    this.owner.push(item);
            }
        }
    }

    static fromJS(data: any): ParticipationStats {
        let result = new ParticipationStats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.all && this.all.constructor === Array) {
            data["all"] = [];
            for (let item of this.all)
                data["all"].push(item);
        }
        if (this.owner && this.owner.constructor === Array) {
            data["owner"] = [];
            for (let item of this.owner)
                data["owner"].push(item);
        }
        return data; 
    }
}

export interface IParticipationStats {
    all?: number[] | undefined;
    owner?: number[] | undefined;
}

export class PatchGist implements IPatchGist {
    description?: string | undefined;
    files?: Files4 | undefined;

    constructor(data?: IPatchGist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.files = data["files"] ? Files4.fromJS(data["files"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PatchGist {
        let result = new PatchGist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["files"] = this.files ? this.files.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPatchGist {
    description?: string | undefined;
    files?: Files4 | undefined;
}

export class PatchOrg implements IPatchOrg {
    /** Billing email address. This address is not publicized. */
    billing_email?: string | undefined;
    company?: string | undefined;
    /** Publicly visible email address. */
    email?: string | undefined;
    location?: string | undefined;
    name?: string | undefined;

    constructor(data?: IPatchOrg) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.billing_email = data["billing_email"];
            this.company = data["company"];
            this.email = data["email"];
            this.location = data["location"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PatchOrg {
        let result = new PatchOrg();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billing_email"] = this.billing_email;
        data["company"] = this.company;
        data["email"] = this.email;
        data["location"] = this.location;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPatchOrg {
    /** Billing email address. This address is not publicized. */
    billing_email?: string | undefined;
    company?: string | undefined;
    /** Publicly visible email address. */
    email?: string | undefined;
    location?: string | undefined;
    name?: string | undefined;
}

export class PostComment implements IPostComment {
    body: string;

    constructor(data?: IPostComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
        }
    }

    static fromJS(data: any): PostComment {
        let result = new PostComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        return data; 
    }
}

export interface IPostComment {
    body: string;
}

export class PostGist implements IPostGist {
    description?: string | undefined;
    files?: Files5 | undefined;
    public?: boolean | undefined;

    constructor(data?: IPostGist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.files = data["files"] ? Files5.fromJS(data["files"]) : <any>undefined;
            this.public = data["public"];
        }
    }

    static fromJS(data: any): PostGist {
        let result = new PostGist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["files"] = this.files ? this.files.toJSON() : <any>undefined;
        data["public"] = this.public;
        return data; 
    }
}

export interface IPostGist {
    description?: string | undefined;
    files?: Files5 | undefined;
    public?: boolean | undefined;
}

export class PostRepo implements IPostRepo {
    /** True to create an initial commit with empty README. Default is false. */
    auto_init?: boolean | undefined;
    description?: string | undefined;
    /** Desired language or platform .gitignore template to apply. Use the name of the template without the extension. For example, "Haskell" Ignored if auto_init parameter is not provided.  */
    gitignore_template?: string | undefined;
    /** True to enable downloads for this repository, false to disable them. Default is true. */
    has_downloads?: boolean | undefined;
    /** True to enable issues for this repository, false to disable them. Default is true. */
    has_issues?: boolean | undefined;
    /** True to enable the wiki for this repository, false to disable it. Default is true. */
    has_wiki?: boolean | undefined;
    homepage?: string | undefined;
    name: string;
    /** True to create a private repository, false to create a public one. Creating private repositories requires a paid GitHub account. */
    private?: boolean | undefined;
    /** The id of the team that will be granted access to this repository. This is only valid when creating a repo in an organization. */
    team_id?: number | undefined;

    constructor(data?: IPostRepo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.auto_init = data["auto_init"];
            this.description = data["description"];
            this.gitignore_template = data["gitignore_template"];
            this.has_downloads = data["has_downloads"];
            this.has_issues = data["has_issues"];
            this.has_wiki = data["has_wiki"];
            this.homepage = data["homepage"];
            this.name = data["name"];
            this.private = data["private"];
            this.team_id = data["team_id"];
        }
    }

    static fromJS(data: any): PostRepo {
        let result = new PostRepo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["auto_init"] = this.auto_init;
        data["description"] = this.description;
        data["gitignore_template"] = this.gitignore_template;
        data["has_downloads"] = this.has_downloads;
        data["has_issues"] = this.has_issues;
        data["has_wiki"] = this.has_wiki;
        data["homepage"] = this.homepage;
        data["name"] = this.name;
        data["private"] = this.private;
        data["team_id"] = this.team_id;
        return data; 
    }
}

export interface IPostRepo {
    /** True to create an initial commit with empty README. Default is false. */
    auto_init?: boolean | undefined;
    description?: string | undefined;
    /** Desired language or platform .gitignore template to apply. Use the name of the template without the extension. For example, "Haskell" Ignored if auto_init parameter is not provided.  */
    gitignore_template?: string | undefined;
    /** True to enable downloads for this repository, false to disable them. Default is true. */
    has_downloads?: boolean | undefined;
    /** True to enable issues for this repository, false to disable them. Default is true. */
    has_issues?: boolean | undefined;
    /** True to enable the wiki for this repository, false to disable it. Default is true. */
    has_wiki?: boolean | undefined;
    homepage?: string | undefined;
    name: string;
    /** True to create a private repository, false to create a public one. Creating private repositories requires a paid GitHub account. */
    private?: boolean | undefined;
    /** The id of the team that will be granted access to this repository. This is only valid when creating a repo in an organization. */
    team_id?: number | undefined;
}

export class PullRequest implements IPullRequest {
    _links?: _links4 | undefined;
    additions?: number | undefined;
    base?: Base | undefined;
    body?: string | undefined;
    changed_files?: number | undefined;
    closed_at?: string | undefined;
    comments?: number | undefined;
    commits?: number | undefined;
    created_at?: string | undefined;
    deletions?: number | undefined;
    diff_url?: string | undefined;
    head?: Head | undefined;
    html_url?: string | undefined;
    issue_url?: string | undefined;
    merge_commit_sha?: string | undefined;
    mergeable?: boolean | undefined;
    merged?: boolean | undefined;
    merged_at?: string | undefined;
    merged_by?: Merged_by | undefined;
    number?: number | undefined;
    patch_url?: string | undefined;
    state?: string | undefined;
    title?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User5 | undefined;

    constructor(data?: IPullRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links4.fromJS(data["_links"]) : <any>undefined;
            this.additions = data["additions"];
            this.base = data["base"] ? Base.fromJS(data["base"]) : <any>undefined;
            this.body = data["body"];
            this.changed_files = data["changed_files"];
            this.closed_at = data["closed_at"];
            this.comments = data["comments"];
            this.commits = data["commits"];
            this.created_at = data["created_at"];
            this.deletions = data["deletions"];
            this.diff_url = data["diff_url"];
            this.head = data["head"] ? Head.fromJS(data["head"]) : <any>undefined;
            this.html_url = data["html_url"];
            this.issue_url = data["issue_url"];
            this.merge_commit_sha = data["merge_commit_sha"];
            this.mergeable = data["mergeable"];
            this.merged = data["merged"];
            this.merged_at = data["merged_at"];
            this.merged_by = data["merged_by"] ? Merged_by.fromJS(data["merged_by"]) : <any>undefined;
            this.number = data["number"];
            this.patch_url = data["patch_url"];
            this.state = data["state"];
            this.title = data["title"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? User5.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PullRequest {
        let result = new PullRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["additions"] = this.additions;
        data["base"] = this.base ? this.base.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["changed_files"] = this.changed_files;
        data["closed_at"] = this.closed_at;
        data["comments"] = this.comments;
        data["commits"] = this.commits;
        data["created_at"] = this.created_at;
        data["deletions"] = this.deletions;
        data["diff_url"] = this.diff_url;
        data["head"] = this.head ? this.head.toJSON() : <any>undefined;
        data["html_url"] = this.html_url;
        data["issue_url"] = this.issue_url;
        data["merge_commit_sha"] = this.merge_commit_sha;
        data["mergeable"] = this.mergeable;
        data["merged"] = this.merged;
        data["merged_at"] = this.merged_at;
        data["merged_by"] = this.merged_by ? this.merged_by.toJSON() : <any>undefined;
        data["number"] = this.number;
        data["patch_url"] = this.patch_url;
        data["state"] = this.state;
        data["title"] = this.title;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPullRequest {
    _links?: _links4 | undefined;
    additions?: number | undefined;
    base?: Base | undefined;
    body?: string | undefined;
    changed_files?: number | undefined;
    closed_at?: string | undefined;
    comments?: number | undefined;
    commits?: number | undefined;
    created_at?: string | undefined;
    deletions?: number | undefined;
    diff_url?: string | undefined;
    head?: Head | undefined;
    html_url?: string | undefined;
    issue_url?: string | undefined;
    merge_commit_sha?: string | undefined;
    mergeable?: boolean | undefined;
    merged?: boolean | undefined;
    merged_at?: string | undefined;
    merged_by?: Merged_by | undefined;
    number?: number | undefined;
    patch_url?: string | undefined;
    state?: string | undefined;
    title?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User5 | undefined;
}

export class PullUpdate implements IPullUpdate {
    body?: string | undefined;
    state?: string | undefined;
    title?: string | undefined;

    constructor(data?: IPullUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.state = data["state"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): PullUpdate {
        let result = new PullUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        data["state"] = this.state;
        data["title"] = this.title;
        return data; 
    }
}

export interface IPullUpdate {
    body?: string | undefined;
    state?: string | undefined;
    title?: string | undefined;
}

export class PullsComment implements IPullsComment {
    _links?: _links5 | undefined;
    body?: string | undefined;
    commit_id?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    id?: number | undefined;
    path?: string | undefined;
    position?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User6 | undefined;

    constructor(data?: IPullsComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links5.fromJS(data["_links"]) : <any>undefined;
            this.body = data["body"];
            this.commit_id = data["commit_id"];
            this.created_at = data["created_at"];
            this.id = data["id"];
            this.path = data["path"];
            this.position = data["position"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? User6.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PullsComment {
        let result = new PullsComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["commit_id"] = this.commit_id;
        data["created_at"] = this.created_at;
        data["id"] = this.id;
        data["path"] = this.path;
        data["position"] = this.position;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPullsComment {
    _links?: _links5 | undefined;
    body?: string | undefined;
    commit_id?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    id?: number | undefined;
    path?: string | undefined;
    position?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User6 | undefined;
}

export class PullsCommentPost implements IPullsCommentPost {
    body?: string | undefined;
    commit_id?: string | undefined;
    path?: string | undefined;
    position?: number | undefined;

    constructor(data?: IPullsCommentPost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.commit_id = data["commit_id"];
            this.path = data["path"];
            this.position = data["position"];
        }
    }

    static fromJS(data: any): PullsCommentPost {
        let result = new PullsCommentPost();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        data["commit_id"] = this.commit_id;
        data["path"] = this.path;
        data["position"] = this.position;
        return data; 
    }
}

export interface IPullsCommentPost {
    body?: string | undefined;
    commit_id?: string | undefined;
    path?: string | undefined;
    position?: number | undefined;
}

export class PullsPost implements IPullsPost {
    base?: string | undefined;
    body?: string | undefined;
    head?: string | undefined;
    title?: string | undefined;

    constructor(data?: IPullsPost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.base = data["base"];
            this.body = data["body"];
            this.head = data["head"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): PullsPost {
        let result = new PullsPost();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base"] = this.base;
        data["body"] = this.body;
        data["head"] = this.head;
        data["title"] = this.title;
        return data; 
    }
}

export interface IPullsPost {
    base?: string | undefined;
    body?: string | undefined;
    head?: string | undefined;
    title?: string | undefined;
}

export class PutSubscription implements IPutSubscription {
    created_at?: string | undefined;
    ignored?: boolean | undefined;
    reason?: any | undefined;
    subscribed?: boolean | undefined;
    thread_url?: string | undefined;
    url?: string | undefined;

    constructor(data?: IPutSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.ignored = data["ignored"];
            if (data["reason"]) {
                this.reason = {};
                for (let key in data["reason"]) {
                    if (data["reason"].hasOwnProperty(key))
                        this.reason[key] = data["reason"][key];
                }
            }
            this.subscribed = data["subscribed"];
            this.thread_url = data["thread_url"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): PutSubscription {
        let result = new PutSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created_at"] = this.created_at;
        data["ignored"] = this.ignored;
        if (this.reason) {
            data["reason"] = {};
            for (let key in this.reason) {
                if (this.reason.hasOwnProperty(key))
                    data["reason"][key] = this.reason[key];
            }
        }
        data["subscribed"] = this.subscribed;
        data["thread_url"] = this.thread_url;
        data["url"] = this.url;
        return data; 
    }
}

export interface IPutSubscription {
    created_at?: string | undefined;
    ignored?: boolean | undefined;
    reason?: any | undefined;
    subscribed?: boolean | undefined;
    thread_url?: string | undefined;
    url?: string | undefined;
}

export class Rate_limit implements IRate_limit {
    rate?: Rate | undefined;

    constructor(data?: IRate_limit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rate = data["rate"] ? Rate.fromJS(data["rate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Rate_limit {
        let result = new Rate_limit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rate"] = this.rate ? this.rate.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRate_limit {
    rate?: Rate | undefined;
}

export class Readme implements IReadme {
    _links?: _links6 | undefined;
    content?: string | undefined;
    encoding?: string | undefined;
    git_url?: string | undefined;
    html_url?: string | undefined;
    name?: string | undefined;
    path?: string | undefined;
    sha?: string | undefined;
    size?: number | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IReadme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links6.fromJS(data["_links"]) : <any>undefined;
            this.content = data["content"];
            this.encoding = data["encoding"];
            this.git_url = data["git_url"];
            this.html_url = data["html_url"];
            this.name = data["name"];
            this.path = data["path"];
            this.sha = data["sha"];
            this.size = data["size"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Readme {
        let result = new Readme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["content"] = this.content;
        data["encoding"] = this.encoding;
        data["git_url"] = this.git_url;
        data["html_url"] = this.html_url;
        data["name"] = this.name;
        data["path"] = this.path;
        data["sha"] = this.sha;
        data["size"] = this.size;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IReadme {
    _links?: _links6 | undefined;
    content?: string | undefined;
    encoding?: string | undefined;
    git_url?: string | undefined;
    html_url?: string | undefined;
    name?: string | undefined;
    path?: string | undefined;
    sha?: string | undefined;
    size?: number | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class RefBody implements IRefBody {
    object?: Object2 | undefined;
    ref?: string | undefined;
    url?: string | undefined;

    constructor(data?: IRefBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.object = data["object"] ? Object2.fromJS(data["object"]) : <any>undefined;
            this.ref = data["ref"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): RefBody {
        let result = new RefBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["object"] = this.object ? this.object.toJSON() : <any>undefined;
        data["ref"] = this.ref;
        data["url"] = this.url;
        return data; 
    }
}

export interface IRefBody {
    object?: Object2 | undefined;
    ref?: string | undefined;
    url?: string | undefined;
}

export class RefsBody implements IRefsBody {
    ref?: string | undefined;
    sha?: string | undefined;

    constructor(data?: IRefsBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ref = data["ref"];
            this.sha = data["sha"];
        }
    }

    static fromJS(data: any): RefsBody {
        let result = new RefsBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ref"] = this.ref;
        data["sha"] = this.sha;
        return data; 
    }
}

export interface IRefsBody {
    ref?: string | undefined;
    sha?: string | undefined;
}

export class Release implements IRelease {
    assets?: Assets[] | undefined;
    assets_url?: string | undefined;
    author?: Author4 | undefined;
    body?: string | undefined;
    created_at?: string | undefined;
    draft?: boolean | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    name?: string | undefined;
    prerelease?: boolean | undefined;
    published_at?: string | undefined;
    tag_name?: string | undefined;
    tarball_url?: string | undefined;
    target_commitish?: string | undefined;
    upload_url?: string | undefined;
    url?: string | undefined;
    zipball_url?: string | undefined;

    constructor(data?: IRelease) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["assets"] && data["assets"].constructor === Array) {
                this.assets = [];
                for (let item of data["assets"])
                    this.assets.push(Assets.fromJS(item));
            }
            this.assets_url = data["assets_url"];
            this.author = data["author"] ? Author4.fromJS(data["author"]) : <any>undefined;
            this.body = data["body"];
            this.created_at = data["created_at"];
            this.draft = data["draft"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.name = data["name"];
            this.prerelease = data["prerelease"];
            this.published_at = data["published_at"];
            this.tag_name = data["tag_name"];
            this.tarball_url = data["tarball_url"];
            this.target_commitish = data["target_commitish"];
            this.upload_url = data["upload_url"];
            this.url = data["url"];
            this.zipball_url = data["zipball_url"];
        }
    }

    static fromJS(data: any): Release {
        let result = new Release();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.assets && this.assets.constructor === Array) {
            data["assets"] = [];
            for (let item of this.assets)
                data["assets"].push(item.toJSON());
        }
        data["assets_url"] = this.assets_url;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["created_at"] = this.created_at;
        data["draft"] = this.draft;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["name"] = this.name;
        data["prerelease"] = this.prerelease;
        data["published_at"] = this.published_at;
        data["tag_name"] = this.tag_name;
        data["tarball_url"] = this.tarball_url;
        data["target_commitish"] = this.target_commitish;
        data["upload_url"] = this.upload_url;
        data["url"] = this.url;
        data["zipball_url"] = this.zipball_url;
        return data; 
    }
}

export interface IRelease {
    assets?: Assets[] | undefined;
    assets_url?: string | undefined;
    author?: Author4 | undefined;
    body?: string | undefined;
    created_at?: string | undefined;
    draft?: boolean | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    name?: string | undefined;
    prerelease?: boolean | undefined;
    published_at?: string | undefined;
    tag_name?: string | undefined;
    tarball_url?: string | undefined;
    target_commitish?: string | undefined;
    upload_url?: string | undefined;
    url?: string | undefined;
    zipball_url?: string | undefined;
}

export class ReleaseCreate implements IReleaseCreate {
    body?: string | undefined;
    draft?: boolean | undefined;
    name?: string | undefined;
    prerelease?: boolean | undefined;
    tag_name?: string | undefined;
    target_commitish?: string | undefined;

    constructor(data?: IReleaseCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.draft = data["draft"];
            this.name = data["name"];
            this.prerelease = data["prerelease"];
            this.tag_name = data["tag_name"];
            this.target_commitish = data["target_commitish"];
        }
    }

    static fromJS(data: any): ReleaseCreate {
        let result = new ReleaseCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        data["draft"] = this.draft;
        data["name"] = this.name;
        data["prerelease"] = this.prerelease;
        data["tag_name"] = this.tag_name;
        data["target_commitish"] = this.target_commitish;
        return data; 
    }
}

export interface IReleaseCreate {
    body?: string | undefined;
    draft?: boolean | undefined;
    name?: string | undefined;
    prerelease?: boolean | undefined;
    tag_name?: string | undefined;
    target_commitish?: string | undefined;
}

export class Repo implements IRepo {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    has_downloads?: boolean | undefined;
    has_issues?: boolean | undefined;
    has_wiki?: boolean | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    organization?: Organization2 | undefined;
    owner?: Owner2 | undefined;
    /** Is present when the repo is a fork. Parent is the repo this repo was forked from. */
    parent?: Parent | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    /** Is present when the repo is a fork. Source is the ultimate source for the network. */
    source?: Source | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;

    constructor(data?: IRepo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.has_downloads = data["has_downloads"];
            this.has_issues = data["has_issues"];
            this.has_wiki = data["has_wiki"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.organization = data["organization"] ? Organization2.fromJS(data["organization"]) : <any>undefined;
            this.owner = data["owner"] ? Owner2.fromJS(data["owner"]) : <any>undefined;
            this.parent = data["parent"] ? Parent.fromJS(data["parent"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.source = data["source"] ? Source.fromJS(data["source"]) : <any>undefined;
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Repo {
        let result = new Repo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["has_downloads"] = this.has_downloads;
        data["has_issues"] = this.has_issues;
        data["has_wiki"] = this.has_wiki;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

export interface IRepo {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    has_downloads?: boolean | undefined;
    has_issues?: boolean | undefined;
    has_wiki?: boolean | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    organization?: Organization2 | undefined;
    owner?: Owner2 | undefined;
    /** Is present when the repo is a fork. Parent is the repo this repo was forked from. */
    parent?: Parent | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    /** Is present when the repo is a fork. Source is the ultimate source for the network. */
    source?: Source | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;
}

export class RepoCommit implements IRepoCommit {
    author?: Author5 | undefined;
    committer?: Committer5 | undefined;
    message?: string | undefined;
    parents?: Parents3[] | undefined;
    sha?: string | undefined;
    tree?: Tree2 | undefined;
    url?: string | undefined;

    constructor(data?: IRepoCommit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author5.fromJS(data["author"]) : <any>undefined;
            this.committer = data["committer"] ? Committer5.fromJS(data["committer"]) : <any>undefined;
            this.message = data["message"];
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(Parents3.fromJS(item));
            }
            this.sha = data["sha"];
            this.tree = data["tree"] ? Tree2.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): RepoCommit {
        let result = new RepoCommit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        data["sha"] = this.sha;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

export interface IRepoCommit {
    author?: Author5 | undefined;
    committer?: Committer5 | undefined;
    message?: string | undefined;
    parents?: Parents3[] | undefined;
    sha?: string | undefined;
    tree?: Tree2 | undefined;
    url?: string | undefined;
}

export class RepoCommitBody implements IRepoCommitBody {
    author?: Author6 | undefined;
    message: string;
    parents: string[] = [];
    tree: string;

    constructor(data?: IRepoCommitBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author6.fromJS(data["author"]) : <any>undefined;
            this.message = data["message"];
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(item);
            }
            this.tree = data["tree"];
        }
    }

    static fromJS(data: any): RepoCommitBody {
        let result = new RepoCommitBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["message"] = this.message;
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item);
        }
        data["tree"] = this.tree;
        return data; 
    }
}

export interface IRepoCommitBody {
    author?: Author6 | undefined;
    message: string;
    parents: string[];
    tree: string;
}

export class RepoEdit implements IRepoEdit {
    description?: string | undefined;
    has_downloads?: boolean | undefined;
    has_issues?: boolean | undefined;
    has_wiki?: boolean | undefined;
    homepage?: string | undefined;
    name?: string | undefined;
    private?: boolean | undefined;

    constructor(data?: IRepoEdit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.has_downloads = data["has_downloads"];
            this.has_issues = data["has_issues"];
            this.has_wiki = data["has_wiki"];
            this.homepage = data["homepage"];
            this.name = data["name"];
            this.private = data["private"];
        }
    }

    static fromJS(data: any): RepoEdit {
        let result = new RepoEdit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["has_downloads"] = this.has_downloads;
        data["has_issues"] = this.has_issues;
        data["has_wiki"] = this.has_wiki;
        data["homepage"] = this.homepage;
        data["name"] = this.name;
        data["private"] = this.private;
        return data; 
    }
}

export interface IRepoEdit {
    description?: string | undefined;
    has_downloads?: boolean | undefined;
    has_issues?: boolean | undefined;
    has_wiki?: boolean | undefined;
    homepage?: string | undefined;
    name?: string | undefined;
    private?: boolean | undefined;
}

export class SearchCode implements ISearchCode {
    items?: Items[] | undefined;
    total_count?: number | undefined;

    constructor(data?: ISearchCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Items.fromJS(item));
            }
            this.total_count = data["total_count"];
        }
    }

    static fromJS(data: any): SearchCode {
        let result = new SearchCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["total_count"] = this.total_count;
        return data; 
    }
}

export interface ISearchCode {
    items?: Items[] | undefined;
    total_count?: number | undefined;
}

export class SearchIssues implements ISearchIssues {
    items?: Items2[] | undefined;
    total_count?: number | undefined;

    constructor(data?: ISearchIssues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Items2.fromJS(item));
            }
            this.total_count = data["total_count"];
        }
    }

    static fromJS(data: any): SearchIssues {
        let result = new SearchIssues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["total_count"] = this.total_count;
        return data; 
    }
}

export interface ISearchIssues {
    items?: Items2[] | undefined;
    total_count?: number | undefined;
}

export class SearchIssuesByKeyword implements ISearchIssuesByKeyword {
    issues?: Issues[] | undefined;

    constructor(data?: ISearchIssuesByKeyword) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["issues"] && data["issues"].constructor === Array) {
                this.issues = [];
                for (let item of data["issues"])
                    this.issues.push(Issues.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchIssuesByKeyword {
        let result = new SearchIssuesByKeyword();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.issues && this.issues.constructor === Array) {
            data["issues"] = [];
            for (let item of this.issues)
                data["issues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISearchIssuesByKeyword {
    issues?: Issues[] | undefined;
}

export class SearchRepositories implements ISearchRepositories {
    items?: Items3[] | undefined;
    total_count?: number | undefined;

    constructor(data?: ISearchRepositories) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Items3.fromJS(item));
            }
            this.total_count = data["total_count"];
        }
    }

    static fromJS(data: any): SearchRepositories {
        let result = new SearchRepositories();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["total_count"] = this.total_count;
        return data; 
    }
}

export interface ISearchRepositories {
    items?: Items3[] | undefined;
    total_count?: number | undefined;
}

export class SearchRepositoriesByKeyword implements ISearchRepositoriesByKeyword {
    repositories?: Repositories[] | undefined;

    constructor(data?: ISearchRepositoriesByKeyword) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["repositories"] && data["repositories"].constructor === Array) {
                this.repositories = [];
                for (let item of data["repositories"])
                    this.repositories.push(Repositories.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchRepositoriesByKeyword {
        let result = new SearchRepositoriesByKeyword();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.repositories && this.repositories.constructor === Array) {
            data["repositories"] = [];
            for (let item of this.repositories)
                data["repositories"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISearchRepositoriesByKeyword {
    repositories?: Repositories[] | undefined;
}

export class SearchUserByEmail implements ISearchUserByEmail {
    user?: User7 | undefined;

    constructor(data?: ISearchUserByEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? User7.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchUserByEmail {
        let result = new SearchUserByEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISearchUserByEmail {
    user?: User7 | undefined;
}

export class SearchUsers implements ISearchUsers {
    items?: Items4[] | undefined;
    total_count?: number | undefined;

    constructor(data?: ISearchUsers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Items4.fromJS(item));
            }
            this.total_count = data["total_count"];
        }
    }

    static fromJS(data: any): SearchUsers {
        let result = new SearchUsers();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["total_count"] = this.total_count;
        return data; 
    }
}

export interface ISearchUsers {
    items?: Items4[] | undefined;
    total_count?: number | undefined;
}

export class SearchUsersByKeyword implements ISearchUsersByKeyword {
    users?: Users[] | undefined;

    constructor(data?: ISearchUsersByKeyword) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["users"] && data["users"].constructor === Array) {
                this.users = [];
                for (let item of data["users"])
                    this.users.push(Users.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchUsersByKeyword {
        let result = new SearchUsersByKeyword();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.users && this.users.constructor === Array) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISearchUsersByKeyword {
    users?: Users[] | undefined;
}

export class Subscribition implements ISubscribition {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    ignored?: boolean | undefined;
    reason?: string | undefined;
    repository_url?: string | undefined;
    subscribed?: boolean | undefined;
    url?: string | undefined;

    constructor(data?: ISubscribition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.ignored = data["ignored"];
            this.reason = data["reason"];
            this.repository_url = data["repository_url"];
            this.subscribed = data["subscribed"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Subscribition {
        let result = new Subscribition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created_at"] = this.created_at;
        data["ignored"] = this.ignored;
        data["reason"] = this.reason;
        data["repository_url"] = this.repository_url;
        data["subscribed"] = this.subscribed;
        data["url"] = this.url;
        return data; 
    }
}

export interface ISubscribition {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    ignored?: boolean | undefined;
    reason?: string | undefined;
    repository_url?: string | undefined;
    subscribed?: boolean | undefined;
    url?: string | undefined;
}

export class SubscribitionBody implements ISubscribitionBody {
    ignored?: boolean | undefined;
    subscribed?: boolean | undefined;

    constructor(data?: ISubscribitionBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ignored = data["ignored"];
            this.subscribed = data["subscribed"];
        }
    }

    static fromJS(data: any): SubscribitionBody {
        let result = new SubscribitionBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ignored"] = this.ignored;
        data["subscribed"] = this.subscribed;
        return data; 
    }
}

export interface ISubscribitionBody {
    ignored?: boolean | undefined;
    subscribed?: boolean | undefined;
}

export class Subscription implements ISubscription {
    created_at?: string | undefined;
    ignored?: boolean | undefined;
    reason?: boolean | undefined;
    subscribed?: boolean | undefined;
    thread_url?: string | undefined;
    url?: string | undefined;

    constructor(data?: ISubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.ignored = data["ignored"];
            this.reason = data["reason"];
            this.subscribed = data["subscribed"];
            this.thread_url = data["thread_url"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Subscription {
        let result = new Subscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created_at"] = this.created_at;
        data["ignored"] = this.ignored;
        data["reason"] = this.reason;
        data["subscribed"] = this.subscribed;
        data["thread_url"] = this.thread_url;
        data["url"] = this.url;
        return data; 
    }
}

export interface ISubscription {
    created_at?: string | undefined;
    ignored?: boolean | undefined;
    reason?: boolean | undefined;
    subscribed?: boolean | undefined;
    thread_url?: string | undefined;
    url?: string | undefined;
}

export class Tag implements ITag {
    message?: string | undefined;
    object?: Object3 | undefined;
    sha?: string | undefined;
    tag?: string | undefined;
    tagger?: Tagger | undefined;
    url?: string | undefined;

    constructor(data?: ITag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["message"];
            this.object = data["object"] ? Object3.fromJS(data["object"]) : <any>undefined;
            this.sha = data["sha"];
            this.tag = data["tag"];
            this.tagger = data["tagger"] ? Tagger.fromJS(data["tagger"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Tag {
        let result = new Tag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["object"] = this.object ? this.object.toJSON() : <any>undefined;
        data["sha"] = this.sha;
        data["tag"] = this.tag;
        data["tagger"] = this.tagger ? this.tagger.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

export interface ITag {
    message?: string | undefined;
    object?: Object3 | undefined;
    sha?: string | undefined;
    tag?: string | undefined;
    tagger?: Tagger | undefined;
    url?: string | undefined;
}

export class Tags implements ITags {
    /** String of the tag message. */
    message: string;
    /** String of the SHA of the git object this is tagging. */
    object: string;
    tag: string;
    tagger: Tagger2 = new Tagger2();
    /** String of the type of the object we’re tagging. Normally this is a commit but it can also be a tree or a blob. */
    type: string;

    constructor(data?: ITags) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["message"];
            this.object = data["object"];
            this.tag = data["tag"];
            this.tagger = data["tagger"] ? Tagger2.fromJS(data["tagger"]) : new Tagger2();
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Tags {
        let result = new Tags();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["object"] = this.object;
        data["tag"] = this.tag;
        data["tagger"] = this.tagger ? this.tagger.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data; 
    }
}

export interface ITags {
    /** String of the tag message. */
    message: string;
    /** String of the SHA of the git object this is tagging. */
    object: string;
    tag: string;
    tagger: Tagger2;
    /** String of the type of the object we’re tagging. Normally this is a commit but it can also be a tree or a blob. */
    type: string;
}

export class Team implements ITeam {
    id?: number | undefined;
    members_count?: number | undefined;
    name?: string | undefined;
    permission?: string | undefined;
    repos_count?: number | undefined;
    url?: string | undefined;

    constructor(data?: ITeam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.members_count = data["members_count"];
            this.name = data["name"];
            this.permission = data["permission"];
            this.repos_count = data["repos_count"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Team {
        let result = new Team();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["members_count"] = this.members_count;
        data["name"] = this.name;
        data["permission"] = this.permission;
        data["repos_count"] = this.repos_count;
        data["url"] = this.url;
        return data; 
    }
}

export interface ITeam {
    id?: number | undefined;
    members_count?: number | undefined;
    name?: string | undefined;
    permission?: string | undefined;
    repos_count?: number | undefined;
    url?: string | undefined;
}

export class TeamMembership implements ITeamMembership {
    state?: string | undefined;
    url?: string | undefined;

    constructor(data?: ITeamMembership) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): TeamMembership {
        let result = new TeamMembership();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["url"] = this.url;
        return data; 
    }
}

export interface ITeamMembership {
    state?: string | undefined;
    url?: string | undefined;
}

export class Tree implements ITree {
    sha?: string | undefined;
    tree?: Tree3[] | undefined;
    url?: string | undefined;

    constructor(data?: ITree) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            if (data["tree"] && data["tree"].constructor === Array) {
                this.tree = [];
                for (let item of data["tree"])
                    this.tree.push(Tree3.fromJS(item));
            }
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Tree {
        let result = new Tree();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        if (this.tree && this.tree.constructor === Array) {
            data["tree"] = [];
            for (let item of this.tree)
                data["tree"].push(item.toJSON());
        }
        data["url"] = this.url;
        return data; 
    }
}

export interface ITree {
    sha?: string | undefined;
    tree?: Tree3[] | undefined;
    url?: string | undefined;
}

export class Trees implements ITrees {
    base_tree?: string | undefined;
    /** SHA1 checksum ID of the object in the tree. */
    sha?: string | undefined;
    tree?: Tree4[] | undefined;
    url?: string | undefined;

    constructor(data?: ITrees) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.base_tree = data["base_tree"];
            this.sha = data["sha"];
            if (data["tree"] && data["tree"].constructor === Array) {
                this.tree = [];
                for (let item of data["tree"])
                    this.tree.push(Tree4.fromJS(item));
            }
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Trees {
        let result = new Trees();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base_tree"] = this.base_tree;
        data["sha"] = this.sha;
        if (this.tree && this.tree.constructor === Array) {
            data["tree"] = [];
            for (let item of this.tree)
                data["tree"].push(item.toJSON());
        }
        data["url"] = this.url;
        return data; 
    }
}

export interface ITrees {
    base_tree?: string | undefined;
    /** SHA1 checksum ID of the object in the tree. */
    sha?: string | undefined;
    tree?: Tree4[] | undefined;
    url?: string | undefined;
}

export class User implements IUser {
    avatar_url?: string | undefined;
    bio?: string | undefined;
    blog?: string | undefined;
    collaborators?: number | undefined;
    company?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    disk_usage?: number | undefined;
    email?: string | undefined;
    followers?: number | undefined;
    following?: number | undefined;
    gravatar_id?: string | undefined;
    hireable?: boolean | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    location?: string | undefined;
    login?: string | undefined;
    name?: string | undefined;
    owned_private_repos?: number | undefined;
    plan?: Plan | undefined;
    private_gists?: number | undefined;
    public_gists?: number | undefined;
    public_repos?: number | undefined;
    total_private_repos?: number | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.bio = data["bio"];
            this.blog = data["blog"];
            this.collaborators = data["collaborators"];
            this.company = data["company"];
            this.created_at = data["created_at"];
            this.disk_usage = data["disk_usage"];
            this.email = data["email"];
            this.followers = data["followers"];
            this.following = data["following"];
            this.gravatar_id = data["gravatar_id"];
            this.hireable = data["hireable"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.location = data["location"];
            this.login = data["login"];
            this.name = data["name"];
            this.owned_private_repos = data["owned_private_repos"];
            this.plan = data["plan"] ? Plan.fromJS(data["plan"]) : <any>undefined;
            this.private_gists = data["private_gists"];
            this.public_gists = data["public_gists"];
            this.public_repos = data["public_repos"];
            this.total_private_repos = data["total_private_repos"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User {
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["bio"] = this.bio;
        data["blog"] = this.blog;
        data["collaborators"] = this.collaborators;
        data["company"] = this.company;
        data["created_at"] = this.created_at;
        data["disk_usage"] = this.disk_usage;
        data["email"] = this.email;
        data["followers"] = this.followers;
        data["following"] = this.following;
        data["gravatar_id"] = this.gravatar_id;
        data["hireable"] = this.hireable;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["location"] = this.location;
        data["login"] = this.login;
        data["name"] = this.name;
        data["owned_private_repos"] = this.owned_private_repos;
        data["plan"] = this.plan ? this.plan.toJSON() : <any>undefined;
        data["private_gists"] = this.private_gists;
        data["public_gists"] = this.public_gists;
        data["public_repos"] = this.public_repos;
        data["total_private_repos"] = this.total_private_repos;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser {
    avatar_url?: string | undefined;
    bio?: string | undefined;
    blog?: string | undefined;
    collaborators?: number | undefined;
    company?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    disk_usage?: number | undefined;
    email?: string | undefined;
    followers?: number | undefined;
    following?: number | undefined;
    gravatar_id?: string | undefined;
    hireable?: boolean | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    location?: string | undefined;
    login?: string | undefined;
    name?: string | undefined;
    owned_private_repos?: number | undefined;
    plan?: Plan | undefined;
    private_gists?: number | undefined;
    public_gists?: number | undefined;
    public_repos?: number | undefined;
    total_private_repos?: number | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class UserKeysKeyId implements IUserKeysKeyId {
    id?: number | undefined;
    key?: string | undefined;
    title?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUserKeysKeyId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.key = data["key"];
            this.title = data["title"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): UserKeysKeyId {
        let result = new UserKeysKeyId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["title"] = this.title;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUserKeysKeyId {
    id?: number | undefined;
    key?: string | undefined;
    title?: string | undefined;
    url?: string | undefined;
}

export class UserKeysPost implements IUserKeysPost {
    key?: string | undefined;
    title?: string | undefined;

    constructor(data?: IUserKeysPost) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): UserKeysPost {
        let result = new UserKeysPost();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["title"] = this.title;
        return data; 
    }
}

export interface IUserKeysPost {
    key?: string | undefined;
    title?: string | undefined;
}

export class UserUpdate implements IUserUpdate {
    bio?: string | undefined;
    blog?: string | undefined;
    company?: string | undefined;
    email?: string | undefined;
    hireable?: boolean | undefined;
    location?: string | undefined;
    name?: string | undefined;

    constructor(data?: IUserUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bio = data["bio"];
            this.blog = data["blog"];
            this.company = data["company"];
            this.email = data["email"];
            this.hireable = data["hireable"];
            this.location = data["location"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): UserUpdate {
        let result = new UserUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bio"] = this.bio;
        data["blog"] = this.blog;
        data["company"] = this.company;
        data["email"] = this.email;
        data["hireable"] = this.hireable;
        data["location"] = this.location;
        data["name"] = this.name;
        return data; 
    }
}

export interface IUserUpdate {
    bio?: string | undefined;
    blog?: string | undefined;
    company?: string | undefined;
    email?: string | undefined;
    hireable?: boolean | undefined;
    location?: string | undefined;
    name?: string | undefined;
}

export class UserUserId implements IUserUserId {
    avatar_url?: string | undefined;
    bio?: string | undefined;
    blog?: string | undefined;
    company?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    /** Note: The returned email is the user’s publicly visible email address (or null if the user has not specified a public email address in their profile). */
    email?: string | undefined;
    followers?: number | undefined;
    following?: number | undefined;
    gravatar_id?: string | undefined;
    hireable?: boolean | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    location?: string | undefined;
    login?: string | undefined;
    name?: string | undefined;
    public_gists?: number | undefined;
    public_repos?: number | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUserUserId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.bio = data["bio"];
            this.blog = data["blog"];
            this.company = data["company"];
            this.created_at = data["created_at"];
            this.email = data["email"];
            this.followers = data["followers"];
            this.following = data["following"];
            this.gravatar_id = data["gravatar_id"];
            this.hireable = data["hireable"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.location = data["location"];
            this.login = data["login"];
            this.name = data["name"];
            this.public_gists = data["public_gists"];
            this.public_repos = data["public_repos"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): UserUserId {
        let result = new UserUserId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["bio"] = this.bio;
        data["blog"] = this.blog;
        data["company"] = this.company;
        data["created_at"] = this.created_at;
        data["email"] = this.email;
        data["followers"] = this.followers;
        data["following"] = this.following;
        data["gravatar_id"] = this.gravatar_id;
        data["hireable"] = this.hireable;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["location"] = this.location;
        data["login"] = this.login;
        data["name"] = this.name;
        data["public_gists"] = this.public_gists;
        data["public_repos"] = this.public_repos;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUserUserId {
    avatar_url?: string | undefined;
    bio?: string | undefined;
    blog?: string | undefined;
    company?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    /** Note: The returned email is the user’s publicly visible email address (or null if the user has not specified a public email address in their profile). */
    email?: string | undefined;
    followers?: number | undefined;
    following?: number | undefined;
    gravatar_id?: string | undefined;
    hireable?: boolean | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    location?: string | undefined;
    login?: string | undefined;
    name?: string | undefined;
    public_gists?: number | undefined;
    public_repos?: number | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

/** Issues assigned to you / created by you / mentioning you / you're subscribed to updates for / All issues the authenticated user can see */
export enum Filter {
    Assigned = <any>"assigned", 
    Created = <any>"created", 
    Mentioned = <any>"mentioned", 
    Subscribed = <any>"subscribed", 
    All = <any>"all", 
}

export enum State {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

export enum Sort {
    Created = <any>"created", 
    Updated = <any>"updated", 
    Comments = <any>"comments", 
}

export enum Direction {
    Asc = <any>"asc", 
    Desc = <any>"desc", 
}

/** Indicates the state of the issues to return. Can be either open or closed. */
export enum State2 {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

/** The sort field. if sort param is provided. Can be either asc or desc. */
export enum Order {
    Desc = <any>"desc", 
    Asc = <any>"asc", 
}

/** The sort field. One of stars, forks, or updated. Default: results are sorted by best match. */
export enum Sort2 {
    Updated = <any>"updated", 
    Stars = <any>"stars", 
    Forks = <any>"forks", 
}

/** The sort field. if sort param is provided. Can be either asc or desc. */
export enum Order2 {
    Desc = <any>"desc", 
    Asc = <any>"asc", 
}

/** The sort field. One of stars, forks, or updated. Default: results are sorted by best match. */
export enum Sort3 {
    Updated = <any>"updated", 
    Stars = <any>"stars", 
    Forks = <any>"forks", 
}

/** Issues assigned to you / created by you / mentioning you / you're subscribed to updates for / All issues the authenticated user can see */
export enum Filter2 {
    Assigned = <any>"assigned", 
    Created = <any>"created", 
    Mentioned = <any>"mentioned", 
    Subscribed = <any>"subscribed", 
    All = <any>"all", 
}

export enum State3 {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

export enum Sort4 {
    Created = <any>"created", 
    Updated = <any>"updated", 
    Comments = <any>"comments", 
}

export enum Direction2 {
    Asc = <any>"asc", 
    Desc = <any>"desc", 
}

export enum Type {
    All = <any>"all", 
    Public = <any>"public", 
    Private = <any>"private", 
    Forks = <any>"forks", 
    Sources = <any>"sources", 
    Member = <any>"member", 
}

export enum Sort5 {
    Newes = <any>"newes", 
    Oldes = <any>"oldes", 
    Watchers = <any>"watchers", 
}

/** Issues assigned to you / created by you / mentioning you / you're subscribed to updates for / All issues the authenticated user can see */
export enum Filter3 {
    Assigned = <any>"assigned", 
    Created = <any>"created", 
    Mentioned = <any>"mentioned", 
    Subscribed = <any>"subscribed", 
    All = <any>"all", 
}

export enum State4 {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

export enum Sort6 {
    Created = <any>"created", 
    Updated = <any>"updated", 
    Comments = <any>"comments", 
}

export enum Direction3 {
    Asc = <any>"asc", 
    Desc = <any>"desc", 
}

export enum Sort7 {
    Created = <any>"created", 
    Updated = <any>"updated", 
}

/** String to filter by state. */
export enum State5 {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

export enum Sort8 {
    Due_date = <any>"due_date", 
    Completeness = <any>"completeness", 
}

/** String to filter by state. */
export enum State6 {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

export enum Sort9 {
    Created = <any>"created", 
    Updated = <any>"updated", 
}

export enum Archive_format {
    Tarball = <any>"tarball", 
    Zipball = <any>"zipball", 
}

/** The sort field. if sort param is provided. Can be either asc or desc. */
export enum Order3 {
    Desc = <any>"desc", 
    Asc = <any>"asc", 
}

/** Can only be 'indexed', which indicates how recently a file has been indexed by the GitHub search infrastructure. If not provided, results are sorted by best match. */
export enum Sort10 {
    Indexed = <any>"indexed", 
}

/** The sort field. if sort param is provided. Can be either asc or desc. */
export enum Order4 {
    Desc = <any>"desc", 
    Asc = <any>"asc", 
}

/** The sort field. Can be comments, created, or updated. Default: results are sorted by best match. */
export enum Sort11 {
    Updated = <any>"updated", 
    Created = <any>"created", 
    Comments = <any>"comments", 
}

/** The sort field. if sort param is provided. Can be either asc or desc. */
export enum Order5 {
    Desc = <any>"desc", 
    Asc = <any>"asc", 
}

/** If not provided, results are sorted by best match. */
export enum Sort12 {
    Stars = <any>"stars", 
    Forks = <any>"forks", 
    Updated = <any>"updated", 
}

/** The sort field. if sort param is provided. Can be either asc or desc. */
export enum Order6 {
    Desc = <any>"desc", 
    Asc = <any>"asc", 
}

/** If not provided, results are sorted by best match. */
export enum Sort13 {
    Followers = <any>"followers", 
    Repositories = <any>"repositories", 
    Joined = <any>"joined", 
}

/** Issues assigned to you / created by you / mentioning you / you're subscribed to updates for / All issues the authenticated user can see */
export enum Filter4 {
    Assigned = <any>"assigned", 
    Created = <any>"created", 
    Mentioned = <any>"mentioned", 
    Subscribed = <any>"subscribed", 
    All = <any>"all", 
}

export enum State7 {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

export enum Sort14 {
    Created = <any>"created", 
    Updated = <any>"updated", 
    Comments = <any>"comments", 
}

export enum Direction4 {
    Asc = <any>"asc", 
    Desc = <any>"desc", 
}

export enum Type2 {
    All = <any>"all", 
    Public = <any>"public", 
    Private = <any>"private", 
    Forks = <any>"forks", 
    Sources = <any>"sources", 
    Member = <any>"member", 
}

export enum Sort15 {
    Created = <any>"created", 
    Updated = <any>"updated", 
}

export enum Type3 {
    All = <any>"all", 
    Public = <any>"public", 
    Private = <any>"private", 
    Forks = <any>"forks", 
    Sources = <any>"sources", 
    Member = <any>"member", 
}

export class Anonymous implements IAnonymous {
    comments?: number | undefined;
    comments_url?: string | undefined;
    created_at?: string | undefined;
    description?: string | undefined;
    files?: Files6 | undefined;
    git_pull_url?: string | undefined;
    git_push_url?: string | undefined;
    html_url?: string | undefined;
    id?: string | undefined;
    public?: boolean | undefined;
    url?: string | undefined;
    user?: User8 | undefined;

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comments = data["comments"];
            this.comments_url = data["comments_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.files = data["files"] ? Files6.fromJS(data["files"]) : <any>undefined;
            this.git_pull_url = data["git_pull_url"];
            this.git_push_url = data["git_push_url"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.public = data["public"];
            this.url = data["url"];
            this.user = data["user"] ? User8.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous {
        let result = new Anonymous();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comments"] = this.comments;
        data["comments_url"] = this.comments_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["files"] = this.files ? this.files.toJSON() : <any>undefined;
        data["git_pull_url"] = this.git_pull_url;
        data["git_push_url"] = this.git_push_url;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["public"] = this.public;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAnonymous {
    comments?: number | undefined;
    comments_url?: string | undefined;
    created_at?: string | undefined;
    description?: string | undefined;
    files?: Files6 | undefined;
    git_pull_url?: string | undefined;
    git_push_url?: string | undefined;
    html_url?: string | undefined;
    id?: string | undefined;
    public?: boolean | undefined;
    url?: string | undefined;
    user?: User8 | undefined;
}

export class Anonymous2 implements IAnonymous2 {
    body?: string | undefined;
    /** ISO 8601. */
    created_at?: string | undefined;
    id?: number | undefined;
    url?: string | undefined;
    user?: User9 | undefined;

    constructor(data?: IAnonymous2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.created_at = data["created_at"];
            this.id = data["id"];
            this.url = data["url"];
            this.user = data["user"] ? User9.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous2 {
        let result = new Anonymous2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        data["created_at"] = this.created_at;
        data["id"] = this.id;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAnonymous2 {
    body?: string | undefined;
    /** ISO 8601. */
    created_at?: string | undefined;
    id?: number | undefined;
    url?: string | undefined;
    user?: User9 | undefined;
}

export class Anonymous3 implements IAnonymous3 {
    assignee?: Assignee | undefined;
    body?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    closed_at?: string | undefined;
    comments?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    html_url?: string | undefined;
    labels?: Labels[] | undefined;
    milestone?: Milestone2 | undefined;
    number?: number | undefined;
    pull_request?: Pull_request | undefined;
    state?: State8 | undefined;
    title?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User10 | undefined;

    constructor(data?: IAnonymous3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assignee = data["assignee"] ? Assignee.fromJS(data["assignee"]) : <any>undefined;
            this.body = data["body"];
            this.closed_at = data["closed_at"];
            this.comments = data["comments"];
            this.created_at = data["created_at"];
            this.html_url = data["html_url"];
            if (data["labels"] && data["labels"].constructor === Array) {
                this.labels = [];
                for (let item of data["labels"])
                    this.labels.push(Labels.fromJS(item));
            }
            this.milestone = data["milestone"] ? Milestone2.fromJS(data["milestone"]) : <any>undefined;
            this.number = data["number"];
            this.pull_request = data["pull_request"] ? Pull_request.fromJS(data["pull_request"]) : <any>undefined;
            this.state = data["state"];
            this.title = data["title"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? User10.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous3 {
        let result = new Anonymous3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assignee"] = this.assignee ? this.assignee.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["closed_at"] = this.closed_at;
        data["comments"] = this.comments;
        data["created_at"] = this.created_at;
        data["html_url"] = this.html_url;
        if (this.labels && this.labels.constructor === Array) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        data["milestone"] = this.milestone ? this.milestone.toJSON() : <any>undefined;
        data["number"] = this.number;
        data["pull_request"] = this.pull_request ? this.pull_request.toJSON() : <any>undefined;
        data["state"] = this.state;
        data["title"] = this.title;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAnonymous3 {
    assignee?: Assignee | undefined;
    body?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    closed_at?: string | undefined;
    comments?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    html_url?: string | undefined;
    labels?: Labels[] | undefined;
    milestone?: Milestone2 | undefined;
    number?: number | undefined;
    pull_request?: Pull_request | undefined;
    state?: State8 | undefined;
    title?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User10 | undefined;
}

export class Anonymous4 implements IAnonymous4 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAnonymous4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous4 {
        let result = new Anonymous4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAnonymous4 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Anonymous5 implements IAnonymous5 {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner3 | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;

    constructor(data?: IAnonymous5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? Owner3.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Anonymous5 {
        let result = new Anonymous5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

export interface IAnonymous5 {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner3 | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;
}

export class Anonymous6 implements IAnonymous6 {
    id?: number | undefined;
    name?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAnonymous6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous6 {
        let result = new Anonymous6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAnonymous6 {
    id?: number | undefined;
    name?: string | undefined;
    url?: string | undefined;
}

export class Anonymous7 implements IAnonymous7 {
    avatar_url?: number | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAnonymous7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous7 {
        let result = new Anonymous7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAnonymous7 {
    avatar_url?: number | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Anonymous8 implements IAnonymous8 {
    commit?: Commit7 | undefined;
    name?: string | undefined;

    constructor(data?: IAnonymous8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.commit = data["commit"] ? Commit7.fromJS(data["commit"]) : <any>undefined;
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Anonymous8 {
        let result = new Anonymous8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAnonymous8 {
    commit?: Commit7 | undefined;
    name?: string | undefined;
}

export class Anonymous9 implements IAnonymous9 {
    body?: string | undefined;
    commit_id?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    line?: number | undefined;
    path?: string | undefined;
    position?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User11 | undefined;

    constructor(data?: IAnonymous9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.commit_id = data["commit_id"];
            this.created_at = data["created_at"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.line = data["line"];
            this.path = data["path"];
            this.position = data["position"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? User11.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous9 {
        let result = new Anonymous9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        data["commit_id"] = this.commit_id;
        data["created_at"] = this.created_at;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["line"] = this.line;
        data["path"] = this.path;
        data["position"] = this.position;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAnonymous9 {
    body?: string | undefined;
    commit_id?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    line?: number | undefined;
    path?: string | undefined;
    position?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User11 | undefined;
}

export class Anonymous10 implements IAnonymous10 {
    author?: Author7 | undefined;
    commit?: Commit8 | undefined;
    committer?: Committer6 | undefined;
    parents?: Parents4[] | undefined;
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAnonymous10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author7.fromJS(data["author"]) : <any>undefined;
            this.commit = data["commit"] ? Commit8.fromJS(data["commit"]) : <any>undefined;
            this.committer = data["committer"] ? Committer6.fromJS(data["committer"]) : <any>undefined;
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(Parents4.fromJS(item));
            }
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous10 {
        let result = new Anonymous10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAnonymous10 {
    author?: Author7 | undefined;
    commit?: Commit8 | undefined;
    committer?: Committer6 | undefined;
    parents?: Parents4[] | undefined;
    sha?: string | undefined;
    url?: string | undefined;
}

export class Anonymous11 implements IAnonymous11 {
    commit_url?: string | undefined;
    name?: string | undefined;
    repository_url?: string | undefined;
    sha?: string | undefined;
    state?: string | undefined;
    statuses?: Statuses[] | undefined;

    constructor(data?: IAnonymous11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.commit_url = data["commit_url"];
            this.name = data["name"];
            this.repository_url = data["repository_url"];
            this.sha = data["sha"];
            this.state = data["state"];
            if (data["statuses"] && data["statuses"].constructor === Array) {
                this.statuses = [];
                for (let item of data["statuses"])
                    this.statuses.push(Statuses.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous11 {
        let result = new Anonymous11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commit_url"] = this.commit_url;
        data["name"] = this.name;
        data["repository_url"] = this.repository_url;
        data["sha"] = this.sha;
        data["state"] = this.state;
        if (this.statuses && this.statuses.constructor === Array) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAnonymous11 {
    commit_url?: string | undefined;
    name?: string | undefined;
    repository_url?: string | undefined;
    sha?: string | undefined;
    state?: string | undefined;
    statuses?: Statuses[] | undefined;
}

export class Anonymous12 implements IAnonymous12 {
    avatar_url?: string | undefined;
    contributions?: number | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAnonymous12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.contributions = data["contributions"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous12 {
        let result = new Anonymous12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["contributions"] = this.contributions;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAnonymous12 {
    avatar_url?: string | undefined;
    contributions?: number | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Anonymous13 implements IAnonymous13 {
    created_at?: string | undefined;
    creator?: Creator3 | undefined;
    description?: string | undefined;
    id?: number | undefined;
    payload?: string | undefined;
    sha?: string | undefined;
    statuses_url?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAnonymous13) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.creator = data["creator"] ? Creator3.fromJS(data["creator"]) : <any>undefined;
            this.description = data["description"];
            this.id = data["id"];
            this.payload = data["payload"];
            this.sha = data["sha"];
            this.statuses_url = data["statuses_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous13 {
        let result = new Anonymous13();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created_at"] = this.created_at;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["id"] = this.id;
        data["payload"] = this.payload;
        data["sha"] = this.sha;
        data["statuses_url"] = this.statuses_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAnonymous13 {
    created_at?: string | undefined;
    creator?: Creator3 | undefined;
    description?: string | undefined;
    id?: number | undefined;
    payload?: string | undefined;
    sha?: string | undefined;
    statuses_url?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;
}

export class Anonymous14 implements IAnonymous14 {
    created_at?: string | undefined;
    creator?: Creator4 | undefined;
    description?: string | undefined;
    id?: number | undefined;
    payload?: string | undefined;
    state?: string | undefined;
    target_url?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAnonymous14) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.creator = data["creator"] ? Creator4.fromJS(data["creator"]) : <any>undefined;
            this.description = data["description"];
            this.id = data["id"];
            this.payload = data["payload"];
            this.state = data["state"];
            this.target_url = data["target_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous14 {
        let result = new Anonymous14();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created_at"] = this.created_at;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["id"] = this.id;
        data["payload"] = this.payload;
        data["state"] = this.state;
        data["target_url"] = this.target_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAnonymous14 {
    created_at?: string | undefined;
    creator?: Creator4 | undefined;
    description?: string | undefined;
    id?: number | undefined;
    payload?: string | undefined;
    state?: string | undefined;
    target_url?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;
}

export class Anonymous15 implements IAnonymous15 {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner4 | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;

    constructor(data?: IAnonymous15) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? Owner4.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Anonymous15 {
        let result = new Anonymous15();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

export interface IAnonymous15 {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner4 | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;
}

export class Anonymous16 implements IAnonymous16 {
    object?: Object4 | undefined;
    ref?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAnonymous16) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.object = data["object"] ? Object4.fromJS(data["object"]) : <any>undefined;
            this.ref = data["ref"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous16 {
        let result = new Anonymous16();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["object"] = this.object ? this.object.toJSON() : <any>undefined;
        data["ref"] = this.ref;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAnonymous16 {
    object?: Object4 | undefined;
    ref?: string | undefined;
    url?: string | undefined;
}

export class Anonymous17 implements IAnonymous17 {
    active?: boolean | undefined;
    config?: Config | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    events?: Events2[] | undefined;
    id?: number | undefined;
    name?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAnonymous17) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.active = data["active"];
            this.config = data["config"] ? Config.fromJS(data["config"]) : <any>undefined;
            this.created_at = data["created_at"];
            if (data["events"] && data["events"].constructor === Array) {
                this.events = [];
                for (let item of data["events"])
                    this.events.push(item);
            }
            this.id = data["id"];
            this.name = data["name"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous17 {
        let result = new Anonymous17();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["active"] = this.active;
        data["config"] = this.config ? this.config.toJSON() : <any>undefined;
        data["created_at"] = this.created_at;
        if (this.events && this.events.constructor === Array) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item);
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAnonymous17 {
    active?: boolean | undefined;
    config?: Config | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    events?: Events2[] | undefined;
    id?: number | undefined;
    name?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
}

export class Anonymous18 implements IAnonymous18 {
    _links?: _links7 | undefined;
    body?: string | undefined;
    commit_id?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    id?: number | undefined;
    path?: string | undefined;
    position?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User12 | undefined;

    constructor(data?: IAnonymous18) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links7.fromJS(data["_links"]) : <any>undefined;
            this.body = data["body"];
            this.commit_id = data["commit_id"];
            this.created_at = data["created_at"];
            this.id = data["id"];
            this.path = data["path"];
            this.position = data["position"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? User12.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous18 {
        let result = new Anonymous18();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["commit_id"] = this.commit_id;
        data["created_at"] = this.created_at;
        data["id"] = this.id;
        data["path"] = this.path;
        data["position"] = this.position;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAnonymous18 {
    _links?: _links7 | undefined;
    body?: string | undefined;
    commit_id?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    id?: number | undefined;
    path?: string | undefined;
    position?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User12 | undefined;
}

export class Anonymous19 implements IAnonymous19 {
    color?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAnonymous19) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.color = data["color"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous19 {
        let result = new Anonymous19();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["color"] = this.color;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAnonymous19 {
    color?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
}

export class Anonymous20 implements IAnonymous20 {
    id?: number | undefined;
    key?: string | undefined;
    title?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAnonymous20) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.key = data["key"];
            this.title = data["title"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous20 {
        let result = new Anonymous20();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["title"] = this.title;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAnonymous20 {
    id?: number | undefined;
    key?: string | undefined;
    title?: string | undefined;
    url?: string | undefined;
}

export class Anonymous21 implements IAnonymous21 {
    _links?: _links8 | undefined;
    base?: Base2 | undefined;
    body?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    closed_at?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    diff_url?: string | undefined;
    head?: Head2 | undefined;
    html_url?: string | undefined;
    issue_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    merged_at?: string | undefined;
    number?: number | undefined;
    patch_url?: string | undefined;
    state?: State9 | undefined;
    title?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User13 | undefined;

    constructor(data?: IAnonymous21) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links8.fromJS(data["_links"]) : <any>undefined;
            this.base = data["base"] ? Base2.fromJS(data["base"]) : <any>undefined;
            this.body = data["body"];
            this.closed_at = data["closed_at"];
            this.created_at = data["created_at"];
            this.diff_url = data["diff_url"];
            this.head = data["head"] ? Head2.fromJS(data["head"]) : <any>undefined;
            this.html_url = data["html_url"];
            this.issue_url = data["issue_url"];
            this.merged_at = data["merged_at"];
            this.number = data["number"];
            this.patch_url = data["patch_url"];
            this.state = data["state"];
            this.title = data["title"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? User13.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Anonymous21 {
        let result = new Anonymous21();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["base"] = this.base ? this.base.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["closed_at"] = this.closed_at;
        data["created_at"] = this.created_at;
        data["diff_url"] = this.diff_url;
        data["head"] = this.head ? this.head.toJSON() : <any>undefined;
        data["html_url"] = this.html_url;
        data["issue_url"] = this.issue_url;
        data["merged_at"] = this.merged_at;
        data["number"] = this.number;
        data["patch_url"] = this.patch_url;
        data["state"] = this.state;
        data["title"] = this.title;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAnonymous21 {
    _links?: _links8 | undefined;
    base?: Base2 | undefined;
    body?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    closed_at?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    diff_url?: string | undefined;
    head?: Head2 | undefined;
    html_url?: string | undefined;
    issue_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    merged_at?: string | undefined;
    number?: number | undefined;
    patch_url?: string | undefined;
    state?: State9 | undefined;
    title?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User13 | undefined;
}

export class Anonymous22 implements IAnonymous22 {
    assets?: Assets2[] | undefined;
    assets_url?: string | undefined;
    author?: Author8 | undefined;
    body?: string | undefined;
    created_at?: string | undefined;
    draft?: boolean | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    name?: string | undefined;
    prerelease?: boolean | undefined;
    published_at?: string | undefined;
    tag_name?: string | undefined;
    tarball_url?: string | undefined;
    target_commitish?: string | undefined;
    upload_url?: string | undefined;
    url?: string | undefined;
    zipball_url?: string | undefined;

    constructor(data?: IAnonymous22) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["assets"] && data["assets"].constructor === Array) {
                this.assets = [];
                for (let item of data["assets"])
                    this.assets.push(Assets2.fromJS(item));
            }
            this.assets_url = data["assets_url"];
            this.author = data["author"] ? Author8.fromJS(data["author"]) : <any>undefined;
            this.body = data["body"];
            this.created_at = data["created_at"];
            this.draft = data["draft"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.name = data["name"];
            this.prerelease = data["prerelease"];
            this.published_at = data["published_at"];
            this.tag_name = data["tag_name"];
            this.tarball_url = data["tarball_url"];
            this.target_commitish = data["target_commitish"];
            this.upload_url = data["upload_url"];
            this.url = data["url"];
            this.zipball_url = data["zipball_url"];
        }
    }

    static fromJS(data: any): Anonymous22 {
        let result = new Anonymous22();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.assets && this.assets.constructor === Array) {
            data["assets"] = [];
            for (let item of this.assets)
                data["assets"].push(item.toJSON());
        }
        data["assets_url"] = this.assets_url;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["created_at"] = this.created_at;
        data["draft"] = this.draft;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["name"] = this.name;
        data["prerelease"] = this.prerelease;
        data["published_at"] = this.published_at;
        data["tag_name"] = this.tag_name;
        data["tarball_url"] = this.tarball_url;
        data["target_commitish"] = this.target_commitish;
        data["upload_url"] = this.upload_url;
        data["url"] = this.url;
        data["zipball_url"] = this.zipball_url;
        return data; 
    }
}

export interface IAnonymous22 {
    assets?: Assets2[] | undefined;
    assets_url?: string | undefined;
    author?: Author8 | undefined;
    body?: string | undefined;
    created_at?: string | undefined;
    draft?: boolean | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    name?: string | undefined;
    prerelease?: boolean | undefined;
    published_at?: string | undefined;
    tag_name?: string | undefined;
    tarball_url?: string | undefined;
    target_commitish?: string | undefined;
    upload_url?: string | undefined;
    url?: string | undefined;
    zipball_url?: string | undefined;
}

export class Anonymous23 implements IAnonymous23 {
    content_type?: string | undefined;
    created_at?: string | undefined;
    download_count?: number | undefined;
    id?: number | undefined;
    label?: string | undefined;
    name?: string | undefined;
    size?: number | undefined;
    state?: string | undefined;
    updated_at?: string | undefined;
    uploader?: Uploader2 | undefined;
    url?: string | undefined;

    constructor(data?: IAnonymous23) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content_type = data["content_type"];
            this.created_at = data["created_at"];
            this.download_count = data["download_count"];
            this.id = data["id"];
            this.label = data["label"];
            this.name = data["name"];
            this.size = data["size"];
            this.state = data["state"];
            this.updated_at = data["updated_at"];
            this.uploader = data["uploader"] ? Uploader2.fromJS(data["uploader"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous23 {
        let result = new Anonymous23();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content_type"] = this.content_type;
        data["created_at"] = this.created_at;
        data["download_count"] = this.download_count;
        data["id"] = this.id;
        data["label"] = this.label;
        data["name"] = this.name;
        data["size"] = this.size;
        data["state"] = this.state;
        data["updated_at"] = this.updated_at;
        data["uploader"] = this.uploader ? this.uploader.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAnonymous23 {
    content_type?: string | undefined;
    created_at?: string | undefined;
    download_count?: number | undefined;
    id?: number | undefined;
    label?: string | undefined;
    name?: string | undefined;
    size?: number | undefined;
    state?: string | undefined;
    updated_at?: string | undefined;
    uploader?: Uploader2 | undefined;
    url?: string | undefined;
}

export class Anonymous24 implements IAnonymous24 {
    author?: Author9 | undefined;
    /** The Total number of commits authored by the contributor. */
    total?: number | undefined;
    weeks?: Weeks[] | undefined;

    constructor(data?: IAnonymous24) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author9.fromJS(data["author"]) : <any>undefined;
            this.total = data["total"];
            if (data["weeks"] && data["weeks"].constructor === Array) {
                this.weeks = [];
                for (let item of data["weeks"])
                    this.weeks.push(Weeks.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Anonymous24 {
        let result = new Anonymous24();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["total"] = this.total;
        if (this.weeks && this.weeks.constructor === Array) {
            data["weeks"] = [];
            for (let item of this.weeks)
                data["weeks"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAnonymous24 {
    author?: Author9 | undefined;
    /** The Total number of commits authored by the contributor. */
    total?: number | undefined;
    weeks?: Weeks[] | undefined;
}

export class Anonymous25 implements IAnonymous25 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    creator?: Creator5 | undefined;
    description?: string | undefined;
    id?: number | undefined;
    state?: string | undefined;
    target_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAnonymous25) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.creator = data["creator"] ? Creator5.fromJS(data["creator"]) : <any>undefined;
            this.description = data["description"];
            this.id = data["id"];
            this.state = data["state"];
            this.target_url = data["target_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous25 {
        let result = new Anonymous25();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created_at"] = this.created_at;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["id"] = this.id;
        data["state"] = this.state;
        data["target_url"] = this.target_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAnonymous25 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    creator?: Creator5 | undefined;
    description?: string | undefined;
    id?: number | undefined;
    state?: string | undefined;
    target_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
}

export class Anonymous26 implements IAnonymous26 {
    description?: string | undefined;
    fork?: boolean | undefined;
    full_name?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    name?: string | undefined;
    owner?: Owner5 | undefined;
    private?: boolean | undefined;
    url?: string | undefined;

    constructor(data?: IAnonymous26) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.fork = data["fork"];
            this.full_name = data["full_name"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.name = data["name"];
            this.owner = data["owner"] ? Owner5.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous26 {
        let result = new Anonymous26();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["full_name"] = this.full_name;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["name"] = this.name;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAnonymous26 {
    description?: string | undefined;
    fork?: boolean | undefined;
    full_name?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    name?: string | undefined;
    owner?: Owner5 | undefined;
    private?: boolean | undefined;
    url?: string | undefined;
}

export class Anonymous27 implements IAnonymous27 {
    clone_url?: string | undefined;
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: Language | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner6 | undefined;
    private?: boolean | undefined;
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;

    constructor(data?: IAnonymous27) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? Owner6.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Anonymous27 {
        let result = new Anonymous27();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

export interface IAnonymous27 {
    clone_url?: string | undefined;
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: Language | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner6 | undefined;
    private?: boolean | undefined;
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;
}

export class Anonymous28 implements IAnonymous28 {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: number | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner7 | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;

    constructor(data?: IAnonymous28) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? Owner7.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Anonymous28 {
        let result = new Anonymous28();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

export interface IAnonymous28 {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: number | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner7 | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;
}

export class Anonymous29 implements IAnonymous29 {
    id?: number | undefined;
    members_count?: number | undefined;
    name?: string | undefined;
    organization?: Organization3 | undefined;
    permission?: string | undefined;
    repos_count?: number | undefined;
    url?: string | undefined;

    constructor(data?: IAnonymous29) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.members_count = data["members_count"];
            this.name = data["name"];
            this.organization = data["organization"] ? Organization3.fromJS(data["organization"]) : <any>undefined;
            this.permission = data["permission"];
            this.repos_count = data["repos_count"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Anonymous29 {
        let result = new Anonymous29();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["members_count"] = this.members_count;
        data["name"] = this.name;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["permission"] = this.permission;
        data["repos_count"] = this.repos_count;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAnonymous29 {
    id?: number | undefined;
    members_count?: number | undefined;
    name?: string | undefined;
    organization?: Organization3 | undefined;
    permission?: string | undefined;
    repos_count?: number | undefined;
    url?: string | undefined;
}

export class Anonymous30 implements IAnonymous30 {
    days?: number[] | undefined;
    total?: number | undefined;
    week?: number | undefined;

    constructor(data?: IAnonymous30) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["days"] && data["days"].constructor === Array) {
                this.days = [];
                for (let item of data["days"])
                    this.days.push(item);
            }
            this.total = data["total"];
            this.week = data["week"];
        }
    }

    static fromJS(data: any): Anonymous30 {
        let result = new Anonymous30();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.days && this.days.constructor === Array) {
            data["days"] = [];
            for (let item of this.days)
                data["days"].push(item);
        }
        data["total"] = this.total;
        data["week"] = this.week;
        return data; 
    }
}

export interface IAnonymous30 {
    days?: number[] | undefined;
    total?: number | undefined;
    week?: number | undefined;
}

export class Uploader implements IUploader {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUploader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Uploader {
        let result = new Uploader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUploader {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export enum BlobEncoding {
    Utf8 = <any>"utf-8", 
    Base64 = <any>"base64", 
}

export class _links implements I_links {
    html?: string | undefined;
    self?: string | undefined;

    constructor(data?: I_links) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.html = data["html"];
            this.self = data["self"];
        }
    }

    static fromJS(data: any): _links {
        let result = new _links();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["html"] = this.html;
        data["self"] = this.self;
        return data; 
    }
}

export interface I_links {
    html?: string | undefined;
    self?: string | undefined;
}

export class Commit2 implements ICommit2 {
    author?: Author10 | undefined;
    commit?: Commit9 | undefined;
    committer?: Committer7 | undefined;
    parents?: Parents5[] | undefined;
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICommit2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author10.fromJS(data["author"]) : <any>undefined;
            this.commit = data["commit"] ? Commit9.fromJS(data["commit"]) : <any>undefined;
            this.committer = data["committer"] ? Committer7.fromJS(data["committer"]) : <any>undefined;
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(Parents5.fromJS(item));
            }
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Commit2 {
        let result = new Commit2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommit2 {
    author?: Author10 | undefined;
    commit?: Commit9 | undefined;
    committer?: Committer7 | undefined;
    parents?: Parents5[] | undefined;
    sha?: string | undefined;
    url?: string | undefined;
}

export class Author implements IAuthor {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAuthor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Author {
        let result = new Author();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAuthor {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Commit3 implements ICommit3 {
    author?: Author11 | undefined;
    committer?: Committer8 | undefined;
    message?: string | undefined;
    tree?: Tree5 | undefined;
    url?: string | undefined;

    constructor(data?: ICommit3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author11.fromJS(data["author"]) : <any>undefined;
            this.committer = data["committer"] ? Committer8.fromJS(data["committer"]) : <any>undefined;
            this.message = data["message"];
            this.tree = data["tree"] ? Tree5.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Commit3 {
        let result = new Commit3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommit3 {
    author?: Author11 | undefined;
    committer?: Committer8 | undefined;
    message?: string | undefined;
    tree?: Tree5 | undefined;
    url?: string | undefined;
}

export class Committer implements ICommitter {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICommitter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Committer {
        let result = new Committer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommitter {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Files implements IFiles {
    additions?: number | undefined;
    blob_url?: string | undefined;
    changes?: number | undefined;
    deletions?: number | undefined;
    filename?: string | undefined;
    patch?: string | undefined;
    raw_url?: string | undefined;
    status?: string | undefined;

    constructor(data?: IFiles) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additions = data["additions"];
            this.blob_url = data["blob_url"];
            this.changes = data["changes"];
            this.deletions = data["deletions"];
            this.filename = data["filename"];
            this.patch = data["patch"];
            this.raw_url = data["raw_url"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): Files {
        let result = new Files();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additions"] = this.additions;
        data["blob_url"] = this.blob_url;
        data["changes"] = this.changes;
        data["deletions"] = this.deletions;
        data["filename"] = this.filename;
        data["patch"] = this.patch;
        data["raw_url"] = this.raw_url;
        data["status"] = this.status;
        return data; 
    }
}

export interface IFiles {
    additions?: number | undefined;
    blob_url?: string | undefined;
    changes?: number | undefined;
    deletions?: number | undefined;
    filename?: string | undefined;
    patch?: string | undefined;
    raw_url?: string | undefined;
    status?: string | undefined;
}

export class Parents implements IParents {
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: IParents) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Parents {
        let result = new Parents();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface IParents {
    sha?: string | undefined;
    url?: string | undefined;
}

export class Stats implements IStats {
    additions?: number | undefined;
    deletions?: number | undefined;
    total?: number | undefined;

    constructor(data?: IStats) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additions = data["additions"];
            this.deletions = data["deletions"];
            this.total = data["total"];
        }
    }

    static fromJS(data: any): Stats {
        let result = new Stats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additions"] = this.additions;
        data["deletions"] = this.deletions;
        data["total"] = this.total;
        return data; 
    }
}

export interface IStats {
    additions?: number | undefined;
    deletions?: number | undefined;
    total?: number | undefined;
}

export class User2 implements IUser2 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User2 {
        let result = new User2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser2 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Base_commit implements IBase_commit {
    author?: Author12 | undefined;
    commit?: Commit10 | undefined;
    committer?: Committer9 | undefined;
    parents?: Parents6[] | undefined;
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: IBase_commit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author12.fromJS(data["author"]) : <any>undefined;
            this.commit = data["commit"] ? Commit10.fromJS(data["commit"]) : <any>undefined;
            this.committer = data["committer"] ? Committer9.fromJS(data["committer"]) : <any>undefined;
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(Parents6.fromJS(item));
            }
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Base_commit {
        let result = new Base_commit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface IBase_commit {
    author?: Author12 | undefined;
    commit?: Commit10 | undefined;
    committer?: Committer9 | undefined;
    parents?: Parents6[] | undefined;
    sha?: string | undefined;
    url?: string | undefined;
}

export class Commits implements ICommits {
    author?: Author13 | undefined;
    commit?: Commit11 | undefined;
    committer?: Committer10 | undefined;
    parents?: Parents7[] | undefined;
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICommits) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author13.fromJS(data["author"]) : <any>undefined;
            this.commit = data["commit"] ? Commit11.fromJS(data["commit"]) : <any>undefined;
            this.committer = data["committer"] ? Committer10.fromJS(data["committer"]) : <any>undefined;
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(Parents7.fromJS(item));
            }
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Commits {
        let result = new Commits();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["commit"] = this.commit ? this.commit.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommits {
    author?: Author13 | undefined;
    commit?: Commit11 | undefined;
    committer?: Committer10 | undefined;
    parents?: Parents7[] | undefined;
    sha?: string | undefined;
    url?: string | undefined;
}

export class Files2 implements IFiles2 {
    additions?: number | undefined;
    blob_url?: string | undefined;
    changes?: number | undefined;
    contents_url?: string | undefined;
    deletions?: number | undefined;
    filename?: string | undefined;
    patch?: string | undefined;
    raw_url?: string | undefined;
    sha?: string | undefined;
    status?: string | undefined;

    constructor(data?: IFiles2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additions = data["additions"];
            this.blob_url = data["blob_url"];
            this.changes = data["changes"];
            this.contents_url = data["contents_url"];
            this.deletions = data["deletions"];
            this.filename = data["filename"];
            this.patch = data["patch"];
            this.raw_url = data["raw_url"];
            this.sha = data["sha"];
            this.status = data["status"];
        }
    }

    static fromJS(data: any): Files2 {
        let result = new Files2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additions"] = this.additions;
        data["blob_url"] = this.blob_url;
        data["changes"] = this.changes;
        data["contents_url"] = this.contents_url;
        data["deletions"] = this.deletions;
        data["filename"] = this.filename;
        data["patch"] = this.patch;
        data["raw_url"] = this.raw_url;
        data["sha"] = this.sha;
        data["status"] = this.status;
        return data; 
    }
}

export interface IFiles2 {
    additions?: number | undefined;
    blob_url?: string | undefined;
    changes?: number | undefined;
    contents_url?: string | undefined;
    deletions?: number | undefined;
    filename?: string | undefined;
    patch?: string | undefined;
    raw_url?: string | undefined;
    sha?: string | undefined;
    status?: string | undefined;
}

export class _links2 implements I_links2 {
    git?: string | undefined;
    html?: string | undefined;
    self?: string | undefined;

    constructor(data?: I_links2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.git = data["git"];
            this.html = data["html"];
            this.self = data["self"];
        }
    }

    static fromJS(data: any): _links2 {
        let result = new _links2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["git"] = this.git;
        data["html"] = this.html;
        data["self"] = this.self;
        return data; 
    }
}

export interface I_links2 {
    git?: string | undefined;
    html?: string | undefined;
    self?: string | undefined;
}

export class Commit4 implements ICommit4 {
    author?: Author14 | undefined;
    committer?: Committer11 | undefined;
    html_url?: string | undefined;
    message?: string | undefined;
    parents?: Parents8[] | undefined;
    sha?: string | undefined;
    tree?: Tree6 | undefined;
    url?: string | undefined;

    constructor(data?: ICommit4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author14.fromJS(data["author"]) : <any>undefined;
            this.committer = data["committer"] ? Committer11.fromJS(data["committer"]) : <any>undefined;
            this.html_url = data["html_url"];
            this.message = data["message"];
            if (data["parents"] && data["parents"].constructor === Array) {
                this.parents = [];
                for (let item of data["parents"])
                    this.parents.push(Parents8.fromJS(item));
            }
            this.sha = data["sha"];
            this.tree = data["tree"] ? Tree6.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Commit4 {
        let result = new Commit4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["html_url"] = this.html_url;
        data["message"] = this.message;
        if (this.parents && this.parents.constructor === Array) {
            data["parents"] = [];
            for (let item of this.parents)
                data["parents"].push(item.toJSON());
        }
        data["sha"] = this.sha;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommit4 {
    author?: Author14 | undefined;
    committer?: Committer11 | undefined;
    html_url?: string | undefined;
    message?: string | undefined;
    parents?: Parents8[] | undefined;
    sha?: string | undefined;
    tree?: Tree6 | undefined;
    url?: string | undefined;
}

export class Content implements IContent {
    _links?: _links9 | undefined;
    git_url?: string | undefined;
    html_url?: string | undefined;
    name?: string | undefined;
    path?: string | undefined;
    sha?: string | undefined;
    size?: number | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this._links = data["_links"] ? _links9.fromJS(data["_links"]) : <any>undefined;
            this.git_url = data["git_url"];
            this.html_url = data["html_url"];
            this.name = data["name"];
            this.path = data["path"];
            this.sha = data["sha"];
            this.size = data["size"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Content {
        let result = new Content();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
        data["git_url"] = this.git_url;
        data["html_url"] = this.html_url;
        data["name"] = this.name;
        data["path"] = this.path;
        data["sha"] = this.sha;
        data["size"] = this.size;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IContent {
    _links?: _links9 | undefined;
    git_url?: string | undefined;
    html_url?: string | undefined;
    name?: string | undefined;
    path?: string | undefined;
    sha?: string | undefined;
    size?: number | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Committer2 implements ICommitter2 {
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICommitter2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Committer2 {
        let result = new Committer2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICommitter2 {
    email?: string | undefined;
    name?: string | undefined;
}

export class Commit5 implements ICommit5 {
    author?: Author15 | undefined;
    committer?: Committer12 | undefined;
    html_url?: string | undefined;
    message?: string | undefined;
    parents?: Parents9 | undefined;
    sha?: string | undefined;
    tree?: Tree7 | undefined;
    url?: string | undefined;

    constructor(data?: ICommit5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author15.fromJS(data["author"]) : <any>undefined;
            this.committer = data["committer"] ? Committer12.fromJS(data["committer"]) : <any>undefined;
            this.html_url = data["html_url"];
            this.message = data["message"];
            this.parents = data["parents"] ? Parents9.fromJS(data["parents"]) : <any>undefined;
            this.sha = data["sha"];
            this.tree = data["tree"] ? Tree7.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Commit5 {
        let result = new Commit5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["html_url"] = this.html_url;
        data["message"] = this.message;
        data["parents"] = this.parents ? this.parents.toJSON() : <any>undefined;
        data["sha"] = this.sha;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommit5 {
    author?: Author15 | undefined;
    committer?: Committer12 | undefined;
    html_url?: string | undefined;
    message?: string | undefined;
    parents?: Parents9 | undefined;
    sha?: string | undefined;
    tree?: Tree7 | undefined;
    url?: string | undefined;
}

export class Committer3 implements ICommitter3 {
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICommitter3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Committer3 {
        let result = new Committer3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICommitter3 {
    email?: string | undefined;
    name?: string | undefined;
}

export class Payload implements IPayload {
    deploy_user?: string | undefined;
    environment?: string | undefined;
    room_id?: number | undefined;

    constructor(data?: IPayload) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deploy_user = data["deploy_user"];
            this.environment = data["environment"];
            this.room_id = data["room_id"];
        }
    }

    static fromJS(data: any): Payload {
        let result = new Payload();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deploy_user"] = this.deploy_user;
        data["environment"] = this.environment;
        data["room_id"] = this.room_id;
        return data; 
    }
}

export interface IPayload {
    deploy_user?: string | undefined;
    environment?: string | undefined;
    room_id?: number | undefined;
}

export class Creator implements ICreator {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICreator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Creator {
        let result = new Creator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICreator {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export enum EditTeamPermission {
    Pull = <any>"pull", 
    Push = <any>"push", 
    Admin = <any>"admin", 
}

export class Actor implements IActor {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IActor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Actor {
        let result = new Actor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IActor {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Issue2 implements IIssue2 {
    assignee?: Assignee2 | undefined;
    body?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    closed_at?: string | undefined;
    comments?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    html_url?: string | undefined;
    labels?: Labels2[] | undefined;
    milestone?: Milestone3 | undefined;
    number?: number | undefined;
    pull_request?: Pull_request2 | undefined;
    state?: Issue2State | undefined;
    title?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User14 | undefined;

    constructor(data?: IIssue2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assignee = data["assignee"] ? Assignee2.fromJS(data["assignee"]) : <any>undefined;
            this.body = data["body"];
            this.closed_at = data["closed_at"];
            this.comments = data["comments"];
            this.created_at = data["created_at"];
            this.html_url = data["html_url"];
            if (data["labels"] && data["labels"].constructor === Array) {
                this.labels = [];
                for (let item of data["labels"])
                    this.labels.push(Labels2.fromJS(item));
            }
            this.milestone = data["milestone"] ? Milestone3.fromJS(data["milestone"]) : <any>undefined;
            this.number = data["number"];
            this.pull_request = data["pull_request"] ? Pull_request2.fromJS(data["pull_request"]) : <any>undefined;
            this.state = data["state"];
            this.title = data["title"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? User14.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Issue2 {
        let result = new Issue2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assignee"] = this.assignee ? this.assignee.toJSON() : <any>undefined;
        data["body"] = this.body;
        data["closed_at"] = this.closed_at;
        data["comments"] = this.comments;
        data["created_at"] = this.created_at;
        data["html_url"] = this.html_url;
        if (this.labels && this.labels.constructor === Array) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        data["milestone"] = this.milestone ? this.milestone.toJSON() : <any>undefined;
        data["number"] = this.number;
        data["pull_request"] = this.pull_request ? this.pull_request.toJSON() : <any>undefined;
        data["state"] = this.state;
        data["title"] = this.title;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIssue2 {
    assignee?: Assignee2 | undefined;
    body?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    closed_at?: string | undefined;
    comments?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    html_url?: string | undefined;
    labels?: Labels2[] | undefined;
    milestone?: Milestone3 | undefined;
    number?: number | undefined;
    pull_request?: Pull_request2 | undefined;
    state?: Issue2State | undefined;
    title?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User14 | undefined;
}

export class Actor2 implements IActor2 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IActor2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Actor2 {
        let result = new Actor2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IActor2 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Org implements IOrg {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOrg) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Org {
        let result = new Org();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOrg {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Repo2 implements IRepo2 {
    id?: number | undefined;
    name?: string | undefined;
    url?: string | undefined;

    constructor(data?: IRepo2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Repo2 {
        let result = new Repo2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

export interface IRepo2 {
    id?: number | undefined;
    name?: string | undefined;
    url?: string | undefined;
}

export class _links3 implements I_links3 {
    current_user?: Current_user | undefined;
    current_user_actor?: Current_user_actor | undefined;
    current_user_organization?: Current_user_organization | undefined;
    current_user_public?: Current_user_public | undefined;
    timeline?: Timeline | undefined;
    user?: User15 | undefined;

    constructor(data?: I_links3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.current_user = data["current_user"] ? Current_user.fromJS(data["current_user"]) : <any>undefined;
            this.current_user_actor = data["current_user_actor"] ? Current_user_actor.fromJS(data["current_user_actor"]) : <any>undefined;
            this.current_user_organization = data["current_user_organization"] ? Current_user_organization.fromJS(data["current_user_organization"]) : <any>undefined;
            this.current_user_public = data["current_user_public"] ? Current_user_public.fromJS(data["current_user_public"]) : <any>undefined;
            this.timeline = data["timeline"] ? Timeline.fromJS(data["timeline"]) : <any>undefined;
            this.user = data["user"] ? User15.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): _links3 {
        let result = new _links3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["current_user"] = this.current_user ? this.current_user.toJSON() : <any>undefined;
        data["current_user_actor"] = this.current_user_actor ? this.current_user_actor.toJSON() : <any>undefined;
        data["current_user_organization"] = this.current_user_organization ? this.current_user_organization.toJSON() : <any>undefined;
        data["current_user_public"] = this.current_user_public ? this.current_user_public.toJSON() : <any>undefined;
        data["timeline"] = this.timeline ? this.timeline.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface I_links3 {
    current_user?: Current_user | undefined;
    current_user_actor?: Current_user_actor | undefined;
    current_user_organization?: Current_user_organization | undefined;
    current_user_public?: Current_user_public | undefined;
    timeline?: Timeline | undefined;
    user?: User15 | undefined;
}

export class Owner implements IOwner {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOwner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Owner {
        let result = new Owner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOwner {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Files3 implements IFiles3 {
    ringErl?: RingErl | undefined;

    constructor(data?: IFiles3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ringErl = data["ring.erl"] ? RingErl.fromJS(data["ring.erl"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Files3 {
        let result = new Files3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ring.erl"] = this.ringErl ? this.ringErl.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFiles3 {
    ringErl?: RingErl | undefined;
}

export class Forks implements IForks {
    /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
    created_at?: string | undefined;
    url?: string | undefined;
    user?: User16 | undefined;

    constructor(data?: IForks) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.url = data["url"];
            this.user = data["user"] ? User16.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Forks {
        let result = new Forks();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created_at"] = this.created_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IForks {
    /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
    created_at?: string | undefined;
    url?: string | undefined;
    user?: User16 | undefined;
}

export class History implements IHistory {
    change_status?: Change_status | undefined;
    /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
    committed_at?: string | undefined;
    url?: string | undefined;
    user?: User17 | undefined;
    version?: string | undefined;

    constructor(data?: IHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.change_status = data["change_status"] ? Change_status.fromJS(data["change_status"]) : <any>undefined;
            this.committed_at = data["committed_at"];
            this.url = data["url"];
            this.user = data["user"] ? User17.fromJS(data["user"]) : <any>undefined;
            this.version = data["version"];
        }
    }

    static fromJS(data: any): History {
        let result = new History();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["change_status"] = this.change_status ? this.change_status.toJSON() : <any>undefined;
        data["committed_at"] = this.committed_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["version"] = this.version;
        return data; 
    }
}

export interface IHistory {
    change_status?: Change_status | undefined;
    /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
    committed_at?: string | undefined;
    url?: string | undefined;
    user?: User17 | undefined;
    version?: string | undefined;
}

export class User3 implements IUser3 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User3 {
        let result = new User3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser3 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Author2 implements IAuthor2 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: IAuthor2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Author2 {
        let result = new Author2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAuthor2 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Object implements IObject {
    sha?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Object {
        let result = new Object();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IObject {
    sha?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class User4 implements IUser4 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User4 {
        let result = new User4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser4 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Author3 implements IAuthor3 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAuthor3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Author3 {
        let result = new Author3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAuthor3 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Commit6 implements ICommit6 {
    author?: Author16 | undefined;
    comment_count?: number | undefined;
    committer?: Committer13 | undefined;
    message?: string | undefined;
    tree?: Tree8 | undefined;
    url?: string | undefined;

    constructor(data?: ICommit6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author16.fromJS(data["author"]) : <any>undefined;
            this.comment_count = data["comment_count"];
            this.committer = data["committer"] ? Committer13.fromJS(data["committer"]) : <any>undefined;
            this.message = data["message"];
            this.tree = data["tree"] ? Tree8.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Commit6 {
        let result = new Commit6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["comment_count"] = this.comment_count;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommit6 {
    author?: Author16 | undefined;
    comment_count?: number | undefined;
    committer?: Committer13 | undefined;
    message?: string | undefined;
    tree?: Tree8 | undefined;
    url?: string | undefined;
}

export class Committer4 implements ICommitter4 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICommitter4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Committer4 {
        let result = new Committer4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommitter4 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Parents2 implements IParents2 {
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: IParents2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Parents2 {
        let result = new Parents2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface IParents2 {
    sha?: string | undefined;
    url?: string | undefined;
}

export class Creator2 implements ICreator2 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICreator2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Creator2 {
        let result = new Creator2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICreator2 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export enum MilestoneState {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

export class Repository implements IRepository {
    description?: string | undefined;
    fork?: boolean | undefined;
    full_name?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    name?: string | undefined;
    owner?: Owner8 | undefined;
    private?: boolean | undefined;
    url?: string | undefined;

    constructor(data?: IRepository) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.fork = data["fork"];
            this.full_name = data["full_name"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.name = data["name"];
            this.owner = data["owner"] ? Owner8.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Repository {
        let result = new Repository();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["full_name"] = this.full_name;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["name"] = this.name;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["url"] = this.url;
        return data; 
    }
}

export interface IRepository {
    description?: string | undefined;
    fork?: boolean | undefined;
    full_name?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    name?: string | undefined;
    owner?: Owner8 | undefined;
    private?: boolean | undefined;
    url?: string | undefined;
}

export class Subject implements ISubject {
    latest_comment_url?: string | undefined;
    title?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: ISubject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.latest_comment_url = data["latest_comment_url"];
            this.title = data["title"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Subject {
        let result = new Subject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latest_comment_url"] = this.latest_comment_url;
        data["title"] = this.title;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface ISubject {
    latest_comment_url?: string | undefined;
    title?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export enum OrgTeamsPostPermission {
    Pull = <any>"pull", 
    Push = <any>"push", 
    Admin = <any>"admin", 
}

export class Errors implements IErrors {
    code?: string | undefined;
    field?: string | undefined;
    resource?: string | undefined;

    constructor(data?: IErrors) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.field = data["field"];
            this.resource = data["resource"];
        }
    }

    static fromJS(data: any): Errors {
        let result = new Errors();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["field"] = this.field;
        data["resource"] = this.resource;
        return data; 
    }
}

export interface IErrors {
    code?: string | undefined;
    field?: string | undefined;
    resource?: string | undefined;
}

export class Files4 implements IFiles4 {
    delete_this_fileTxt?: string | undefined;
    file1Txt?: File1Txt | undefined;
    new_fileTxt?: New_fileTxt | undefined;
    old_nameTxt?: Old_nameTxt | undefined;

    constructor(data?: IFiles4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.delete_this_fileTxt = data["delete_this_file.txt"];
            this.file1Txt = data["file1.txt"] ? File1Txt.fromJS(data["file1.txt"]) : <any>undefined;
            this.new_fileTxt = data["new_file.txt"] ? New_fileTxt.fromJS(data["new_file.txt"]) : <any>undefined;
            this.old_nameTxt = data["old_name.txt"] ? Old_nameTxt.fromJS(data["old_name.txt"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Files4 {
        let result = new Files4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["delete_this_file.txt"] = this.delete_this_fileTxt;
        data["file1.txt"] = this.file1Txt ? this.file1Txt.toJSON() : <any>undefined;
        data["new_file.txt"] = this.new_fileTxt ? this.new_fileTxt.toJSON() : <any>undefined;
        data["old_name.txt"] = this.old_nameTxt ? this.old_nameTxt.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFiles4 {
    delete_this_fileTxt?: string | undefined;
    file1Txt?: File1Txt | undefined;
    new_fileTxt?: New_fileTxt | undefined;
    old_nameTxt?: Old_nameTxt | undefined;
}

export class Files5 implements IFiles5 {
    file1Txt?: File1Txt2 | undefined;

    constructor(data?: IFiles5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.file1Txt = data["file1.txt"] ? File1Txt2.fromJS(data["file1.txt"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Files5 {
        let result = new Files5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file1.txt"] = this.file1Txt ? this.file1Txt.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFiles5 {
    file1Txt?: File1Txt2 | undefined;
}

export class _links4 implements I_links4 {
    comments?: Comments | undefined;
    html?: Html | undefined;
    review_comments?: Review_comments | undefined;
    self?: Self | undefined;

    constructor(data?: I_links4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comments = data["comments"] ? Comments.fromJS(data["comments"]) : <any>undefined;
            this.html = data["html"] ? Html.fromJS(data["html"]) : <any>undefined;
            this.review_comments = data["review_comments"] ? Review_comments.fromJS(data["review_comments"]) : <any>undefined;
            this.self = data["self"] ? Self.fromJS(data["self"]) : <any>undefined;
        }
    }

    static fromJS(data: any): _links4 {
        let result = new _links4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comments"] = this.comments ? this.comments.toJSON() : <any>undefined;
        data["html"] = this.html ? this.html.toJSON() : <any>undefined;
        data["review_comments"] = this.review_comments ? this.review_comments.toJSON() : <any>undefined;
        data["self"] = this.self ? this.self.toJSON() : <any>undefined;
        return data; 
    }
}

export interface I_links4 {
    comments?: Comments | undefined;
    html?: Html | undefined;
    review_comments?: Review_comments | undefined;
    self?: Self | undefined;
}

export class Base implements IBase {
    label?: string | undefined;
    ref?: string | undefined;
    repo?: Repo3 | undefined;
    sha?: string | undefined;
    user?: User18 | undefined;

    constructor(data?: IBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.ref = data["ref"];
            this.repo = data["repo"] ? Repo3.fromJS(data["repo"]) : <any>undefined;
            this.sha = data["sha"];
            this.user = data["user"] ? User18.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Base {
        let result = new Base();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["ref"] = this.ref;
        data["repo"] = this.repo ? this.repo.toJSON() : <any>undefined;
        data["sha"] = this.sha;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBase {
    label?: string | undefined;
    ref?: string | undefined;
    repo?: Repo3 | undefined;
    sha?: string | undefined;
    user?: User18 | undefined;
}

export class Head implements IHead {
    label?: string | undefined;
    ref?: string | undefined;
    repo?: Repo4 | undefined;
    sha?: string | undefined;
    user?: User19 | undefined;

    constructor(data?: IHead) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.ref = data["ref"];
            this.repo = data["repo"] ? Repo4.fromJS(data["repo"]) : <any>undefined;
            this.sha = data["sha"];
            this.user = data["user"] ? User19.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Head {
        let result = new Head();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["ref"] = this.ref;
        data["repo"] = this.repo ? this.repo.toJSON() : <any>undefined;
        data["sha"] = this.sha;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHead {
    label?: string | undefined;
    ref?: string | undefined;
    repo?: Repo4 | undefined;
    sha?: string | undefined;
    user?: User19 | undefined;
}

export class Merged_by implements IMerged_by {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IMerged_by) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Merged_by {
        let result = new Merged_by();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IMerged_by {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class User5 implements IUser5 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User5 {
        let result = new User5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser5 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class _links5 implements I_links5 {
    html?: Html2 | undefined;
    pull_request?: Pull_request3 | undefined;
    self?: Self2 | undefined;

    constructor(data?: I_links5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.html = data["html"] ? Html2.fromJS(data["html"]) : <any>undefined;
            this.pull_request = data["pull_request"] ? Pull_request3.fromJS(data["pull_request"]) : <any>undefined;
            this.self = data["self"] ? Self2.fromJS(data["self"]) : <any>undefined;
        }
    }

    static fromJS(data: any): _links5 {
        let result = new _links5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["html"] = this.html ? this.html.toJSON() : <any>undefined;
        data["pull_request"] = this.pull_request ? this.pull_request.toJSON() : <any>undefined;
        data["self"] = this.self ? this.self.toJSON() : <any>undefined;
        return data; 
    }
}

export interface I_links5 {
    html?: Html2 | undefined;
    pull_request?: Pull_request3 | undefined;
    self?: Self2 | undefined;
}

export class User6 implements IUser6 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User6 {
        let result = new User6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser6 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Rate implements IRate {
    limit?: number | undefined;
    remaining?: number | undefined;
    reset?: number | undefined;

    constructor(data?: IRate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.limit = data["limit"];
            this.remaining = data["remaining"];
            this.reset = data["reset"];
        }
    }

    static fromJS(data: any): Rate {
        let result = new Rate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["limit"] = this.limit;
        data["remaining"] = this.remaining;
        data["reset"] = this.reset;
        return data; 
    }
}

export interface IRate {
    limit?: number | undefined;
    remaining?: number | undefined;
    reset?: number | undefined;
}

export class _links6 implements I_links6 {
    git?: string | undefined;
    html?: string | undefined;
    self?: string | undefined;

    constructor(data?: I_links6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.git = data["git"];
            this.html = data["html"];
            this.self = data["self"];
        }
    }

    static fromJS(data: any): _links6 {
        let result = new _links6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["git"] = this.git;
        data["html"] = this.html;
        data["self"] = this.self;
        return data; 
    }
}

export interface I_links6 {
    git?: string | undefined;
    html?: string | undefined;
    self?: string | undefined;
}

export class Object2 implements IObject2 {
    sha?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IObject2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Object2 {
        let result = new Object2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IObject2 {
    sha?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Assets implements IAssets {
    content_type?: string | undefined;
    created_at?: string | undefined;
    download_count?: number | undefined;
    id?: number | undefined;
    label?: string | undefined;
    name?: string | undefined;
    size?: number | undefined;
    state?: string | undefined;
    updated_at?: string | undefined;
    uploader?: Uploader3 | undefined;
    url?: string | undefined;

    constructor(data?: IAssets) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content_type = data["content_type"];
            this.created_at = data["created_at"];
            this.download_count = data["download_count"];
            this.id = data["id"];
            this.label = data["label"];
            this.name = data["name"];
            this.size = data["size"];
            this.state = data["state"];
            this.updated_at = data["updated_at"];
            this.uploader = data["uploader"] ? Uploader3.fromJS(data["uploader"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Assets {
        let result = new Assets();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content_type"] = this.content_type;
        data["created_at"] = this.created_at;
        data["download_count"] = this.download_count;
        data["id"] = this.id;
        data["label"] = this.label;
        data["name"] = this.name;
        data["size"] = this.size;
        data["state"] = this.state;
        data["updated_at"] = this.updated_at;
        data["uploader"] = this.uploader ? this.uploader.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAssets {
    content_type?: string | undefined;
    created_at?: string | undefined;
    download_count?: number | undefined;
    id?: number | undefined;
    label?: string | undefined;
    name?: string | undefined;
    size?: number | undefined;
    state?: string | undefined;
    updated_at?: string | undefined;
    uploader?: Uploader3 | undefined;
    url?: string | undefined;
}

export class Author4 implements IAuthor4 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAuthor4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Author4 {
        let result = new Author4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAuthor4 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Organization2 implements IOrganization2 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOrganization2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Organization2 {
        let result = new Organization2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOrganization2 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Owner2 implements IOwner2 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOwner2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Owner2 {
        let result = new Owner2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOwner2 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Parent implements IParent {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner9 | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;

    constructor(data?: IParent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? Owner9.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Parent {
        let result = new Parent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

export interface IParent {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner9 | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;
}

export class Source implements ISource {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner10 | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;

    constructor(data?: ISource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? Owner10.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Source {
        let result = new Source();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

export interface ISource {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner10 | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;
}

export class Author5 implements IAuthor5 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: IAuthor5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Author5 {
        let result = new Author5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAuthor5 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Committer5 implements ICommitter5 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICommitter5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Committer5 {
        let result = new Committer5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICommitter5 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Parents3 implements IParents3 {
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: IParents3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Parents3 {
        let result = new Parents3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface IParents3 {
    sha?: string | undefined;
    url?: string | undefined;
}

export class Tree2 implements ITree2 {
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: ITree2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Tree2 {
        let result = new Tree2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface ITree2 {
    sha?: string | undefined;
    url?: string | undefined;
}

export class Author6 implements IAuthor6 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: IAuthor6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Author6 {
        let result = new Author6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAuthor6 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Items implements IItems {
    git_url?: string | undefined;
    html_url?: string | undefined;
    name?: string | undefined;
    path?: string | undefined;
    repository?: Repository2 | undefined;
    score?: number | undefined;
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: IItems) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.git_url = data["git_url"];
            this.html_url = data["html_url"];
            this.name = data["name"];
            this.path = data["path"];
            this.repository = data["repository"] ? Repository2.fromJS(data["repository"]) : <any>undefined;
            this.score = data["score"];
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Items {
        let result = new Items();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["git_url"] = this.git_url;
        data["html_url"] = this.html_url;
        data["name"] = this.name;
        data["path"] = this.path;
        data["repository"] = this.repository ? this.repository.toJSON() : <any>undefined;
        data["score"] = this.score;
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface IItems {
    git_url?: string | undefined;
    html_url?: string | undefined;
    name?: string | undefined;
    path?: string | undefined;
    repository?: Repository2 | undefined;
    score?: number | undefined;
    sha?: string | undefined;
    url?: string | undefined;
}

export class Items2 implements IItems2 {
    assignee?: Assignee3 | undefined;
    body?: string | undefined;
    closed_at?: Closed_at | undefined;
    comments?: number | undefined;
    comments_url?: string | undefined;
    created_at?: string | undefined;
    events_url?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    labels?: Labels3[] | undefined;
    labels_url?: string | undefined;
    milestone?: Milestone4 | undefined;
    number?: number | undefined;
    pull_request?: Pull_request4 | undefined;
    score?: number | undefined;
    state?: string | undefined;
    title?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User20 | undefined;

    constructor(data?: IItems2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assignee = data["assignee"];
            this.body = data["body"];
            this.closed_at = data["closed_at"];
            this.comments = data["comments"];
            this.comments_url = data["comments_url"];
            this.created_at = data["created_at"];
            this.events_url = data["events_url"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            if (data["labels"] && data["labels"].constructor === Array) {
                this.labels = [];
                for (let item of data["labels"])
                    this.labels.push(Labels3.fromJS(item));
            }
            this.labels_url = data["labels_url"];
            this.milestone = data["milestone"];
            this.number = data["number"];
            this.pull_request = data["pull_request"] ? Pull_request4.fromJS(data["pull_request"]) : <any>undefined;
            this.score = data["score"];
            this.state = data["state"];
            this.title = data["title"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.user = data["user"] ? User20.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Items2 {
        let result = new Items2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assignee"] = this.assignee;
        data["body"] = this.body;
        data["closed_at"] = this.closed_at;
        data["comments"] = this.comments;
        data["comments_url"] = this.comments_url;
        data["created_at"] = this.created_at;
        data["events_url"] = this.events_url;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        if (this.labels && this.labels.constructor === Array) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        data["labels_url"] = this.labels_url;
        data["milestone"] = this.milestone;
        data["number"] = this.number;
        data["pull_request"] = this.pull_request ? this.pull_request.toJSON() : <any>undefined;
        data["score"] = this.score;
        data["state"] = this.state;
        data["title"] = this.title;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IItems2 {
    assignee?: Assignee3 | undefined;
    body?: string | undefined;
    closed_at?: Closed_at | undefined;
    comments?: number | undefined;
    comments_url?: string | undefined;
    created_at?: string | undefined;
    events_url?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    labels?: Labels3[] | undefined;
    labels_url?: string | undefined;
    milestone?: Milestone4 | undefined;
    number?: number | undefined;
    pull_request?: Pull_request4 | undefined;
    score?: number | undefined;
    state?: string | undefined;
    title?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;
    user?: User20 | undefined;
}

export class Issues implements IIssues {
    body?: string | undefined;
    comments?: number | undefined;
    created_at?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    labels?: string[] | undefined;
    number?: number | undefined;
    position?: number | undefined;
    state?: string | undefined;
    title?: string | undefined;
    updated_at?: string | undefined;
    user?: string | undefined;
    votes?: number | undefined;

    constructor(data?: IIssues) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.body = data["body"];
            this.comments = data["comments"];
            this.created_at = data["created_at"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            if (data["labels"] && data["labels"].constructor === Array) {
                this.labels = [];
                for (let item of data["labels"])
                    this.labels.push(item);
            }
            this.number = data["number"];
            this.position = data["position"];
            this.state = data["state"];
            this.title = data["title"];
            this.updated_at = data["updated_at"];
            this.user = data["user"];
            this.votes = data["votes"];
        }
    }

    static fromJS(data: any): Issues {
        let result = new Issues();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        data["comments"] = this.comments;
        data["created_at"] = this.created_at;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        if (this.labels && this.labels.constructor === Array) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        data["number"] = this.number;
        data["position"] = this.position;
        data["state"] = this.state;
        data["title"] = this.title;
        data["updated_at"] = this.updated_at;
        data["user"] = this.user;
        data["votes"] = this.votes;
        return data; 
    }
}

export interface IIssues {
    body?: string | undefined;
    comments?: number | undefined;
    created_at?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    labels?: string[] | undefined;
    number?: number | undefined;
    position?: number | undefined;
    state?: string | undefined;
    title?: string | undefined;
    updated_at?: string | undefined;
    user?: string | undefined;
    votes?: number | undefined;
}

export class Items3 implements IItems3 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    default_branch?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner11 | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    score?: number | undefined;
    size?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;

    constructor(data?: IItems3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created_at = data["created_at"];
            this.default_branch = data["default_branch"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? Owner11.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.score = data["score"];
            this.size = data["size"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Items3 {
        let result = new Items3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created_at"] = this.created_at;
        data["default_branch"] = this.default_branch;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["score"] = this.score;
        data["size"] = this.size;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

export interface IItems3 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    default_branch?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner11 | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    score?: number | undefined;
    size?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;
}

export class Repositories implements IRepositories {
    created?: string | undefined;
    created_at?: string | undefined;
    description?: string | undefined;
    followers?: number | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    has_downloads?: boolean | undefined;
    has_issues?: boolean | undefined;
    has_wiki?: boolean | undefined;
    homepage?: string | undefined;
    language?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    owner?: string | undefined;
    private?: boolean | undefined;
    pushed?: string | undefined;
    pushed_at?: string | undefined;
    score?: number | undefined;
    size?: number | undefined;
    type?: string | undefined;
    url?: string | undefined;
    username?: string | undefined;
    watchers?: number | undefined;

    constructor(data?: IRepositories) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created = data["created"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.followers = data["followers"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.has_downloads = data["has_downloads"];
            this.has_issues = data["has_issues"];
            this.has_wiki = data["has_wiki"];
            this.homepage = data["homepage"];
            this.language = data["language"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.owner = data["owner"];
            this.private = data["private"];
            this.pushed = data["pushed"];
            this.pushed_at = data["pushed_at"];
            this.score = data["score"];
            this.size = data["size"];
            this.type = data["type"];
            this.url = data["url"];
            this.username = data["username"];
            this.watchers = data["watchers"];
        }
    }

    static fromJS(data: any): Repositories {
        let result = new Repositories();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["followers"] = this.followers;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["has_downloads"] = this.has_downloads;
        data["has_issues"] = this.has_issues;
        data["has_wiki"] = this.has_wiki;
        data["homepage"] = this.homepage;
        data["language"] = this.language;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["owner"] = this.owner;
        data["private"] = this.private;
        data["pushed"] = this.pushed;
        data["pushed_at"] = this.pushed_at;
        data["score"] = this.score;
        data["size"] = this.size;
        data["type"] = this.type;
        data["url"] = this.url;
        data["username"] = this.username;
        data["watchers"] = this.watchers;
        return data; 
    }
}

export interface IRepositories {
    created?: string | undefined;
    created_at?: string | undefined;
    description?: string | undefined;
    followers?: number | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    has_downloads?: boolean | undefined;
    has_issues?: boolean | undefined;
    has_wiki?: boolean | undefined;
    homepage?: string | undefined;
    language?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    owner?: string | undefined;
    private?: boolean | undefined;
    pushed?: string | undefined;
    pushed_at?: string | undefined;
    score?: number | undefined;
    size?: number | undefined;
    type?: string | undefined;
    url?: string | undefined;
    username?: string | undefined;
    watchers?: number | undefined;
}

export class User7 implements IUser7 {
    blog?: string | undefined;
    company?: string | undefined;
    created?: string | undefined;
    created_at?: string | undefined;
    email?: string | undefined;
    followers_count?: number | undefined;
    following_count?: number | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    location?: string | undefined;
    login?: string | undefined;
    name?: string | undefined;
    public_gist_count?: number | undefined;
    public_repo_count?: number | undefined;
    type?: string | undefined;

    constructor(data?: IUser7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.blog = data["blog"];
            this.company = data["company"];
            this.created = data["created"];
            this.created_at = data["created_at"];
            this.email = data["email"];
            this.followers_count = data["followers_count"];
            this.following_count = data["following_count"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.location = data["location"];
            this.login = data["login"];
            this.name = data["name"];
            this.public_gist_count = data["public_gist_count"];
            this.public_repo_count = data["public_repo_count"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): User7 {
        let result = new User7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["blog"] = this.blog;
        data["company"] = this.company;
        data["created"] = this.created;
        data["created_at"] = this.created_at;
        data["email"] = this.email;
        data["followers_count"] = this.followers_count;
        data["following_count"] = this.following_count;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["location"] = this.location;
        data["login"] = this.login;
        data["name"] = this.name;
        data["public_gist_count"] = this.public_gist_count;
        data["public_repo_count"] = this.public_repo_count;
        data["type"] = this.type;
        return data; 
    }
}

export interface IUser7 {
    blog?: string | undefined;
    company?: string | undefined;
    created?: string | undefined;
    created_at?: string | undefined;
    email?: string | undefined;
    followers_count?: number | undefined;
    following_count?: number | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    location?: string | undefined;
    login?: string | undefined;
    name?: string | undefined;
    public_gist_count?: number | undefined;
    public_repo_count?: number | undefined;
    type?: string | undefined;
}

export class Items4 implements IItems4 {
    avatar_url?: string | undefined;
    followers_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    score?: number | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IItems4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.followers_url = data["followers_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.score = data["score"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Items4 {
        let result = new Items4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["followers_url"] = this.followers_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["score"] = this.score;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IItems4 {
    avatar_url?: string | undefined;
    followers_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    score?: number | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Users implements IUsers {
    created?: string | undefined;
    created_at?: string | undefined;
    followers?: number | undefined;
    followers_count?: number | undefined;
    fullname?: string | undefined;
    gravatar_id?: string | undefined;
    id?: string | undefined;
    language?: string | undefined;
    location?: string | undefined;
    login?: string | undefined;
    name?: string | undefined;
    public_repo_count?: number | undefined;
    repos?: number | undefined;
    score?: number | undefined;
    type?: string | undefined;
    username?: string | undefined;

    constructor(data?: IUsers) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.created = data["created"];
            this.created_at = data["created_at"];
            this.followers = data["followers"];
            this.followers_count = data["followers_count"];
            this.fullname = data["fullname"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.language = data["language"];
            this.location = data["location"];
            this.login = data["login"];
            this.name = data["name"];
            this.public_repo_count = data["public_repo_count"];
            this.repos = data["repos"];
            this.score = data["score"];
            this.type = data["type"];
            this.username = data["username"];
        }
    }

    static fromJS(data: any): Users {
        let result = new Users();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created;
        data["created_at"] = this.created_at;
        data["followers"] = this.followers;
        data["followers_count"] = this.followers_count;
        data["fullname"] = this.fullname;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["language"] = this.language;
        data["location"] = this.location;
        data["login"] = this.login;
        data["name"] = this.name;
        data["public_repo_count"] = this.public_repo_count;
        data["repos"] = this.repos;
        data["score"] = this.score;
        data["type"] = this.type;
        data["username"] = this.username;
        return data; 
    }
}

export interface IUsers {
    created?: string | undefined;
    created_at?: string | undefined;
    followers?: number | undefined;
    followers_count?: number | undefined;
    fullname?: string | undefined;
    gravatar_id?: string | undefined;
    id?: string | undefined;
    language?: string | undefined;
    location?: string | undefined;
    login?: string | undefined;
    name?: string | undefined;
    public_repo_count?: number | undefined;
    repos?: number | undefined;
    score?: number | undefined;
    type?: string | undefined;
    username?: string | undefined;
}

export class Object3 implements IObject3 {
    sha?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IObject3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Object3 {
        let result = new Object3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IObject3 {
    sha?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Tagger implements ITagger {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: ITagger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Tagger {
        let result = new Tagger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface ITagger {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Tagger2 implements ITagger2 {
    /** Timestamp of when this object was tagged. */
    date?: string | undefined;
    /** String of the email of the author of the tag. */
    email?: string | undefined;
    /** String of the name of the author of the tag. */
    name?: string | undefined;

    constructor(data?: ITagger2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Tagger2 {
        let result = new Tagger2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface ITagger2 {
    /** Timestamp of when this object was tagged. */
    date?: string | undefined;
    /** String of the email of the author of the tag. */
    email?: string | undefined;
    /** String of the name of the author of the tag. */
    name?: string | undefined;
}

export class Tree3 implements ITree3 {
    mode?: string | undefined;
    path?: string | undefined;
    sha?: string | undefined;
    size?: number | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: ITree3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mode = data["mode"];
            this.path = data["path"];
            this.sha = data["sha"];
            this.size = data["size"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Tree3 {
        let result = new Tree3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mode"] = this.mode;
        data["path"] = this.path;
        data["sha"] = this.sha;
        data["size"] = this.size;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface ITree3 {
    mode?: string | undefined;
    path?: string | undefined;
    sha?: string | undefined;
    size?: number | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Tree4 implements ITree4 {
    /** One of 100644 for file (blob), 100755 for executable (blob), 040000 for subdirectory (tree), 160000 for submodule (commit) or 120000 for a blob that specifies the path of a symlink. */
    mode?: Tree4Mode | undefined;
    path?: string | undefined;
    /** SHA1 checksum ID of the object in the tree. */
    sha?: string | undefined;
    type?: Tree4Type | undefined;
    url?: string | undefined;

    constructor(data?: ITree4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mode = data["mode"];
            this.path = data["path"];
            this.sha = data["sha"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Tree4 {
        let result = new Tree4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mode"] = this.mode;
        data["path"] = this.path;
        data["sha"] = this.sha;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface ITree4 {
    /** One of 100644 for file (blob), 100755 for executable (blob), 040000 for subdirectory (tree), 160000 for submodule (commit) or 120000 for a blob that specifies the path of a symlink. */
    mode?: Tree4Mode | undefined;
    path?: string | undefined;
    /** SHA1 checksum ID of the object in the tree. */
    sha?: string | undefined;
    type?: Tree4Type | undefined;
    url?: string | undefined;
}

export class Plan implements IPlan {
    collaborators?: number | undefined;
    name?: string | undefined;
    private_repos?: number | undefined;
    space?: number | undefined;

    constructor(data?: IPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.collaborators = data["collaborators"];
            this.name = data["name"];
            this.private_repos = data["private_repos"];
            this.space = data["space"];
        }
    }

    static fromJS(data: any): Plan {
        let result = new Plan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["collaborators"] = this.collaborators;
        data["name"] = this.name;
        data["private_repos"] = this.private_repos;
        data["space"] = this.space;
        return data; 
    }
}

export interface IPlan {
    collaborators?: number | undefined;
    name?: string | undefined;
    private_repos?: number | undefined;
    space?: number | undefined;
}

export class Files6 implements IFiles6 {
    ringErl?: RingErl2 | undefined;

    constructor(data?: IFiles6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ringErl = data["ring.erl"] ? RingErl2.fromJS(data["ring.erl"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Files6 {
        let result = new Files6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ring.erl"] = this.ringErl ? this.ringErl.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFiles6 {
    ringErl?: RingErl2 | undefined;
}

export class User8 implements IUser8 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User8 {
        let result = new User8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser8 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class User9 implements IUser9 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User9 {
        let result = new User9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser9 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Assignee implements IAssignee {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAssignee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Assignee {
        let result = new Assignee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAssignee {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Labels implements ILabels {
    color?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;

    constructor(data?: ILabels) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.color = data["color"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Labels {
        let result = new Labels();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["color"] = this.color;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

export interface ILabels {
    color?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
}

export class Milestone2 implements IMilestone2 {
    closed_issues?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    creator?: Creator6 | undefined;
    description?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    due_on?: string | undefined;
    number?: number | undefined;
    open_issues?: number | undefined;
    state?: Milestone2State | undefined;
    title?: string | undefined;
    url?: string | undefined;

    constructor(data?: IMilestone2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.closed_issues = data["closed_issues"];
            this.created_at = data["created_at"];
            this.creator = data["creator"] ? Creator6.fromJS(data["creator"]) : <any>undefined;
            this.description = data["description"];
            this.due_on = data["due_on"];
            this.number = data["number"];
            this.open_issues = data["open_issues"];
            this.state = data["state"];
            this.title = data["title"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Milestone2 {
        let result = new Milestone2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["closed_issues"] = this.closed_issues;
        data["created_at"] = this.created_at;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["due_on"] = this.due_on;
        data["number"] = this.number;
        data["open_issues"] = this.open_issues;
        data["state"] = this.state;
        data["title"] = this.title;
        data["url"] = this.url;
        return data; 
    }
}

export interface IMilestone2 {
    closed_issues?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    creator?: Creator6 | undefined;
    description?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    due_on?: string | undefined;
    number?: number | undefined;
    open_issues?: number | undefined;
    state?: Milestone2State | undefined;
    title?: string | undefined;
    url?: string | undefined;
}

export class Pull_request implements IPull_request {
    diff_url?: string | undefined;
    html_url?: string | undefined;
    patch_url?: string | undefined;

    constructor(data?: IPull_request) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.diff_url = data["diff_url"];
            this.html_url = data["html_url"];
            this.patch_url = data["patch_url"];
        }
    }

    static fromJS(data: any): Pull_request {
        let result = new Pull_request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["diff_url"] = this.diff_url;
        data["html_url"] = this.html_url;
        data["patch_url"] = this.patch_url;
        return data; 
    }
}

export interface IPull_request {
    diff_url?: string | undefined;
    html_url?: string | undefined;
    patch_url?: string | undefined;
}

export enum State8 {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

export class User10 implements IUser10 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User10 {
        let result = new User10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser10 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Owner3 implements IOwner3 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOwner3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Owner3 {
        let result = new Owner3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOwner3 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Commit7 implements ICommit7 {
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICommit7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Commit7 {
        let result = new Commit7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommit7 {
    sha?: string | undefined;
    url?: string | undefined;
}

export class User11 implements IUser11 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User11 {
        let result = new User11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser11 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Author7 implements IAuthor7 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAuthor7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Author7 {
        let result = new Author7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAuthor7 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Commit8 implements ICommit8 {
    author?: Author17 | undefined;
    committer?: Committer14 | undefined;
    message?: string | undefined;
    tree?: Tree9 | undefined;
    url?: string | undefined;

    constructor(data?: ICommit8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author17.fromJS(data["author"]) : <any>undefined;
            this.committer = data["committer"] ? Committer14.fromJS(data["committer"]) : <any>undefined;
            this.message = data["message"];
            this.tree = data["tree"] ? Tree9.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Commit8 {
        let result = new Commit8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommit8 {
    author?: Author17 | undefined;
    committer?: Committer14 | undefined;
    message?: string | undefined;
    tree?: Tree9 | undefined;
    url?: string | undefined;
}

export class Committer6 implements ICommitter6 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICommitter6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Committer6 {
        let result = new Committer6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommitter6 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Parents4 implements IParents4 {
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: IParents4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Parents4 {
        let result = new Parents4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface IParents4 {
    sha?: string | undefined;
    url?: string | undefined;
}

export class Statuses implements IStatuses {
    context?: string | undefined;
    created_at?: string | undefined;
    description?: string | undefined;
    id?: number | undefined;
    state?: string | undefined;
    target_url?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;

    constructor(data?: IStatuses) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.context = data["context"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.id = data["id"];
            this.state = data["state"];
            this.target_url = data["target_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Statuses {
        let result = new Statuses();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["context"] = this.context;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["id"] = this.id;
        data["state"] = this.state;
        data["target_url"] = this.target_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        return data; 
    }
}

export interface IStatuses {
    context?: string | undefined;
    created_at?: string | undefined;
    description?: string | undefined;
    id?: number | undefined;
    state?: string | undefined;
    target_url?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;
}

export class Creator3 implements ICreator3 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICreator3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Creator3 {
        let result = new Creator3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICreator3 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Creator4 implements ICreator4 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICreator4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Creator4 {
        let result = new Creator4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICreator4 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Owner4 implements IOwner4 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOwner4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Owner4 {
        let result = new Owner4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOwner4 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Object4 implements IObject4 {
    sha?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IObject4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Object4 {
        let result = new Object4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IObject4 {
    sha?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Config implements IConfig {
    content_type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content_type = data["content_type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Config {
        let result = new Config();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content_type"] = this.content_type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IConfig {
    content_type?: string | undefined;
    url?: string | undefined;
}

export enum Events2 {
    Push = <any>"push", 
    Issues = <any>"issues", 
    Issue_comment = <any>"issue_comment", 
    Commit_comment = <any>"commit_comment", 
    Pull_request = <any>"pull_request", 
    Pull_request_review_comment = <any>"pull_request_review_comment", 
    Gollum = <any>"gollum", 
    Watch = <any>"watch", 
    Download = <any>"download", 
    Fork = <any>"fork", 
    Fork_apply = <any>"fork_apply", 
    Member = <any>"member", 
    Public = <any>"public", 
    Team_add = <any>"team_add", 
    Status = <any>"status", 
}

export class _links7 implements I_links7 {
    html?: Html3 | undefined;
    pull_request?: Pull_request5 | undefined;
    self?: Self3 | undefined;

    constructor(data?: I_links7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.html = data["html"] ? Html3.fromJS(data["html"]) : <any>undefined;
            this.pull_request = data["pull_request"] ? Pull_request5.fromJS(data["pull_request"]) : <any>undefined;
            this.self = data["self"] ? Self3.fromJS(data["self"]) : <any>undefined;
        }
    }

    static fromJS(data: any): _links7 {
        let result = new _links7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["html"] = this.html ? this.html.toJSON() : <any>undefined;
        data["pull_request"] = this.pull_request ? this.pull_request.toJSON() : <any>undefined;
        data["self"] = this.self ? this.self.toJSON() : <any>undefined;
        return data; 
    }
}

export interface I_links7 {
    html?: Html3 | undefined;
    pull_request?: Pull_request5 | undefined;
    self?: Self3 | undefined;
}

export class User12 implements IUser12 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User12 {
        let result = new User12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser12 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class _links8 implements I_links8 {
    comments?: Comments2 | undefined;
    html?: Html4 | undefined;
    review_comments?: Review_comments2 | undefined;
    self?: Self4 | undefined;

    constructor(data?: I_links8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comments = data["comments"] ? Comments2.fromJS(data["comments"]) : <any>undefined;
            this.html = data["html"] ? Html4.fromJS(data["html"]) : <any>undefined;
            this.review_comments = data["review_comments"] ? Review_comments2.fromJS(data["review_comments"]) : <any>undefined;
            this.self = data["self"] ? Self4.fromJS(data["self"]) : <any>undefined;
        }
    }

    static fromJS(data: any): _links8 {
        let result = new _links8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comments"] = this.comments ? this.comments.toJSON() : <any>undefined;
        data["html"] = this.html ? this.html.toJSON() : <any>undefined;
        data["review_comments"] = this.review_comments ? this.review_comments.toJSON() : <any>undefined;
        data["self"] = this.self ? this.self.toJSON() : <any>undefined;
        return data; 
    }
}

export interface I_links8 {
    comments?: Comments2 | undefined;
    html?: Html4 | undefined;
    review_comments?: Review_comments2 | undefined;
    self?: Self4 | undefined;
}

export class Base2 implements IBase2 {
    label?: string | undefined;
    ref?: string | undefined;
    repo?: Repo5 | undefined;
    sha?: string | undefined;
    user?: User21 | undefined;

    constructor(data?: IBase2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.ref = data["ref"];
            this.repo = data["repo"] ? Repo5.fromJS(data["repo"]) : <any>undefined;
            this.sha = data["sha"];
            this.user = data["user"] ? User21.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Base2 {
        let result = new Base2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["ref"] = this.ref;
        data["repo"] = this.repo ? this.repo.toJSON() : <any>undefined;
        data["sha"] = this.sha;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBase2 {
    label?: string | undefined;
    ref?: string | undefined;
    repo?: Repo5 | undefined;
    sha?: string | undefined;
    user?: User21 | undefined;
}

export class Head2 implements IHead2 {
    label?: string | undefined;
    ref?: string | undefined;
    repo?: Repo6 | undefined;
    sha?: string | undefined;
    user?: User22 | undefined;

    constructor(data?: IHead2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.ref = data["ref"];
            this.repo = data["repo"] ? Repo6.fromJS(data["repo"]) : <any>undefined;
            this.sha = data["sha"];
            this.user = data["user"] ? User22.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Head2 {
        let result = new Head2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["ref"] = this.ref;
        data["repo"] = this.repo ? this.repo.toJSON() : <any>undefined;
        data["sha"] = this.sha;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHead2 {
    label?: string | undefined;
    ref?: string | undefined;
    repo?: Repo6 | undefined;
    sha?: string | undefined;
    user?: User22 | undefined;
}

export enum State9 {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

export class User13 implements IUser13 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser13) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User13 {
        let result = new User13();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser13 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Assets2 implements IAssets2 {
    content_type?: string | undefined;
    created_at?: string | undefined;
    download_count?: number | undefined;
    id?: number | undefined;
    label?: string | undefined;
    name?: string | undefined;
    size?: number | undefined;
    state?: string | undefined;
    updated_at?: string | undefined;
    uploader?: Uploader4 | undefined;
    url?: string | undefined;

    constructor(data?: IAssets2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content_type = data["content_type"];
            this.created_at = data["created_at"];
            this.download_count = data["download_count"];
            this.id = data["id"];
            this.label = data["label"];
            this.name = data["name"];
            this.size = data["size"];
            this.state = data["state"];
            this.updated_at = data["updated_at"];
            this.uploader = data["uploader"] ? Uploader4.fromJS(data["uploader"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Assets2 {
        let result = new Assets2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content_type"] = this.content_type;
        data["created_at"] = this.created_at;
        data["download_count"] = this.download_count;
        data["id"] = this.id;
        data["label"] = this.label;
        data["name"] = this.name;
        data["size"] = this.size;
        data["state"] = this.state;
        data["updated_at"] = this.updated_at;
        data["uploader"] = this.uploader ? this.uploader.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAssets2 {
    content_type?: string | undefined;
    created_at?: string | undefined;
    download_count?: number | undefined;
    id?: number | undefined;
    label?: string | undefined;
    name?: string | undefined;
    size?: number | undefined;
    state?: string | undefined;
    updated_at?: string | undefined;
    uploader?: Uploader4 | undefined;
    url?: string | undefined;
}

export class Author8 implements IAuthor8 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAuthor8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Author8 {
        let result = new Author8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAuthor8 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Uploader2 implements IUploader2 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUploader2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Uploader2 {
        let result = new Uploader2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUploader2 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Author9 implements IAuthor9 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAuthor9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Author9 {
        let result = new Author9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAuthor9 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Weeks implements IWeeks {
    /** Number of additions. */
    a?: number | undefined;
    /** Number of commits. */
    c?: number | undefined;
    /** Number of deletions. */
    d?: number | undefined;
    /** Start of the week. */
    w?: string | undefined;

    constructor(data?: IWeeks) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.a = data["a"];
            this.c = data["c"];
            this.d = data["d"];
            this.w = data["w"];
        }
    }

    static fromJS(data: any): Weeks {
        let result = new Weeks();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["a"] = this.a;
        data["c"] = this.c;
        data["d"] = this.d;
        data["w"] = this.w;
        return data; 
    }
}

export interface IWeeks {
    /** Number of additions. */
    a?: number | undefined;
    /** Number of commits. */
    c?: number | undefined;
    /** Number of deletions. */
    d?: number | undefined;
    /** Start of the week. */
    w?: string | undefined;
}

export class Creator5 implements ICreator5 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICreator5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Creator5 {
        let result = new Creator5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICreator5 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Owner5 implements IOwner5 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOwner5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Owner5 {
        let result = new Owner5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOwner5 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Language implements ILanguage {

    constructor(data?: ILanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Language {
        let result = new Language();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface ILanguage {
}

export class Owner6 implements IOwner6 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOwner6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Owner6 {
        let result = new Owner6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOwner6 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Owner7 implements IOwner7 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOwner7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Owner7 {
        let result = new Owner7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOwner7 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Organization3 implements IOrganization3 {
    avatar_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOrganization3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Organization3 {
        let result = new Organization3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOrganization3 {
    avatar_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Author10 implements IAuthor10 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAuthor10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Author10 {
        let result = new Author10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAuthor10 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Commit9 implements ICommit9 {
    author?: Author18 | undefined;
    committer?: Committer15 | undefined;
    message?: string | undefined;
    tree?: Tree10 | undefined;
    url?: string | undefined;

    constructor(data?: ICommit9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author18.fromJS(data["author"]) : <any>undefined;
            this.committer = data["committer"] ? Committer15.fromJS(data["committer"]) : <any>undefined;
            this.message = data["message"];
            this.tree = data["tree"] ? Tree10.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Commit9 {
        let result = new Commit9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommit9 {
    author?: Author18 | undefined;
    committer?: Committer15 | undefined;
    message?: string | undefined;
    tree?: Tree10 | undefined;
    url?: string | undefined;
}

export class Committer7 implements ICommitter7 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICommitter7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Committer7 {
        let result = new Committer7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommitter7 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Parents5 implements IParents5 {
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: IParents5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Parents5 {
        let result = new Parents5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface IParents5 {
    sha?: string | undefined;
    url?: string | undefined;
}

export class Author11 implements IAuthor11 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: IAuthor11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Author11 {
        let result = new Author11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAuthor11 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Committer8 implements ICommitter8 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICommitter8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Committer8 {
        let result = new Committer8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICommitter8 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Tree5 implements ITree5 {
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: ITree5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Tree5 {
        let result = new Tree5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface ITree5 {
    sha?: string | undefined;
    url?: string | undefined;
}

export class Author12 implements IAuthor12 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAuthor12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Author12 {
        let result = new Author12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAuthor12 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Commit10 implements ICommit10 {
    author?: Author19 | undefined;
    committer?: Committer16 | undefined;
    message?: string | undefined;
    tree?: Tree11 | undefined;
    url?: string | undefined;

    constructor(data?: ICommit10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author19.fromJS(data["author"]) : <any>undefined;
            this.committer = data["committer"] ? Committer16.fromJS(data["committer"]) : <any>undefined;
            this.message = data["message"];
            this.tree = data["tree"] ? Tree11.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Commit10 {
        let result = new Commit10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommit10 {
    author?: Author19 | undefined;
    committer?: Committer16 | undefined;
    message?: string | undefined;
    tree?: Tree11 | undefined;
    url?: string | undefined;
}

export class Committer9 implements ICommitter9 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICommitter9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Committer9 {
        let result = new Committer9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommitter9 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Parents6 implements IParents6 {
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: IParents6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Parents6 {
        let result = new Parents6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface IParents6 {
    sha?: string | undefined;
    url?: string | undefined;
}

export class Author13 implements IAuthor13 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAuthor13) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Author13 {
        let result = new Author13();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAuthor13 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Commit11 implements ICommit11 {
    author?: Author20 | undefined;
    committer?: Committer17 | undefined;
    message?: string | undefined;
    tree?: Tree12 | undefined;
    url?: string | undefined;

    constructor(data?: ICommit11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.author = data["author"] ? Author20.fromJS(data["author"]) : <any>undefined;
            this.committer = data["committer"] ? Committer17.fromJS(data["committer"]) : <any>undefined;
            this.message = data["message"];
            this.tree = data["tree"] ? Tree12.fromJS(data["tree"]) : <any>undefined;
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Commit11 {
        let result = new Commit11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["committer"] = this.committer ? this.committer.toJSON() : <any>undefined;
        data["message"] = this.message;
        data["tree"] = this.tree ? this.tree.toJSON() : <any>undefined;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommit11 {
    author?: Author20 | undefined;
    committer?: Committer17 | undefined;
    message?: string | undefined;
    tree?: Tree12 | undefined;
    url?: string | undefined;
}

export class Committer10 implements ICommitter10 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICommitter10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Committer10 {
        let result = new Committer10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICommitter10 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Parents7 implements IParents7 {
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: IParents7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Parents7 {
        let result = new Parents7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface IParents7 {
    sha?: string | undefined;
    url?: string | undefined;
}

export class Author14 implements IAuthor14 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: IAuthor14) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Author14 {
        let result = new Author14();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAuthor14 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Committer11 implements ICommitter11 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICommitter11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Committer11 {
        let result = new Committer11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICommitter11 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Parents8 implements IParents8 {
    html_url?: string | undefined;
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: IParents8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.html_url = data["html_url"];
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Parents8 {
        let result = new Parents8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["html_url"] = this.html_url;
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface IParents8 {
    html_url?: string | undefined;
    sha?: string | undefined;
    url?: string | undefined;
}

export class Tree6 implements ITree6 {
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: ITree6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Tree6 {
        let result = new Tree6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface ITree6 {
    sha?: string | undefined;
    url?: string | undefined;
}

export class _links9 implements I_links9 {
    git?: string | undefined;
    html?: string | undefined;
    self?: string | undefined;

    constructor(data?: I_links9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.git = data["git"];
            this.html = data["html"];
            this.self = data["self"];
        }
    }

    static fromJS(data: any): _links9 {
        let result = new _links9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["git"] = this.git;
        data["html"] = this.html;
        data["self"] = this.self;
        return data; 
    }
}

export interface I_links9 {
    git?: string | undefined;
    html?: string | undefined;
    self?: string | undefined;
}

export class Author15 implements IAuthor15 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: IAuthor15) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Author15 {
        let result = new Author15();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAuthor15 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Committer12 implements ICommitter12 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICommitter12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Committer12 {
        let result = new Committer12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICommitter12 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Parents9 implements IParents9 {
    html_url?: string | undefined;
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: IParents9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.html_url = data["html_url"];
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Parents9 {
        let result = new Parents9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["html_url"] = this.html_url;
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface IParents9 {
    html_url?: string | undefined;
    sha?: string | undefined;
    url?: string | undefined;
}

export class Tree7 implements ITree7 {
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: ITree7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Tree7 {
        let result = new Tree7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface ITree7 {
    sha?: string | undefined;
    url?: string | undefined;
}

export class Assignee2 implements IAssignee2 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IAssignee2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Assignee2 {
        let result = new Assignee2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IAssignee2 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Labels2 implements ILabels2 {
    color?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;

    constructor(data?: ILabels2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.color = data["color"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Labels2 {
        let result = new Labels2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["color"] = this.color;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

export interface ILabels2 {
    color?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
}

export class Milestone3 implements IMilestone3 {
    closed_issues?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    creator?: Creator7 | undefined;
    description?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    due_on?: string | undefined;
    number?: number | undefined;
    open_issues?: number | undefined;
    state?: Milestone3State | undefined;
    title?: string | undefined;
    url?: string | undefined;

    constructor(data?: IMilestone3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.closed_issues = data["closed_issues"];
            this.created_at = data["created_at"];
            this.creator = data["creator"] ? Creator7.fromJS(data["creator"]) : <any>undefined;
            this.description = data["description"];
            this.due_on = data["due_on"];
            this.number = data["number"];
            this.open_issues = data["open_issues"];
            this.state = data["state"];
            this.title = data["title"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Milestone3 {
        let result = new Milestone3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["closed_issues"] = this.closed_issues;
        data["created_at"] = this.created_at;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["due_on"] = this.due_on;
        data["number"] = this.number;
        data["open_issues"] = this.open_issues;
        data["state"] = this.state;
        data["title"] = this.title;
        data["url"] = this.url;
        return data; 
    }
}

export interface IMilestone3 {
    closed_issues?: number | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    creator?: Creator7 | undefined;
    description?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    due_on?: string | undefined;
    number?: number | undefined;
    open_issues?: number | undefined;
    state?: Milestone3State | undefined;
    title?: string | undefined;
    url?: string | undefined;
}

export class Pull_request2 implements IPull_request2 {
    diff_url?: string | undefined;
    html_url?: string | undefined;
    patch_url?: string | undefined;

    constructor(data?: IPull_request2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.diff_url = data["diff_url"];
            this.html_url = data["html_url"];
            this.patch_url = data["patch_url"];
        }
    }

    static fromJS(data: any): Pull_request2 {
        let result = new Pull_request2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["diff_url"] = this.diff_url;
        data["html_url"] = this.html_url;
        data["patch_url"] = this.patch_url;
        return data; 
    }
}

export interface IPull_request2 {
    diff_url?: string | undefined;
    html_url?: string | undefined;
    patch_url?: string | undefined;
}

export enum Issue2State {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

export class User14 implements IUser14 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser14) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User14 {
        let result = new User14();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser14 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Current_user implements ICurrent_user {
    href?: string | undefined;
    type?: string | undefined;

    constructor(data?: ICurrent_user) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Current_user {
        let result = new Current_user();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        data["type"] = this.type;
        return data; 
    }
}

export interface ICurrent_user {
    href?: string | undefined;
    type?: string | undefined;
}

export class Current_user_actor implements ICurrent_user_actor {
    href?: string | undefined;
    type?: string | undefined;

    constructor(data?: ICurrent_user_actor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Current_user_actor {
        let result = new Current_user_actor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        data["type"] = this.type;
        return data; 
    }
}

export interface ICurrent_user_actor {
    href?: string | undefined;
    type?: string | undefined;
}

export class Current_user_organization implements ICurrent_user_organization {
    href?: string | undefined;
    type?: string | undefined;

    constructor(data?: ICurrent_user_organization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Current_user_organization {
        let result = new Current_user_organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        data["type"] = this.type;
        return data; 
    }
}

export interface ICurrent_user_organization {
    href?: string | undefined;
    type?: string | undefined;
}

export class Current_user_public implements ICurrent_user_public {
    href?: string | undefined;
    type?: string | undefined;

    constructor(data?: ICurrent_user_public) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Current_user_public {
        let result = new Current_user_public();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        data["type"] = this.type;
        return data; 
    }
}

export interface ICurrent_user_public {
    href?: string | undefined;
    type?: string | undefined;
}

export class Timeline implements ITimeline {
    href?: string | undefined;
    type?: string | undefined;

    constructor(data?: ITimeline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Timeline {
        let result = new Timeline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        data["type"] = this.type;
        return data; 
    }
}

export interface ITimeline {
    href?: string | undefined;
    type?: string | undefined;
}

export class User15 implements IUser15 {
    href?: string | undefined;
    type?: string | undefined;

    constructor(data?: IUser15) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): User15 {
        let result = new User15();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        data["type"] = this.type;
        return data; 
    }
}

export interface IUser15 {
    href?: string | undefined;
    type?: string | undefined;
}

export class RingErl implements IRingErl {
    filename?: string | undefined;
    raw_url?: string | undefined;
    size?: number | undefined;

    constructor(data?: IRingErl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filename = data["filename"];
            this.raw_url = data["raw_url"];
            this.size = data["size"];
        }
    }

    static fromJS(data: any): RingErl {
        let result = new RingErl();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filename"] = this.filename;
        data["raw_url"] = this.raw_url;
        data["size"] = this.size;
        return data; 
    }
}

export interface IRingErl {
    filename?: string | undefined;
    raw_url?: string | undefined;
    size?: number | undefined;
}

export class User16 implements IUser16 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser16) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User16 {
        let result = new User16();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser16 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Change_status implements IChange_status {
    additions?: number | undefined;
    deletions?: number | undefined;
    total?: number | undefined;

    constructor(data?: IChange_status) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.additions = data["additions"];
            this.deletions = data["deletions"];
            this.total = data["total"];
        }
    }

    static fromJS(data: any): Change_status {
        let result = new Change_status();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["additions"] = this.additions;
        data["deletions"] = this.deletions;
        data["total"] = this.total;
        return data; 
    }
}

export interface IChange_status {
    additions?: number | undefined;
    deletions?: number | undefined;
    total?: number | undefined;
}

export class User17 implements IUser17 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser17) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User17 {
        let result = new User17();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser17 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Author16 implements IAuthor16 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: IAuthor16) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Author16 {
        let result = new Author16();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAuthor16 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Committer13 implements ICommitter13 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICommitter13) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Committer13 {
        let result = new Committer13();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICommitter13 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Tree8 implements ITree8 {
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: ITree8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Tree8 {
        let result = new Tree8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface ITree8 {
    sha?: string | undefined;
    url?: string | undefined;
}

export class Owner8 implements IOwner8 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOwner8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Owner8 {
        let result = new Owner8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOwner8 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class File1Txt implements IFile1Txt {
    content?: string | undefined;

    constructor(data?: IFile1Txt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
        }
    }

    static fromJS(data: any): File1Txt {
        let result = new File1Txt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        return data; 
    }
}

export interface IFile1Txt {
    content?: string | undefined;
}

export class New_fileTxt implements INew_fileTxt {
    content?: string | undefined;

    constructor(data?: INew_fileTxt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
        }
    }

    static fromJS(data: any): New_fileTxt {
        let result = new New_fileTxt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        return data; 
    }
}

export interface INew_fileTxt {
    content?: string | undefined;
}

export class Old_nameTxt implements IOld_nameTxt {
    content?: string | undefined;
    filename?: string | undefined;

    constructor(data?: IOld_nameTxt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
            this.filename = data["filename"];
        }
    }

    static fromJS(data: any): Old_nameTxt {
        let result = new Old_nameTxt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["filename"] = this.filename;
        return data; 
    }
}

export interface IOld_nameTxt {
    content?: string | undefined;
    filename?: string | undefined;
}

export class File1Txt2 implements IFile1Txt2 {
    content?: string | undefined;

    constructor(data?: IFile1Txt2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
        }
    }

    static fromJS(data: any): File1Txt2 {
        let result = new File1Txt2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        return data; 
    }
}

export interface IFile1Txt2 {
    content?: string | undefined;
}

export class Comments implements IComments {
    href?: string | undefined;

    constructor(data?: IComments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Comments {
        let result = new Comments();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

export interface IComments {
    href?: string | undefined;
}

export class Html implements IHtml {
    href?: string | undefined;

    constructor(data?: IHtml) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Html {
        let result = new Html();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

export interface IHtml {
    href?: string | undefined;
}

export class Review_comments implements IReview_comments {
    href?: string | undefined;

    constructor(data?: IReview_comments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Review_comments {
        let result = new Review_comments();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

export interface IReview_comments {
    href?: string | undefined;
}

export class Self implements ISelf {
    href?: string | undefined;

    constructor(data?: ISelf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Self {
        let result = new Self();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

export interface ISelf {
    href?: string | undefined;
}

export class Repo3 implements IRepo3 {
    clone_url?: string | undefined;
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: Language2 | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner12 | undefined;
    private?: boolean | undefined;
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;

    constructor(data?: IRepo3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? Owner12.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Repo3 {
        let result = new Repo3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

export interface IRepo3 {
    clone_url?: string | undefined;
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: Language2 | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner12 | undefined;
    private?: boolean | undefined;
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;
}

export class User18 implements IUser18 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser18) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User18 {
        let result = new User18();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser18 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Repo4 implements IRepo4 {
    clone_url?: string | undefined;
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: Language3 | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner13 | undefined;
    private?: boolean | undefined;
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;

    constructor(data?: IRepo4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? Owner13.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Repo4 {
        let result = new Repo4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

export interface IRepo4 {
    clone_url?: string | undefined;
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: Language3 | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner13 | undefined;
    private?: boolean | undefined;
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;
}

export class User19 implements IUser19 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser19) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User19 {
        let result = new User19();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser19 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Html2 implements IHtml2 {
    href?: string | undefined;

    constructor(data?: IHtml2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Html2 {
        let result = new Html2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

export interface IHtml2 {
    href?: string | undefined;
}

export class Pull_request3 implements IPull_request3 {
    href?: string | undefined;

    constructor(data?: IPull_request3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Pull_request3 {
        let result = new Pull_request3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

export interface IPull_request3 {
    href?: string | undefined;
}

export class Self2 implements ISelf2 {
    href?: string | undefined;

    constructor(data?: ISelf2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Self2 {
        let result = new Self2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

export interface ISelf2 {
    href?: string | undefined;
}

export class Uploader3 implements IUploader3 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUploader3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Uploader3 {
        let result = new Uploader3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUploader3 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Owner9 implements IOwner9 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOwner9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Owner9 {
        let result = new Owner9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOwner9 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Owner10 implements IOwner10 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOwner10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Owner10 {
        let result = new Owner10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOwner10 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Repository2 implements IRepository2 {
    archive_url?: string | undefined;
    assignees_url?: string | undefined;
    blobs_url?: string | undefined;
    branches_url?: string | undefined;
    collaborators_url?: string | undefined;
    comments_url?: string | undefined;
    commits_url?: string | undefined;
    compare_url?: string | undefined;
    contents_url?: string | undefined;
    contributors_url?: string | undefined;
    description?: string | undefined;
    downloads_url?: string | undefined;
    events_url?: string | undefined;
    fork?: boolean | undefined;
    forks_url?: string | undefined;
    full_name?: string | undefined;
    git_commits_url?: string | undefined;
    git_refs_url?: string | undefined;
    git_tags_url?: string | undefined;
    hooks_url?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    issue_comment_url?: string | undefined;
    issue_events_url?: string | undefined;
    issues_url?: string | undefined;
    keys_url?: string | undefined;
    labels_url?: string | undefined;
    languages_url?: string | undefined;
    merges_url?: string | undefined;
    milestones_url?: string | undefined;
    name?: string | undefined;
    notifications_url?: string | undefined;
    owner?: Owner14 | undefined;
    private?: boolean | undefined;
    pulls_url?: string | undefined;
    stargazers_url?: string | undefined;
    statuses_url?: string | undefined;
    subscribers_url?: string | undefined;
    subscription_url?: string | undefined;
    tags_url?: string | undefined;
    teams_url?: string | undefined;
    trees_url?: string | undefined;
    url?: string | undefined;

    constructor(data?: IRepository2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.archive_url = data["archive_url"];
            this.assignees_url = data["assignees_url"];
            this.blobs_url = data["blobs_url"];
            this.branches_url = data["branches_url"];
            this.collaborators_url = data["collaborators_url"];
            this.comments_url = data["comments_url"];
            this.commits_url = data["commits_url"];
            this.compare_url = data["compare_url"];
            this.contents_url = data["contents_url"];
            this.contributors_url = data["contributors_url"];
            this.description = data["description"];
            this.downloads_url = data["downloads_url"];
            this.events_url = data["events_url"];
            this.fork = data["fork"];
            this.forks_url = data["forks_url"];
            this.full_name = data["full_name"];
            this.git_commits_url = data["git_commits_url"];
            this.git_refs_url = data["git_refs_url"];
            this.git_tags_url = data["git_tags_url"];
            this.hooks_url = data["hooks_url"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.issue_comment_url = data["issue_comment_url"];
            this.issue_events_url = data["issue_events_url"];
            this.issues_url = data["issues_url"];
            this.keys_url = data["keys_url"];
            this.labels_url = data["labels_url"];
            this.languages_url = data["languages_url"];
            this.merges_url = data["merges_url"];
            this.milestones_url = data["milestones_url"];
            this.name = data["name"];
            this.notifications_url = data["notifications_url"];
            this.owner = data["owner"] ? Owner14.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pulls_url = data["pulls_url"];
            this.stargazers_url = data["stargazers_url"];
            this.statuses_url = data["statuses_url"];
            this.subscribers_url = data["subscribers_url"];
            this.subscription_url = data["subscription_url"];
            this.tags_url = data["tags_url"];
            this.teams_url = data["teams_url"];
            this.trees_url = data["trees_url"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Repository2 {
        let result = new Repository2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["archive_url"] = this.archive_url;
        data["assignees_url"] = this.assignees_url;
        data["blobs_url"] = this.blobs_url;
        data["branches_url"] = this.branches_url;
        data["collaborators_url"] = this.collaborators_url;
        data["comments_url"] = this.comments_url;
        data["commits_url"] = this.commits_url;
        data["compare_url"] = this.compare_url;
        data["contents_url"] = this.contents_url;
        data["contributors_url"] = this.contributors_url;
        data["description"] = this.description;
        data["downloads_url"] = this.downloads_url;
        data["events_url"] = this.events_url;
        data["fork"] = this.fork;
        data["forks_url"] = this.forks_url;
        data["full_name"] = this.full_name;
        data["git_commits_url"] = this.git_commits_url;
        data["git_refs_url"] = this.git_refs_url;
        data["git_tags_url"] = this.git_tags_url;
        data["hooks_url"] = this.hooks_url;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["issue_comment_url"] = this.issue_comment_url;
        data["issue_events_url"] = this.issue_events_url;
        data["issues_url"] = this.issues_url;
        data["keys_url"] = this.keys_url;
        data["labels_url"] = this.labels_url;
        data["languages_url"] = this.languages_url;
        data["merges_url"] = this.merges_url;
        data["milestones_url"] = this.milestones_url;
        data["name"] = this.name;
        data["notifications_url"] = this.notifications_url;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pulls_url"] = this.pulls_url;
        data["stargazers_url"] = this.stargazers_url;
        data["statuses_url"] = this.statuses_url;
        data["subscribers_url"] = this.subscribers_url;
        data["subscription_url"] = this.subscription_url;
        data["tags_url"] = this.tags_url;
        data["teams_url"] = this.teams_url;
        data["trees_url"] = this.trees_url;
        data["url"] = this.url;
        return data; 
    }
}

export interface IRepository2 {
    archive_url?: string | undefined;
    assignees_url?: string | undefined;
    blobs_url?: string | undefined;
    branches_url?: string | undefined;
    collaborators_url?: string | undefined;
    comments_url?: string | undefined;
    commits_url?: string | undefined;
    compare_url?: string | undefined;
    contents_url?: string | undefined;
    contributors_url?: string | undefined;
    description?: string | undefined;
    downloads_url?: string | undefined;
    events_url?: string | undefined;
    fork?: boolean | undefined;
    forks_url?: string | undefined;
    full_name?: string | undefined;
    git_commits_url?: string | undefined;
    git_refs_url?: string | undefined;
    git_tags_url?: string | undefined;
    hooks_url?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    issue_comment_url?: string | undefined;
    issue_events_url?: string | undefined;
    issues_url?: string | undefined;
    keys_url?: string | undefined;
    labels_url?: string | undefined;
    languages_url?: string | undefined;
    merges_url?: string | undefined;
    milestones_url?: string | undefined;
    name?: string | undefined;
    notifications_url?: string | undefined;
    owner?: Owner14 | undefined;
    private?: boolean | undefined;
    pulls_url?: string | undefined;
    stargazers_url?: string | undefined;
    statuses_url?: string | undefined;
    subscribers_url?: string | undefined;
    subscription_url?: string | undefined;
    tags_url?: string | undefined;
    teams_url?: string | undefined;
    trees_url?: string | undefined;
    url?: string | undefined;
}

export class Assignee3 implements IAssignee3 {

    constructor(data?: IAssignee3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Assignee3 {
        let result = new Assignee3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IAssignee3 {
}

export class Closed_at implements IClosed_at {

    constructor(data?: IClosed_at) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Closed_at {
        let result = new Closed_at();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IClosed_at {
}

export class Labels3 implements ILabels3 {
    color?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;

    constructor(data?: ILabels3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.color = data["color"];
            this.name = data["name"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Labels3 {
        let result = new Labels3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["color"] = this.color;
        data["name"] = this.name;
        data["url"] = this.url;
        return data; 
    }
}

export interface ILabels3 {
    color?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
}

export class Milestone4 implements IMilestone4 {

    constructor(data?: IMilestone4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Milestone4 {
        let result = new Milestone4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IMilestone4 {
}

export class Pull_request4 implements IPull_request4 {
    diff_url?: Diff_url | undefined;
    html_url?: Html_url | undefined;
    patch_url?: Patch_url | undefined;

    constructor(data?: IPull_request4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.diff_url = data["diff_url"];
            this.html_url = data["html_url"];
            this.patch_url = data["patch_url"];
        }
    }

    static fromJS(data: any): Pull_request4 {
        let result = new Pull_request4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["diff_url"] = this.diff_url;
        data["html_url"] = this.html_url;
        data["patch_url"] = this.patch_url;
        return data; 
    }
}

export interface IPull_request4 {
    diff_url?: Diff_url | undefined;
    html_url?: Html_url | undefined;
    patch_url?: Patch_url | undefined;
}

export class User20 implements IUser20 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser20) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User20 {
        let result = new User20();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser20 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Owner11 implements IOwner11 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    received_events_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOwner11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.received_events_url = data["received_events_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Owner11 {
        let result = new Owner11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["received_events_url"] = this.received_events_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOwner11 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    received_events_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export enum Tree4Mode {
    _100644 = <any>"100644", 
    _100755 = <any>"100755", 
    _040000 = <any>"040000", 
    _160000 = <any>"160000", 
    _120000 = <any>"120000", 
}

export enum Tree4Type {
    Blob = <any>"blob", 
    Tree = <any>"tree", 
    Commit = <any>"commit", 
}

export class RingErl2 implements IRingErl2 {
    filename?: string | undefined;
    raw_url?: string | undefined;
    size?: number | undefined;

    constructor(data?: IRingErl2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filename = data["filename"];
            this.raw_url = data["raw_url"];
            this.size = data["size"];
        }
    }

    static fromJS(data: any): RingErl2 {
        let result = new RingErl2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filename"] = this.filename;
        data["raw_url"] = this.raw_url;
        data["size"] = this.size;
        return data; 
    }
}

export interface IRingErl2 {
    filename?: string | undefined;
    raw_url?: string | undefined;
    size?: number | undefined;
}

export class Creator6 implements ICreator6 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICreator6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Creator6 {
        let result = new Creator6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICreator6 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export enum Milestone2State {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

export class Author17 implements IAuthor17 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: IAuthor17) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Author17 {
        let result = new Author17();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAuthor17 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Committer14 implements ICommitter14 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICommitter14) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Committer14 {
        let result = new Committer14();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICommitter14 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Tree9 implements ITree9 {
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: ITree9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Tree9 {
        let result = new Tree9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface ITree9 {
    sha?: string | undefined;
    url?: string | undefined;
}

export class Html3 implements IHtml3 {
    href?: string | undefined;

    constructor(data?: IHtml3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Html3 {
        let result = new Html3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

export interface IHtml3 {
    href?: string | undefined;
}

export class Pull_request5 implements IPull_request5 {
    href?: string | undefined;

    constructor(data?: IPull_request5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Pull_request5 {
        let result = new Pull_request5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

export interface IPull_request5 {
    href?: string | undefined;
}

export class Self3 implements ISelf3 {
    href?: string | undefined;

    constructor(data?: ISelf3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Self3 {
        let result = new Self3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

export interface ISelf3 {
    href?: string | undefined;
}

export class Comments2 implements IComments2 {
    href?: string | undefined;

    constructor(data?: IComments2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Comments2 {
        let result = new Comments2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

export interface IComments2 {
    href?: string | undefined;
}

export class Html4 implements IHtml4 {
    href?: string | undefined;

    constructor(data?: IHtml4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Html4 {
        let result = new Html4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

export interface IHtml4 {
    href?: string | undefined;
}

export class Review_comments2 implements IReview_comments2 {
    href?: string | undefined;

    constructor(data?: IReview_comments2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Review_comments2 {
        let result = new Review_comments2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

export interface IReview_comments2 {
    href?: string | undefined;
}

export class Self4 implements ISelf4 {
    href?: string | undefined;

    constructor(data?: ISelf4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Self4 {
        let result = new Self4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["href"] = this.href;
        return data; 
    }
}

export interface ISelf4 {
    href?: string | undefined;
}

export class Repo5 implements IRepo5 {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner15 | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;

    constructor(data?: IRepo5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? Owner15.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Repo5 {
        let result = new Repo5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

export interface IRepo5 {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner15 | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;
}

export class User21 implements IUser21 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser21) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User21 {
        let result = new User21();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser21 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Repo6 implements IRepo6 {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner16 | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;

    constructor(data?: IRepo6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clone_url = data["clone_url"];
            this.created_at = data["created_at"];
            this.description = data["description"];
            this.fork = data["fork"];
            this.forks = data["forks"];
            this.forks_count = data["forks_count"];
            this.full_name = data["full_name"];
            this.git_url = data["git_url"];
            this.homepage = data["homepage"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.language = data["language"];
            this.master_branch = data["master_branch"];
            this.mirror_url = data["mirror_url"];
            this.name = data["name"];
            this.open_issues = data["open_issues"];
            this.open_issues_count = data["open_issues_count"];
            this.owner = data["owner"] ? Owner16.fromJS(data["owner"]) : <any>undefined;
            this.private = data["private"];
            this.pushed_at = data["pushed_at"];
            this.size = data["size"];
            this.ssh_url = data["ssh_url"];
            this.svn_url = data["svn_url"];
            this.updated_at = data["updated_at"];
            this.url = data["url"];
            this.watchers = data["watchers"];
            this.watchers_count = data["watchers_count"];
        }
    }

    static fromJS(data: any): Repo6 {
        let result = new Repo6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clone_url"] = this.clone_url;
        data["created_at"] = this.created_at;
        data["description"] = this.description;
        data["fork"] = this.fork;
        data["forks"] = this.forks;
        data["forks_count"] = this.forks_count;
        data["full_name"] = this.full_name;
        data["git_url"] = this.git_url;
        data["homepage"] = this.homepage;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["language"] = this.language;
        data["master_branch"] = this.master_branch;
        data["mirror_url"] = this.mirror_url;
        data["name"] = this.name;
        data["open_issues"] = this.open_issues;
        data["open_issues_count"] = this.open_issues_count;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["private"] = this.private;
        data["pushed_at"] = this.pushed_at;
        data["size"] = this.size;
        data["ssh_url"] = this.ssh_url;
        data["svn_url"] = this.svn_url;
        data["updated_at"] = this.updated_at;
        data["url"] = this.url;
        data["watchers"] = this.watchers;
        data["watchers_count"] = this.watchers_count;
        return data; 
    }
}

export interface IRepo6 {
    clone_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    created_at?: string | undefined;
    description?: string | undefined;
    fork?: boolean | undefined;
    forks?: number | undefined;
    forks_count?: number | undefined;
    full_name?: string | undefined;
    git_url?: string | undefined;
    homepage?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    language?: string | undefined;
    master_branch?: string | undefined;
    mirror_url?: string | undefined;
    name?: string | undefined;
    open_issues?: number | undefined;
    open_issues_count?: number | undefined;
    owner?: Owner16 | undefined;
    private?: boolean | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    pushed_at?: string | undefined;
    size?: number | undefined;
    ssh_url?: string | undefined;
    svn_url?: string | undefined;
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    updated_at?: string | undefined;
    url?: string | undefined;
    watchers?: number | undefined;
    watchers_count?: number | undefined;
}

export class User22 implements IUser22 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUser22) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): User22 {
        let result = new User22();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUser22 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Uploader4 implements IUploader4 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IUploader4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.site_admin = data["site_admin"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Uploader4 {
        let result = new Uploader4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["site_admin"] = this.site_admin;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IUploader4 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    site_admin?: boolean | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Author18 implements IAuthor18 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: IAuthor18) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Author18 {
        let result = new Author18();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAuthor18 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Committer15 implements ICommitter15 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICommitter15) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Committer15 {
        let result = new Committer15();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICommitter15 {
    /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Tree10 implements ITree10 {
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: ITree10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Tree10 {
        let result = new Tree10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface ITree10 {
    sha?: string | undefined;
    url?: string | undefined;
}

export class Author19 implements IAuthor19 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: IAuthor19) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Author19 {
        let result = new Author19();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAuthor19 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Committer16 implements ICommitter16 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICommitter16) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Committer16 {
        let result = new Committer16();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICommitter16 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Tree11 implements ITree11 {
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: ITree11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Tree11 {
        let result = new Tree11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface ITree11 {
    sha?: string | undefined;
    url?: string | undefined;
}

export class Author20 implements IAuthor20 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: IAuthor20) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Author20 {
        let result = new Author20();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface IAuthor20 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Committer17 implements ICommitter17 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICommitter17) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"];
            this.email = data["email"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Committer17 {
        let result = new Committer17();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["email"] = this.email;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICommitter17 {
    date?: string | undefined;
    email?: string | undefined;
    name?: string | undefined;
}

export class Tree12 implements ITree12 {
    sha?: string | undefined;
    url?: string | undefined;

    constructor(data?: ITree12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sha = data["sha"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Tree12 {
        let result = new Tree12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sha"] = this.sha;
        data["url"] = this.url;
        return data; 
    }
}

export interface ITree12 {
    sha?: string | undefined;
    url?: string | undefined;
}

export class Creator7 implements ICreator7 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: ICreator7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Creator7 {
        let result = new Creator7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface ICreator7 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export enum Milestone3State {
    Open = <any>"open", 
    Closed = <any>"closed", 
}

export class Language2 implements ILanguage2 {

    constructor(data?: ILanguage2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Language2 {
        let result = new Language2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface ILanguage2 {
}

export class Owner12 implements IOwner12 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOwner12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Owner12 {
        let result = new Owner12();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOwner12 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Language3 implements ILanguage3 {

    constructor(data?: ILanguage3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Language3 {
        let result = new Language3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface ILanguage3 {
}

export class Owner13 implements IOwner13 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOwner13) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Owner13 {
        let result = new Owner13();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOwner13 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Owner14 implements IOwner14 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOwner14) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.events_url = data["events_url"];
            this.followers_url = data["followers_url"];
            this.following_url = data["following_url"];
            this.gists_url = data["gists_url"];
            this.gravatar_id = data["gravatar_id"];
            this.html_url = data["html_url"];
            this.id = data["id"];
            this.login = data["login"];
            this.organizations_url = data["organizations_url"];
            this.received_events_url = data["received_events_url"];
            this.repos_url = data["repos_url"];
            this.starred_url = data["starred_url"];
            this.subscriptions_url = data["subscriptions_url"];
            this.type = data["type"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Owner14 {
        let result = new Owner14();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["events_url"] = this.events_url;
        data["followers_url"] = this.followers_url;
        data["following_url"] = this.following_url;
        data["gists_url"] = this.gists_url;
        data["gravatar_id"] = this.gravatar_id;
        data["html_url"] = this.html_url;
        data["id"] = this.id;
        data["login"] = this.login;
        data["organizations_url"] = this.organizations_url;
        data["received_events_url"] = this.received_events_url;
        data["repos_url"] = this.repos_url;
        data["starred_url"] = this.starred_url;
        data["subscriptions_url"] = this.subscriptions_url;
        data["type"] = this.type;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOwner14 {
    avatar_url?: string | undefined;
    events_url?: string | undefined;
    followers_url?: string | undefined;
    following_url?: string | undefined;
    gists_url?: string | undefined;
    gravatar_id?: string | undefined;
    html_url?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    organizations_url?: string | undefined;
    received_events_url?: string | undefined;
    repos_url?: string | undefined;
    starred_url?: string | undefined;
    subscriptions_url?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
}

export class Diff_url implements IDiff_url {

    constructor(data?: IDiff_url) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Diff_url {
        let result = new Diff_url();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IDiff_url {
}

export class Html_url implements IHtml_url {

    constructor(data?: IHtml_url) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Html_url {
        let result = new Html_url();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IHtml_url {
}

export class Patch_url implements IPatch_url {

    constructor(data?: IPatch_url) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): Patch_url {
        let result = new Patch_url();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IPatch_url {
}

export class Owner15 implements IOwner15 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOwner15) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Owner15 {
        let result = new Owner15();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOwner15 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class Owner16 implements IOwner16 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;

    constructor(data?: IOwner16) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.avatar_url = data["avatar_url"];
            this.gravatar_id = data["gravatar_id"];
            this.id = data["id"];
            this.login = data["login"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Owner16 {
        let result = new Owner16();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["avatar_url"] = this.avatar_url;
        data["gravatar_id"] = this.gravatar_id;
        data["id"] = this.id;
        data["login"] = this.login;
        data["url"] = this.url;
        return data; 
    }
}

export interface IOwner16 {
    avatar_url?: string | undefined;
    gravatar_id?: string | undefined;
    id?: number | undefined;
    login?: string | undefined;
    url?: string | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
	headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
		super();

        this.message = message;
        this.status = status;
        this.response = response;
		this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => { 
        let reader = new FileReader(); 
        reader.onload = function() { 
            observer.next(this.result);
            observer.complete();
        }
        reader.readAsText(blob); 
    });
}